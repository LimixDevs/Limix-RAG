{
  "anchor": [
    "pub fn version_binary_path(version: &Version) -> PathBuf {\n    get_bin_dir_path().join(format!(\"anchor-{version}\"))\n}",
    "pub fn ensure_paths() {\n    let home_dir = AVM_HOME.to_path_buf();\n    if !home_dir.exists() {\n        fs::create_dir_all(&home_dir).expect(\"Could not create .avm directory\");\n    }\n\n    let bin_dir = get_bin_dir_path();\n    if !bin_dir.exists() {\n        fs::create_dir_all(bin_dir).expect(\"Could not create .avm/bin directory\");\n    }\n\n    if !current_version_file_path().exists() {\n        fs::File::create(current_version_file_path()).expect(\"Could not create .version file\");\n    }\n}\n\n/// Read the current version from the version file\npub fn current_version() -> Result<Version> {\n    fs::read_to_string(current_version_file_path())\n        .map_err(|e| anyhow!(\"Could not read version file: {}\", e))?\n        .trim_end_matches('\\n')\n        .parse::<Version>()\n        .map_err(|e| anyhow!(\"Could not parse version file: {}\", e))\n}",
    "pub fn use_version(opt_version: Option<Version>) -> Result<()> {\n    let version = match opt_version {\n        Some(version) => version,\n        None => read_anchorversion_file()?,\n    };\n\n    // Make sure the requested version is installed\n    let installed_versions = read_installed_versions()?;\n    if !installed_versions.contains(&version) {\n        println!(\"Version {version} is not installed. Would you like to install? [y/n]\");\n        let input = std::io::stdin()\n            .lock()\n            .lines()\n            .next()\n            .expect(\"Expected input\")?;\n        match input.as_str() {\n            \"y\" | \"yes\" => return install_version(InstallTarget::Version(version), false, false),\n            _ => return Err(anyhow!(\"Installation rejected.\")),\n        };\n    }\n\n    let mut current_version_file = fs::File::create(current_version_file_path())?;\n    current_version_file.write_all(version.to_string().as_bytes())?;\n    println!(\"Now using anchor version {}.\", current_version()?);\n    Ok(())\n}",
    "pub fn update() -> Result<()> {\n    let latest_version = get_latest_version()?;\n    install_version(InstallTarget::Version(latest_version), false, false)\n}",
    "pub fn check_and_get_full_commit(commit: &str) -> Result<String> {\n    let client = reqwest::blocking::Client::new();\n    let response = client\n        .get(format!(\n            \"https://api.github.com/repos/coral-xyz/anchor/commits/{commit}\"\n        ))\n        .header(USER_AGENT, \"avm https://github.com/coral-xyz/anchor\")\n        .send()?;\n\n    if response.status() != StatusCode::OK {\n        return Err(anyhow!(\n            \"Error checking commit {commit}: {}\",\n            response.text()?\n        ));\n    };\n\n    #[derive(Deserialize)]\n    struct GetCommitResponse {\n        sha: String,\n    }\n\n    response\n        .json::<GetCommitResponse>()\n        .map(|resp| resp.sha)\n        .map_err(|err| anyhow!(\"Failed to parse the response to JSON: {err:?}\"))\n}",
    "pub fn install_version(\n    install_target: InstallTarget,\n    force: bool,\n    from_source: bool,\n) -> Result<()> {\n    let version = match &install_target {\n        InstallTarget::Version(version) => version.to_owned(),\n        InstallTarget::Commit(commit) => get_anchor_version_from_commit(commit)?,\n    };\n    // Return early if version is already installed\n    if !force && read_installed_versions()?.contains(&version) {\n        eprintln!(\"Version `{version}` is already installed\");\n        return Ok(());\n    }\n\n    let is_commit = matches!(install_target, InstallTarget::Commit(_));\n    let is_older_than_v0_31_0 = version < Version::parse(\"0.31.0\")?;\n    if from_source || is_commit || is_older_than_v0_31_0 {\n        // Build from source using `cargo install --git`\n        let mut args: Vec<String> = vec![\n            \"install\".into(),\n            \"anchor-cli\".into(),\n            \"--git\".into(),\n            \"https://github.com/coral-xyz/anchor\".into(),\n            \"--locked\".into(),\n            \"--root\".into(),\n            AVM_HOME.to_str().unwrap().into(),\n        ];\n        let conditional_args = match install_target {\n            InstallTarget::Version(version) => [\"--tag\".into(), format!(\"v{}\", version)],\n            InstallTarget::Commit(commit) => [\"--rev\".into(), commit],\n        };\n        args.extend_from_slice(&conditional_args);\n\n        // If the version is older than v0.31, install using `rustc 1.79.0` to get around the problem\n        // explained in https://github.com/coral-xyz/anchor/pull/3143\n        if is_older_than_v0_31_0 {\n            const REQUIRED_VERSION: &str = \"1.79.0\";\n            let is_installed = Command::new(\"rustup\")\n                .args([\"toolchain\", \"list\"])\n                .output()\n                .map(|output| String::from_utf8(output.stdout))??\n                .lines()\n                .any(|line| line.starts_with(REQUIRED_VERSION));\n            if !is_installed {\n                let exit_status = Command::new(\"rustup\")\n                    .args([\"toolchain\", \"install\", REQUIRED_VERSION])\n                    .spawn()?\n                    .wait()?;\n                if !exit_status.success() {\n                    return Err(anyhow!(\n                        \"Installation of `rustc {REQUIRED_VERSION}` failed. \\\n                    `rustc <1.80` is required to install Anchor v{version} from source. \\\n                    See https://github.com/coral-xyz/anchor/pull/3143 for more information.\"\n                    ));\n                }\n            }\n\n            // Prepend the toolchain to use with the `cargo install` command\n            args.insert(0, format!(\"+{REQUIRED_VERSION}\"));\n        }\n\n        let output = Command::new(\"cargo\")\n            .args(args)\n            .stdout(Stdio::inherit())\n            .stderr(Stdio::inherit())\n            .output()\n            .map_err(|e| anyhow!(\"`cargo install` for version `{version}` failed: {e}\"))?;\n        if !output.status.success() {\n            return Err(anyhow!(\n                \"Failed to install {version}, is it a valid version?\"\n            ));\n        }\n\n        let bin_dir = get_bin_dir_path();\n        let bin_name = if cfg!(target_os = \"windows\") {\n            \"anchor.exe\"\n        } else {\n            \"anchor\"\n        };\n        fs::rename(bin_dir.join(bin_name), version_binary_path(&version))?;\n    } else {\n        let output = Command::new(\"rustc\").arg(\"-vV\").output()?;\n        let target = core::str::from_utf8(&output.stdout)?\n            .lines()\n            .find(|line| line.starts_with(\"host:\"))\n            .and_then(|line| line.split(':').last())\n            .ok_or_else(|| anyhow!(\"`host` not found from `rustc -vV` output\"))?\n            .trim();\n        let ext = if cfg!(target_os = \"windows\") {\n            \".exe\"\n        } else {\n            \"\"\n        };\n        let res = reqwest::blocking::get(format!(\n            \"https://github.com/coral-xyz/anchor/releases/download/v{version}/anchor-{version}-{target}{ext}\"\n        ))?;\n        if !res.status().is_success() {\n            return Err(anyhow!(\n                \"Failed to download the binary for version `{version}` (status code: {})\",\n                res.status()\n            ));\n        }\n\n        let bin_path = version_binary_path(&version);\n        fs::write(&bin_path, res.bytes()?)?;\n\n        // Set file to executable on UNIX\n        #[cfg(unix)]\n        fs::set_permissions(\n            bin_path,\n            <fs::Permissions as std::os::unix::fs::PermissionsExt>::from_mode(0o775),\n        )?;\n    }\n\n    // If .version file is empty or not parseable, write the newly installed version to it\n    if current_version().is_err() {\n        let mut current_version_file = fs::File::create(current_version_file_path())?;\n        current_version_file.write_all(version.to_string().as_bytes())?;\n    }\n\n    use_version(Some(version))\n}",
    "pub fn uninstall_version(version: &Version) -> Result<()> {\n    let version_path = version_binary_path(version);\n    if !version_path.exists() {\n        return Err(anyhow!(\"anchor-cli {} is not installed\", version));\n    }\n    if version == &current_version()? {\n        return Err(anyhow!(\"anchor-cli {} is currently in use\", version));\n    }\n    fs::remove_file(version_path)?;\n\n    Ok(())\n}",
    "pub fn read_anchorversion_file() -> Result<Version> {\n    fs::read_to_string(\".anchorversion\")\n        .map_err(|e| anyhow!(\".anchorversion file not found: {e}\"))\n        .map(|content| Version::parse(content.trim()))?\n        .map_err(|e| anyhow!(\"Unable to parse version: {e}\"))\n}",
    "pub fn fetch_versions() -> Result<Vec<Version>, Error> {\n    #[derive(Deserialize)]\n    struct Release {\n        #[serde(rename = \"name\", deserialize_with = \"version_deserializer\")]\n        version: Version,\n    }\n\n    fn version_deserializer<'de, D>(deserializer: D) -> Result<Version, D::Error>\n    where\n        D: de::Deserializer<'de>,\n    {\n        let s: &str = de::Deserialize::deserialize(deserializer)?;\n        Version::parse(s.trim_start_matches('v')).map_err(de::Error::custom)\n    }",
    "pub fn list_versions() -> Result<()> {\n    let mut installed_versions = read_installed_versions()?;\n\n    let mut available_versions = fetch_versions()?;\n    // Reverse version list so latest versions are printed last\n    available_versions.reverse();\n\n    let print_versions =\n        |versions: Vec<Version>, installed_versions: &mut Vec<Version>, show_latest: bool| {\n            versions.iter().enumerate().for_each(|(i, v)| {\n                print!(\"{v}\");\n                let mut flags = vec![];\n                if i == versions.len() - 1 && show_latest {\n                    flags.push(\"latest\");\n                }\n                if let Some(position) = installed_versions.iter().position(|iv| iv == v) {\n                    flags.push(\"installed\");\n                    installed_versions.remove(position);\n                }\n                if current_version().map(|cv| &cv == v).unwrap_or_default() {\n                    flags.push(\"current\");\n                }\n\n                if flags.is_empty() {\n                    println!();\n                } else {\n                    println!(\"\\t({})\", flags.join(\", \"));\n                }\n            })\n        }",
    "pub fn get_latest_version() -> Result<Version> {\n    fetch_versions()?\n        .into_iter()\n        .next()\n        .ok_or_else(|| anyhow!(\"First version not found\"))\n}",
    "pub fn read_installed_versions() -> Result<Vec<Version>> {\n    const PREFIX: &str = \"anchor-\";\n    let versions = fs::read_dir(get_bin_dir_path())?\n        .filter_map(|entry_result| entry_result.ok())\n        .filter_map(|entry| entry.file_name().to_str().map(|f| f.to_owned()))\n        .filter(|file_name| file_name.starts_with(PREFIX))\n        .filter_map(|file_name| file_name.trim_start_matches(PREFIX).parse::<Version>().ok())\n        .collect();\n\n    Ok(versions)\n}",
    "pub fn entry(opts: Cli) -> Result<()> {\n    match opts.command {\n        Commands::Use { version } => avm::use_version(version),\n        Commands::Install {\n            version_or_commit,\n            force,\n            from_source,\n        } => avm::install_version(version_or_commit, force, from_source),\n        Commands::Uninstall { version } => avm::uninstall_version(&version),\n        Commands::List {} => avm::list_versions(),\n        Commands::Update {} => avm::update(),\n        Commands::Completions { shell } => {\n            clap_complete::generate(shell, &mut Cli::command(), \"avm\", &mut std::io::stdout());\n            Ok(())\n        }",
    "pub fn check_overflow(cargo_toml_path: impl AsRef<Path>) -> Result<bool> {\n    Manifest::from_path(cargo_toml_path)?\n        .profile\n        .release\n        .as_ref()\n        .and_then(|profile| profile.overflow_checks)\n        .ok_or(anyhow!(\n            \"`overflow-checks` is not enabled. To enable, add:\\n\\n\\\n    [profile.release]\\n\\\n    overflow-checks = true\\n\\n\\\n    in workspace root Cargo.toml\",\n        ))\n}",
    "pub fn check_anchor_version(cfg: &WithPath<Config>) -> Result<()> {\n    let cli_version = Version::parse(VERSION)?;\n\n    // Check lang crate\n    let mismatched_lang_version = cfg\n        .get_rust_program_list()?\n        .into_iter()\n        .map(|path| path.join(\"Cargo.toml\"))\n        .map(cargo_toml::Manifest::from_path)\n        .filter_map(|man| man.ok())\n        .filter_map(|man| man.dependencies.get(\"anchor-lang\").map(|d| d.to_owned()))\n        .filter_map(|dep| Version::parse(dep.req()).ok())\n        .find(|ver| ver != &cli_version); // Only log the warning once\n\n    if let Some(ver) = mismatched_lang_version {\n        eprintln!(\n            \"WARNING: `anchor-lang` version({ver}) and the current CLI version({cli_version}) \\\n                 don't match.\\n\\n\\t\\\n                 This can lead to unwanted behavior. To use the same CLI version, add:\\n\\n\\t\\\n                 [toolchain]\\n\\t\\\n                 anchor_version = \\\"{ver}\\\"\\n\\n\\t\\\n                 to Anchor.toml\\n\"\n        );\n    }\n\n    // Check TS package\n    let package_json = {\n        let package_json_path = cfg.path().parent().unwrap().join(\"package.json\");\n        let package_json_content = fs::read_to_string(package_json_path)?;\n        serde_json::from_str::<serde_json::Value>(&package_json_content)?\n    };\n    let mismatched_ts_version = package_json\n        .get(\"dependencies\")\n        .and_then(|deps| deps.get(\"@coral-xyz/anchor\"))\n        .and_then(|ver| ver.as_str())\n        .and_then(|ver| VersionReq::parse(ver).ok())\n        .filter(|ver| !ver.matches(&cli_version));\n\n    if let Some(ver) = mismatched_ts_version {\n        let update_cmd = match cfg.toolchain.package_manager.clone().unwrap_or_default() {\n            PackageManager::NPM => \"npm update\",\n            PackageManager::Yarn => \"yarn upgrade\",\n            PackageManager::PNPM => \"pnpm update\",\n        };\n\n        eprintln!(\n            \"WARNING: `@coral-xyz/anchor` version({ver}) and the current CLI version\\\n                ({cli_version}) don't match.\\n\\n\\t\\\n                This can lead to unwanted behavior. To fix, upgrade the package by running:\\n\\n\\t\\\n                {update_cmd} @coral-xyz/anchor@{cli_version}\\n\"\n        );\n    }\n\n    Ok(())\n}",
    "pub fn check_deps(cfg: &WithPath<Config>) -> Result<()> {\n    // Check `solana-program`\n    cfg.get_rust_program_list()?\n        .into_iter()\n        .map(|path| path.join(\"Cargo.toml\"))\n        .map(cargo_toml::Manifest::from_path)\n        .map(|man| man.map_err(|e| anyhow!(\"Failed to read manifest: {e}\")))\n        .collect::<Result<Vec<_>>>()?\n        .into_iter()\n        .filter(|man| man.dependencies.contains_key(\"solana-program\"))\n        .for_each(|man| {\n            eprintln!(\n                \"WARNING: Adding `solana-program` as a separate dependency might cause conflicts.\\n\\\n                To solve, remove the `solana-program` dependency and use the exported crate from \\\n                `anchor-lang`.\\n\\\n                `use solana_program` becomes `use anchor_lang::solana_program`.\\n\\\n                Program name: `{}`\\n\",\n                man.package().name()\n            )\n        }",
    "pub fn check_idl_build_feature() -> Result<()> {\n    let manifest_path = Path::new(\"Cargo.toml\").canonicalize()?;\n    let manifest = Manifest::from_path(&manifest_path)?;\n\n    // Check whether the manifest has `idl-build` feature\n    let has_idl_build_feature = manifest\n        .features\n        .iter()\n        .any(|(feature, _)| feature == \"idl-build\");\n    if !has_idl_build_feature {\n        let anchor_spl_idl_build = manifest\n            .dependencies\n            .iter()\n            .any(|dep| dep.0 == \"anchor-spl\")\n            .then_some(r#\", \"anchor-spl/idl-build\"\"#)\n            .unwrap_or_default();\n\n        return Err(anyhow!(\n            r#\"`idl-build` feature is missing. To solve, add\n\n[features]\nidl-build = [\"anchor-lang/idl-build\"{anchor_spl_idl_build}]\n\nin `{manifest_path:?}`.\"#\n        ));\n    }\n\n    // Check if `idl-build` is enabled by default\n    manifest\n        .dependencies\n        .iter()\n        .filter(|(_, dep)| dep.req_features().contains(&\"idl-build\".into()))\n        .for_each(|(name, _)| {\n            eprintln!(\n                \"WARNING: `idl-build` feature of crate `{name}` is enabled by default. \\\n                    This is not the intended usage.\\n\\n\\t\\\n                    To solve, do not enable the `idl-build` feature and include crates that have \\\n                    `idl-build` feature in the `idl-build` feature list:\\n\\n\\t\\\n                    [features]\\n\\t\\\n                    idl-build = [\\\"{name}/idl-build\\\", ...]\\n\"\n            )\n        }",
    "pub fn new(inner: T, path: PathBuf) -> Self {\n        Self { inner, path }\n    }\n\n    pub fn path(&self) -> &PathBuf {\n        &self.path\n    }\n\n    pub fn into_inner(self) -> T {\n        self.inner\n    }\n}\n\nimpl<T> std::convert::AsRef<T> for WithPath<T> {\n    fn as_ref(&self) -> &T {\n        &self.inner\n    }\n}\n\n#[derive(Debug, Clone, PartialEq)]\npub struct Manifest(cargo_toml::Manifest);\n\nimpl Manifest {\n    pub fn from_path(p: impl AsRef<Path>) -> Result<Self> {\n        cargo_toml::Manifest::from_path(&p)\n            .map(Manifest)\n            .map_err(anyhow::Error::from)\n            .with_context(|| format!(\"Error reading manifest from path: {}\", p.as_ref().display()))\n    }",
    "pub fn lib_name(&self) -> Result<String> {\n        match &self.lib {\n            Some(cargo_toml::Product {\n                name: Some(name), ..\n            }) => Ok(name.to_owned()),\n            _ => self\n                .package\n                .as_ref()\n                .ok_or_else(|| anyhow!(\"package section not provided\"))\n                .map(|pkg| pkg.name.to_snake_case()),\n        }\n    }\n\n    pub fn version(&self) -> String {\n        match &self.package {\n            Some(package) => package.version().to_string(),\n            _ => \"0.0.0\".to_string(),\n        }\n    }\n\n    // Climbs each parent directory from the current dir until we find a Cargo.toml\n    pub fn discover() -> Result<Option<WithPath<Manifest>>> {\n        Manifest::discover_from_path(std::env::current_dir()?)\n    }",
    "pub fn discover_from_path(start_from: PathBuf) -> Result<Option<WithPath<Manifest>>> {\n        let mut cwd_opt = Some(start_from.as_path());\n\n        while let Some(cwd) = cwd_opt {\n            let mut anchor_toml = false;\n\n            for f in fs::read_dir(cwd).with_context(|| {\n                format!(\"Error reading the directory with path: {}\", cwd.display())\n            }",
    "pub fn get_rust_program_list(&self) -> Result<Vec<PathBuf>> {\n        // Canonicalize the workspace filepaths to compare with relative paths.\n        let (members, exclude) = self.canonicalize_workspace()?;\n\n        // Get all candidate programs.\n        //\n        // If [workspace.members] exists, then use that.\n        // Otherwise, default to `programs/*`.\n        let program_paths: Vec<PathBuf> = {\n            if members.is_empty() {\n                let path = self.path().parent().unwrap().join(\"programs\");\n                if let Ok(entries) = fs::read_dir(path) {\n                    entries\n                        .filter(|entry| entry.as_ref().map(|e| e.path().is_dir()).unwrap_or(false))\n                        .map(|dir| dir.map(|d| d.path().canonicalize().unwrap()))\n                        .collect::<Vec<Result<PathBuf, std::io::Error>>>()\n                        .into_iter()\n                        .collect::<Result<Vec<PathBuf>, std::io::Error>>()?\n                } else {\n                    Vec::new()\n                }",
    "pub fn get_solidity_program_list(&self) -> Result<Vec<(String, PathBuf)>> {\n        let path = self.path().parent().unwrap().join(\"solidity\");\n        let mut res = Vec::new();\n\n        if let Ok(entries) = fs::read_dir(path) {\n            for entry in entries {\n                let path = entry?.path();\n\n                if !path.is_file() || path.extension() != Some(OsStr::new(\"sol\")) {\n                    continue;\n                }\n\n                let source = fs::read_to_string(&path)?;\n\n                let tree = match solang_parser::parse(&source, 0) {\n                    Ok((tree, _)) => tree,\n                    Err(diag) => {\n                        // The parser can return multiple errors, however this is exceedingly rare.\n                        // Just use the first one, else the formatting will be a mess.\n                        bail!(\n                            \"{}: {}: {}\",\n                            path.display(),\n                            diag[0].level.to_string(),\n                            diag[0].message\n                        );\n                    }\n                };\n\n                tree.0.iter().for_each(|part| {\n                    if let SourceUnitPart::ContractDefinition(contract) = part {\n                        // Must be a contract, not library/interface/abstract contract\n                        if matches!(&contract.ty, ContractTy::Contract(..)) {\n                            if let Some(name) = &contract.name {\n                                res.push((name.name.clone(), path.clone()));\n                            }\n                        }\n                    }\n                });\n            }\n        }\n\n        Ok(res)\n    }",
    "pub fn read_all_programs(&self) -> Result<Vec<Program>> {\n        let mut r = vec![];\n        for path in self.get_rust_program_list()? {\n            let cargo = Manifest::from_path(path.join(\"Cargo.toml\"))?;\n            let lib_name = cargo.lib_name()?;\n\n            let idl_filepath = Path::new(\"target\")\n                .join(\"idl\")\n                .join(&lib_name)\n                .with_extension(\"json\");\n            let idl = fs::read(idl_filepath)\n                .ok()\n                .map(|bytes| serde_json::from_reader(&*bytes))\n                .transpose()?;\n\n            r.push(Program {\n                lib_name,\n                solidity: false,\n                path,\n                idl,\n            });\n        }\n        for (lib_name, path) in self.get_solidity_program_list()? {\n            let idl_filepath = Path::new(\"target\")\n                .join(\"idl\")\n                .join(&lib_name)\n                .with_extension(\"json\");\n            let idl = fs::read(idl_filepath)\n                .ok()\n                .map(|bytes| serde_json::from_reader(&*bytes))\n                .transpose()?;\n\n            r.push(Program {\n                lib_name,\n                solidity: true,\n                path,\n                idl,\n            });\n        }\n        Ok(r)\n    }",
    "pub fn get_programs(&self, name: Option<String>) -> Result<Vec<Program>> {\n        let programs = self.read_all_programs()?;\n        let programs = match name {\n            Some(name) => vec![programs\n                .into_iter()\n                .find(|program| {\n                    name == program.lib_name\n                        || name == program.path.file_name().unwrap().to_str().unwrap()\n                }",
    "pub fn get_program(&self, name: &str) -> Result<Program> {\n        self.get_programs(Some(name.to_owned()))?\n            .into_iter()\n            .next()\n            .ok_or_else(|| anyhow!(\"Expected a program\"))\n    }",
    "pub fn canonicalize_workspace(&self) -> Result<(Vec<PathBuf>, Vec<PathBuf>)> {\n        let members = self.process_paths(&self.workspace.members)?;\n        let exclude = self.process_paths(&self.workspace.exclude)?;\n        Ok((members, exclude))\n    }",
    "pub fn build_subcommand(&self) -> &str {\n        match self {\n            Self::Bpf => \"build-bpf\",\n            Self::Sbf => \"build-sbf\",\n        }\n    }\n}\n\n#[derive(Debug, Clone)]\npub struct BuildConfig {\n    pub verifiable: bool,\n    pub solana_version: Option<String>,\n    pub docker_image: String,\n    pub bootstrap: BootstrapMode,\n}\n\nimpl Config {\n    pub fn add_test_config(\n        &mut self,\n        root: impl AsRef<Path>,\n        test_paths: Vec<PathBuf>,\n    ) -> Result<()> {\n        self.test_config = TestConfig::discover(root, test_paths)?;\n        Ok(())\n    }",
    "pub fn docker(&self) -> String {\n        let version = self\n            .toolchain\n            .anchor_version\n            .as_deref()\n            .unwrap_or(crate::DOCKER_BUILDER_VERSION);\n        format!(\"solanafoundation/anchor:v{version}\")\n    }",
    "pub fn discover(cfg_override: &ConfigOverride) -> Result<Option<WithPath<Config>>> {\n        Config::_discover().map(|opt| {\n            opt.map(|mut cfg| {\n                if let Some(cluster) = cfg_override.cluster.clone() {\n                    cfg.provider.cluster = cluster;\n                }\n                if let Some(wallet) = cfg_override.wallet.clone() {\n                    cfg.provider.wallet = wallet;\n                }\n                cfg\n            })\n        }",
    "pub fn wallet_kp(&self) -> Result<Keypair> {\n        get_keypair(&self.provider.wallet.to_string())\n    }",
    "pub fn get_solana_cfg_url() -> Result<String, io::Error> {\n    let config_file = CONFIG_FILE.as_ref().ok_or_else(|| {\n        io::Error::new(\n            io::ErrorKind::NotFound,\n            \"Default Solana config was not found\",\n        )\n    }",
    "pub fn discover(root: impl AsRef<Path>, test_paths: Vec<PathBuf>) -> Result<Option<Self>> {\n        let walker = WalkDir::new(root).into_iter();\n        let mut test_suite_configs = HashMap::new();\n        for entry in walker.filter_entry(|e| !is_hidden(e)) {\n            let entry = entry?;\n            if entry.file_name() == \"Test.toml\" {\n                let entry_path = entry.path();\n                let test_toml = TestToml::from_path(entry_path)?;\n                if test_paths.is_empty() || test_paths.iter().any(|p| entry_path.starts_with(p)) {\n                    test_suite_configs.insert(entry.path().into(), test_toml);\n                }\n            }\n        }\n\n        Ok(match test_suite_configs.is_empty() {\n            true => None,\n            false => Some(Self { test_suite_configs }),\n        })\n    }",
    "pub fn from_path(p: impl AsRef<Path>) -> Result<Self> {\n        WithPath::new(_TestToml::from_path(&p)?, p.as_ref().into()).try_into()\n    }",
    "pub fn get_default_ledger_path() -> PathBuf {\n    Path::new(\".anchor\").join(\"test-ledger\")\n}",
    "pub fn pubkey(&self) -> Result<Pubkey> {\n        self.keypair().map(|kp| kp.pubkey())\n    }",
    "pub fn keypair(&self) -> Result<Keypair> {\n        let file = self.keypair_file()?;\n        get_keypair(file.path().to_str().unwrap())\n    }",
    "pub fn keypair_file(&self) -> Result<WithPath<File>> {\n        let deploy_dir_path = Path::new(\"target\").join(\"deploy\");\n        fs::create_dir_all(&deploy_dir_path)\n            .with_context(|| format!(\"Error creating directory with path: {deploy_dir_path:?}\"))?;\n        let path = std::env::current_dir()\n            .expect(\"Must have current dir\")\n            .join(deploy_dir_path.join(format!(\"{}-keypair.json\", self.lib_name)));\n        if path.exists() {\n            return Ok(WithPath::new(\n                File::open(&path)\n                    .with_context(|| format!(\"Error opening file with path: {}\", path.display()))?,\n                path,\n            ));\n        }\n        let program_kp = Keypair::new();\n        let mut file = File::create(&path)\n            .with_context(|| format!(\"Error creating file with path: {}\", path.display()))?;\n        file.write_all(format!(\"{:?}\", &program_kp.to_bytes()).as_bytes())?;\n        Ok(WithPath::new(file, path))\n    }",
    "pub fn binary_path(&self, verifiable: bool) -> PathBuf {\n        let path = Path::new(\"target\")\n            .join(if verifiable { \"verifiable\" } else { \"deploy\" })\n            .join(&self.lib_name)\n            .with_extension(\"so\");\n\n        std::env::current_dir()\n            .expect(\"Must have current dir\")\n            .join(path)\n    }",
    "pub fn from(name: String, cfg: &WithPath<Config>) -> Result<Self> {\n        let cluster = &cfg.provider.cluster;\n        if cluster != &Cluster::Mainnet {\n            return Err(anyhow!(\"Publishing requires the mainnet cluster\"));\n        }\n        let program_details = cfg\n            .programs\n            .get(cluster)\n            .ok_or_else(|| anyhow!(\"Program not provided in Anchor.toml\"))?\n            .get(&name)\n            .ok_or_else(|| anyhow!(\"Program not provided in Anchor.toml\"))?;\n        let idl = program_details.idl.clone();\n        let address = program_details.address.to_string();\n        Ok(Self { name, address, idl })\n    }",
    "pub fn entry(opts: Opts) -> Result<()> {\n    let restore_cbs = override_toolchain(&opts.cfg_override)?;\n    let result = process_command(opts);\n    restore_toolchain(restore_cbs)?;\n\n    result\n}\n\n/// Functions to restore toolchain entries\ntype RestoreToolchainCallbacks = Vec<Box<dyn FnOnce() -> Result<()>>>;\n\n/// Override the toolchain from `Anchor.toml`.\n///\n/// Returns the previous versions to restore back to.\nfn override_toolchain(cfg_override: &ConfigOverride) -> Result<RestoreToolchainCallbacks> {\n    let mut restore_cbs: RestoreToolchainCallbacks = vec![];\n\n    let cfg = Config::discover(cfg_override)?;\n    if let Some(cfg) = cfg {\n        fn parse_version(text: &str) -> Option<String> {\n            Some(\n                Regex::new(r\"(\\d+\\.\\d+\\.\\S+)\")\n                    .unwrap()\n                    .captures_iter(text)\n                    .next()?\n                    .get(0)?\n                    .as_str()\n                    .to_string(),\n            )\n        }",
    "pub fn create_files(files: &Files) -> Result<()> {\n    for (path, content) in files {\n        let path = path\n            .display()\n            .to_string()\n            .replace('/', std::path::MAIN_SEPARATOR_STR);\n        let path = Path::new(&path);\n        if path.exists() {\n            continue;\n        }\n\n        match path.extension() {\n            Some(_) => {\n                fs::create_dir_all(path.parent().unwrap())?;\n                fs::write(path, content)?;\n            }\n            None => fs::create_dir_all(path)?,\n        }\n    }\n\n    Ok(())\n}",
    "pub fn override_or_create_files(files: &Files) -> Result<()> {\n    for (path, content) in files {\n        let path = Path::new(path);\n        if path.exists() {\n            let mut f = fs::OpenOptions::new()\n                .write(true)\n                .truncate(true)\n                .open(path)?;\n            f.write_all(content.as_bytes())?;\n            f.flush()?;\n        } else {\n            fs::create_dir_all(path.parent().unwrap())?;\n            fs::write(path, content)?;\n        }\n    }\n\n    Ok(())\n}",
    "pub fn expand(\n    cfg_override: &ConfigOverride,\n    program_name: Option<String>,\n    cargo_args: &[String],\n) -> Result<()> {\n    // Change to the workspace member directory, if needed.\n    if let Some(program_name) = program_name.as_ref() {\n        cd_member(cfg_override, program_name)?;\n    }\n\n    let workspace_cfg = Config::discover(cfg_override)?.expect(\"Not in workspace.\");\n    let cfg_parent = workspace_cfg.path().parent().expect(\"Invalid Anchor.toml\");\n    let cargo = Manifest::discover()?;\n\n    let expansions_path = cfg_parent.join(\".anchor\").join(\"expanded-macros\");\n    fs::create_dir_all(&expansions_path)?;\n\n    match cargo {\n        // No Cargo.toml found, expand entire workspace\n        None => expand_all(&workspace_cfg, expansions_path, cargo_args),\n        // Cargo.toml is at root of workspace, expand entire workspace\n        Some(cargo) if cargo.path().parent() == workspace_cfg.path().parent() => {\n            expand_all(&workspace_cfg, expansions_path, cargo_args)\n        }",
    "pub fn build(\n    cfg_override: &ConfigOverride,\n    no_idl: bool,\n    idl: Option<String>,\n    idl_ts: Option<String>,\n    verifiable: bool,\n    skip_lint: bool,\n    program_name: Option<String>,\n    solana_version: Option<String>,\n    docker_image: Option<String>,\n    bootstrap: BootstrapMode,\n    stdout: Option<File>, // Used for the package registry server.\n    stderr: Option<File>, // Used for the package registry server.\n    env_vars: Vec<String>,\n    cargo_args: Vec<String>,\n    no_docs: bool,\n    arch: ProgramArch,\n) -> Result<()> {\n    // Change to the workspace member directory, if needed.\n    if let Some(program_name) = program_name.as_ref() {\n        cd_member(cfg_override, program_name)?;\n    }\n    let cfg = Config::discover(cfg_override)?.expect(\"Not in workspace.\");\n    let cfg_parent = cfg.path().parent().expect(\"Invalid Anchor.toml\");\n\n    // Require overflow checks\n    let workspace_cargo_toml_path = cfg_parent.join(\"Cargo.toml\");\n    if workspace_cargo_toml_path.exists() {\n        check_overflow(workspace_cargo_toml_path)?;\n    }\n\n    // Check whether there is a mismatch between CLI and crate/package versions\n    check_anchor_version(&cfg).ok();\n    check_deps(&cfg).ok();\n\n    let idl_out = match idl {\n        Some(idl) => Some(PathBuf::from(idl)),\n        None => Some(cfg_parent.join(\"target\").join(\"idl\")),\n    };\n    fs::create_dir_all(idl_out.as_ref().unwrap())?;\n\n    let idl_ts_out = match idl_ts {\n        Some(idl_ts) => Some(PathBuf::from(idl_ts)),\n        None => Some(cfg_parent.join(\"target\").join(\"types\")),\n    };\n    fs::create_dir_all(idl_ts_out.as_ref().unwrap())?;\n\n    if !cfg.workspace.types.is_empty() {\n        fs::create_dir_all(cfg_parent.join(&cfg.workspace.types))?;\n    };\n\n    let cargo = Manifest::discover()?;\n    let build_config = BuildConfig {\n        verifiable,\n        solana_version: solana_version.or_else(|| cfg.toolchain.solana_version.clone()),\n        docker_image: docker_image.unwrap_or_else(|| cfg.docker()),\n        bootstrap,\n    };\n    match cargo {\n        // No Cargo.toml so build the entire workspace.\n        None => build_all(\n            &cfg,\n            cfg.path(),\n            no_idl,\n            idl_out,\n            idl_ts_out,\n            &build_config,\n            stdout,\n            stderr,\n            env_vars,\n            cargo_args,\n            skip_lint,\n            no_docs,\n            arch,\n        )?,\n        // If the Cargo.toml is at the root, build the entire workspace.\n        Some(cargo) if cargo.path().parent() == cfg.path().parent() => build_all(\n            &cfg,\n            cfg.path(),\n            no_idl,\n            idl_out,\n            idl_ts_out,\n            &build_config,\n            stdout,\n            stderr,\n            env_vars,\n            cargo_args,\n            skip_lint,\n            no_docs,\n            arch,\n        )?,\n        // Cargo.toml represents a single package. Build it.\n        Some(cargo) => build_rust_cwd(\n            &cfg,\n            cargo.path().to_path_buf(),\n            no_idl,\n            idl_out,\n            idl_ts_out,\n            &build_config,\n            stdout,\n            stderr,\n            env_vars,\n            cargo_args,\n            skip_lint,\n            no_docs,\n            &arch,\n        )?,\n    }\n\n    set_workspace_dir_or_exit();\n\n    Ok(())\n}",
    "pub fn verify_bin(program_id: Pubkey, bin_path: &Path, cluster: &str) -> Result<BinVerification> {\n    // Use `finalized` state for verify\n    let client = RpcClient::new_with_commitment(cluster, CommitmentConfig::finalized());\n\n    // Get the deployed build artifacts.\n    let (deployed_bin, state) = {\n        let account = client.get_account(&program_id)?;\n        if account.owner == bpf_loader::id() || account.owner == bpf_loader_deprecated::id() {\n            let bin = account.data.to_vec();\n            let state = BinVerificationState::ProgramData {\n                slot: 0, // Need to look through the transaction history.\n                upgrade_authority_address: None,\n            };\n            (bin, state)\n        }",
    "pub fn create_program(name: &str, template: ProgramTemplate, with_mollusk: bool) -> Result<()> {\n    let program_path = Path::new(\"programs\").join(name);\n    let common_files = vec![\n        (\"Cargo.toml\".into(), workspace_manifest().into()),\n        (\n            program_path.join(\"Cargo.toml\"),\n            cargo_toml(name, with_mollusk),\n        ),\n        (program_path.join(\"Xargo.toml\"), xargo_toml().into()),\n    ];\n\n    let template_files = match template {\n        ProgramTemplate::Single => create_program_template_single(name, &program_path),\n        ProgramTemplate::Multiple => create_program_template_multiple(name, &program_path),\n    };\n\n    create_files(&[common_files, template_files].concat())\n}",
    "pub fn initialize(ctx: Context<Initialize>) -> Result<()> {{\n        msg!(\"Greetings from: {{:?}}\", ctx.program_id);\n        Ok(())\n    }",
    "pub fn initialize(ctx: Context<Initialize>) -> Result<()> {{\n        initialize::handler(ctx)\n    }",
    "pub fn handler(ctx: Context<Initialize>) -> Result<()> {\n    msg!(\"Greetings from: {:?}\", ctx.program_id);\n    Ok(())\n}",
    "pub fn get_or_create_program_id(name: &str) -> Pubkey {\n    let keypair_path = Path::new(\"target\")\n        .join(\"deploy\")\n        .join(format!(\"{}-keypair.json\", name.to_snake_case()));\n\n    read_keypair_file(&keypair_path)\n        .unwrap_or_else(|_| {\n            let keypair = Keypair::new();\n            write_keypair_file(&keypair, keypair_path).expect(\"Unable to create program keypair\");\n            keypair\n        })\n        .pubkey()\n}",
    "pub fn credentials(token: &str) -> String {\n    format!(\n        r#\"[registry]\ntoken = \"{token}\"\n\"#\n    )\n}",
    "pub fn deploy_js_script_host(cluster_url: &str, script_path: &str) -> String {\n    format!(\n        r#\"\nconst anchor = require('@coral-xyz/anchor');\n\n// Deploy script defined by the user.\nconst userScript = require(\"{script_path}\");\n\nasync function main() {{\n    const url = \"{cluster_url}\";\n    const preflightCommitment = 'recent';\n    const connection = new anchor.web3.Connection(url, preflightCommitment);\n    const wallet = anchor.Wallet.local();\n\n    const provider = new anchor.AnchorProvider(connection, wallet, {{\n        preflightCommitment,\n        commitment: 'recent',\n    }});\n\n    // Run the user's deploy script.\n    userScript(provider);\n}}\nmain();\n\"#,\n    )\n}",
    "pub fn deploy_ts_script_host(cluster_url: &str, script_path: &str) -> String {\n    format!(\n        r#\"import * as anchor from '@coral-xyz/anchor';\n\n// Deploy script defined by the user.\nconst userScript = require(\"{script_path}\");\n\nasync function main() {{\n    const url = \"{cluster_url}\";\n    const preflightCommitment = 'recent';\n    const connection = new anchor.web3.Connection(url, preflightCommitment);\n    const wallet = anchor.Wallet.local();\n\n    const provider = new anchor.AnchorProvider(connection, wallet, {{\n        preflightCommitment,\n        commitment: 'recent',\n    }});\n\n    // Run the user's deploy script.\n    userScript(provider);\n}}\nmain();\n\"#,\n    )\n}",
    "pub fn deploy_script() -> &'static str {\n    r#\"// Migrations are an early feature. Currently, they're nothing more than this\n// single deploy script that's invoked from the CLI, injecting a provider\n// configured from the workspace's Anchor.toml.\n\nconst anchor = require(\"@coral-xyz/anchor\");\n\nmodule.exports = async function (provider) {\n  // Configure client to use the provider.\n  anchor.setProvider(provider);\n\n  // Add your deploy script here.\n};\n\"#\n}\n\npub fn ts_deploy_script() -> &'static str {\n    r#\"// Migrations are an early feature. Currently, they're nothing more than this\n// single deploy script that's invoked from the CLI, injecting a provider\n// configured from the workspace's Anchor.toml.\n\nimport * as anchor from \"@coral-xyz/anchor\";\n\nmodule.exports = async function (provider: anchor.AnchorProvider) {\n  // Configure client to use the provider.\n  anchor.setProvider(provider);\n\n  // Add your deploy script here.\n};\n\"#\n}\n\npub fn mocha(name: &str) -> String {\n    format!(\n        r#\"const anchor = require(\"@coral-xyz/anchor\");\n\ndescribe(\"{}\", () => {{\n  // Configure the client to use the local cluster.\n  anchor.setProvider(anchor.AnchorProvider.env());\n\n  it(\"Is initialized!\", async () => {{\n    // Add your test here.\n    const program = anchor.workspace.{};\n    const tx = await program.methods.initialize().rpc();\n    console.log(\"Your transaction signature\", tx);\n  }});\n}});\n\"#,\n        name,\n        name.to_lower_camel_case(),\n    )\n}",
    "pub fn jest(name: &str) -> String {\n    format!(\n        r#\"const anchor = require(\"@coral-xyz/anchor\");\n\ndescribe(\"{}\", () => {{\n  // Configure the client to use the local cluster.\n  anchor.setProvider(anchor.AnchorProvider.env());\n\n  it(\"Is initialized!\", async () => {{\n    // Add your test here.\n    const program = anchor.workspace.{};\n    const tx = await program.methods.initialize().rpc();\n    console.log(\"Your transaction signature\", tx);\n  }});\n}});\n\"#,\n        name,\n        name.to_lower_camel_case(),\n    )\n}",
    "pub fn package_json(jest: bool, license: String) -> String {\n    if jest {\n        format!(\n            r#\"{{\n  \"license\": \"{license}\",\n  \"scripts\": {{\n    \"lint:fix\": \"prettier */*.js \\\"*/**/*{{.js,.ts}}\\\" -w\",\n    \"lint\": \"prettier */*.js \\\"*/**/*{{.js,.ts}}\\\" --check\"\n  }},\n  \"dependencies\": {{\n    \"@coral-xyz/anchor\": \"^{VERSION}\"\n  }},\n  \"devDependencies\": {{\n    \"jest\": \"^29.0.3\",\n    \"prettier\": \"^2.6.2\"\n  }}\n}}\n    \"#\n        )\n    }",
    "pub fn ts_package_json(jest: bool, license: String) -> String {\n    if jest {\n        format!(\n            r#\"{{\n  \"license\": \"{license}\",\n  \"scripts\": {{\n    \"lint:fix\": \"prettier */*.js \\\"*/**/*{{.js,.ts}}\\\" -w\",\n    \"lint\": \"prettier */*.js \\\"*/**/*{{.js,.ts}}\\\" --check\"\n  }},\n  \"dependencies\": {{\n    \"@coral-xyz/anchor\": \"^{VERSION}\"\n  }},\n  \"devDependencies\": {{\n    \"@types/bn.js\": \"^5.1.0\",\n    \"@types/jest\": \"^29.0.3\",\n    \"jest\": \"^29.0.3\",\n    \"prettier\": \"^2.6.2\",\n    \"ts-jest\": \"^29.0.2\",\n    \"typescript\": \"^5.7.3\"\n  }}\n}}\n\"#\n        )\n    }",
    "pub fn ts_mocha(name: &str) -> String {\n    format!(\n        r#\"import * as anchor from \"@coral-xyz/anchor\";\nimport {{ Program }} from \"@coral-xyz/anchor\";\nimport {{ {} }} from \"../target/types/{}\";\n\ndescribe(\"{}\", () => {{\n  // Configure the client to use the local cluster.\n  anchor.setProvider(anchor.AnchorProvider.env());\n\n  const program = anchor.workspace.{} as Program<{}>;\n\n  it(\"Is initialized!\", async () => {{\n    // Add your test here.\n    const tx = await program.methods.initialize().rpc();\n    console.log(\"Your transaction signature\", tx);\n  }});\n}});\n\"#,\n        name.to_pascal_case(),\n        name.to_snake_case(),\n        name,\n        name.to_lower_camel_case(),\n        name.to_pascal_case(),\n    )\n}",
    "pub fn ts_jest(name: &str) -> String {\n    format!(\n        r#\"import * as anchor from \"@coral-xyz/anchor\";\nimport {{ Program }} from \"@coral-xyz/anchor\";\nimport {{ {} }} from \"../target/types/{}\";\n\ndescribe(\"{}\", () => {{\n  // Configure the client to use the local cluster.\n  anchor.setProvider(anchor.AnchorProvider.env());\n\n  const program = anchor.workspace.{} as Program<{}>;\n\n  it(\"Is initialized!\", async () => {{\n    // Add your test here.\n    const tx = await program.methods.initialize().rpc();\n    console.log(\"Your transaction signature\", tx);\n  }});\n}});\n\"#,\n        name.to_pascal_case(),\n        name.to_snake_case(),\n        name,\n        name.to_lower_camel_case(),\n        name.to_pascal_case(),\n    )\n}",
    "pub fn ts_config(jest: bool) -> &'static str {\n    if jest {\n        r#\"{\n  \"compilerOptions\": {\n    \"types\": [\"jest\"],\n    \"typeRoots\": [\"./node_modules/@types\"],\n    \"lib\": [\"es2015\"],\n    \"module\": \"commonjs\",\n    \"target\": \"es6\",\n    \"esModuleInterop\": true\n  }\n}\n\"#\n    } else {\n        r#\"{\n  \"compilerOptions\": {\n    \"types\": [\"mocha\", \"chai\"],\n    \"typeRoots\": [\"./node_modules/@types\"],\n    \"lib\": [\"es2015\"],\n    \"module\": \"commonjs\",\n    \"target\": \"es6\",\n    \"esModuleInterop\": true\n  }\n}\n\"#\n    }\n}\n\npub fn git_ignore() -> &'static str {\n    r#\".anchor\n.DS_Store\ntarget\n**/*.rs.bk\nnode_modules\ntest-ledger\n.yarn\n\"#\n}\n\npub fn prettier_ignore() -> &'static str {\n    r#\".anchor\n.DS_Store\ntarget\nnode_modules\ndist\nbuild\ntest-ledger\n\"#\n}\n\npub fn node_shell(\n    cluster_url: &str,\n    wallet_path: &str,\n    programs: Vec<ProgramWorkspace>,\n) -> Result<String> {\n    let mut eval_string = format!(\n        r#\"\nconst anchor = require('@coral-xyz/anchor');\nconst web3 = anchor.web3;\nconst PublicKey = anchor.web3.PublicKey;\nconst Keypair = anchor.web3.Keypair;\n\nconst __wallet = new anchor.Wallet(\n  Keypair.fromSecretKey(\n    Buffer.from(\n      JSON.parse(\n        require('fs').readFileSync(\n          \"{wallet_path}\",\n          {{\n            encoding: \"utf-8\",\n          }},\n        ),\n      ),\n    ),\n  ),\n);\nconst __connection = new web3.Connection(\"{cluster_url}\", \"processed\");\nconst provider = new anchor.AnchorProvider(__connection, __wallet, {{\n  commitment: \"processed\",\n  preflightcommitment: \"processed\",\n}});\nanchor.setProvider(provider);\n\"#,\n    );\n\n    for program in programs {\n        write!(\n            &mut eval_string,\n            r#\"\nanchor.workspace.{} = new anchor.Program({}, provider);\n\"#,\n            program.name.to_lower_camel_case(),\n            serde_json::to_string(&program.idl)?,\n        )?;\n    }\n\n    Ok(eval_string)\n}",
    "pub fn get_test_script(&self, js: bool, pkg_manager: &PackageManager) -> String {\n        let pkg_manager_exec_cmd = match pkg_manager {\n            PackageManager::Yarn => \"yarn run\",\n            PackageManager::NPM => \"npx\",\n            PackageManager::PNPM => \"pnpm exec\",\n        };\n\n        match &self {\n            Self::Mocha => {\n                if js {\n                    format!(\"{pkg_manager_exec_cmd} mocha -t 1000000 tests/\")\n                }",
    "pub fn create_test_files(\n        &self,\n        project_name: &str,\n        js: bool,\n        solidity: bool,\n        program_id: &str,\n    ) -> Result<()> {\n        match self {\n            Self::Mocha => {\n                // Build the test suite.\n                fs::create_dir_all(\"tests\")?;\n\n                if js {\n                    let mut test = File::create(format!(\"tests/{}.js\", &project_name))?;\n                    if solidity {\n                        test.write_all(solidity_template::mocha(project_name).as_bytes())?;\n                    } else {\n                        test.write_all(mocha(project_name).as_bytes())?;\n                    }\n                } else {\n                    let mut mocha = File::create(format!(\"tests/{}.ts\", &project_name))?;\n                    if solidity {\n                        mocha.write_all(solidity_template::ts_mocha(project_name).as_bytes())?;\n                    } else {\n                        mocha.write_all(ts_mocha(project_name).as_bytes())?;\n                    }\n                }\n            }\n            Self::Jest => {\n                // Build the test suite.\n                fs::create_dir_all(\"tests\")?;\n\n                let mut test = File::create(format!(\"tests/{}.test.js\", &project_name))?;\n                if solidity {\n                    test.write_all(solidity_template::jest(project_name).as_bytes())?;\n                } else {\n                    test.write_all(jest(project_name).as_bytes())?;\n                }\n            }\n            Self::Rust => {\n                // Do not initilize git repo\n                let exit = std::process::Command::new(\"cargo\")\n                    .arg(\"new\")\n                    .arg(\"--vcs\")\n                    .arg(\"none\")\n                    .arg(\"--lib\")\n                    .arg(\"tests\")\n                    .stderr(Stdio::inherit())\n                    .output()\n                    .map_err(|e| anyhow::format_err!(\"{}\", e.to_string()))?;\n                if !exit.status.success() {\n                    eprintln!(\"'cargo new --lib tests' failed\");\n                    std::process::exit(exit.status.code().unwrap_or(1));\n                }\n\n                let mut files = Vec::new();\n                let tests_path = Path::new(\"tests\");\n                files.extend(vec![(\n                    tests_path.join(\"Cargo.toml\"),\n                    tests_cargo_toml(project_name),\n                )]);\n                files.extend(create_program_template_rust_test(\n                    project_name,\n                    tests_path,\n                    program_id,\n                ));\n                override_or_create_files(&files)?;\n            }\n            Self::Mollusk => {\n                // Build the test suite.\n                let tests_path_str = format!(\"programs/{}/tests\", &project_name);\n                let tests_path = Path::new(&tests_path_str);\n                fs::create_dir_all(tests_path)?;\n\n                let mut files = Vec::new();\n                files.extend(create_program_template_mollusk_test(\n                    project_name,\n                    tests_path,\n                ));\n                override_or_create_files(&files)?;\n            }\n        }\n\n        Ok(())\n    }",
    "pub fn tests_cargo_toml(name: &str) -> String {\n    format!(\n        r#\"[package]\nname = \"tests\"\nversion = \"0.1.0\"\ndescription = \"Created with Anchor\"\nedition = \"2021\"\n\n[dependencies]\nanchor-client = \"{0}\"\n{1} = {{ version = \"0.1.0\", path = \"../programs/{1}\" }}\n\"#,\n        VERSION, name,\n    )\n}",
    "pub fn create_program(name: &str) -> Result<()> {\n    let files = vec![(\n        Path::new(\"solidity\").join(name).with_extension(\"sol\"),\n        solidity(name),\n    )];\n    create_files(&files)\n}",
    "pub fn mocha(name: &str) -> String {\n    format!(\n        r#\"const anchor = require(\"@coral-xyz/anchor\");\n\ndescribe(\"{}\", () => {{\n  // Configure the client to use the local cluster.\n  anchor.setProvider(anchor.AnchorProvider.env());\n\n  it(\"Is initialized!\", async () => {{\n    // Add your test here.\n    const program = anchor.workspace.{};\n    const dataAccount = anchor.web3.Keypair.generate();\n\n    const tx = await program.methods\n       .new()\n       .accounts({{ dataAccount: dataAccount.publicKey }})\n       .signers([dataAccount])\n       .rpc();\n\n    console.log(\"Your transaction signature\", tx);\n\n    const val1 = await program.methods\n      .get()\n      .accounts({{ dataAccount: dataAccount.publicKey }})\n      .view();\n\n    console.log(\"state\", val1);\n\n    await program.methods\n      .flip()\n      .accounts({{ dataAccount: dataAccount.publicKey }})\n      .rpc();\n\n    const val2 = await program.methods\n      .get()\n      .accounts({{ dataAccount: dataAccount.publicKey }})\n      .view();\n\n    console.log(\"state\", val2);\n  }});\n}});\n\"#,\n        name,\n        name.to_upper_camel_case(),\n    )\n}",
    "pub fn jest(name: &str) -> String {\n    format!(\n        r#\"const anchor = require(\"@coral-xyz/anchor\");\n\ndescribe(\"{}\", () => {{\n  // Configure the client to use the local cluster.\n  anchor.setProvider(anchor.AnchorProvider.env());\n\n  it(\"Is initialized!\", async () => {{\n    // Add your test here.\n    const program = anchor.workspace.{};\n    const tx = await program.methods.initialize().rpc();\n    console.log(\"Your transaction signature\", tx);\n  }});\n}});\n\"#,\n        name,\n        name.to_upper_camel_case(),\n    )\n}",
    "pub fn ts_mocha(name: &str) -> String {\n    format!(\n        r#\"import * as anchor from \"@coral-xyz/anchor\";\nimport {{ Program }} from \"@coral-xyz/anchor\";\nimport {{ {} }} from \"../target/types/{}\";\n\ndescribe(\"{}\", () => {{\n  // Configure the client to use the local cluster.\n  const provider = anchor.AnchorProvider.env();\n  anchor.setProvider(provider);\n\n  const dataAccount = anchor.web3.Keypair.generate();\n\n  const program = anchor.workspace.{} as Program<{}>;\n\n  it(\"Is initialized!\", async () => {{\n    // Add your test here.\n    const tx = await program.methods\n      .new()\n      .accounts({{ dataAccount: dataAccount.publicKey }})\n      .signers([dataAccount])\n      .rpc();\n    console.log(\"Your transaction signature\", tx);\n\n    const val1 = await program.methods\n      .get()\n      .accounts({{ dataAccount: dataAccount.publicKey }})\n      .view();\n\n    console.log(\"state\", val1);\n\n    await program.methods\n      .flip()\n      .accounts({{ dataAccount: dataAccount.publicKey }})\n      .rpc();\n\n    const val2 = await program.methods\n      .get()\n      .accounts({{ dataAccount: dataAccount.publicKey }})\n      .view();\n\n    console.log(\"state\", val2);  }});\n}});\n\"#,\n        name.to_upper_camel_case(),\n        name.to_snake_case(),\n        name,\n        name.to_upper_camel_case(),\n        name.to_upper_camel_case(),\n    )\n}",
    "pub fn main() -> Result<()> {\n    let opts = Opts::parse();\n\n    // Wallet and cluster params.\n    let payer = read_keypair_file(&*shellexpand::tilde(\"~/.config/solana/id.json\"))\n        .expect(\"Example requires a keypair file\");\n    let url = Cluster::Custom(\n        \"http://localhost:8899\".to_string(),\n        \"ws://127.0.0.1:8900\".to_string(),\n    );\n\n    if !opts.multithreaded {\n        // Client.\n        let payer = Rc::new(payer);\n        let client =\n            Client::new_with_options(url.clone(), payer.clone(), CommitmentConfig::processed());\n\n        // Run tests on single thread with a single client using an Rc\n        println!(\"\\nStarting single thread test...\");\n        composite(&client, opts.composite_pid)?;\n        basic_2(&client, opts.basic_2_pid)?;\n        basic_4(&client, opts.basic_4_pid)?;\n\n        // Can also use references, since they deref to a signer\n        let payer: &Keypair = &payer;\n        let client = Client::new_with_options(url, payer, CommitmentConfig::processed());\n        events(&client, opts.events_pid)?;\n        optional(&client, opts.optional_pid)?;\n    } else {\n        // Client.\n        let payer = Arc::new(payer);\n        let client = Client::new_with_options(url, payer, CommitmentConfig::processed());\n        let client = Arc::new(client);\n\n        // Run tests multithreaded while sharing a client\n        println!(\"\\nStarting multithread test...\");\n        let client = Arc::new(client);\n        let tests: Vec<(TestFn<Arc<Keypair>>, Pubkey)> = vec![\n            (&composite, opts.composite_pid),\n            (&basic_2, opts.basic_2_pid),\n            (&basic_4, opts.basic_4_pid),\n            (&events, opts.events_pid),\n            (&optional, opts.optional_pid),\n        ];\n        let mut handles = vec![];\n        for (test, arg) in tests {\n            let local_client = Arc::clone(&client);\n            handles.push(std::thread::spawn(move || test(&local_client, arg)));\n        }\n        for handle in handles {\n            assert!(handle.join().unwrap().is_ok());\n        }\n    }\n\n    // Success.\n    Ok(())\n}",
    "pub fn unsubscribe(self) {\n        self.runtime_handle.block_on(self.unsubscribe_internal())\n    }",
    "pub fn new(\n        program_id: Pubkey,\n        cfg: Config<C>,\n        #[cfg(feature = \"mock\")] rpc_client: AsyncRpcClient,\n    ) -> Result<Self, ClientError> {\n        let rt: tokio::runtime::Runtime = Builder::new_multi_thread().enable_all().build()?;\n\n        #[cfg(not(feature = \"mock\"))]\n        let rpc_client = {\n            let comm_config = cfg.options.unwrap_or_default();\n            let cluster_url = cfg.cluster.url().to_string();\n            AsyncRpcClient::new_with_commitment(cluster_url.clone(), comm_config)\n        }",
    "pub fn rpc(&self) -> RpcClient {\n        RpcClient::new_with_commitment(\n            self.cfg.cluster.url().to_string(),\n            self.cfg.options.unwrap_or_default(),\n        )\n    }",
    "pub fn request(&self) -> RequestBuilder<'_, C, Box<dyn Signer + '_>> {\n        RequestBuilder::from(\n            self.program_id,\n            self.cfg.cluster.url(),\n            self.cfg.payer.clone(),\n            self.cfg.options,\n            #[cfg(not(feature = \"async\"))]\n            self.rt.handle(),\n            &self.internal_rpc_client,\n        )\n    }",
    "pub fn from(\n        program_id: Pubkey,\n        cluster: &str,\n        payer: C,\n        options: Option<CommitmentConfig>,\n        handle: &'a Handle,\n        rpc_client: &'a AsyncRpcClient,\n    ) -> Self {\n        Self {\n            program_id,\n            payer,\n            cluster: cluster.to_string(),\n            accounts: Vec::new(),\n            options: options.unwrap_or_default(),\n            instructions: Vec::new(),\n            instruction_data: None,\n            signers: Vec::new(),\n            handle,\n            internal_rpc_client: rpc_client,\n            _phantom: PhantomData,\n        }\n    }\n\n    #[must_use]\n    pub fn signer<T: Signer + 'a>(mut self, signer: T) -> Self {\n        self.signers.push(Box::new(signer));\n        self\n    }\n\n    pub fn signed_transaction(&self) -> Result<Transaction, ClientError> {\n        self.handle.block_on(self.signed_transaction_internal())\n    }",
    "pub fn send(&self) -> Result<Signature, ClientError> {\n        self.handle.block_on(self.send_internal())\n    }",
    "pub fn send_with_spinner_and_config(\n        &self,\n        config: RpcSendTransactionConfig,\n    ) -> Result<Signature, ClientError> {\n        self.handle\n            .block_on(self.send_with_spinner_and_config_internal(config))\n    }",
    "pub fn new(cluster: Cluster, payer: C) -> Self {\n        Self {\n            cfg: Config {\n                cluster,\n                payer,\n                options: None,\n            },\n        }\n    }\n\n    pub fn new_with_options(cluster: Cluster, payer: C, options: CommitmentConfig) -> Self {\n        Self {\n            cfg: Config {\n                cluster,\n                payer,\n                options: Some(options),\n            },\n        }\n    }\n\n    pub fn program(\n        &self,\n        program_id: Pubkey,\n        #[cfg(feature = \"mock\")] rpc_client: AsyncRpcClient,\n    ) -> Result<Program<C>, ClientError> {\n        let cfg = Config {\n            cluster: self.cfg.cluster.clone(),\n            options: self.cfg.options,\n            payer: self.cfg.payer.clone(),\n        };\n\n        Program::new(\n            program_id,\n            cfg,\n            #[cfg(feature = \"mock\")]\n            rpc_client,\n        )\n    }",
    "pub fn payer(&self) -> Pubkey {\n        self.cfg.payer.pubkey()\n    }",
    "pub fn id(&self) -> Pubkey {\n        self.program_id\n    }\n\n    #[cfg(feature = \"mock\")]\n    pub fn internal_rpc(&self) -> &AsyncRpcClient {\n        &self.internal_rpc_client\n    }\n\n    async fn account_internal<T: AccountDeserialize>(\n        &self,\n        address: Pubkey,\n    ) -> Result<T, ClientError> {\n        let account = self\n            .internal_rpc_client\n            .get_account_with_commitment(&address, CommitmentConfig::processed())\n            .await?\n            .value\n            .ok_or(ClientError::AccountNotFound)?;\n        let mut data: &[u8] = &account.data;\n        T::try_deserialize(&mut data).map_err(Into::into)\n    }",
    "pub fn handle_system_log(this_program_str: &str, log: &str) -> (Option<String>, bool) {\n    if log.starts_with(&format!(\"Program {this_program_str} log:\")) {\n        (Some(this_program_str.to_string()), false)\n\n        // `Invoke [1]` instructions are pushed to the stack in `parse_logs_response`,\n        // so this ensures we only push CPIs to the stack at this stage\n    } else if log.contains(\"invoke\") && !log.ends_with(\"[1]\") {\n        (Some(\"cpi\".to_string()), false) // Any string will do.\n    } else {\n        let re = Regex::new(r\"^Program (.*) success*$\").unwrap();\n        if re.is_match(log) {\n            (None, true)\n        }",
    "pub fn new(logs: &mut &[String]) -> Result<Self, ClientError> {\n        let l = &logs[0];\n        *logs = &logs[1..];\n\n        let re = Regex::new(r\"^Program (.*) invoke.*$\").unwrap();\n        let c = re\n            .captures(l)\n            .ok_or_else(|| ClientError::LogParseError(l.to_string()))?;\n        let program = c\n            .get(1)\n            .ok_or_else(|| ClientError::LogParseError(l.to_string()))?\n            .as_str()\n            .to_string();\n        Ok(Self {\n            stack: vec![program],\n        })\n    }",
    "pub fn program(&self) -> String {\n        assert!(!self.stack.is_empty());\n        self.stack[self.stack.len() - 1].clone()\n    }",
    "pub fn push(&mut self, new_program: String) {\n        self.stack.push(new_program);\n    }\n\n    pub fn pop(&mut self) {\n        assert!(!self.stack.is_empty());\n        self.stack.pop().unwrap();\n    }\n}\n\n#[derive(Debug)]\npub struct EventContext {\n    pub signature: Signature,\n    pub slot: u64,\n}\n\n#[derive(Debug, Error)]\npub enum ClientError {\n    #[error(\"Account not found\")]\n    AccountNotFound,\n    #[error(\"{0}\")]\n    AnchorError(#[from] anchor_lang::error::Error),\n    #[error(\"{0}\")]\n    ProgramError(#[from] ProgramError),\n    #[error(\"{0}\")]\n    SolanaClientError(#[from] SolanaClientError),\n    #[error(\"{0}\")]\n    SolanaClientPubsubError(#[from] PubsubClientError),\n    #[error(\"Unable to parse log: {0}\")]\n    LogParseError(String),\n    #[error(transparent)]\n    IOError(#[from] std::io::Error),\n}\n\npub trait AsSigner {\n    fn as_signer(&self) -> &dyn Signer;\n}\n\nimpl AsSigner for Box<dyn Signer + '_> {\n    fn as_signer(&self) -> &dyn Signer {\n        self.as_ref()\n    }",
    "pub fn payer(mut self, payer: C) -> Self {\n        self.payer = payer;\n        self\n    }\n\n    #[must_use]\n    pub fn cluster(mut self, url: &str) -> Self {\n        self.cluster = url.to_string();\n        self\n    }\n\n    #[must_use]\n    pub fn instruction(mut self, ix: Instruction) -> Self {\n        self.instructions.push(ix);\n        self\n    }\n\n    #[must_use]\n    pub fn program(mut self, program_id: Pubkey) -> Self {\n        self.program_id = program_id;\n        self\n    }\n\n    /// Set the accounts to pass to the instruction.\n    ///\n    /// `accounts` argument can be:\n    ///\n    /// - Any type that implements [`ToAccountMetas`] trait\n    /// - A vector of [`AccountMeta`]s (for remaining accounts)\n    ///\n    /// Note that the given accounts are appended to the previous list of accounts instead of\n    /// overriding the existing ones (if any).\n    ///\n    /// # Example\n    ///\n    /// ```ignore\n    /// program\n    ///     .request()\n    ///     // Regular accounts\n    ///     .accounts(accounts::Initialize {\n    ///         my_account: my_account_kp.pubkey(),\n    ///         payer: program.payer(),\n    ///         system_program: system_program::ID,\n    ///     })\n    ///     // Remaining accounts\n    ///     .accounts(vec![AccountMeta {\n    ///         pubkey: remaining,\n    ///         is_signer: true,\n    ///         is_writable: true,\n    ///     }])\n    ///     .args(instruction::Initialize { field: 42 })\n    ///     .send()?;\n    /// ```\n    #[must_use]\n    pub fn accounts(mut self, accounts: impl ToAccountMetas) -> Self {\n        let mut metas = accounts.to_account_metas(None);\n        self.accounts.append(&mut metas);\n        self\n    }\n\n    #[must_use]\n    pub fn options(mut self, options: CommitmentConfig) -> Self {\n        self.options = options;\n        self\n    }\n\n    #[must_use]\n    pub fn args(mut self, args: impl InstructionData) -> Self {\n        self.instruction_data = Some(args.data());\n        self\n    }\n\n    pub fn instructions(&self) -> Result<Vec<Instruction>, ClientError> {\n        let mut instructions = self.instructions.clone();\n        if let Some(ix_data) = &self.instruction_data {\n            instructions.push(Instruction {\n                program_id: self.program_id,\n                data: ix_data.clone(),\n                accounts: self.accounts.clone(),\n            });\n        }\n\n        Ok(instructions)\n    }",
    "pub fn transaction(&self) -> Result<Transaction, ClientError> {\n        let instructions = &self.instructions;\n        let tx = Transaction::new_with_payer(instructions, Some(&self.payer.pubkey()));\n        Ok(tx)\n    }",
    "pub fn new(\n        program_id: Pubkey,\n        cfg: Config<C>,\n        #[cfg(feature = \"mock\")] rpc_client: AsyncRpcClient,\n    ) -> Result<Self, ClientError> {\n        #[cfg(not(feature = \"mock\"))]\n        let rpc_client = {\n            let comm_config = cfg.options.unwrap_or_default();\n            let cluster_url = cfg.cluster.url().to_string();\n            AsyncRpcClient::new_with_commitment(cluster_url.clone(), comm_config)\n        }",
    "pub fn rpc(&self) -> AsyncRpcClient {\n        AsyncRpcClient::new_with_commitment(\n            self.cfg.cluster.url().to_string(),\n            self.cfg.options.unwrap_or_default(),\n        )\n    }",
    "pub fn request(&self) -> RequestBuilder<'_, C, Arc<dyn ThreadSafeSigner>> {\n        RequestBuilder::from(\n            self.program_id,\n            self.cfg.cluster.url(),\n            self.cfg.payer.clone(),\n            self.cfg.options,\n            &self.internal_rpc_client,\n        )\n    }",
    "pub fn initialize(_ctx: Context<Initialize>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn initialize(ctx: Context<Initialize>, data: u64) -> Result<()> {\n        let my_account = &mut ctx.accounts.my_account;\n        my_account.data = data;\n        Ok(())\n    }",
    "pub fn update(ctx: Context<Update>, data: u64) -> Result<()> {\n        let my_account = &mut ctx.accounts.my_account;\n        my_account.data = data;\n        Ok(())\n    }",
    "pub fn create(ctx: Context<Create>, authority: Pubkey) -> Result<()> {\n        let counter = &mut ctx.accounts.counter;\n        counter.authority = authority;\n        counter.count = 0;\n        Ok(())\n    }",
    "pub fn increment(ctx: Context<Increment>) -> Result<()> {\n        let counter = &mut ctx.accounts.counter;\n        counter.count += 1;\n        Ok(())\n    }",
    "pub fn initialize(_ctx: Context<Initialize>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn set_data(ctx: Context<SetData>, data: u64) -> Result<()> {\n        let puppet = &mut ctx.accounts.puppet;\n        puppet.data = data;\n        Ok(())\n    }",
    "pub fn pull_strings(ctx: Context<PullStrings>, data: u64) -> anchor_lang::Result<()> {\n        let cpi_program = ctx.accounts.puppet_program.to_account_info();\n        let cpi_accounts = SetData {\n            puppet: ctx.accounts.puppet.to_account_info(),\n        };\n        let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);\n        puppet::cpi::set_data(cpi_ctx, data)\n    }",
    "pub fn initialize(ctx: Context<Initialize>) -> Result<()> {\n        let counter = ctx.accounts.counter.deref_mut();\n        let bump = ctx.bumps.counter;\n\n        *counter = Counter {\n            authority: *ctx.accounts.authority.key,\n            count: 0,\n            bump,\n        };\n\n        Ok(())\n    }",
    "pub fn increment(ctx: Context<Increment>) -> Result<()> {\n        require_keys_eq!(\n            ctx.accounts.authority.key(),\n            ctx.accounts.counter.authority,\n            ErrorCode::Unauthorized\n        );\n\n        ctx.accounts.counter.count += 1;\n        Ok(())\n    }",
    "pub fn create(ctx: Context<Create>) -> Result<()> {\n        let action_state = &mut ctx.accounts.action_state;\n        // * - means dereferencing\n        action_state.user = *ctx.accounts.user.key;\n        // Lets initialize the state\n        action_state.action = 0;\n\n        Ok(())\n    }",
    "pub fn walk(ctx: Context<Walk>) -> Result<()> {\n        let action_state = &mut ctx.accounts.action_state;\n        // Lets change the robot action state to \"walk\"\n        action_state.action = 1;\n\n        Ok(())\n    }",
    "pub fn run(ctx: Context<Run>) -> Result<()> {\n        let action_state = &mut ctx.accounts.action_state;\n        // Lets change the robot action state to \"run\"\n        action_state.action = 2;\n\n        Ok(())\n    }",
    "pub fn jump(ctx: Context<Jump>) -> Result<()> {\n        let action_state = &mut ctx.accounts.action_state;\n        // Lets change the robot action state to \"jump\"\n        action_state.action = 3;\n\n        Ok(())\n    }",
    "pub fn reset(ctx: Context<Reset>) -> Result<()> {\n        let action_state = &mut ctx.accounts.action_state;\n        // Lets reset the robot action states\n        action_state.action = 0;\n\n        Ok(())\n    }",
    "pub fn new() -> Self {\n        Self::default()\n    }",
    "pub fn program_path(mut self, program_path: PathBuf) -> Self {\n        self.program_path.replace(program_path);\n        self\n    }\n\n    /// Set whether to include account resolution information in the IDL (default: true).\n    pub fn resolution(mut self, resolution: bool) -> Self {\n        self.resolution.replace(resolution);\n        self\n    }\n    /// Set whether to skip linting (default: false).\n    pub fn skip_lint(mut self, skip_lint: bool) -> Self {\n        self.skip_lint.replace(skip_lint);\n        self\n    }\n\n    /// Set whether to skip generating docs in the IDL (default: false).\n    pub fn no_docs(mut self, no_docs: bool) -> Self {\n        self.no_docs.replace(no_docs);\n        self\n    }\n\n    /// Set the `cargo` args that will get passed to the underlying `cargo` command when building\n    /// IDLs (default: empty).\n    pub fn cargo_args(mut self, cargo_args: Vec<String>) -> Self {\n        self.cargo_args.replace(cargo_args);\n        self\n    }\n\n    /// Build the IDL with the current configuration.\n    pub fn build(self) -> Result<Idl> {\n        let idl = build(\n            &self\n                .program_path\n                .unwrap_or_else(|| std::env::current_dir().expect(\"Failed to get program path\")),\n            self.resolution.unwrap_or(true),\n            self.skip_lint.unwrap_or_default(),\n            self.no_docs.unwrap_or_default(),\n            &self.cargo_args.unwrap_or_default(),\n        )\n        .map(convert_module_paths)\n        .map(sort)?;\n        verify(&idl)?;\n\n        Ok(idl)\n    }",
    "pub fn build_idl(\n    program_path: impl AsRef<Path>,\n    resolution: bool,\n    skip_lint: bool,\n    no_docs: bool,\n) -> Result<Idl> {\n    IdlBuilder::new()\n        .program_path(program_path.as_ref().into())\n        .resolution(resolution)\n        .skip_lint(skip_lint)\n        .no_docs(no_docs)\n        .build()\n}",
    "pub fn convert_idl(idl: &[u8]) -> Result<Idl> {\n    let value = serde_json::from_slice::<serde_json::Value>(idl)?;\n    let spec = value\n        .get(\"metadata\")\n        .and_then(|m| m.get(\"spec\"))\n        .and_then(|spec| spec.as_str());\n    match spec {\n        // New standard\n        Some(spec) => match spec {\n            \"0.1.0\" => serde_json::from_value(value).map_err(Into::into),\n            _ => Err(anyhow!(\"IDL spec not supported: `{spec}`\")),\n        },\n        // Legacy\n        None => serde_json::from_value::<legacy::Idl>(value).map(TryInto::try_into)?,\n    }\n}\n\n/// Legacy IDL spec (pre Anchor v0.30)\nmod legacy {\n    use crate::types as t;\n    use anyhow::{anyhow, Result};\n    use heck::SnakeCase;\n    use serde::{Deserialize, Serialize};\n\n    #[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\n    pub struct Idl {\n        pub version: String,\n        pub name: String,\n        #[serde(skip_serializing_if = \"Option::is_none\", default)]\n        pub docs: Option<Vec<String>>,\n        #[serde(skip_serializing_if = \"Vec::is_empty\", default)]\n        pub constants: Vec<IdlConst>,\n        pub instructions: Vec<IdlInstruction>,\n        #[serde(skip_serializing_if = \"Vec::is_empty\", default)]\n        pub accounts: Vec<IdlTypeDefinition>,\n        #[serde(skip_serializing_if = \"Vec::is_empty\", default)]\n        pub types: Vec<IdlTypeDefinition>,\n        #[serde(skip_serializing_if = \"Option::is_none\", default)]\n        pub events: Option<Vec<IdlEvent>>,\n        #[serde(skip_serializing_if = \"Option::is_none\", default)]\n        pub errors: Option<Vec<IdlErrorCode>>,\n        #[serde(skip_serializing_if = \"Option::is_none\", default)]\n        pub metadata: Option<serde_json::Value>,\n    }\n\n    #[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\n    pub struct IdlConst {\n        pub name: String,\n        #[serde(rename = \"type\")]\n        pub ty: IdlType,\n        pub value: String,\n    }\n\n    #[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\n    pub struct IdlState {\n        #[serde(rename = \"struct\")]\n        pub strct: IdlTypeDefinition,\n        pub methods: Vec<IdlInstruction>,\n    }\n\n    #[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\n    pub struct IdlInstruction {\n        pub name: String,\n        #[serde(skip_serializing_if = \"Option::is_none\")]\n        pub docs: Option<Vec<String>>,\n        pub accounts: Vec<IdlAccountItem>,\n        pub args: Vec<IdlField>,\n        #[serde(skip_serializing_if = \"Option::is_none\")]\n        pub returns: Option<IdlType>,\n    }\n\n    #[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\n    #[serde(rename_all = \"camelCase\")]\n    pub struct IdlAccounts {\n        pub name: String,\n        pub accounts: Vec<IdlAccountItem>,\n    }\n\n    #[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\n    #[serde(untagged)]\n    pub enum IdlAccountItem {\n        IdlAccount(IdlAccount),\n        IdlAccounts(IdlAccounts),\n    }\n\n    #[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\n    #[serde(rename_all = \"camelCase\")]\n    pub struct IdlAccount {\n        pub name: String,\n        pub is_mut: bool,\n        pub is_signer: bool,\n        #[serde(skip_serializing_if = \"Option::is_none\")]\n        pub is_optional: Option<bool>,\n        #[serde(skip_serializing_if = \"Option::is_none\")]\n        pub docs: Option<Vec<String>>,\n        #[serde(skip_serializing_if = \"Option::is_none\", default)]\n        pub pda: Option<IdlPda>,\n        #[serde(skip_serializing_if = \"Vec::is_empty\", default)]\n        pub relations: Vec<String>,\n    }\n\n    #[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\n    #[serde(rename_all = \"camelCase\")]\n    pub struct IdlPda {\n        pub seeds: Vec<IdlSeed>,\n        #[serde(skip_serializing_if = \"Option::is_none\", default)]\n        pub program_id: Option<IdlSeed>,\n    }\n\n    #[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\n    #[serde(rename_all = \"camelCase\", tag = \"kind\")]\n    pub enum IdlSeed {\n        Const(IdlSeedConst),\n        Arg(IdlSeedArg),\n        Account(IdlSeedAccount),\n    }\n\n    #[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\n    #[serde(rename_all = \"camelCase\")]\n    pub struct IdlSeedAccount {\n        #[serde(rename = \"type\")]\n        pub ty: IdlType,\n        // account_ty points to the entry in the \"accounts\" section.\n        // Some only if the `Account<T>` type is used.\n        #[serde(skip_serializing_if = \"Option::is_none\")]\n        pub account: Option<String>,\n        pub path: String,\n    }\n\n    #[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\n    #[serde(rename_all = \"camelCase\")]\n    pub struct IdlSeedArg {\n        #[serde(rename = \"type\")]\n        pub ty: IdlType,\n        pub path: String,\n    }\n\n    #[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\n    #[serde(rename_all = \"camelCase\")]\n    pub struct IdlSeedConst {\n        #[serde(rename = \"type\")]\n        pub ty: IdlType,\n        pub value: serde_json::Value,\n    }\n\n    #[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\n    pub struct IdlField {\n        pub name: String,\n        #[serde(skip_serializing_if = \"Option::is_none\")]\n        pub docs: Option<Vec<String>>,\n        #[serde(rename = \"type\")]\n        pub ty: IdlType,\n    }\n\n    #[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\n    pub struct IdlEvent {\n        pub name: String,\n        pub fields: Vec<IdlEventField>,\n    }\n\n    #[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\n    pub struct IdlEventField {\n        pub name: String,\n        #[serde(rename = \"type\")]\n        pub ty: IdlType,\n        pub index: bool,\n    }\n\n    #[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\n    pub struct IdlTypeDefinition {\n        /// - `idl-parse`: always the name of the type\n        /// - `idl-build`: full path if there is a name conflict, otherwise the name of the type\n        pub name: String,\n        /// Documentation comments\n        #[serde(skip_serializing_if = \"Option::is_none\")]\n        pub docs: Option<Vec<String>>,\n        /// Generics, only supported with `idl-build`\n        #[serde(skip_serializing_if = \"Option::is_none\")]\n        pub generics: Option<Vec<String>>,\n        /// Type definition, `struct` or `enum`\n        #[serde(rename = \"type\")]\n        pub ty: IdlTypeDefinitionTy,\n    }\n\n    #[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\n    #[serde(rename_all = \"lowercase\", tag = \"kind\")]\n    pub enum IdlTypeDefinitionTy {\n        Struct { fields: Vec<IdlField> },\n        Enum { variants: Vec<IdlEnumVariant> },\n        Alias { value: IdlType },\n    }\n\n    #[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\n    pub struct IdlEnumVariant {\n        pub name: String,\n        #[serde(skip_serializing_if = \"Option::is_none\", default)]\n        pub fields: Option<EnumFields>,\n    }\n\n    #[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\n    #[serde(untagged)]\n    pub enum EnumFields {\n        Named(Vec<IdlField>),\n        Tuple(Vec<IdlType>),\n    }\n\n    #[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\n    #[serde(rename_all = \"camelCase\")]\n    pub enum IdlType {\n        Bool,\n        U8,\n        I8,\n        U16,\n        I16,\n        U32,\n        I32,\n        F32,\n        U64,\n        I64,\n        F64,\n        U128,\n        I128,\n        U256,\n        I256,\n        Bytes,\n        String,\n        PublicKey,\n        Defined(String),\n        Option(Box<IdlType>),\n        Vec(Box<IdlType>),\n        Array(Box<IdlType>, usize),\n        GenericLenArray(Box<IdlType>, String),\n        Generic(String),\n        DefinedWithTypeArgs {\n            name: String,\n            args: Vec<IdlDefinedTypeArg>,\n        },\n    }\n\n    #[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\n    #[serde(rename_all = \"camelCase\")]\n    pub enum IdlDefinedTypeArg {\n        Generic(String),\n        Value(String),\n        Type(IdlType),\n    }\n\n    #[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]\n    pub struct IdlErrorCode {\n        pub code: u32,\n        pub name: String,\n        #[serde(skip_serializing_if = \"Option::is_none\", default)]\n        pub msg: Option<String>,\n    }\n\n    impl TryFrom<Idl> for t::Idl {\n        type Error = anyhow::Error;\n\n        fn try_from(idl: Idl) -> Result<Self> {\n            Ok(Self {\n                address: idl\n                    .metadata\n                    .as_ref()\n                    .and_then(|m| m.get(\"address\"))\n                    .and_then(|a| a.as_str())\n                    .ok_or_else(|| anyhow!(\"Program id missing in `idl.metadata.address` field\"))?\n                    .into(),\n                metadata: t::IdlMetadata {\n                    name: idl.name,\n                    version: idl.version,\n                    spec: t::IDL_SPEC.into(),\n                    description: Default::default(),\n                    repository: Default::default(),\n                    dependencies: Default::default(),\n                    contact: Default::default(),\n                    deployments: Default::default(),\n                },\n                docs: idl.docs.unwrap_or_default(),\n                instructions: idl.instructions.into_iter().map(Into::into).collect(),\n                accounts: idl.accounts.clone().into_iter().map(Into::into).collect(),\n                events: idl\n                    .events\n                    .clone()\n                    .unwrap_or_default()\n                    .into_iter()\n                    .map(Into::into)\n                    .collect(),\n                errors: idl\n                    .errors\n                    .unwrap_or_default()\n                    .into_iter()\n                    .map(Into::into)\n                    .collect(),\n                types: idl\n                    .types\n                    .into_iter()\n                    .map(Into::into)\n                    .chain(idl.accounts.into_iter().map(Into::into))\n                    .chain(idl.events.unwrap_or_default().into_iter().map(Into::into))\n                    .collect(),\n                constants: idl.constants.into_iter().map(Into::into).collect(),\n            })\n        }",
    "pub fn create(ctx: Context<Create>, bump_seed: u8) -> Result<()> {\n///       let my_account = &mut ctx.accounts.my_account;\n///       my_account.bump_seed = bump_seed;\n///     }\n/// }\n///\n/// #[derive(Accounts)]\n/// pub struct Create {\n///   #[account(init)]\n///   my_account: Account<'info, MyAccount>,\n/// }\n///\n/// impl Create {\n///   pub fn accounts(ctx: &Context<Create>, bump_seed: u8) -> Result<()> {\n///     let seeds = &[ctx.accounts.my_account.to_account_info().key.as_ref(), &[bump_seed]];\n///     Pubkey::create_program_address(seeds, ctx.program_id)\n///       .map_err(|_| ErrorCode::InvalidNonce)?;\n///     Ok(())\n///   }\n/// }\n/// ```\n///\n/// This example demonstrates a useful pattern. Not only can you use\n/// `#[access_control]` to ensure any invariants or preconditions hold prior to\n/// executing an instruction, but also it can be used to finish any validation\n/// on the `Accounts` struct, particularly when instruction arguments are\n/// needed. Here, we use the given `bump_seed` to verify it creates a valid\n/// program-derived address.\n#[proc_macro_attribute]\npub fn access_control(\n    args: proc_macro::TokenStream,\n    input: proc_macro::TokenStream,\n) -> proc_macro::TokenStream {\n    let mut args = args.to_string();\n    args.retain(|c| !c.is_whitespace());\n    let access_control: Vec<proc_macro2::TokenStream> = args\n        .split(')')\n        .filter(|ac| !ac.is_empty())\n        .map(|ac| format!(\"{ac})\")) // Put back on the split char.\n        .map(|ac| format!(\"{ac}?;\")) // Add `?;` syntax.\n        .map(|ac| ac.parse().unwrap())\n        .collect();\n\n    let item_fn = parse_macro_input!(input as syn::ItemFn);\n\n    let fn_attrs = item_fn.attrs;\n    let fn_vis = item_fn.vis;\n    let fn_sig = item_fn.sig;\n    let fn_block = item_fn.block;\n\n    let fn_stmts = fn_block.stmts;\n\n    proc_macro::TokenStream::from(quote! {\n        #(#fn_attrs)*\n        #fn_vis #fn_sig {\n\n            #(#access_control)*\n\n            #(#fn_stmts)*\n        }\n    })\n}",
    "pub fn check_id(id: &#pubkey_type) -> bool {\n            id == &ID\n        }\n\n        /// Returns the program ID\n        pub fn id() -> #pubkey_type {\n            ID\n        }\n\n        /// Const version of `ID`\n        pub const fn id_const() -> #pubkey_type {\n            ID_CONST\n        }\n\n        #[cfg(test)]\n        #[test]\n        fn test_id() {\n            assert!(check_id(&id()));\n        }\n    });\n}\n\npub struct Pubkey(proc_macro2::TokenStream);\n\nimpl Parse for Pubkey {\n    fn parse(input: ParseStream) -> Result<Self> {\n        parse_id(\n            input,\n            quote! { anchor_lang::solana_program::pubkey::Pubkey },\n        )\n        .map(Self)\n    }",
    "pub fn gen_lazy(strct: &syn::ItemStruct) -> syn::Result<TokenStream> {\n    let ident = &strct.ident;\n    let lazy_ident = format_ident!(\"Lazy{}\", ident);\n    let load_common_ident = to_private_ident(\"load_common\");\n    let initialize_fields = to_private_ident(\"initialize_fields\");\n    let lazy_acc_ty = quote! { anchor_lang::accounts::lazy_account::LazyAccount };\n    let disc_len = quote! { <#ident as anchor_lang::Discriminator>::DISCRIMINATOR.len() }",
    "pub fn account(\n    args: proc_macro::TokenStream,\n    input: proc_macro::TokenStream,\n) -> proc_macro::TokenStream {\n    let args = parse_macro_input!(args as AccountArgs);\n    let namespace = args.namespace.unwrap_or_default();\n    let is_zero_copy = args.zero_copy.is_some();\n    let unsafe_bytemuck = args.zero_copy.unwrap_or_default();\n\n    let account_strct = parse_macro_input!(input as syn::ItemStruct);\n    let account_name = &account_strct.ident;\n    let account_name_str = account_name.to_string();\n    let (impl_gen, type_gen, where_clause) = account_strct.generics.split_for_impl();\n\n    let discriminator = args\n        .overrides\n        .and_then(|ov| ov.discriminator)\n        .unwrap_or_else(|| {\n            // Namespace the discriminator to prevent collisions.\n            let namespace = if namespace.is_empty() {\n                \"account\"\n            } else {\n                &namespace\n            };\n\n            gen_discriminator(namespace, account_name)\n        }",
    "pub fn derive_zero_copy_accessor(item: proc_macro::TokenStream) -> proc_macro::TokenStream {\n    let account_strct = parse_macro_input!(item as syn::ItemStruct);\n    let account_name = &account_strct.ident;\n    let (impl_gen, ty_gen, where_clause) = account_strct.generics.split_for_impl();\n\n    let fields = match &account_strct.fields {\n        syn::Fields::Named(n) => n,\n        _ => panic!(\"Fields must be named\"),\n    };\n    let methods: Vec<proc_macro2::TokenStream> = fields\n        .named\n        .iter()\n        .filter_map(|field: &syn::Field| {\n            field\n                .attrs\n                .iter()\n                .find(|attr| anchor_syn::parser::tts_to_string(&attr.path) == \"accessor\")\n                .map(|attr| {\n                    let mut tts = attr.tokens.clone().into_iter();\n                    let g_stream = match tts.next().expect(\"Must have a token group\") {\n                        proc_macro2::TokenTree::Group(g) => g.stream(),\n                        _ => panic!(\"Invalid syntax\"),\n                    };\n                    let accessor_ty = match g_stream.into_iter().next() {\n                        Some(token) => token,\n                        _ => panic!(\"Missing accessor type\"),\n                    };\n\n                    let field_name = field.ident.as_ref().unwrap();\n\n                    let get_field: proc_macro2::TokenStream =\n                        format!(\"get_{field_name}\").parse().unwrap();\n                    let set_field: proc_macro2::TokenStream =\n                        format!(\"set_{field_name}\").parse().unwrap();\n\n                    quote! {\n                        pub fn #get_field(&self) -> #accessor_ty {\n                            anchor_lang::__private::ZeroCopyAccessor::get(&self.#field_name)\n                        }",
    "pub fn zero_copy(\n    args: proc_macro::TokenStream,\n    item: proc_macro::TokenStream,\n) -> proc_macro::TokenStream {\n    let mut is_unsafe = false;\n    for arg in args.into_iter() {\n        match arg {\n            proc_macro::TokenTree::Ident(ident) => {\n                if ident.to_string() == \"unsafe\" {\n                    // `#[zero_copy(unsafe)]` maintains the old behaviour\n                    //\n                    // ```ignore\n                    // #[derive(Copy, Clone)]\n                    // #[repr(packed)]\n                    // struct MyStruct {...}\n                    // ```\n                    is_unsafe = true;\n                } else {\n                    // TODO: how to return a compile error with a span (can't return prase error because expected type TokenStream)\n                    panic!(\"expected single ident `unsafe`\");\n                }\n            }\n            _ => {\n                panic!(\"expected single ident `unsafe`\");\n            }\n        }\n    }\n\n    let account_strct = parse_macro_input!(item as syn::ItemStruct);\n\n    // Takes the first repr. It's assumed that more than one are not on the\n    // struct.\n    let attr = account_strct\n        .attrs\n        .iter()\n        .find(|attr| anchor_syn::parser::tts_to_string(&attr.path) == \"repr\");\n\n    let repr = match attr {\n        // Users might want to manually specify repr modifiers e.g. repr(C, packed)\n        Some(_attr) => quote! {},\n        None => {\n            if is_unsafe {\n                quote! {#[repr(Rust, packed)]}\n            } else {\n                quote! {#[repr(C)]}\n            }\n        }\n    };\n\n    let mut has_pod_attr = false;\n    let mut has_zeroable_attr = false;\n    for attr in account_strct.attrs.iter() {\n        let token_string = attr.tokens.to_string();\n        if token_string.contains(\"bytemuck :: Pod\") {\n            has_pod_attr = true;\n        }\n        if token_string.contains(\"bytemuck :: Zeroable\") {\n            has_zeroable_attr = true;\n        }\n    }\n\n    // Once the Pod derive macro is expanded the compiler has to use the local crate's\n    // bytemuck `::bytemuck::Pod` anyway, so we're no longer using the privately\n    // exported anchor bytemuck `__private::bytemuck`, so that there won't be any\n    // possible disparity between the anchor version and the local crate's version.\n    let pod = if has_pod_attr || is_unsafe {\n        quote! {}\n    } else {\n        quote! {#[derive(::bytemuck::Pod)]}\n    };\n    let zeroable = if has_zeroable_attr || is_unsafe {\n        quote! {}\n    } else {\n        quote! {#[derive(::bytemuck::Zeroable)]}\n    };\n\n    let ret = quote! {\n        #[derive(anchor_lang::__private::ZeroCopyAccessor, Copy, Clone)]\n        #repr\n        #pod\n        #zeroable\n        #account_strct\n    };\n\n    #[cfg(feature = \"idl-build\")]\n    {\n        let derive_unsafe = if is_unsafe {\n            // Not a real proc-macro but exists in order to pass the serialization info\n            quote! { #[derive(bytemuck::Unsafe)] }\n        } else {\n            quote! {}\n        };\n        let zc_struct = syn::parse2(quote! {\n            #derive_unsafe\n            #ret\n        })\n        .unwrap();\n        let idl_build_impl = anchor_syn::idl::impl_idl_build_struct(&zc_struct);\n        return proc_macro::TokenStream::from(quote! {\n            #ret\n            #idl_build_impl\n        });\n    }\n\n    #[allow(unreachable_code)]\n    proc_macro::TokenStream::from(ret)\n}",
    "pub fn pubkey(input: proc_macro::TokenStream) -> proc_macro::TokenStream {\n    let pk = parse_macro_input!(input as id::Pubkey);\n    proc_macro::TokenStream::from(quote! {#pk})\n}",
    "pub fn declare_id(input: proc_macro::TokenStream) -> proc_macro::TokenStream {\n    #[cfg(feature = \"idl-build\")]\n    let address = input.clone().to_string();\n\n    let id = parse_macro_input!(input as id::Id);\n    let ret = quote! { #id };\n\n    #[cfg(feature = \"idl-build\")]\n    {\n        let idl_print = anchor_syn::idl::gen_idl_print_fn_address(address);\n        return proc_macro::TokenStream::from(quote! {\n            #ret\n            #idl_print\n        });\n    }\n\n    #[allow(unreachable_code)]\n    proc_macro::TokenStream::from(ret)\n}",
    "pub fn hello(_ctx: Context<Hello>) -> Result<()> {\n///         Err(error!(MyError::Hello))\n///     }\n/// }\n///\n/// #[derive(Accounts)]\n/// pub struct Hello {}\n///\n/// #[error_code]\n/// pub enum MyError {\n///     #[msg(\"This is an error message clients will automatically display\")]\n///     Hello,\n/// }\n/// ```\n///\n/// Note that we generate a new `Error` type so that we can return either the\n/// user defined error enum *or* a\n/// [`ProgramError`](../solana_program/enum.ProgramError.html), which is used\n/// pervasively, throughout solana program crates. The generated `Error` type\n/// should almost never be used directly, as the user defined error is\n/// preferred. In the example above, `error!(MyError::Hello)`.\n///\n/// # Msg\n///\n/// The `#[msg(..)]` attribute is inert, and is used only as a marker so that\n/// parsers  and IDLs can map error codes to error messages.\n#[proc_macro_attribute]\npub fn error_code(\n    args: proc_macro::TokenStream,\n    input: proc_macro::TokenStream,\n) -> proc_macro::TokenStream {\n    let args = match args.is_empty() {\n        true => None,\n        false => Some(parse_macro_input!(args as ErrorArgs)),\n    };\n    let mut error_enum = parse_macro_input!(input as syn::ItemEnum);\n    let error = codegen::error::generate(error_parser::parse(&mut error_enum, args));\n    proc_macro::TokenStream::from(error)\n}",
    "pub fn example(_ctx: Context<Example>) -> Result<()> {\n///         Err(error!(MyError::Hello))\n///     }\n/// }\n///\n/// #[error_code]\n/// pub enum MyError {\n///     #[msg(\"This is an error message clients will automatically display\")]\n///     Hello,\n/// }\n/// ```\n#[proc_macro]\npub fn error(ts: proc_macro::TokenStream) -> TokenStream {\n    let input = parse_macro_input!(ts as ErrorInput);\n    let error_code = input.error_code;\n    create_error(error_code, true, None)\n}",
    "pub fn event(\n    args: proc_macro::TokenStream,\n    input: proc_macro::TokenStream,\n) -> proc_macro::TokenStream {\n    let args = parse_macro_input!(args as Overrides);\n    let event_strct = parse_macro_input!(input as syn::ItemStruct);\n    let event_name = &event_strct.ident;\n\n    let discriminator = args\n        .discriminator\n        .unwrap_or_else(|| gen_discriminator(\"event\", event_name));\n\n    let ret = quote! {\n        #[derive(AnchorSerialize, AnchorDeserialize)]\n        #event_strct\n\n        impl anchor_lang::Event for #event_name {\n            fn data(&self) -> Vec<u8> {\n                let mut data = Vec::with_capacity(256);\n                data.extend_from_slice(#event_name::DISCRIMINATOR);\n                self.serialize(&mut data).unwrap();\n                data\n            }\n        }\n\n        impl anchor_lang::Discriminator for #event_name {\n            const DISCRIMINATOR: &'static [u8] = #discriminator;\n        }\n    };\n\n    #[cfg(feature = \"idl-build\")]\n    {\n        let idl_build = anchor_syn::idl::gen_idl_print_fn_event(&event_strct);\n        return proc_macro::TokenStream::from(quote! {\n            #ret\n            #idl_build\n        });\n    }\n\n    #[allow(unreachable_code)]\n    proc_macro::TokenStream::from(ret)\n}",
    "pub fn initialize(_ctx: Context<Initialize>) -> Result<()> {\n///     emit!(MyEvent {\n///         data: 5,\n///         label: [1,2,3,4,5],\n///     });\n///     Ok(())\n/// }\n///\n/// #[event]\n/// pub struct MyEvent {\n///     pub data: u64,\n///     pub label: [u8; 5],\n/// }\n/// ```\n#[proc_macro]\npub fn emit(input: proc_macro::TokenStream) -> proc_macro::TokenStream {\n    let data: proc_macro2::TokenStream = input.into();\n    proc_macro::TokenStream::from(quote! {\n        {\n            anchor_lang::solana_program::log::sol_log_data(&[&anchor_lang::Event::data(&#data)]);\n        }\n    })\n}",
    "pub fn my_instruction(ctx: Context<MyInstruction>) -> Result<()> {\n///         emit_cpi!(MyEvent { data: 42 });\n///         Ok(())\n///     }\n/// }\n///\n/// #[event_cpi]\n/// #[derive(Accounts)]\n/// pub struct MyInstruction {}\n///\n/// #[event]\n/// pub struct MyEvent {\n///     pub data: u64,\n/// }\n/// ```\n///\n/// **NOTE:** This macro requires `ctx` to be in scope.\n///\n/// *Only available with `event-cpi` feature enabled.*\n#[cfg(feature = \"event-cpi\")]\n#[proc_macro]\npub fn emit_cpi(input: proc_macro::TokenStream) -> proc_macro::TokenStream {\n    let event_struct = parse_macro_input!(input as syn::Expr);\n\n    let authority = EventAuthority::get();\n    let authority_name = authority.name_token_stream();\n    let authority_seeds = authority.seeds;\n\n    proc_macro::TokenStream::from(quote! {\n        {\n            let authority_info = ctx.accounts.#authority_name.to_account_info();\n            let authority_bump = ctx.bumps.#authority_name;\n\n            let disc = anchor_lang::event::EVENT_IX_TAG_LE;\n            let inner_data = anchor_lang::Event::data(&#event_struct);\n            let ix_data: Vec<u8> = disc\n                .into_iter()\n                .map(|b| *b)\n                .chain(inner_data.into_iter())\n                .collect();\n\n            let ix = anchor_lang::solana_program::instruction::Instruction::new_with_bytes(\n                crate::ID,\n                &ix_data,\n                vec![\n                    anchor_lang::solana_program::instruction::AccountMeta::new_readonly(\n                        *authority_info.key,\n                        true,\n                    ),\n                ],\n            );\n            anchor_lang::solana_program::program::invoke_signed(\n                &ix,\n                &[authority_info],\n                &[&[#authority_seeds, &[authority_bump]]],\n            )\n            .map_err(anchor_lang::error::Error::from)?;\n        }\n    })\n}",
    "pub fn event_cpi(\n    _attr: proc_macro::TokenStream,\n    input: proc_macro::TokenStream,\n) -> proc_macro::TokenStream {\n    let accounts_struct = parse_macro_input!(input as syn::ItemStruct);\n    let accounts_struct = add_event_cpi_accounts(&accounts_struct).unwrap();\n    proc_macro::TokenStream::from(quote! {#accounts_struct})\n}",
    "pub fn program(\n    _args: proc_macro::TokenStream,\n    input: proc_macro::TokenStream,\n) -> proc_macro::TokenStream {\n    parse_macro_input!(input as anchor_syn::Program)\n        .to_token_stream()\n        .into()\n}",
    "pub fn declare_program(input: proc_macro::TokenStream) -> proc_macro::TokenStream {\n    parse_macro_input!(input as DeclareProgram)\n        .to_token_stream()\n        .into()\n}",
    "pub fn get_canonical_program_id() -> proc_macro2::TokenStream {\n    quote! { super::__ID }\n}\n\npub fn gen_docs(docs: &[String]) -> proc_macro2::TokenStream {\n    let docs = docs\n        .iter()\n        .map(|doc| format!(\"{}{doc}\", if doc.is_empty() { \"\" } else { \" \" }))\n        .map(|doc| quote! { #[doc = #doc] });\n    quote! { #(#docs)* }\n}\n\npub fn gen_discriminator(disc: &[u8]) -> proc_macro2::TokenStream {\n    quote! { [#(#disc), *] }\n}\n\npub fn gen_accounts_common(idl: &Idl, prefix: &str) -> proc_macro2::TokenStream {\n    let re_exports = idl\n        .instructions\n        .iter()\n        .map(|ix| format_ident!(\"__{}_accounts_{}\", prefix, ix.name))\n        .map(|ident| quote! { pub use super::internal::#ident::*; });\n\n    quote! {\n        pub mod accounts {\n            #(#re_exports)*\n        }\n    }\n}\n\npub fn convert_idl_type_to_syn_type(ty: &IdlType) -> syn::Type {\n    syn::parse_str(&convert_idl_type_to_str(ty)).unwrap()\n}",
    "pub fn convert_idl_type_to_str(ty: &IdlType) -> String {\n    match ty {\n        IdlType::Bool => \"bool\".into(),\n        IdlType::U8 => \"u8\".into(),\n        IdlType::I8 => \"i8\".into(),\n        IdlType::U16 => \"u16\".into(),\n        IdlType::I16 => \"i16\".into(),\n        IdlType::U32 => \"u32\".into(),\n        IdlType::I32 => \"i32\".into(),\n        IdlType::F32 => \"f32\".into(),\n        IdlType::U64 => \"u64\".into(),\n        IdlType::I64 => \"i64\".into(),\n        IdlType::F64 => \"f64\".into(),\n        IdlType::U128 => \"u128\".into(),\n        IdlType::I128 => \"i128\".into(),\n        IdlType::U256 => \"u256\".into(),\n        IdlType::I256 => \"i256\".into(),\n        IdlType::Bytes => \"Vec<u8>\".into(),\n        IdlType::String => \"String\".into(),\n        IdlType::Pubkey => \"Pubkey\".into(),\n        IdlType::Option(ty) => format!(\"Option<{}>\", convert_idl_type_to_str(ty)),\n        IdlType::Vec(ty) => format!(\"Vec<{}>\", convert_idl_type_to_str(ty)),\n        IdlType::Array(ty, len) => format!(\n            \"[{}; {}]\",\n            convert_idl_type_to_str(ty),\n            match len {\n                IdlArrayLen::Generic(len) => len.into(),\n                IdlArrayLen::Value(len) => len.to_string(),\n            }\n        ),\n        IdlType::Defined { name, generics } => generics\n            .iter()\n            .map(|generic| match generic {\n                IdlGenericArg::Type { ty } => convert_idl_type_to_str(ty),\n                IdlGenericArg::Const { value } => value.into(),\n            })\n            .reduce(|mut acc, cur| {\n                if !acc.is_empty() {\n                    acc.push(',');\n                }\n                acc.push_str(&cur);\n                acc\n            })\n            .map(|generics| format!(\"{name}<{generics}>\"))\n            .unwrap_or(name.into()),\n        IdlType::Generic(ty) => ty.into(),\n        _ => unimplemented!(\"{ty:?}\"),\n    }\n}\n\npub fn convert_idl_type_def_to_ts(\n    ty_def: &IdlTypeDef,\n    ty_defs: &[IdlTypeDef],\n) -> proc_macro2::TokenStream {\n    let name = format_ident!(\"{}\", ty_def.name);\n    let docs = gen_docs(&ty_def.docs);\n\n    let generics = {\n        let generics = ty_def\n            .generics\n            .iter()\n            .map(|generic| match generic {\n                IdlTypeDefGeneric::Type { name } => {\n                    let name = format_ident!(\"{}\", name);\n                    quote! { #name }\n                }\n                IdlTypeDefGeneric::Const { name, ty } => {\n                    let name = format_ident!(\"{}\", name);\n                    let ty = format_ident!(\"{}\", ty);\n                    quote! { const #name: #ty }\n                }\n            })\n            .collect::<Vec<_>>();\n        if generics.is_empty() {\n            quote!()\n        }",
    "pub fn gen_accounts_mod(idl: &Idl) -> proc_macro2::TokenStream {\n    let accounts = idl.accounts.iter().map(|acc| {\n        let name = format_ident!(\"{}\", acc.name);\n        let discriminator = gen_discriminator(&acc.discriminator);\n        let disc = quote! { #name::DISCRIMINATOR };\n\n        let ty_def = idl\n            .types\n            .iter()\n            .find(|ty| ty.name == acc.name)\n            .expect(\"Type must exist\");\n\n        let impls = {\n            let try_deserialize = quote! {\n                fn try_deserialize(buf: &mut &[u8]) -> anchor_lang::Result<Self> {\n                    if buf.len() < #disc.len() {\n                        return Err(anchor_lang::error::ErrorCode::AccountDiscriminatorNotFound.into());\n                    }\n\n                    let given_disc = &buf[..#disc.len()];\n                    if #disc != given_disc {\n                        return Err(\n                            anchor_lang::error!(anchor_lang::error::ErrorCode::AccountDiscriminatorMismatch)\n                            .with_account_name(stringify!(#name))\n                        );\n                    }\n\n                    Self::try_deserialize_unchecked(buf)\n                }",
    "pub fn gen_client_mod(idl: &Idl) -> proc_macro2::TokenStream {\n    let client_args_mod = gen_client_args_mod();\n    let client_accounts_mod = gen_client_accounts_mod(idl);\n\n    quote! {\n        /// Off-chain client helpers.\n        pub mod client {\n            use super::*;\n\n            #client_args_mod\n            #client_accounts_mod\n        }\n    }\n}\n\nfn gen_client_args_mod() -> proc_macro2::TokenStream {\n    quote! {\n        /// Client args.\n        pub mod args {\n            pub use super::internal::args::*;\n        }\n    }\n}\n\nfn gen_client_accounts_mod(idl: &Idl) -> proc_macro2::TokenStream {\n    gen_accounts_common(idl, \"client\")\n}",
    "pub fn gen_cpi_mod(idl: &Idl) -> proc_macro2::TokenStream {\n    let cpi_instructions = gen_cpi_instructions(idl);\n    let cpi_return_type = gen_cpi_return_type();\n    let cpi_accounts_mod = gen_cpi_accounts_mod(idl);\n\n    quote! {\n        /// Cross program invocation (CPI) helpers.\n        pub mod cpi {\n            use super::*;\n\n            #cpi_instructions\n            #cpi_return_type\n            #cpi_accounts_mod\n        }\n    }\n}\n\nfn gen_cpi_instructions(idl: &Idl) -> proc_macro2::TokenStream {\n    let ixs = idl.instructions.iter().map(|ix| {\n        let method_name = format_ident!(\"{}\", ix.name);\n        let accounts_ident = format_ident!(\"{}\", ix.name.to_camel_case());\n\n        let accounts_generic = if ix.accounts.is_empty() {\n           quote!()\n        }",
    "pub fn get(&self) -> T {\n                let (_key, data) = anchor_lang::solana_program::program::get_return_data().unwrap();\n                T::try_from_slice(&data).unwrap()\n            }",
    "pub fn gen_internal_mod(idl: &Idl) -> proc_macro2::TokenStream {\n    let internal_args_mod = gen_internal_args_mod(idl);\n    let internal_accounts_mod = gen_internal_accounts(idl);\n\n    quote! {\n        #[doc(hidden)]\n        mod internal {\n            use super::*;\n\n            #internal_args_mod\n            #internal_accounts_mod\n        }\n    }\n}\n\nfn gen_internal_args_mod(idl: &Idl) -> proc_macro2::TokenStream {\n    let ixs = idl.instructions.iter().map(|ix| {\n        let ix_struct_name = format_ident!(\"{}\", ix.name.to_camel_case());\n\n        let fields = ix.args.iter().map(|arg| {\n            let name = format_ident!(\"{}\", arg.name);\n            let ty = convert_idl_type_to_syn_type(&arg.ty);\n            quote! { pub #name: #ty }\n        });\n\n        let ix_struct = if ix.args.is_empty() {\n            quote! {\n                pub struct #ix_struct_name;\n            }\n        } else {\n            quote! {\n                pub struct #ix_struct_name {\n                    #(#fields),*\n                }\n            }\n        };\n\n        let discriminator = gen_discriminator(&ix.discriminator);\n        let impl_discriminator = quote! {\n            impl anchor_lang::Discriminator for #ix_struct_name {\n                const DISCRIMINATOR: &'static [u8] = &#discriminator;\n            }\n        };\n\n        let impl_ix_data = quote! {\n            impl anchor_lang::InstructionData for #ix_struct_name {}\n        };\n\n        let program_id = get_canonical_program_id();\n        let impl_owner = quote! {\n            impl anchor_lang::Owner for #ix_struct_name {\n                fn owner() -> Pubkey {\n                    #program_id\n                }\n            }\n        };\n\n        quote! {\n            /// Instruction argument\n            #[derive(AnchorSerialize, AnchorDeserialize)]\n            #ix_struct\n\n            #impl_discriminator\n            #impl_ix_data\n            #impl_owner\n        }\n    });\n\n    quote! {\n        /// An Anchor generated module containing the program's set of instructions, where each\n        /// method handler in the `#[program]` mod is associated with a struct defining the input\n        /// arguments to the method. These should be used directly, when one wants to serialize\n        /// Anchor instruction data, for example, when specifying instructions instructions on a\n        /// client.\n        pub mod args {\n            use super::*;\n\n            #(#ixs)*\n        }\n    }\n}\n\nfn gen_internal_accounts(idl: &Idl) -> proc_macro2::TokenStream {\n    let cpi_accounts = gen_internal_accounts_common(idl, __cpi_client_accounts::generate);\n    let client_accounts = gen_internal_accounts_common(idl, __client_accounts::generate);\n\n    quote! {\n        #cpi_accounts\n        #client_accounts\n    }\n}\n\nfn gen_internal_accounts_common(\n    idl: &Idl,\n    gen_accounts: impl Fn(&AccountsStruct, proc_macro2::TokenStream) -> proc_macro2::TokenStream,\n) -> proc_macro2::TokenStream {\n    // It's possible to declare an accounts struct and not use it as an instruction, see\n    // https://github.com/coral-xyz/anchor/issues/3274\n    fn get_non_instruction_composite_accounts<'a>(\n        accs: &'a [IdlInstructionAccountItem],\n        idl: &'a Idl,\n    ) -> Vec<&'a IdlInstructionAccounts> {\n        accs.iter()\n            .flat_map(|acc| match acc {\n                IdlInstructionAccountItem::Composite(accs)\n                    if !idl\n                        .instructions\n                        .iter()\n                        .any(|ix| ix.accounts == accs.accounts) =>\n                {\n                    let mut non_ix_composite_accs =\n                        get_non_instruction_composite_accounts(&accs.accounts, idl);\n                    if !non_ix_composite_accs.contains(&accs) {\n                        non_ix_composite_accs.push(accs);\n                    }\n                    non_ix_composite_accs\n                }\n                _ => Default::default(),\n            })\n            .collect()\n    }",
    "pub fn gen_types_mod(idl: &Idl) -> proc_macro2::TokenStream {\n    let types = idl\n        .types\n        .iter()\n        .filter(|ty| {\n            // Skip accounts and events\n            !(idl.accounts.iter().any(|acc| acc.name == ty.name)\n                || idl.events.iter().any(|ev| ev.name == ty.name))\n        }",
    "pub fn gen_utils_mod(idl: &Idl) -> proc_macro2::TokenStream {\n    let account = gen_account(idl);\n    let event = gen_event(idl);\n\n    quote! {\n        /// Program utilities.\n        pub mod utils {\n            use super::*;\n\n            #account\n            #event\n        }\n    }\n}\n\nfn gen_account(idl: &Idl) -> proc_macro2::TokenStream {\n    let variants = idl\n        .accounts\n        .iter()\n        .map(|acc| format_ident!(\"{}\", acc.name))\n        .map(|name| quote! { #name(#name) }",
    "pub fn try_from_bytes(bytes: &[u8]) -> Result<Self> {\n                Self::try_from(bytes)\n            }",
    "pub fn try_from_bytes(bytes: &[u8]) -> Result<Self> {\n                Self::try_from(bytes)\n            }",
    "pub fn initialize(ctx: Context<Create>, bump: u8, authority: Pubkey, data: u64) -> anchor_lang::Result<()> {\n///     ...\n///     Ok(())\n/// }\n/// ...\n/// #[derive(Accounts)]\n/// #[instruction(bump: u8)]\n/// pub struct Initialize<'info> {\n///     ...\n/// }\n/// ```\n///\n/// # Constraints\n///\n/// There are different types of constraints that can be applied with the `#[account(..)]` attribute.\n///\n/// Attributes may reference other data structures. When `<expr>` is used in the tables below, an arbitrary expression\n/// may be passed in as long as it evaluates to a value of the expected type, e.g. `owner = token_program.key()`. If `target_account`\n/// used, the `target_account` must exist in the struct and the `.key()` is implicit, e.g. `payer = authority`.\n///\n/// - [Normal Constraints](#normal-constraints)\n/// - [SPL Constraints](#spl-constraints)\n///\n/// # Normal Constraints\n/// <table>\n///     <thead>\n///         <tr>\n///             <th>Attribute</th>\n///             <th>Description</th>\n///         </tr>\n///     </thead>\n///     <tbody>\n///         <tr>\n///             <td>\n///                 <code>#[account(signer)]</code> <br><br><code>#[account(signer @ &lt;custom_error&gt;)]</code>\n///             </td>\n///             <td>\n///                 Checks the given account signed the transaction.<br>\n///                 Custom errors are supported via <code>@</code>.<br>\n///                 Consider using the <code>Signer</code> type if you would only have this constraint on the account.<br><br>\n///                 Example:\n///                 <pre><code>\n/// #[account(signer)]\n/// pub authority: AccountInfo<'info>,\n/// #[account(signer @ MyError::MyErrorCode)]\n/// pub payer: AccountInfo<'info>\n///                 </code></pre>\n///             </td>\n///         </tr>\n///         <tr>\n///             <td>\n///                 <code>#[account(mut)]</code> <br><br><code>#[account(mut @ &lt;custom_error&gt;)]</code>\n///             </td>\n///             <td>\n///                 Checks the given account is mutable.<br>\n///                 Makes anchor persist any state changes.<br>\n///                 Custom errors are supported via <code>@</code>.<br><br>\n///                 Example:\n///                 <pre><code>\n/// #[account(mut)]\n/// pub data_account: Account<'info, MyData>,\n/// #[account(mut @ MyError::MyErrorCode)]\n/// pub data_account_two: Account<'info, MyData>\n///                 </code></pre>\n///             </td>\n///         </tr>\n///         <tr>\n///             <td>\n///                 <code>#[account(init, payer = &lt;target_account&gt;, space = &lt;num_bytes&gt;)]</code>\n///             </td>\n///             <td>\n///                 Creates the account via a CPI to the system program and\n///                 initializes it (sets its account discriminator). The annotated account is required to sign for this instruction\n///                 unless `seeds` is provided. <br>\n///                 Marks the account as mutable and is mutually exclusive with <code>mut</code>.<br>\n///                 Makes the account rent exempt unless skipped with <code>rent_exempt = skip</code>.<br><br>\n///                 Use <code>#[account(zero)]</code> for accounts larger than 10 Kibibyte.<br><br>\n///                 <code>init</code> has to be used with additional constraints:\n///                 <ul>\n///                     <li>\n///                         Requires the <code>payer</code> constraint to also be on the account.\n///                         The <code>payer</code> account pays for the\n///                         account creation.\n///                     </li>\n///                     <li>\n///                         Requires the system program to exist on the struct\n///                         and be called <code>system_program</code>.\n///                     </li>\n///                     <li>\n///                         Requires that the <code>space</code> constraint is specified.\n///                         When using the <code>space</code> constraint, one must remember to add 8 to it\n///                         which is the size of the account discriminator. This only has to be done\n///                         for accounts owned by anchor programs.<br>\n///                         The given space number is the size of the account in bytes, so accounts that hold\n///                         a variable number of items such as a <code>Vec</code> should allocate sufficient space for all items that may\n///                         be added to the data structure because account size is fixed.\n///                         Check out the <a href = \"https://www.anchor-lang.com/docs/space\" target = \"_blank\" rel = \"noopener noreferrer\">space reference</a>\n///                         and the <a href = \"https://borsh.io/\" target = \"_blank\" rel = \"noopener noreferrer\">borsh library</a>\n///                         (which anchor uses under the hood for serialization) specification to learn how much\n///                         space different data structures require.\n///                     </li>\n///                 <br>\n///                 Example:\n///                 <pre>\n/// #[account]\n/// pub struct MyData {\n/// &nbsp;&nbsp;&nbsp;&nbsp;pub data: u64\n/// }&#10;\n/// #[derive(Accounts)]\n/// pub struct Initialize<'info> {\n/// &nbsp;&nbsp;&nbsp;&nbsp;#[account(init, payer = payer, space = 8 + 8)]\n/// &nbsp;&nbsp;&nbsp;&nbsp;pub data_account_two: Account<'info, MyData>,\n/// &nbsp;&nbsp;&nbsp;&nbsp;#[account(mut)]\n/// &nbsp;&nbsp;&nbsp;&nbsp;pub payer: Signer<'info>,\n/// &nbsp;&nbsp;&nbsp;&nbsp;pub system_program: Program<'info, System>,\n/// }\n///                 </pre>\n///                 </ul>\n///                 <code>init</code> can be combined with other constraints (at the same time):\n///                 <ul>\n///                     <li>\n///                         By default <code>init</code> sets the owner field of the created account to the\n///                         currently executing program. Add the <code>owner</code> constraint to specify a\n///                         different program owner.\n///                     </li>\n///                     <li>\n///                         Use the <code>seeds</code> constraint together with <code>bump</code>to create PDAs.<br>\n///                         <code>init</code> uses <code>find_program_address</code> to calculate the pda so the\n///                         bump value can be left empty.<br>\n///                         However, if you want to use the bump in your instruction,\n///                         you can pass it in as instruction data and set the bump value like shown in the example,\n///                         using the <code>instruction_data</code> attribute.\n///                         Anchor will then check that the bump returned by <code>find_program_address</code> equals\n///                         the bump in the instruction data.<br>\n///                         <code>seeds::program</code> cannot be used together with init because the creation of an\n///                         account requires its signature which for PDAs only the currently executing program can provide.\n///                     </li>\n///                 </ul>\n///                 Example:\n///                 <pre>\n/// #[derive(Accounts)]\n/// #[instruction(bump: u8)]\n/// pub struct Initialize<'info> {\n/// &nbsp;&nbsp;&nbsp;&nbsp;#[account(\n/// &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;init, payer = payer, space = 8 + 8\n/// &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;seeds = [b\"example_seed\"], bump = bump\n/// &nbsp;&nbsp;&nbsp;&nbsp;)]\n/// &nbsp;&nbsp;&nbsp;&nbsp;pub pda_data_account: Account<'info, MyData>,\n/// &nbsp;&nbsp;&nbsp;&nbsp;#[account(\n/// &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;init, payer = payer,\n/// &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;space = 8 + 8, owner = other_program.key()\n/// &nbsp;&nbsp;&nbsp;&nbsp;)]\n/// &nbsp;&nbsp;&nbsp;&nbsp;pub account_for_other_program: AccountInfo<'info>,\n/// &nbsp;&nbsp;&nbsp;&nbsp;#[account(\n/// &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;init, payer = payer, space = 8 + 8,\n/// &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;owner = other_program.key(),\n/// &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;seeds = [b\"other_seed\"], bump\n/// &nbsp;&nbsp;&nbsp;&nbsp;)]\n/// &nbsp;&nbsp;&nbsp;&nbsp;pub pda_for_other_program: AccountInfo<'info>,\n/// &nbsp;&nbsp;&nbsp;&nbsp;#[account(mut)]\n/// &nbsp;&nbsp;&nbsp;&nbsp;pub payer: Signer<'info>,\n/// &nbsp;&nbsp;&nbsp;&nbsp;pub system_program: Program<'info, System>,\n/// &nbsp;&nbsp;&nbsp;&nbsp;pub other_program: Program<'info, OtherProgram>\n/// }\n///                 </pre>\n///             </td>\n///         </tr>\n///         <tr>\n///             <td>\n///                 <code>#[account(init_if_needed, payer = &lt;target_account&gt;)]</code><br><br>\n///                 <code>#[account(init_if_needed, payer = &lt;target_account&gt;, space = &lt;num_bytes&gt;)]</code>\n///             </td>\n///             <td>\n///                 Exact same functionality as the <code>init</code> constraint but only runs if the account does not exist yet.<br>\n///                 If the account does exist, it still checks whether the given init constraints are correct,\n///                 e.g. that the account has the expected amount of space and, if it's a PDA, the correct seeds etc.<br><br>\n///                 This feature should be used with care and is therefore behind a feature flag.\n///                 You can enable it by importing <code>anchor-lang</code> with the <code>init-if-needed</code> cargo feature.<br>\n///                 When using <code>init_if_needed</code>, you need to make sure you properly protect yourself\n///                 against re-initialization attacks. You need to include checks in your code that check\n///                 that the initialized account cannot be reset to its initial settings after the first time it was\n///                 initialized (unless that it what you want).<br>\n///                 Because of the possibility of re-initialization attacks and the general guideline that instructions\n///                 should avoid having multiple execution flows (which is important so they remain easy to understand),\n///                 consider breaking up your instruction into two instructions - one for initializing and one for using\n///                 the account - unless you have a good reason not to do so.\n///                 <br><br>\n///                 Example:\n///                 <pre>\n/// #[account]\n/// #[derive(Default)]\n/// pub struct MyData {\n/// &nbsp;&nbsp;&nbsp;&nbsp;pub data: u64\n/// }&#10;\n/// #[account]\n/// pub struct OtherData {\n/// &nbsp;&nbsp;&nbsp;&nbsp;pub data: u64\n/// }&#10;\n/// #[derive(Accounts)]\n/// pub struct Initialize<'info> {\n/// &nbsp;&nbsp;&nbsp;&nbsp;#[account(init_if_needed, payer = payer)]\n/// &nbsp;&nbsp;&nbsp;&nbsp;pub data_account: Account<'info, MyData>,\n/// &nbsp;&nbsp;&nbsp;&nbsp;#[account(init_if_needed, payer = payer, space = 8 + 8)]\n/// &nbsp;&nbsp;&nbsp;&nbsp;pub data_account_two: Account<'info, OtherData>,\n/// &nbsp;&nbsp;&nbsp;&nbsp;#[account(mut)]\n/// &nbsp;&nbsp;&nbsp;&nbsp;pub payer: Signer<'info>,\n/// &nbsp;&nbsp;&nbsp;&nbsp;pub system_program: Program<'info, System>\n/// }\n///                 </pre>\n///             </td>\n///         </tr>\n///         <tr>\n///             <td>\n///                 <code>#[account(seeds = &lt;seeds&gt;, bump)]</code><br><br>\n///                 <code>#[account(seeds = &lt;seeds&gt;, bump, seeds::program = &lt;expr&gt;)]<br><br>\n///                 <code>#[account(seeds = &lt;seeds&gt;, bump = &lt;expr&gt;)]</code><br><br>\n///                 <code>#[account(seeds = &lt;seeds&gt;, bump = &lt;expr&gt;, seeds::program = &lt;expr&gt;)]</code><br><br>\n///             </td>\n///             <td>\n///                 Checks that given account is a PDA derived from the currently executing program,\n///                 the seeds, and if provided, the bump. If not provided, anchor uses the canonical\n///                 bump. <br>\n///                 Add <code>seeds::program = &lt;expr&gt;</code> to derive the PDA from a different\n///                 program than the currently executing one.<br>\n///                 This constraint behaves slightly differently when used with <code>init</code>.\n///                 See its description.\n///                 <br><br>\n///                 Example:\n///                 <pre><code>\n/// #[derive(Accounts)]\n/// #[instruction(first_bump: u8, second_bump: u8)]\n/// pub struct Example {\n///     #[account(seeds = [b\"example_seed\"], bump)]\n///     pub canonical_pda: AccountInfo<'info>,\n///     #[account(\n///         seeds = [b\"example_seed\"],\n///         bump,\n///         seeds::program = other_program.key()\n///     )]\n///     pub canonical_pda_two: AccountInfo<'info>,\n///     #[account(seeds = [b\"other_seed\"], bump = first_bump)]\n///     pub arbitrary_pda: AccountInfo<'info>\n///     #[account(\n///         seeds = [b\"other_seed\"],\n///         bump = second_bump,\n///         seeds::program = other_program.key()\n///     )]\n///     pub arbitrary_pda_two: AccountInfo<'info>,\n///     pub other_program: Program<'info, OtherProgram>\n/// }\n///                 </code></pre>\n///             </td>\n///         </tr>\n///         <tr>\n///             <td>\n///                 <code>#[account(has_one = &lt;target_account&gt;)]</code><br><br>\n///                 <code>#[account(has_one = &lt;target_account&gt; @ &lt;custom_error&gt;)]</code>\n///             </td>\n///             <td>\n///                 Checks the <code>target_account</code> field on the account matches the\n///                 key of the <code>target_account</code> field in the Accounts struct.<br>\n///                 Custom errors are supported via <code>@</code>.<br><br>\n///                 Example:\n///                 <pre><code>\n/// #[account(mut, has_one = authority)]\n/// pub data: Account<'info, MyData>,\n/// pub authority: Signer<'info>\n///                 </code></pre>\n///                 In this example <code>has_one</code> checks that <code>data.authority = authority.key()</code>\n///             </td>\n///         </tr>\n///         <tr>\n///             <td>\n///                 <code>#[account(address = &lt;expr&gt;)]</code><br><br>\n///                 <code>#[account(address = &lt;expr&gt; @ &lt;custom_error&gt;)]</code>\n///             </td>\n///             <td>\n///                 Checks the account key matches the pubkey.<br>\n///                 Custom errors are supported via <code>@</code>.<br><br>\n///                 Example:\n///                 <pre><code>\n/// #[account(address = crate::ID)]\n/// pub data: Account<'info, MyData>,\n/// #[account(address = crate::ID @ MyError::MyErrorCode)]\n/// pub data_two: Account<'info, MyData>\n///                 </code></pre>\n///             </td>\n///         </tr>\n///         <tr>\n///             <td>\n///                 <code>#[account(owner = &lt;expr&gt;)]</code><br><br>\n///                 <code>#[account(owner = &lt;expr&gt; @ &lt;custom_error&gt;)]</code>\n///             </td>\n///             <td>\n///                 Checks the account owner matches <code>expr</code>.<br>\n///                 Custom errors are supported via <code>@</code>.<br><br>\n///                 Example:\n///                 <pre><code>\n/// #[account(owner = Token::ID @ MyError::MyErrorCode)]\n/// pub data: Account<'info, MyData>,\n/// #[account(owner = token_program.key())]\n/// pub data_two: Account<'info, MyData>,\n/// pub token_program: Program<'info, Token>\n///                 </code></pre>\n///             </td>\n///         </tr>\n///         <tr>\n///             <td>\n///                 <code>#[account(executable)]</code>\n///             </td>\n///             <td>\n///                 Checks the account is executable (i.e. the account is a program).<br>\n///                 You may want to use the <code>Program</code> type instead.<br><br>\n///                 Example:\n///                 <pre><code>\n/// #[account(executable)]\n/// pub my_program: AccountInfo<'info>\n///                 </code></pre>\n///             </td>\n///         </tr>\n///         <tr>\n///             <td>\n///                 <code>#[account(rent_exempt = skip)]</code><br><br>\n///                 <code>#[account(rent_exempt = enforce)]</code>\n///             </td>\n///             <td>\n///                 Enforces rent exemption with <code>= enforce</code>.<br>\n///                 Skips rent exemption check that would normally be done\n///                 through other constraints with <code>= skip</code>,\n///                 e.g. when used with the <code>zero</code> constraint<br><br>\n///                 Example:\n///                 <pre><code>\n/// #[account(zero, rent_exempt = skip)]\n/// pub skipped_account: Account<'info, MyData>,\n/// #[account(rent_exempt = enforce)]\n/// pub enforced_account: AccountInfo<'info>\n///                 </code></pre>\n///             </td>\n///         </tr>\n///         <tr>\n///             <td>\n///                 <code>#[account(zero)]</code>\n///             </td>\n///             <td>\n///                 Checks the account discriminator is zero.<br>\n///                 Enforces rent exemption unless skipped with <code>rent_exempt = skip</code>.<br><br>\n///                 Use this constraint if you want to create an account in a previous instruction\n///                 and then initialize it in your instruction instead of using <code>init</code>.\n///                 This is necessary for accounts that are larger than 10 Kibibyte because those\n///                 accounts cannot be created via a CPI (which is what <code>init</code> would do).<br><br>\n///                 Anchor adds internal data to the account when using <code>zero</code> just like it\n///                 does with <code>init</code> which is why <code>zero</code> implies <code>mut</code>.\n///                 <br><br>\n///                 Example:\n///                 <pre><code>\n/// #[account(zero)]\n/// pub my_account: Account<'info, MyData>\n///                 </code></pre>\n///             </td>\n///         </tr>\n///         <tr>\n///             <td>\n///                 <code>#[account(close = &lt;target_account&gt;)]</code>\n///             </td>\n///             <td>\n///                 Closes the account by:<br>\n///                 &nbsp;&nbsp;&nbsp;&nbsp;- Sending the lamports to the specified account<br>\n///                 &nbsp;&nbsp;&nbsp;&nbsp;- Assigning the owner to the System Program<br>\n///                 &nbsp;&nbsp;&nbsp;&nbsp;- Resetting the data of the account<br><br>\n///                 Requires <code>mut</code> to exist on the account.\n///                 <br><br>\n///                 Example:\n///                 <pre><code>\n/// #[account(mut, close = receiver)]\n/// pub data_account: Account<'info, MyData>,\n/// #[account(mut)]\n/// pub receiver: SystemAccount<'info>\n///                 </code></pre>\n///             </td>\n///         </tr>\n///         <tr>\n///             <td>\n///                 <code>#[account(constraint = &lt;expr&gt;)]</code><br><br><code>#[account(constraint = &lt;expr&gt; @ &lt;custom_error&gt;)]</code>\n///             </td>\n///             <td>\n///                 Constraint that checks whether the given expression evaluates to true.<br>\n///                 Use this when no other constraint fits your use case.\n///                 <br><br>\n///                 Example:\n///                 <pre><code>\n/// #[account(constraint = one.keys[0].age == two.apple.age)]\n/// pub one: Account<'info, MyData>,\n/// pub two: Account<'info, OtherData>\n///                 </code></pre>\n///             </td>\n///         </tr>\n///         <tr>\n///             <td>\n///                 <code>#[account(realloc = &lt;space&gt;, realloc::payer = &lt;target&gt;, realloc::zero = &lt;bool&gt;)]</code>\n///             </td>\n///             <td>\n///                 Used to <a href=\"https://docs.rs/solana-program/latest/solana_program/account_info/struct.AccountInfo.html#method.realloc\" target = \"_blank\" rel = \"noopener noreferrer\">realloc</a>\n///                 program account space at the beginning of an instruction.\n///                 <br><br>\n///                 The account must be marked as <code>mut</code> and applied to either <code>Account</code> or <code>AccountLoader</code> types.\n///                 <br><br>\n///                 If the change in account data length is additive, lamports will be transferred from the <code>realloc::payer</code> into the\n///                 program account in order to maintain rent exemption. Likewise, if the change is subtractive, lamports will be transferred from\n///                 the program account back into the <code>realloc::payer</code>.\n///                 <br><br>\n///                 The <code>realloc::zero</code> constraint is required in order to determine whether the new memory should be zero initialized after\n///                 reallocation. Please read the documentation on the <code>AccountInfo::realloc</code> function linked above to understand the\n///                 caveats regarding compute units when providing <code>true</code or <code>false</code> to this flag.\n///                 <br><br>\n///                 The manual use of `AccountInfo::realloc` is discouraged in favor of the `realloc` constraint group due to the lack of native runtime checks\n///                 to prevent reallocation over the `MAX_PERMITTED_DATA_INCREASE` limit (which can unintentionally cause account data overwrite other accounts).\n///                 The constraint group also ensure account reallocation idempotency but checking and restricting duplicate account reallocation within a single ix.\n///                 <br><br>\n///                 Example:\n///                 <pre>\n/// #[derive(Accounts)]\n/// pub struct Example {\n///     #[account(mut)]\n///     pub payer: Signer<'info>,\n///     #[account(\n///         mut,\n///         seeds = [b\"example\"],\n///         bump,\n///         realloc = 8 + std::mem::size_of::<MyType>() + 100,\n///         realloc::payer = payer,\n///         realloc::zero = false,\n///     )]\n///     pub acc: Account<'info, MyType>,\n///     pub system_program: Program<'info, System>,\n/// }\n///                 </pre>\n///             </td>\n///         </tr>\n///     </tbody>\n/// </table>\n///\n/// # SPL Constraints\n///\n/// Anchor provides constraints that make verifying SPL accounts easier.\n///\n/// <table>\n///     <thead>\n///         <tr>\n///             <th>Attribute</th>\n///             <th>Description</th>\n///         </tr>\n///     </thead>\n///     <tbody>\n///         <tr>\n///             <td>\n///                 <code>#[account(token::mint = &lt;target_account&gt;, token::authority = &lt;target_account&gt;)]</code>\n///             <br><br>\n///                 <code>#[account(token::mint = &lt;target_account&gt;, token::authority = &lt;target_account&gt;, token::token_program = &lt;target_account&gt;)]</code>\n///             </td>\n///             <td>\n///                 Can be used as a check or with <code>init</code> to create a token\n///                 account with the given mint address and authority.<br>\n///                  When used as a check, it's possible to only specify a subset of the constraints.\n///                 <br><br>\n///                 Example:\n///                 <pre>\n/// use anchor_spl::{mint, token::{TokenAccount, Mint, Token}};\n/// ...&#10;\n/// #[account(\n///     init,\n///     payer = payer,\n///     token::mint = mint,\n///     token::authority = payer,\n/// )]\n/// pub token: Account<'info, TokenAccount>,\n/// #[account(address = mint::USDC)]\n/// pub mint: Account<'info, Mint>,\n/// #[account(mut)]\n/// pub payer: Signer<'info>,\n/// pub token_program: Program<'info, Token>,\n/// pub system_program: Program<'info, System>\n///                 </pre>\n///             </td>\n///         </tr>\n///         <tr>\n///             <td>\n///                 <code>#[account(mint::authority = &lt;target_account&gt;, mint::decimals = &lt;expr&gt;)]</code>\n///                 <br><br>\n///                 <code>#[account(mint::authority = &lt;target_account&gt;, mint::decimals = &lt;expr&gt;, mint::freeze_authority = &lt;target_account&gt;)]</code>\n///             </td>\n///             <td>\n///                 Can be used as a check or with <code>init</code> to create a mint\n///                 account with the given mint decimals and mint authority.<br>\n///                 The freeze authority is optional when used with <code>init</code>.<br>\n///                 When used as a check, it's possible to only specify a subset of the constraints.\n///                 <br><br>\n///                 Example:\n///                 <pre>\n/// use anchor_spl::token::{Mint, Token};\n/// ...&#10;\n/// #[account(\n///     init,\n///     payer = payer,\n///     mint::decimals = 9,\n///     mint::authority = payer,\n/// )]\n/// pub mint_one: Account<'info, Mint>,\n/// #[account(\n///     init,\n///     payer = payer,\n///     mint::decimals = 9,\n///     mint::authority = payer,\n///     mint::freeze_authority = payer\n/// )]\n/// pub mint_two: Account<'info, Mint>,\n/// #[account(mut)]\n/// pub payer: Signer<'info>,\n/// pub token_program: Program<'info, Token>,\n/// pub system_program: Program<'info, System>\n///                 </pre>\n///             </td>\n///         </tr>\n///         <tr>\n///             <td>\n///                 <code>#[account(associated_token::mint = &lt;target_account&gt;, associated_token::authority = &lt;target_account&gt;)]</code>\n///                <br><br>\n///                 <code>#[account(associated_token::mint = &lt;target_account&gt;, associated_token::authority = &lt;target_account&gt;, associated_token::token_program = &lt;target_account&gt;)]</code>\n///             </td>\n///             <td>\n///                 Can be used as a standalone as a check or with <code>init</code> to create an associated token\n///                 account with the given mint address and authority.\n///                 <br><br>\n///                 Example:\n///                 <pre>\n/// use anchor_spl::{\n///     associated_token::AssociatedToken,\n///     mint,\n///     token::{TokenAccount, Mint, Token}\n/// };\n/// ...&#10;\n/// #[account(\n///     init,\n///     payer = payer,\n///     associated_token::mint = mint,\n///     associated_token::authority = payer,\n/// )]\n/// pub token: Account<'info, TokenAccount>,\n/// #[account(\n///     associated_token::mint = mint,\n///     associated_token::authority = payer,\n/// )]\n/// pub second_token: Account<'info, TokenAccount>,\n/// #[account(address = mint::USDC)]\n/// pub mint: Account<'info, Mint>,\n/// #[account(mut)]\n/// pub payer: Signer<'info>,\n/// pub token_program: Program<'info, Token>,\n/// pub associated_token_program: Program<'info, AssociatedToken>,\n/// pub system_program: Program<'info, System>\n///                 </pre>\n///             </td>\n///         </tr><tr>\n///             <td>\n///                 <code>#[account(*::token_program = &lt;target_account&gt;)]</code>\n///             </td>\n///             <td>\n///                 The <code>token_program</code> can optionally be overridden.\n///                 <br><br>\n///                 Example:\n///                 <pre>\n/// use anchor_spl::token_interface::{TokenInterface, TokenAccount, Mint};\n/// ...&#10;\n/// #[account(\n///     mint::token_program = token_a_token_program,\n/// )]\n/// pub token_a_mint: InterfaceAccount<'info, Mint>,\n/// #[account(\n///     mint::token_program = token_b_token_program,\n/// )]\n/// pub token_b_mint: InterfaceAccount<'info, Mint>,\n/// #[account(\n///     init,\n///     payer = payer,\n///     token::mint = token_a_mint,\n///     token::authority = payer,\n///     token::token_program = token_a_token_program,\n/// )]\n/// pub token_a_account: InterfaceAccount<'info, TokenAccount>,\n/// #[account(\n///     init,\n///     payer = payer,\n///     token::mint = token_b_mint,\n///     token::authority = payer,\n///     token::token_program = token_b_token_program,\n/// )]\n/// pub token_b_account: InterfaceAccount<'info, TokenAccount>,\n/// pub token_a_token_program: Interface<'info, TokenInterface>,\n/// pub token_b_token_program: Interface<'info, TokenInterface>,\n/// #[account(mut)]\n/// pub payer: Signer<'info>,\n/// pub system_program: Program<'info, System>\n///                 </pre>\n///             </td>\n///         </tr>\n///     <tbody>\n/// </table>\n#[proc_macro_derive(Accounts, attributes(account, instruction))]\npub fn derive_accounts(item: TokenStream) -> TokenStream {\n    parse_macro_input!(item as anchor_syn::AccountsStruct)\n        .to_token_stream()\n        .into()\n}",
    "pub fn gen_lazy(input: proc_macro::TokenStream) -> syn::Result<proc_macro2::TokenStream> {\n    let item = syn::parse::<Item>(input)?;\n    let (name, generics, size, sized) = match &item {\n        Item::Struct(strct) => (\n            &strct.ident,\n            &strct.generics,\n            sum_fields(&strct.fields),\n            strct\n                .fields\n                .iter()\n                .map(|field| &field.ty)\n                .map(|ty| quote! { <#ty as anchor_lang::__private::Lazy>::SIZED })\n                .fold(quote!(true), |acc, sized| quote! { #acc && #sized }),\n        ),\n        Item::Enum(enm) => {\n            let arms = enm\n                .variants\n                .iter()\n                .map(|variant| sum_fields(&variant.fields))\n                .enumerate()\n                .map(|(i, size)| (Literal::usize_unsuffixed(i), size))\n                .map(|(i, size)| quote! { Some(#i) => { #size } });\n\n            (\n                &enm.ident,\n                &enm.generics,\n                quote! {\n                    1 + match buf.first() {\n                        #(#arms,)*\n                        _ => unreachable!(),\n                    }\n                },\n                quote!(false),\n            )\n        }",
    "pub fn anchor_serialize(input: TokenStream) -> TokenStream {\n    #[cfg(not(feature = \"idl-build\"))]\n    let ret = gen_borsh_serialize(input);\n    #[cfg(feature = \"idl-build\")]\n    let ret = gen_borsh_serialize(input.clone());\n\n    #[cfg(feature = \"idl-build\")]\n    {\n        use anchor_syn::idl::*;\n        use quote::quote;\n\n        let idl_build_impl = match syn::parse(input).unwrap() {\n            Item::Struct(item) => impl_idl_build_struct(&item),\n            Item::Enum(item) => impl_idl_build_enum(&item),\n            Item::Union(item) => impl_idl_build_union(&item),\n            // Derive macros can only be defined on structs, enums, and unions.\n            _ => unreachable!(),\n        };\n\n        return TokenStream::from(quote! {\n            #ret\n            #idl_build_impl\n        });\n    };\n\n    #[allow(unreachable_code)]\n    TokenStream::from(ret)\n}",
    "pub fn borsh_deserialize(input: TokenStream) -> TokenStream {\n    #[cfg(feature = \"lazy-account\")]\n    {\n        let deser = gen_borsh_deserialize(input.clone());\n        let lazy = lazy::gen_lazy(input).unwrap_or_else(|e| e.to_compile_error());\n        quote::quote! {\n            #deser\n            #lazy\n        }\n        .into()\n    }",
    "pub fn lazy(input: TokenStream) -> TokenStream {\n    lazy::gen_lazy(input)\n        .unwrap_or_else(|e| e.to_compile_error())\n        .into()\n}",
    "pub fn derive_init_space(item: TokenStream) -> TokenStream {\n    let input = parse_macro_input!(item as DeriveInput);\n    let (impl_generics, ty_generics, where_clause) = input.generics.split_for_impl();\n    let name = input.ident;\n\n    let process_struct_fields = |fields: Punctuated<Field, Comma>| {\n        let recurse = fields.into_iter().map(|f| {\n            let mut max_len_args = get_max_len_args(&f.attrs);\n            len_from_type(f.ty, &mut max_len_args)\n        }",
    "pub fn new(inner: T) -> Self {\n        Self { inner, pos: 0 }\n    }\n}\n\nimpl Write for BpfWriter<&mut [u8]> {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        if self.pos >= self.inner.len() as u64 {\n            return Ok(0);\n        }\n\n        let amt = cmp::min(\n            self.inner.len().saturating_sub(self.pos as usize),\n            buf.len(),\n        );\n        sol_memcpy(&mut self.inner[(self.pos as usize)..], buf, amt);\n        self.pos += amt as u64;\n        Ok(amt)\n    }",
    "pub fn is_closed(info: &AccountInfo) -> bool {\n    info.owner == &System::id() && info.data_is_empty()\n}",
    "pub fn set_data(ctx: Context<SetData>, age: u64, other_data: u32) -> Result<()> {\n///     // Set account data like this\n///     (*ctx.accounts.my_account).age = age;\n///     (*ctx.accounts.my_account).other_data = other_data;\n///     // or like this\n///     let my_account = &mut ctx.account.my_account;\n///     my_account.age = age;\n///     my_account.other_data = other_data;\n///     Ok(())\n/// }\n/// ```\npub struct Context<'a, 'b, 'c, 'info, T: Bumps> {\n    /// Currently executing program id.\n    pub program_id: &'a Pubkey,\n    /// Deserialized accounts.\n    pub accounts: &'b mut T,\n    /// Remaining accounts given but not deserialized or validated.\n    /// Be very careful when using this directly.\n    pub remaining_accounts: &'c [AccountInfo<'info>],\n    /// Bump seeds found during constraint validation. This is provided as a\n    /// convenience so that handlers don't have to recalculate bump seeds or\n    /// pass them in as arguments.\n    /// Type is the bumps struct generated by #[derive(Accounts)]\n    pub bumps: T::Bumps,\n}\n\nimpl<T> fmt::Debug for Context<'_, '_, '_, '_, T>\nwhere\n    T: fmt::Debug + Bumps,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"Context\")\n            .field(\"program_id\", &self.program_id)\n            .field(\"accounts\", &self.accounts)\n            .field(\"remaining_accounts\", &self.remaining_accounts)\n            .field(\"bumps\", &self.bumps)\n            .finish()\n    }",
    "pub fn log(&self) {\n        match self {\n            Error::ProgramError(program_error) => program_error.log(),\n            Error::AnchorError(anchor_error) => anchor_error.log(),\n        }\n    }\n\n    pub fn with_account_name(mut self, account_name: impl ToString) -> Self {\n        match &mut self {\n            Error::AnchorError(ae) => {\n                ae.error_origin = Some(ErrorOrigin::AccountName(account_name.to_string()));\n            }\n            Error::ProgramError(pe) => {\n                pe.error_origin = Some(ErrorOrigin::AccountName(account_name.to_string()));\n            }\n        };\n        self\n    }\n\n    pub fn with_source(mut self, source: Source) -> Self {\n        match &mut self {\n            Error::AnchorError(ae) => {\n                ae.error_origin = Some(ErrorOrigin::Source(source));\n            }\n            Error::ProgramError(pe) => {\n                pe.error_origin = Some(ErrorOrigin::Source(source));\n            }\n        };\n        self\n    }\n\n    pub fn with_pubkeys(mut self, pubkeys: (Pubkey, Pubkey)) -> Self {\n        let pubkeys = Some(ComparedValues::Pubkeys((pubkeys.0, pubkeys.1)));\n        match &mut self {\n            Error::AnchorError(ae) => ae.compared_values = pubkeys,\n            Error::ProgramError(pe) => pe.compared_values = pubkeys,\n        };\n        self\n    }\n\n    pub fn with_values(mut self, values: (impl ToString, impl ToString)) -> Self {\n        match &mut self {\n            Error::AnchorError(ae) => {\n                ae.compared_values = Some(ComparedValues::Values((\n                    values.0.to_string(),\n                    values.1.to_string(),\n                )))\n            }",
    "pub fn log(&self) {\n        match &self.error_origin {\n            None => {\n                anchor_lang::solana_program::msg!(\n                    \"ProgramError occurred. Error Code: {:?}. Error Number: {}. Error Message: {}.\",\n                    self.program_error,\n                    u64::from(self.program_error.clone()),\n                    self.program_error\n                );\n            }\n            Some(ErrorOrigin::Source(source)) => {\n                anchor_lang::solana_program::msg!(\n                    \"ProgramError thrown in {}:{}. Error Code: {:?}. Error Number: {}. Error Message: {}.\",\n                    source.filename,\n                    source.line,\n                    self.program_error,\n                    u64::from(self.program_error.clone()),\n                    self.program_error\n                );\n            }\n            Some(ErrorOrigin::AccountName(account_name)) => {\n                // using sol_log because msg! wrongly interprets 5 inputs as u64\n                anchor_lang::solana_program::log::sol_log(&format!(\n                    \"ProgramError caused by account: {}. Error Code: {:?}. Error Number: {}. Error Message: {}.\",\n                    account_name,\n                    self.program_error,\n                    u64::from(self.program_error.clone()),\n                    self.program_error\n                ));\n            }\n        }\n        match &self.compared_values {\n            Some(ComparedValues::Pubkeys((left, right))) => {\n                anchor_lang::solana_program::msg!(\"Left:\");\n                left.log();\n                anchor_lang::solana_program::msg!(\"Right:\");\n                right.log();\n            }\n            Some(ComparedValues::Values((left, right))) => {\n                anchor_lang::solana_program::msg!(\"Left: {}\", left);\n                anchor_lang::solana_program::msg!(\"Right: {}\", right);\n            }\n            None => (),\n        }\n    }\n\n    pub fn with_source(mut self, source: Source) -> Self {\n        self.error_origin = Some(ErrorOrigin::Source(source));\n        self\n    }\n\n    pub fn with_account_name(mut self, account_name: impl ToString) -> Self {\n        self.error_origin = Some(ErrorOrigin::AccountName(account_name.to_string()));\n        self\n    }\n}\n\nimpl From<ProgramError> for ProgramErrorWithOrigin {\n    fn from(program_error: ProgramError) -> Self {\n        Self {\n            program_error,\n            error_origin: None,\n            compared_values: None,\n        }\n    }\n}\n\n#[derive(Debug)]\npub enum ComparedValues {\n    Values((String, String)),\n    Pubkeys((Pubkey, Pubkey)),\n}\n\n#[derive(Debug)]\npub enum ErrorOrigin {\n    Source(Source),\n    AccountName(String),\n}\n\n#[derive(Debug)]\npub struct AnchorError {\n    pub error_name: String,\n    pub error_code_number: u32,\n    pub error_msg: String,\n    pub error_origin: Option<ErrorOrigin>,\n    pub compared_values: Option<ComparedValues>,\n}\n\nimpl AnchorError {\n    pub fn log(&self) {\n        match &self.error_origin {\n            None => {\n                anchor_lang::solana_program::log::sol_log(&format!(\n                    \"AnchorError occurred. Error Code: {}. Error Number: {}. Error Message: {}.\",\n                    self.error_name, self.error_code_number, self.error_msg\n                ));\n            }\n            Some(ErrorOrigin::Source(source)) => {\n                anchor_lang::solana_program::msg!(\n                    \"AnchorError thrown in {}:{}. Error Code: {}. Error Number: {}. Error Message: {}.\",\n                    source.filename,\n                    source.line,\n                    self.error_name,\n                    self.error_code_number,\n                    self.error_msg\n                );\n            }\n            Some(ErrorOrigin::AccountName(account_name)) => {\n                anchor_lang::solana_program::log::sol_log(&format!(\n                    \"AnchorError caused by account: {}. Error Code: {}. Error Number: {}. Error Message: {}.\",\n                    account_name,\n                    self.error_name,\n                    self.error_code_number,\n                    self.error_msg\n                ));\n            }\n        }\n        match &self.compared_values {\n            Some(ComparedValues::Pubkeys((left, right))) => {\n                anchor_lang::solana_program::msg!(\"Left:\");\n                left.log();\n                anchor_lang::solana_program::msg!(\"Right:\");\n                right.log();\n            }\n            Some(ComparedValues::Values((left, right))) => {\n                anchor_lang::solana_program::msg!(\"Left: {}\", left);\n                anchor_lang::solana_program::msg!(\"Right: {}\", right);\n            }\n            None => (),\n        }\n    }\n\n    pub fn with_source(mut self, source: Source) -> Self {\n        self.error_origin = Some(ErrorOrigin::Source(source));\n        self\n    }\n\n    pub fn with_account_name(mut self, account_name: impl ToString) -> Self {\n        self.error_origin = Some(ErrorOrigin::AccountName(account_name.to_string()));\n        self\n    }\n}\n\nimpl Display for AnchorError {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        Debug::fmt(&self, f)\n    }",
    "pub fn address(program_id: &Pubkey) -> Pubkey {\n        let program_signer = Pubkey::find_program_address(&[], program_id).0;\n        Pubkey::create_with_seed(&program_signer, IdlAccount::seed(), program_id)\n            .expect(\"Seed is always valid\")\n    }",
    "pub fn set_data(ctx: Context<SetData>, data: u64) -> Result<()> {\n///     require!(ctx.accounts.data.mutation_allowed, MyError::MutationForbidden);\n///     ctx.accounts.data.data = data;\n///     Ok(())\n/// }\n///\n/// // An enum for custom error codes\n/// #[error_code]\n/// pub enum MyError {\n///     MutationForbidden\n/// }\n///\n/// // An account definition\n/// #[account]\n/// #[derive(Default)]\n/// pub struct MyData {\n///     mutation_allowed: bool,\n///     data: u64\n/// }\n///\n/// // An account validation struct\n/// #[derive(Accounts)]\n/// pub struct SetData<'info> {\n///     #[account(mut)]\n///     pub data: Account<'info, MyData>\n/// }\n/// ```\n#[macro_export]\nmacro_rules! require {\n    ($invariant:expr, $error:tt $(,)?) => {\n        if !($invariant) {\n            return Err(anchor_lang::error!($crate::ErrorCode::$error));\n        }\n    };\n    ($invariant:expr, $error:expr $(,)?) => {\n        if !($invariant) {\n            return Err(anchor_lang::error!($error));\n        }\n    };\n}\n\n/// Ensures two NON-PUBKEY values are equal.\n///\n/// Use [require_keys_eq](crate::prelude::require_keys_eq)\n/// to compare two pubkeys.\n///\n/// Can be used with or without a custom error code.\n///\n/// # Example\n/// ```rust,ignore\n/// pub fn set_data(ctx: Context<SetData>, data: u64) -> Result<()> {\n///     require_eq!(ctx.accounts.data.data, 0);\n///     ctx.accounts.data.data = data;\n///     Ok(())\n/// }\n/// ```\n#[macro_export]\nmacro_rules! require_eq {\n    ($value1: expr, $value2: expr, $error_code:expr $(,)?) => {\n        if $value1 != $value2 {\n            return Err(error!($error_code).with_values(($value1, $value2)));\n        }\n    };\n    ($value1: expr, $value2: expr $(,)?) => {\n        if $value1 != $value2 {\n            return Err(error!(anchor_lang::error::ErrorCode::RequireEqViolated)\n                .with_values(($value1, $value2)));\n        }\n    };\n}\n\n/// Ensures two NON-PUBKEY values are not equal.\n///\n/// Use [require_keys_neq](crate::prelude::require_keys_neq)\n/// to compare two pubkeys.\n///\n/// Can be used with or without a custom error code.\n///\n/// # Example\n/// ```rust,ignore\n/// pub fn set_data(ctx: Context<SetData>, data: u64) -> Result<()> {\n///     require_neq!(ctx.accounts.data.data, 0);\n///     ctx.accounts.data.data = data;\n///     Ok(());\n/// }\n/// ```\n#[macro_export]\nmacro_rules! require_neq {\n    ($value1: expr, $value2: expr, $error_code: expr $(,)?) => {\n        if $value1 == $value2 {\n            return Err(error!($error_code).with_values(($value1, $value2)));\n        }\n    };\n    ($value1: expr, $value2: expr $(,)?) => {\n        if $value1 == $value2 {\n            return Err(error!(anchor_lang::error::ErrorCode::RequireNeqViolated)\n                .with_values(($value1, $value2)));\n        }\n    };\n}\n\n/// Ensures two pubkeys values are equal.\n///\n/// Use [require_eq](crate::prelude::require_eq)\n/// to compare two non-pubkey values.\n///\n/// Can be used with or without a custom error code.\n///\n/// # Example\n/// ```rust,ignore\n/// pub fn set_data(ctx: Context<SetData>, data: u64) -> Result<()> {\n///     require_keys_eq!(ctx.accounts.data.authority.key(), ctx.accounts.authority.key());\n///     ctx.accounts.data.data = data;\n///     Ok(())\n/// }\n/// ```\n#[macro_export]\nmacro_rules! require_keys_eq {\n    ($value1: expr, $value2: expr, $error_code:expr $(,)?) => {\n        if $value1 != $value2 {\n            return Err(error!($error_code).with_pubkeys(($value1, $value2)));\n        }\n    };\n    ($value1: expr, $value2: expr $(,)?) => {\n        if $value1 != $value2 {\n            return Err(error!(anchor_lang::error::ErrorCode::RequireKeysEqViolated)\n                .with_pubkeys(($value1, $value2)));\n        }\n    };\n}\n\n/// Ensures two pubkeys are not equal.\n///\n/// Use [require_neq](crate::prelude::require_neq)\n/// to compare two non-pubkey values.\n///\n/// Can be used with or without a custom error code.\n///\n/// # Example\n/// ```rust,ignore\n/// pub fn set_data(ctx: Context<SetData>, data: u64) -> Result<()> {\n///     require_keys_neq!(ctx.accounts.data.authority.key(), ctx.accounts.other.key());\n///     ctx.accounts.data.data = data;\n///     Ok(())\n/// }\n/// ```\n#[macro_export]\nmacro_rules! require_keys_neq {\n    ($value1: expr, $value2: expr, $error_code: expr $(,)?) => {\n        if $value1 == $value2 {\n            return Err(error!($error_code).with_pubkeys(($value1, $value2)));\n        }\n    };\n    ($value1: expr, $value2: expr $(,)?) => {\n        if $value1 == $value2 {\n            return Err(\n                error!(anchor_lang::error::ErrorCode::RequireKeysNeqViolated)\n                    .with_pubkeys(($value1, $value2)),\n            );\n        }\n    };\n}\n\n/// Ensures the first NON-PUBKEY value is greater than the second\n/// NON-PUBKEY value.\n///\n/// To include an equality check, use [require_gte](crate::require_gte).\n///\n/// Can be used with or without a custom error code.\n///\n/// # Example\n/// ```rust,ignore\n/// pub fn set_data(ctx: Context<SetData>, data: u64) -> Result<()> {\n///     require_gt!(ctx.accounts.data.data, 0);\n///     ctx.accounts.data.data = data;\n///     Ok(());\n/// }\n/// ```\n#[macro_export]\nmacro_rules! require_gt {\n    ($value1: expr, $value2: expr, $error_code: expr $(,)?) => {\n        if $value1 <= $value2 {\n            return Err(error!($error_code).with_values(($value1, $value2)));\n        }\n    };\n    ($value1: expr, $value2: expr $(,)?) => {\n        if $value1 <= $value2 {\n            return Err(error!(anchor_lang::error::ErrorCode::RequireGtViolated)\n                .with_values(($value1, $value2)));\n        }\n    };\n}\n\n/// Ensures the first NON-PUBKEY value is greater than or equal\n/// to the second NON-PUBKEY value.\n///\n/// Can be used with or without a custom error code.\n///\n/// # Example\n/// ```rust,ignore\n/// pub fn set_data(ctx: Context<SetData>, data: u64) -> Result<()> {\n///     require_gte!(ctx.accounts.data.data, 1);\n///     ctx.accounts.data.data = data;\n///     Ok(());\n/// }\n/// ```\n#[macro_export]\nmacro_rules! require_gte {\n    ($value1: expr, $value2: expr, $error_code: expr $(,)?) => {\n        if $value1 < $value2 {\n            return Err(error!($error_code).with_values(($value1, $value2)));\n        }\n    };\n    ($value1: expr, $value2: expr $(,)?) => {\n        if $value1 < $value2 {\n            return Err(error!(anchor_lang::error::ErrorCode::RequireGteViolated)\n                .with_values(($value1, $value2)));\n        }\n    };\n}\n\n/// Returns with the given error.\n/// Use this with a custom error type.\n///\n/// # Example\n/// ```ignore\n/// // Instruction function\n/// pub fn example(ctx: Context<Example>) -> Result<()> {\n///     err!(MyError::SomeError)\n/// }\n///\n/// // An enum for custom error codes\n/// #[error_code]\n/// pub enum MyError {\n///     SomeError\n/// }\n/// ```\n#[macro_export]\nmacro_rules! err {\n    ($error:tt $(,)?) => {\n        Err(anchor_lang::error!($crate::ErrorCode::$error))\n    }",
    "pub fn set_data(ctx: Context<SetData>, data: u64) -> Result<()> {\n///         if (*ctx.accounts.auth_account).authorized {\n///             (*ctx.accounts.my_account).data = data;\n///         }\n///         Ok(())\n///     }\n/// }\n///\n/// #[account]\n/// #[derive(Default)]\n/// pub struct MyData {\n///     pub data: u64\n/// }\n///\n/// #[derive(Accounts)]\n/// pub struct SetData<'info> {\n///     #[account(mut)]\n///     pub my_account: Account<'info, MyData> // checks that my_account.info.owner == Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS\n///     pub auth_account: Account<'info, Auth> // checks that auth_account.info.owner == FEZGUxNhZWpYPj9MJCrZJvUo1iF9ys34UHx52y4SzVW9\n/// }\n///\n/// // In a different program\n///\n/// ...\n/// declare_id!(\"FEZGUxNhZWpYPj9MJCrZJvUo1iF9ys34UHx52y4SzVW9\");\n/// #[account]\n/// #[derive(Default)]\n/// pub struct Auth {\n///     pub authorized: bool\n/// }\n/// ...\n/// ```\n///\n/// # Using Account with non-anchor programs\n///\n/// Account can also be used with non-anchor programs. The data types from\n/// those programs are not annotated with `#[account]` so you have to\n/// - create a wrapper type around the structs you want to wrap with Account\n/// - implement the functions required by Account yourself\n///\n/// instead of using `#[account]`. You only have to implement a fraction of the\n/// functions `#[account]` generates. See the example below for the code you have\n/// to write.\n///\n/// The mint wrapper type that Anchor provides out of the box for the token program ([source](https://github.com/coral-xyz/anchor/blob/master/spl/src/token.rs))\n/// ```ignore\n/// #[derive(Clone)]\n/// pub struct Mint(spl_token::state::Mint);\n///\n/// // This is necessary so we can use \"anchor_spl::token::Mint::LEN\"\n/// // because rust does not resolve \"anchor_spl::token::Mint::LEN\" to\n/// // \"spl_token::state::Mint::LEN\" automatically\n/// impl Mint {\n///     pub const LEN: usize = spl_token::state::Mint::LEN;\n/// }\n///\n/// // You don't have to implement the \"try_deserialize\" function\n/// // from this trait. It delegates to\n/// // \"try_deserialize_unchecked\" by default which is what we want here\n/// // because non-anchor accounts don't have a discriminator to check\n/// impl anchor_lang::AccountDeserialize for Mint {\n///     fn try_deserialize_unchecked(buf: &mut &[u8]) -> Result<Self> {\n///         spl_token::state::Mint::unpack(buf).map(Mint)\n///     }\n/// }\n/// // AccountSerialize defaults to a no-op which is what we want here\n/// // because it's a foreign program, so our program does not\n/// // have permission to write to the foreign program's accounts anyway\n/// impl anchor_lang::AccountSerialize for Mint {}\n///\n/// impl anchor_lang::Owner for Mint {\n///     fn owner() -> Pubkey {\n///         // pub use spl_token::ID is used at the top of the file\n///         ID\n///     }\n/// }\n///\n/// // Implement the \"std::ops::Deref\" trait for better user experience\n/// impl Deref for Mint {\n///     type Target = spl_token::state::Mint;\n///\n///     fn deref(&self) -> &Self::Target {\n///         &self.0\n///     }\n/// }\n/// ```\n///\n/// ## Out of the box wrapper types\n///\n/// ### Accessing BPFUpgradeableLoader Data\n///\n/// Anchor provides wrapper types to access data stored in programs owned by the BPFUpgradeableLoader\n/// such as the upgrade authority. If you're interested in the data of a program account, you can use\n/// ```ignore\n/// Account<'info, BpfUpgradeableLoaderState>\n/// ```\n/// and then match on its contents inside your instruction function.\n///\n/// Alternatively, you can use\n/// ```ignore\n/// Account<'info, ProgramData>\n/// ```\n/// to let anchor do the matching for you and return the ProgramData variant of BpfUpgradeableLoaderState.\n///\n/// # Example\n/// ```ignore\n/// use anchor_lang::prelude::*;\n/// use crate::program::MyProgram;\n///\n/// declare_id!(\"Cum9tTyj5HwcEiAmhgaS7Bbj4UczCwsucrCkxRECzM4e\");\n///\n/// #[program]\n/// pub mod my_program {\n///     use super::*;\n///\n///     pub fn set_initial_admin(\n///         ctx: Context<SetInitialAdmin>,\n///         admin_key: Pubkey\n///     ) -> Result<()> {\n///         ctx.accounts.admin_settings.admin_key = admin_key;\n///         Ok(())\n///     }\n///\n///     pub fn set_admin(...){...}\n///\n///     pub fn set_settings(...){...}\n/// }\n///\n/// #[account]\n/// #[derive(Default, Debug)]\n/// pub struct AdminSettings {\n///     admin_key: Pubkey\n/// }\n///\n/// #[derive(Accounts)]\n/// pub struct SetInitialAdmin<'info> {\n///     #[account(init, payer = authority, seeds = [b\"admin\"], bump)]\n///     pub admin_settings: Account<'info, AdminSettings>,\n///     #[account(mut)]\n///     pub authority: Signer<'info>,\n///     #[account(constraint = program.programdata_address()? == Some(program_data.key()))]\n///     pub program: Program<'info, MyProgram>,\n///     #[account(constraint = program_data.upgrade_authority_address == Some(authority.key()))]\n///     pub program_data: Account<'info, ProgramData>,\n///     pub system_program: Program<'info, System>,\n/// }\n/// ```\n///\n/// This example solves a problem you may face if your program has admin settings: How do you set the\n/// admin key for restricted functionality after deployment? Setting the admin key itself should\n/// be a restricted action but how do you restrict it without having set an admin key?\n/// You're stuck in a loop.\n/// One solution is to use the upgrade authority of the program as the initial\n/// (or permanent) admin key.\n///\n/// ### SPL Types\n///\n/// Anchor provides wrapper types to access accounts owned by the token program. Use\n/// ```ignore\n/// use anchor_spl::token::TokenAccount;\n///\n/// #[derive(Accounts)]\n/// pub struct Example {\n///     pub my_acc: Account<'info, TokenAccount>\n/// }\n/// ```\n/// to access token accounts and\n/// ```ignore\n/// use anchor_spl::token::Mint;\n///\n/// #[derive(Accounts)]\n/// pub struct Example {\n///     pub my_acc: Account<'info, Mint>\n/// }\n/// ```\n/// to access mint accounts.\n#[derive(Clone)]\npub struct Account<'info, T: AccountSerialize + AccountDeserialize + Clone> {\n    account: T,\n    info: &'info AccountInfo<'info>,\n}\n\nimpl<T: AccountSerialize + AccountDeserialize + Clone + fmt::Debug> fmt::Debug for Account<'_, T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        self.fmt_with_name(\"Account\", f)\n    }",
    "pub fn reload(&mut self) -> Result<()> {\n        let mut data: &[u8] = &self.info.try_borrow_data()?;\n        self.account = T::try_deserialize(&mut data)?;\n        Ok(())\n    }",
    "pub fn into_inner(self) -> T {\n        self.account\n    }\n\n    /// Sets the inner account.\n    ///\n    /// Instead of this:\n    /// ```ignore\n    /// pub fn new_user(ctx: Context<CreateUser>, new_user:User) -> Result<()> {\n    ///     (*ctx.accounts.user_to_create).name = new_user.name;\n    ///     (*ctx.accounts.user_to_create).age = new_user.age;\n    ///     (*ctx.accounts.user_to_create).address = new_user.address;\n    /// }\n    /// ```\n    /// You can do this:\n    /// ```ignore\n    /// pub fn new_user(ctx: Context<CreateUser>, new_user:User) -> Result<()> {\n    ///     ctx.accounts.user_to_create.set_inner(new_user);\n    /// }\n    /// ```\n    pub fn set_inner(&mut self, inner: T) {\n        self.account = inner;\n    }\n}\n\nimpl<'a, T: AccountSerialize + AccountDeserialize + Owner + Clone> Account<'a, T> {\n    /// Deserializes the given `info` into a `Account`.\n    #[inline(never)]\n    pub fn try_from(info: &'a AccountInfo<'a>) -> Result<Account<'a, T>> {\n        if info.owner == &system_program::ID && info.lamports() == 0 {\n            return Err(ErrorCode::AccountNotInitialized.into());\n        }\n        if info.owner != &T::owner() {\n            return Err(Error::from(ErrorCode::AccountOwnedByWrongProgram)\n                .with_pubkeys((*info.owner, T::owner())));\n        }\n        let mut data: &[u8] = &info.try_borrow_data()?;\n        Ok(Account::new(info, T::try_deserialize(&mut data)?))\n    }",
    "pub fn try_from_unchecked(info: &'a AccountInfo<'a>) -> Result<Account<'a, T>> {\n        if info.owner == &system_program::ID && info.lamports() == 0 {\n            return Err(ErrorCode::AccountNotInitialized.into());\n        }\n        if info.owner != &T::owner() {\n            return Err(Error::from(ErrorCode::AccountOwnedByWrongProgram)\n                .with_pubkeys((*info.owner, T::owner())));\n        }\n        let mut data: &[u8] = &info.try_borrow_data()?;\n        Ok(Account::new(info, T::try_deserialize_unchecked(&mut data)?))\n    }",
    "pub fn create_bar(ctx: Context<CreateBar>, data: u64) -> Result<()> {\n///         let bar = &mut ctx.accounts.bar.load_init()?;\n///         bar.authority = ctx.accounts.authority.key();\n///         bar.data = data;\n///         Ok(())\n///     }\n///\n///     pub fn update_bar(ctx: Context<UpdateBar>, data: u64) -> Result<()> {\n///         (*ctx.accounts.bar.load_mut()?).data = data;\n///         Ok(())\n///     }\n/// }\n///\n/// #[account(zero_copy)]\n/// #[derive(Default)]\n/// pub struct Bar {\n///     authority: Pubkey,\n///     data: u64\n/// }\n///\n/// #[derive(Accounts)]\n/// pub struct CreateBar<'info> {\n///     #[account(\n///         init,\n///         payer = authority\n///     )]\n///     bar: AccountLoader<'info, Bar>,\n///     #[account(mut)]\n///     authority: Signer<'info>,\n///     system_program: AccountInfo<'info>,\n/// }\n///\n/// #[derive(Accounts)]\n/// pub struct UpdateBar<'info> {\n///     #[account(\n///         mut,\n///         has_one = authority,\n///     )]\n///     pub bar: AccountLoader<'info, Bar>,\n///     pub authority: Signer<'info>,\n/// }\n/// ```\n#[derive(Clone)]\npub struct AccountLoader<'info, T: ZeroCopy + Owner> {\n    acc_info: &'info AccountInfo<'info>,\n    phantom: PhantomData<&'info T>,\n}\n\nimpl<T: ZeroCopy + Owner + fmt::Debug> fmt::Debug for AccountLoader<'_, T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"AccountLoader\")\n            .field(\"acc_info\", &self.acc_info)\n            .field(\"phantom\", &self.phantom)\n            .finish()\n    }",
    "pub fn try_from(acc_info: &'info AccountInfo<'info>) -> Result<AccountLoader<'info, T>> {\n        if acc_info.owner != &T::owner() {\n            return Err(Error::from(ErrorCode::AccountOwnedByWrongProgram)\n                .with_pubkeys((*acc_info.owner, T::owner())));\n        }\n\n        let data = &acc_info.try_borrow_data()?;\n        let disc = T::DISCRIMINATOR;\n        if data.len() < disc.len() {\n            return Err(ErrorCode::AccountDiscriminatorNotFound.into());\n        }\n\n        let given_disc = &data[..disc.len()];\n        if given_disc != disc {\n            return Err(ErrorCode::AccountDiscriminatorMismatch.into());\n        }\n\n        Ok(AccountLoader::new(acc_info))\n    }",
    "pub fn try_from_unchecked(\n        _program_id: &Pubkey,\n        acc_info: &'info AccountInfo<'info>,\n    ) -> Result<AccountLoader<'info, T>> {\n        if acc_info.owner != &T::owner() {\n            return Err(Error::from(ErrorCode::AccountOwnedByWrongProgram)\n                .with_pubkeys((*acc_info.owner, T::owner())));\n        }\n        Ok(AccountLoader::new(acc_info))\n    }",
    "pub fn load(&self) -> Result<Ref<T>> {\n        let data = self.acc_info.try_borrow_data()?;\n        let disc = T::DISCRIMINATOR;\n        if data.len() < disc.len() {\n            return Err(ErrorCode::AccountDiscriminatorNotFound.into());\n        }\n\n        let given_disc = &data[..disc.len()];\n        if given_disc != disc {\n            return Err(ErrorCode::AccountDiscriminatorMismatch.into());\n        }\n\n        Ok(Ref::map(data, |data| {\n            bytemuck::from_bytes(&data[disc.len()..mem::size_of::<T>() + disc.len()])\n        }",
    "pub fn load_mut(&self) -> Result<RefMut<T>> {\n        // AccountInfo api allows you to borrow mut even if the account isn't\n        // writable, so add this check for a better dev experience.\n        if !self.acc_info.is_writable {\n            return Err(ErrorCode::AccountNotMutable.into());\n        }\n\n        let data = self.acc_info.try_borrow_mut_data()?;\n        let disc = T::DISCRIMINATOR;\n        if data.len() < disc.len() {\n            return Err(ErrorCode::AccountDiscriminatorNotFound.into());\n        }\n\n        let given_disc = &data[..disc.len()];\n        if given_disc != disc {\n            return Err(ErrorCode::AccountDiscriminatorMismatch.into());\n        }\n\n        Ok(RefMut::map(data, |data| {\n            bytemuck::from_bytes_mut(\n                &mut data.deref_mut()[disc.len()..mem::size_of::<T>() + disc.len()],\n            )\n        }",
    "pub fn load_init(&self) -> Result<RefMut<T>> {\n        // AccountInfo api allows you to borrow mut even if the account isn't\n        // writable, so add this check for a better dev experience.\n        if !self.acc_info.is_writable {\n            return Err(ErrorCode::AccountNotMutable.into());\n        }\n\n        let data = self.acc_info.try_borrow_mut_data()?;\n\n        // The discriminator should be zero, since we're initializing.\n        let disc = T::DISCRIMINATOR;\n        let given_disc = &data[..disc.len()];\n        let has_disc = given_disc.iter().any(|b| *b != 0);\n        if has_disc {\n            return Err(ErrorCode::AccountDiscriminatorAlreadySet.into());\n        }\n\n        Ok(RefMut::map(data, |data| {\n            bytemuck::from_bytes_mut(\n                &mut data.deref_mut()[disc.len()..mem::size_of::<T>() + disc.len()],\n            )\n        }",
    "pub fn programdata_address(&self) -> Result<Option<Pubkey>> {\n        self.0.programdata_address()\n    }",
    "pub fn set_data(ctx: Context<SetData>, data: u64) -> Result<()> {\n///         if (*ctx.accounts.auth_account).authorized {\n///             (*ctx.accounts.my_account).data = data;\n///         }\n///         Ok(())\n///     }\n/// }\n///\n/// #[account]\n/// #[derive(Default)]\n/// pub struct MyData {\n///     pub data: u64\n/// }\n///\n/// #[derive(Accounts)]\n/// pub struct SetData<'info> {\n///     #[account(mut)]\n///     pub my_account: InterfaceAccount<'info, MyData> // checks that my_account.info.owner == Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS\n///     pub auth_account: InterfaceAccount<'info, Auth> // checks that auth_account.info.owner == FEZGUxNhZWpYPj9MJCrZJvUo1iF9ys34UHx52y4SzVW9\n/// }\n///\n/// // In a different program\n///\n/// ...\n/// declare_id!(\"FEZGUxNhZWpYPj9MJCrZJvUo1iF9ys34UHx52y4SzVW9\");\n/// #[account]\n/// #[derive(Default)]\n/// pub struct Auth {\n///     pub authorized: bool\n/// }\n/// ...\n/// ```\n///\n/// # Using InterfaceAccount with non-anchor programs\n///\n/// InterfaceAccount can also be used with non-anchor programs. The data types from\n/// those programs are not annotated with `#[account]` so you have to\n/// - create a wrapper type around the structs you want to wrap with InterfaceAccount\n/// - implement the functions required by InterfaceAccount yourself\n///\n/// instead of using `#[account]`. You only have to implement a fraction of the\n/// functions `#[account]` generates. See the example below for the code you have\n/// to write.\n///\n/// The mint wrapper type that Anchor provides out of the box for the token program ([source](https://github.com/coral-xyz/anchor/blob/master/spl/src/token.rs))\n/// ```ignore\n/// #[derive(Clone)]\n/// pub struct Mint(spl_token::state::Mint);\n///\n/// // This is necessary so we can use \"anchor_spl::token::Mint::LEN\"\n/// // because rust does not resolve \"anchor_spl::token::Mint::LEN\" to\n/// // \"spl_token::state::Mint::LEN\" automatically\n/// impl Mint {\n///     pub const LEN: usize = spl_token::state::Mint::LEN;\n/// }\n///\n/// // You don't have to implement the \"try_deserialize\" function\n/// // from this trait. It delegates to\n/// // \"try_deserialize_unchecked\" by default which is what we want here\n/// // because non-anchor accounts don't have a discriminator to check\n/// impl anchor_lang::AccountDeserialize for Mint {\n///     fn try_deserialize_unchecked(buf: &mut &[u8]) -> Result<Self> {\n///         spl_token::state::Mint::unpack(buf).map(Mint)\n///     }\n/// }\n/// // AccountSerialize defaults to a no-op which is what we want here\n/// // because it's a foreign program, so our program does not\n/// // have permission to write to the foreign program's accounts anyway\n/// impl anchor_lang::AccountSerialize for Mint {}\n///\n/// impl anchor_lang::Owner for Mint {\n///     fn owner() -> Pubkey {\n///         // pub use spl_token::ID is used at the top of the file\n///         ID\n///     }\n/// }\n///\n/// // Implement the \"std::ops::Deref\" trait for better user experience\n/// impl Deref for Mint {\n///     type Target = spl_token::state::Mint;\n///\n///     fn deref(&self) -> &Self::Target {\n///         &self.0\n///     }\n/// }\n/// ```\n///\n/// ## Out of the box wrapper types\n///\n/// ### SPL Types\n///\n/// Anchor provides wrapper types to access accounts owned by the token programs. Use\n/// ```ignore\n/// use anchor_spl::token_interface::TokenAccount;\n///\n/// #[derive(Accounts)]\n/// pub struct Example {\n///     pub my_acc: InterfaceAccount<'info, TokenAccount>\n/// }\n/// ```\n/// to access token accounts and\n/// ```ignore\n/// use anchor_spl::token_interface::Mint;\n///\n/// #[derive(Accounts)]\n/// pub struct Example {\n///     pub my_acc: InterfaceAccount<'info, Mint>\n/// }\n/// ```\n/// to access mint accounts.\n#[derive(Clone)]\npub struct InterfaceAccount<'info, T: AccountSerialize + AccountDeserialize + Clone> {\n    account: Account<'info, T>,\n    // The owner here is used to make sure that changes aren't incorrectly propagated\n    // to an account with a modified owner\n    owner: Pubkey,\n}\n\nimpl<T: AccountSerialize + AccountDeserialize + Clone + fmt::Debug> fmt::Debug\n    for InterfaceAccount<'_, T>\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        self.account.fmt_with_name(\"InterfaceAccount\", f)\n    }",
    "pub fn reload(&mut self) -> Result<()> {\n        self.account.reload()\n    }",
    "pub fn into_inner(self) -> T {\n        self.account.into_inner()\n    }",
    "pub fn new_user(ctx: Context<CreateUser>, new_user:User) -> Result<()> {\n    ///     (*ctx.accounts.user_to_create).name = new_user.name;\n    ///     (*ctx.accounts.user_to_create).age = new_user.age;\n    ///     (*ctx.accounts.user_to_create).address = new_user.address;\n    /// }\n    /// ```\n    /// You can do this:\n    /// ```ignore\n    /// pub fn new_user(ctx: Context<CreateUser>, new_user:User) -> Result<()> {\n    ///     ctx.accounts.user_to_create.set_inner(new_user);\n    /// }\n    /// ```\n    pub fn set_inner(&mut self, inner: T) {\n        self.account.set_inner(inner);\n    }\n}\n\nimpl<'a, T: AccountSerialize + AccountDeserialize + CheckOwner + Clone> InterfaceAccount<'a, T> {\n    /// Deserializes the given `info` into a `InterfaceAccount`.\n    #[inline(never)]\n    pub fn try_from(info: &'a AccountInfo<'a>) -> Result<Self> {\n        if info.owner == &system_program::ID && info.lamports() == 0 {\n            return Err(ErrorCode::AccountNotInitialized.into());\n        }\n        T::check_owner(info.owner)?;\n        let mut data: &[u8] = &info.try_borrow_data()?;\n        Ok(Self::new(info, T::try_deserialize(&mut data)?))\n    }",
    "pub fn try_from_unchecked(info: &'a AccountInfo<'a>) -> Result<Self> {\n        if info.owner == &system_program::ID && info.lamports() == 0 {\n            return Err(ErrorCode::AccountNotInitialized.into());\n        }\n        T::check_owner(info.owner)?;\n        let mut data: &[u8] = &info.try_borrow_data()?;\n        Ok(Self::new(info, T::try_deserialize_unchecked(&mut data)?))\n    }",
    "pub fn init(ctx: Context<Init>) -> Result<()> {\n///         let mut my_account = ctx.accounts.my_account.load_mut()?;\n///         my_account.authority = ctx.accounts.authority.key();\n///\n///         // Fill the dynamic data\n///         for _ in 0..MAX_DATA_LEN {\n///             my_account.dynamic.push(ctx.accounts.authority.key());\n///         }\n///\n///         Ok(())\n///     }\n///\n///     pub fn read(ctx: Context<Read>) -> Result<()> {\n///         // Cached load due to the `has_one` constraint\n///         let authority = ctx.accounts.my_account.load_authority()?;\n///         msg!(\"Authority: {}\", authority);\n///         Ok(())\n///     }\n///\n///     pub fn write(ctx: Context<Write>, new_authority: Pubkey) -> Result<()> {\n///         // Cached load due to the `has_one` constraint\n///         *ctx.accounts.my_account.load_mut_authority()? = new_authority;\n///         Ok(())\n///     }\n/// }\n///\n/// #[derive(Accounts)]\n/// pub struct Init<'info> {\n///     #[account(mut)]\n///     pub authority: Signer<'info>,\n///     #[account(\n///         init,\n///         payer = authority,\n///         space = MyAccount::DISCRIMINATOR.len() + MyAccount::INIT_SPACE\n///     )]\n///     pub my_account: LazyAccount<'info, MyAccount>,\n///     pub system_program: Program<'info, System>,\n/// }\n///\n/// #[derive(Accounts)]\n/// pub struct Read<'info> {\n///     pub authority: Signer<'info>,\n///     #[account(has_one = authority)]\n///     pub my_account: LazyAccount<'info, MyAccount>,\n/// }\n///\n/// #[derive(Accounts)]\n/// pub struct Write<'info> {\n///     pub authority: Signer<'info>,\n///     #[account(mut, has_one = authority)]\n///     pub my_account: LazyAccount<'info, MyAccount>,\n/// }\n///\n/// const MAX_DATA_LEN: usize = 256;\n///\n/// #[account]\n/// #[derive(InitSpace)]\n/// pub struct MyAccount {\n///     pub authority: Pubkey,\n///     pub fixed: [Pubkey; 8],\n///     // Dynamic sized data also works, unlike `AccountLoader`\n///     #[max_len(MAX_DATA_LEN)]\n///     pub dynamic: Vec<Pubkey>,\n/// }\n/// ```\n///\n/// # Safety\n///\n/// The safety checks are done using the account's discriminator and the account's owner (similar\n/// to [`Account`]). However, you should be extra careful when deserializing individual fields if,\n/// for example, the account needs to be migrated. Make sure the previously serialized data always\n/// matches the account's type identically.\n///\n/// # Performance\n///\n/// ## Memory\n///\n/// All fields (including the inner account type) are heap allocated. It only uses 24 bytes (3x\n/// pointer size) of stack memory in total.\n///\n/// It's worth noting that where the account is being deserialized matters. For example, the main\n/// place where Anchor programs are likely to hit stack violation errors is a generated function\n/// called `try_accounts` (you might be familiar with it from the mangled build logs). This is\n/// where the instruction is deserialized and constraints are run. Although having everything at the\n/// same place is convenient for using constraints, this also makes it very easy to use the fixed\n/// amount of stack space (4096 bytes) SVM allocates just by increasing the number of accounts the\n/// instruction has. In SVM, each function has its own stack frame, meaning that it's possible to\n/// deserialize more accounts simply by deserializing them inside other functions (rather than in\n/// `try_accounts` which is already quite heavy).\n///\n/// The mentioned stack limitation can be solved using dynamic stack frames, see [SIMD-0166].\n///\n/// ## Compute units\n///\n/// Compute is harder to formulate, as it varies based on the inner account's type. That being said,\n/// there are a few things you can do to optimize compute units usage when using [`LazyAccount`]:\n///\n/// - Order account fields from fixed-size data (e.g. `u8`, `Pubkey`) to dynamic data (e.g. `Vec`).\n/// - Order account fields based on how frequently the field is accessed (starting with the most\n///   frequent).\n/// - Reduce or limit dynamic fields.\n///\n/// [`borsh`]: crate::prelude::borsh\n/// [`Account`]: crate::prelude::Account\n/// [SIMD-0166]: https://github.com/solana-foundation/solana-improvement-documents/pull/166\npub struct LazyAccount<'info, T>\nwhere\n    T: AccountSerialize + Discriminator + Owner + Clone,\n{\n    /// **INTERNAL FIELD DO NOT USE!**\n    #[doc(hidden)]\n    pub __info: &'info AccountInfo<'info>,\n    /// **INTERNAL FIELD DO NOT USE!**\n    #[doc(hidden)]\n    pub __account: Rc<RefCell<MaybeUninit<T>>>,\n    /// **INTERNAL FIELD DO NOT USE!**\n    #[doc(hidden)]\n    pub __fields: Rc<RefCell<Option<Vec<bool>>>>,\n}\n\nimpl<T> fmt::Debug for LazyAccount<'_, T>\nwhere\n    T: AccountSerialize + Discriminator + Owner + Clone + fmt::Debug,\n{\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.debug_struct(\"LazyAccount\")\n            .field(\"info\", &self.__info)\n            .field(\"account\", &self.__account)\n            .field(\"fields\", &self.__fields)\n            .finish()\n    }",
    "pub fn try_from(info: &'info AccountInfo<'info>) -> Result<LazyAccount<'info, T>> {\n        let data = &info.try_borrow_data()?;\n        let disc = T::DISCRIMINATOR;\n        if data.len() < disc.len() {\n            return Err(ErrorCode::AccountDiscriminatorNotFound.into());\n        }\n\n        let given_disc = &data[..disc.len()];\n        if given_disc != disc {\n            return Err(ErrorCode::AccountDiscriminatorMismatch.into());\n        }\n\n        Self::try_from_unchecked(info)\n    }",
    "pub fn try_from_unchecked(info: &'info AccountInfo<'info>) -> Result<LazyAccount<'info, T>> {\n        if info.owner != &T::owner() {\n            return Err(Error::from(ErrorCode::AccountOwnedByWrongProgram)\n                .with_pubkeys((*info.owner, T::owner())));\n        }\n\n        Ok(LazyAccount::new(info))\n    }",
    "pub fn unload(&self) -> Result<&Self> {\n        // TODO: Should we drop the initialized fields manually?\n        *self.__account.borrow_mut() = MaybeUninit::uninit();\n        *self.__fields.borrow_mut() = None;\n        Ok(self)\n    }",
    "pub fn programdata_address(&self) -> Result<Option<Pubkey>> {\n        if *self.info.owner == bpf_loader_upgradeable::ID {\n            let mut data: &[u8] = &self.info.try_borrow_data()?;\n            let upgradable_loader_state =\n                UpgradeableLoaderState::try_deserialize_unchecked(&mut data)?;\n\n            match upgradable_loader_state {\n                UpgradeableLoaderState::Uninitialized\n                | UpgradeableLoaderState::Buffer {\n                    authority_address: _,\n                }\n                | UpgradeableLoaderState::ProgramData {\n                    slot: _,\n                    upgrade_authority_address: _,\n                } => {\n                    // Unreachable because check in try_from\n                    // ensures that program is executable\n                    // and therefore a program account.\n                    unreachable!()\n                }",
    "pub fn try_from(info: &'info AccountInfo<'info>) -> Result<Signer<'info>> {\n        if !info.is_signer {\n            return Err(ErrorCode::AccountNotSigner.into());\n        }\n        Ok(Signer::new(info))\n    }",
    "pub fn try_from(info: &'info AccountInfo<'info>) -> Result<SystemAccount<'info>> {\n        if *info.owner != system_program::ID {\n            return Err(ErrorCode::AccountNotSystemOwned.into());\n        }\n        Ok(SystemAccount::new(info))\n    }",
    "pub fn from_account_info(acc_info: &'info AccountInfo<'info>) -> Result<Sysvar<'info, T>> {\n        match T::from_account_info(acc_info) {\n            Ok(val) => Ok(Sysvar {\n                info: acc_info,\n                account: val,\n            }),\n            Err(_) => Err(ErrorCode::AccountSysvarMismatch.into()),\n        }\n    }\n}\n\nimpl<T: solana_program::sysvar::Sysvar> Clone for Sysvar<'_, T> {\n    fn clone(&self) -> Self {\n        Self {\n            info: self.info,\n            account: T::from_account_info(self.info).unwrap(),\n        }\n    }\n}\n\nimpl<'info, B, T: solana_program::sysvar::Sysvar> Accounts<'info, B> for Sysvar<'info, T> {\n    fn try_accounts(\n        _program_id: &Pubkey,\n        accounts: &mut &'info [AccountInfo<'info>],\n        _ix_data: &[u8],\n        _bumps: &mut B,\n        _reallocs: &mut BTreeSet<Pubkey>,\n    ) -> Result<Self> {\n        if accounts.is_empty() {\n            return Err(ErrorCode::AccountNotEnoughKeys.into());\n        }\n        let account = &accounts[0];\n        *accounts = &accounts[1..];\n        Sysvar::from_account_info(account)\n    }",
    "pub fn try_from(acc_info: &'info AccountInfo<'info>) -> Self {\n        Self(acc_info)\n    }",
    "pub fn hash(&mut self, val: &[u8]) {\n        self.hasher.update(val);\n    }\n    pub fn hashv(&mut self, vals: &[&[u8]]) {\n        for val in vals {\n            self.hash(val);\n        }\n    }\n    pub fn result(self) -> Hash {\n        // At the time of this writing, the sha2 library is stuck on an old version\n        // of generic_array (0.9.0). Decouple ourselves with a clone to our version.\n        Hash(<[u8; HASH_BYTES]>::try_from(self.hasher.finalize().as_slice()).unwrap())\n    }",
    "pub fn new(hash_slice: &[u8]) -> Self {\n        Hash(<[u8; HASH_BYTES]>::try_from(hash_slice).unwrap())\n    }",
    "pub fn to_bytes(self) -> [u8; HASH_BYTES] {\n        self.0\n    }\n}\n\n/// Return a Sha256 hash for the given data.\npub fn hashv(vals: &[&[u8]]) -> Hash {\n    // Perform the calculation inline, calling this from within a program is\n    // not supported\n    let mut hasher = Hasher::default();\n    hasher.hashv(vals);\n    hasher.result()\n}",
    "pub fn hash(val: &[u8]) -> Hash {\n    hashv(&[val])\n}",
    "pub fn new(\n        strct: ItemStruct,\n        fields: Vec<AccountField>,\n        instruction_api: Option<Punctuated<Expr, Comma>>,\n    ) -> Self {\n        let ident = strct.ident.clone();\n        let generics = strct.generics;\n        Self {\n            ident,\n            generics,\n            fields,\n            instruction_api,\n        }\n    }\n\n    // Return value maps instruction name to type.\n    // E.g. if we have `#[instruction(data: u64)]` then returns\n    // { \"data\": \"u64\"}.\n    pub fn instruction_args(&self) -> Option<HashMap<String, String>> {\n        self.instruction_api.as_ref().map(|instruction_api| {\n            instruction_api\n                .iter()\n                .map(|expr| {\n                    let arg = parser::tts_to_string(expr);\n                    let components: Vec<&str> = arg.split(\" : \").collect();\n                    assert!(components.len() == 2);\n                    (components[0].to_string(), components[1].to_string())\n                }",
    "pub fn field_names(&self) -> Vec<String> {\n        self.fields\n            .iter()\n            .map(|field| field.ident().to_string())\n            .collect()\n    }",
    "pub fn has_optional(&self) -> bool {\n        for field in &self.fields {\n            if let AccountField::Field(field) = field {\n                if field.is_optional {\n                    return true;\n                }\n            }\n        }\n        false\n    }\n\n    pub fn is_field_optional<T: quote::ToTokens>(&self, field: &T) -> bool {\n        let matching_field = self\n            .fields\n            .iter()\n            .find(|f| *f.ident() == parser::tts_to_string(field));\n        if let Some(matching_field) = matching_field {\n            matching_field.is_optional()\n        }",
    "pub fn ty_name(&self) -> Option<String> {\n        let qualified_ty_name = match self {\n            AccountField::Field(field) => match &field.ty {\n                Ty::Account(account) => Some(parser::tts_to_string(&account.account_type_path)),\n                Ty::LazyAccount(account) => Some(parser::tts_to_string(&account.account_type_path)),\n                _ => None,\n            },\n            AccountField::CompositeField(field) => Some(field.symbol.clone()),\n        };\n\n        qualified_ty_name.map(|name| match name.rsplit_once(\" :: \") {\n            Some((_prefix, suffix)) => suffix.to_string(),\n            None => name,\n        })\n    }",
    "pub fn typed_ident(&self) -> proc_macro2::TokenStream {\n        let name = &self.ident;\n        let ty_decl = self.ty_decl(false);\n        quote! {\n            #name: #ty_decl\n        }\n    }\n\n    pub fn ty_decl(&self, ignore_option: bool) -> proc_macro2::TokenStream {\n        let account_ty = self.account_ty();\n        let container_ty = self.container_ty();\n        let inner_ty = match &self.ty {\n            Ty::AccountInfo => quote! {\n                AccountInfo\n            },\n            Ty::UncheckedAccount => quote! {\n                UncheckedAccount\n            },\n            Ty::Signer => quote! {\n                Signer\n            },\n            Ty::ProgramData => quote! {\n                ProgramData\n            },\n            Ty::SystemAccount => quote! {\n                SystemAccount\n            },\n            Ty::Account(AccountTy { boxed, .. })\n            | Ty::InterfaceAccount(InterfaceAccountTy { boxed, .. }) => {\n                if *boxed {\n                    quote! {\n                        Box<#container_ty<#account_ty>>\n                    }\n                } else {\n                    quote! {\n                        #container_ty<#account_ty>\n                    }\n                }\n            }\n            Ty::Sysvar(ty) => {\n                let account = match ty {\n                    SysvarTy::Clock => quote! {Clock},\n                    SysvarTy::Rent => quote! {Rent},\n                    SysvarTy::EpochSchedule => quote! {EpochSchedule},\n                    SysvarTy::Fees => quote! {Fees},\n                    SysvarTy::RecentBlockhashes => quote! {RecentBlockhashes},\n                    SysvarTy::SlotHashes => quote! {SlotHashes},\n                    SysvarTy::SlotHistory => quote! {SlotHistory},\n                    SysvarTy::StakeHistory => quote! {StakeHistory},\n                    SysvarTy::Instructions => quote! {Instructions},\n                    SysvarTy::Rewards => quote! {Rewards},\n                };\n                quote! {\n                    Sysvar<#account>\n                }\n            }\n            _ => quote! {\n                #container_ty<#account_ty>\n            },\n        };\n        if self.is_optional && !ignore_option {\n            quote! {\n                Option<#inner_ty>\n            }\n        } else {\n            quote! {\n                #inner_ty\n            }\n        }\n    }\n\n    // Ignores optional accounts. Optional account checks and handing should be done prior to this\n    // function being called.\n    pub fn from_account_info(\n        &self,\n        kind: Option<&InitKind>,\n        checked: bool,\n    ) -> proc_macro2::TokenStream {\n        let field = &self.ident;\n        let field_str = field.to_string();\n        let container_ty = self.container_ty();\n        let owner_addr = match &kind {\n            None => quote! { __program_id },\n            Some(InitKind::Program { .. }) => quote! {\n                __program_id\n            },\n            _ => quote! {\n                &anchor_spl::token::ID\n            },\n        };\n        match &self.ty {\n            Ty::AccountInfo => quote! { #field.to_account_info() }",
    "pub fn container_ty(&self) -> proc_macro2::TokenStream {\n        match &self.ty {\n            Ty::Account(_) => quote! {\n                anchor_lang::accounts::account::Account\n            },\n            Ty::LazyAccount(_) => quote! {\n                anchor_lang::accounts::lazy_account::LazyAccount\n            },\n            Ty::AccountLoader(_) => quote! {\n                anchor_lang::accounts::account_loader::AccountLoader\n            },\n            Ty::Sysvar(_) => quote! { anchor_lang::accounts::sysvar::Sysvar },\n            Ty::Program(_) => quote! { anchor_lang::accounts::program::Program },\n            Ty::Interface(_) => quote! { anchor_lang::accounts::interface::Interface },\n            Ty::InterfaceAccount(_) => {\n                quote! { anchor_lang::accounts::interface_account::InterfaceAccount }\n            }\n            Ty::AccountInfo => quote! {},\n            Ty::UncheckedAccount => quote! {},\n            Ty::Signer => quote! {},\n            Ty::SystemAccount => quote! {},\n            Ty::ProgramData => quote! {},\n        }\n    }\n\n    // Returns the inner account struct type.\n    pub fn account_ty(&self) -> proc_macro2::TokenStream {\n        match &self.ty {\n            Ty::AccountInfo => quote! {\n                AccountInfo\n            },\n            Ty::UncheckedAccount => quote! {\n                UncheckedAccount\n            },\n            Ty::Signer => quote! {\n                Signer\n            },\n            Ty::SystemAccount => quote! {\n                SystemAccount\n            },\n            Ty::ProgramData => quote! {\n                ProgramData\n            },\n            Ty::Account(ty) => {\n                let ident = &ty.account_type_path;\n                quote! {\n                    #ident\n                }\n            }\n            Ty::LazyAccount(ty) => {\n                let ident = &ty.account_type_path;\n                quote! {\n                    #ident\n                }\n            }\n            Ty::InterfaceAccount(ty) => {\n                let ident = &ty.account_type_path;\n                quote! {\n                    #ident\n                }\n            }\n            Ty::AccountLoader(ty) => {\n                let ident = &ty.account_type_path;\n                quote! {\n                    #ident\n                }\n            }\n            Ty::Sysvar(ty) => match ty {\n                SysvarTy::Clock => quote! {Clock},\n                SysvarTy::Rent => quote! {Rent},\n                SysvarTy::EpochSchedule => quote! {EpochSchedule},\n                SysvarTy::Fees => quote! {Fees},\n                SysvarTy::RecentBlockhashes => quote! {RecentBlockhashes},\n                SysvarTy::SlotHashes => quote! {SlotHashes},\n                SysvarTy::SlotHistory => quote! {SlotHistory},\n                SysvarTy::StakeHistory => quote! {StakeHistory},\n                SysvarTy::Instructions => quote! {Instructions},\n                SysvarTy::Rewards => quote! {Rewards},\n            },\n            Ty::Program(ty) => {\n                let program = &ty.account_type_path;\n                quote! {\n                    #program\n                }\n            }\n            Ty::Interface(ty) => {\n                let program = &ty.account_type_path;\n                quote! {\n                    #program\n                }\n            }\n        }\n    }\n}\n\n#[derive(Debug)]\npub struct CompositeField {\n    pub ident: Ident,\n    pub constraints: ConstraintGroup,\n    pub symbol: String,\n    pub raw_field: syn::Field,\n    /// IDL Doc comment\n    pub docs: Option<Vec<String>>,\n}\n\n// A type of an account field.\n#[derive(Debug, PartialEq, Eq)]\npub enum Ty {\n    AccountInfo,\n    UncheckedAccount,\n    AccountLoader(AccountLoaderTy),\n    Sysvar(SysvarTy),\n    Account(AccountTy),\n    LazyAccount(LazyAccountTy),\n    Program(ProgramTy),\n    Interface(InterfaceTy),\n    InterfaceAccount(InterfaceAccountTy),\n    Signer,\n    SystemAccount,\n    ProgramData,\n}\n\n#[derive(Debug, PartialEq, Eq)]\npub enum SysvarTy {\n    Clock,\n    Rent,\n    EpochSchedule,\n    Fees,\n    RecentBlockhashes,\n    SlotHashes,\n    SlotHistory,\n    StakeHistory,\n    Instructions,\n    Rewards,\n}\n\n#[derive(Debug, PartialEq, Eq)]\npub struct AccountLoaderTy {\n    // The struct type of the account.\n    pub account_type_path: TypePath,\n}\n\n#[derive(Debug, PartialEq, Eq)]\npub struct AccountTy {\n    // The struct type of the account.\n    pub account_type_path: TypePath,\n    // True if the account has been boxed via `Box<T>`.\n    pub boxed: bool,\n}\n\n#[derive(Debug, PartialEq, Eq)]\npub struct LazyAccountTy {\n    // The struct type of the account.\n    pub account_type_path: TypePath,\n}\n\n#[derive(Debug, PartialEq, Eq)]\npub struct InterfaceAccountTy {\n    // The struct type of the account.\n    pub account_type_path: TypePath,\n    // True if the account has been boxed via `Box<T>`.\n    pub boxed: bool,\n}\n\n#[derive(Debug, PartialEq, Eq)]\npub struct ProgramTy {\n    // The struct type of the account.\n    pub account_type_path: TypePath,\n}\n\n#[derive(Debug, PartialEq, Eq)]\npub struct InterfaceTy {\n    // The struct type of the account.\n    pub account_type_path: TypePath,\n}\n\n#[derive(Debug)]\npub struct Error {\n    pub name: String,\n    pub raw_enum: ItemEnum,\n    pub ident: Ident,\n    pub codes: Vec<ErrorCode>,\n    pub args: Option<ErrorArgs>,\n}\n\n#[derive(Debug)]\npub struct ErrorArgs {\n    pub offset: LitInt,\n}\n\nimpl Parse for ErrorArgs {\n    fn parse(stream: ParseStream) -> ParseResult<Self> {\n        let offset_span = stream.span();\n        let offset = stream.call(Ident::parse_any)?;\n        if offset.to_string().as_str() != \"offset\" {\n            return Err(ParseError::new(offset_span, \"expected keyword offset\"));\n        }\n        stream.parse::<Token![=]>()?;\n        Ok(ErrorArgs {\n            offset: stream.parse()?,\n        })\n    }",
    "pub fn is_zeroed(&self) -> bool {\n        self.zeroed.is_some()\n    }",
    "pub fn is_mutable(&self) -> bool {\n        self.mutable.is_some()\n    }",
    "pub fn is_signer(&self) -> bool {\n        self.signer.is_some()\n    }",
    "pub fn is_close(&self) -> bool {\n        self.close.is_some()\n    }",
    "pub fn generate(error: Error) -> proc_macro2::TokenStream {\n    let error_enum = &error.raw_enum;\n    let enum_name = &error.ident;\n    // Each arm of the `match` statement for implementing `std::fmt::Display`\n    // on the user defined error code.\n    let display_variant_dispatch: Vec<proc_macro2::TokenStream> = error\n        .raw_enum\n        .variants\n        .iter()\n        .enumerate()\n        .map(|(idx, variant)| {\n            let ident = &variant.ident;\n            let error_code = &error.codes[idx];\n            let display_msg = match &error_code.msg {\n                None => {\n                    quote! {\n                        <Self as std::fmt::Debug>::fmt(self, fmt)\n                    }",
    "pub fn name(&self) -> String {\n                match self {\n                    #(#name_variant_dispatch),*\n                }\n            }\n        }\n\n        impl From<#enum_name> for u32 {\n            fn from(e: #enum_name) -> u32 {\n                e as u32 + #offset\n            }\n        }\n\n        impl From<#enum_name> for anchor_lang::error::Error {\n            fn from(error_code: #enum_name) -> anchor_lang::error::Error {\n                anchor_lang::error::Error::from(\n                    anchor_lang::error::AnchorError {\n                        error_name: error_code.name(),\n                        error_code_number: error_code.into(),\n                        error_msg: error_code.to_string(),\n                        error_origin: None,\n                        compared_values: None\n                    }\n                )\n            }",
    "pub fn generate(accs: &AccountsStruct) -> proc_macro2::TokenStream {\n    let name = &accs.ident;\n    let bumps_name = generate_bumps_name(name);\n    let ParsedGenerics {\n        combined_generics,\n        trait_generics: _,\n        struct_generics,\n        where_clause,\n    } = generics(accs);\n\n    let (bump_fields, bump_default_fields): (\n        Vec<proc_macro2::TokenStream>,\n        Vec<proc_macro2::TokenStream>,\n    ) = accs\n        .fields\n        .iter()\n        .filter_map(|af| {\n            let ident = af.ident();\n\n            match af {\n                AccountField::Field(f) => {\n                    let constraints = constraints::linearize(&f.constraints);\n                    let (bump_field, bump_default_field) = if f.is_optional {\n                        (quote!(pub #ident: Option<u8>), quote!(#ident: None))\n                    }",
    "pub fn generate(f: &Field, accs: &AccountsStruct) -> proc_macro2::TokenStream {\n    let constraints = linearize(&f.constraints);\n\n    let rent = constraints\n        .iter()\n        .any(|c| matches!(c, Constraint::RentExempt(ConstraintRentExempt::Enforce)))\n        .then(|| quote! { let __anchor_rent = Rent::get()?; })\n        .unwrap_or_else(|| quote! {});\n\n    let checks: Vec<proc_macro2::TokenStream> = constraints\n        .iter()\n        .map(|c| generate_constraint(f, c, accs))\n        .collect();\n\n    let mut all_checks = quote! {#(#checks)*};\n\n    // If the field is optional we do all the inner checks as if the account\n    // wasn't optional. If the account is init we also need to return an Option\n    // by wrapping the resulting value with Some or returning None if it doesn't exist.\n    if f.is_optional && !constraints.is_empty() {\n        let ident = &f.ident;\n        let ty_decl = f.ty_decl(false);\n        all_checks = match &constraints[0] {\n            Constraint::Init(_) | Constraint::Zeroed(_) => {\n                quote! {\n                    let #ident: #ty_decl = if let Some(#ident) = #ident {\n                        #all_checks\n                        Some(#ident)\n                    }",
    "pub fn generate_composite(f: &CompositeField) -> proc_macro2::TokenStream {\n    let checks: Vec<proc_macro2::TokenStream> = linearize(&f.constraints)\n        .iter()\n        .map(|c| match c {\n            Constraint::Raw(_) => c,\n            _ => panic!(\"Invariant violation: composite constraints can only be raw or literals\"),\n        })\n        .map(|c| generate_constraint_composite(f, c))\n        .collect();\n    quote! {\n        #(#checks)*\n    }\n}\n\n// Linearizes the constraint group so that constraints with dependencies\n// run after those without.\npub fn linearize(c_group: &ConstraintGroup) -> Vec<Constraint> {\n    let ConstraintGroup {\n        init,\n        zeroed,\n        mutable,\n        signer,\n        has_one,\n        raw,\n        owner,\n        rent_exempt,\n        seeds,\n        executable,\n        close,\n        address,\n        associated_token,\n        token_account,\n        mint,\n        realloc,\n    } = c_group.clone();\n\n    let mut constraints = Vec::new();\n\n    if let Some(c) = zeroed {\n        constraints.push(Constraint::Zeroed(c));\n    }\n    if let Some(c) = init {\n        constraints.push(Constraint::Init(c));\n    }\n    if let Some(c) = realloc {\n        constraints.push(Constraint::Realloc(c));\n    }\n    if let Some(c) = seeds {\n        constraints.push(Constraint::Seeds(c));\n    }\n    if let Some(c) = associated_token {\n        constraints.push(Constraint::AssociatedToken(c));\n    }\n    if let Some(c) = mutable {\n        constraints.push(Constraint::Mut(c));\n    }\n    if let Some(c) = signer {\n        constraints.push(Constraint::Signer(c));\n    }\n    constraints.append(&mut has_one.into_iter().map(Constraint::HasOne).collect());\n    constraints.append(&mut raw.into_iter().map(Constraint::Raw).collect());\n    if let Some(c) = owner {\n        constraints.push(Constraint::Owner(c));\n    }\n    if let Some(c) = rent_exempt {\n        constraints.push(Constraint::RentExempt(c));\n    }\n    if let Some(c) = executable {\n        constraints.push(Constraint::Executable(c));\n    }\n    if let Some(c) = close {\n        constraints.push(Constraint::Close(c));\n    }\n    if let Some(c) = address {\n        constraints.push(Constraint::Address(c));\n    }\n    if let Some(c) = token_account {\n        constraints.push(Constraint::TokenAccount(c));\n    }\n    if let Some(c) = mint {\n        constraints.push(Constraint::Mint(c));\n    }\n    constraints\n}\n\nfn generate_constraint(\n    f: &Field,\n    c: &Constraint,\n    accs: &AccountsStruct,\n) -> proc_macro2::TokenStream {\n    match c {\n        Constraint::Init(c) => generate_constraint_init(f, c, accs),\n        Constraint::Zeroed(c) => generate_constraint_zeroed(f, c, accs),\n        Constraint::Mut(c) => generate_constraint_mut(f, c),\n        Constraint::HasOne(c) => generate_constraint_has_one(f, c, accs),\n        Constraint::Signer(c) => generate_constraint_signer(f, c),\n        Constraint::Raw(c) => generate_constraint_raw(&f.ident, c),\n        Constraint::Owner(c) => generate_constraint_owner(f, c),\n        Constraint::RentExempt(c) => generate_constraint_rent_exempt(f, c),\n        Constraint::Seeds(c) => generate_constraint_seeds(f, c),\n        Constraint::Executable(c) => generate_constraint_executable(f, c),\n        Constraint::Close(c) => generate_constraint_close(f, c, accs),\n        Constraint::Address(c) => generate_constraint_address(f, c),\n        Constraint::AssociatedToken(c) => generate_constraint_associated_token(f, c, accs),\n        Constraint::TokenAccount(c) => generate_constraint_token_account(f, c, accs),\n        Constraint::Mint(c) => generate_constraint_mint(f, c, accs),\n        Constraint::Realloc(c) => generate_constraint_realloc(f, c, accs),\n    }\n}\n\nfn generate_constraint_composite(f: &CompositeField, c: &Constraint) -> proc_macro2::TokenStream {\n    match c {\n        Constraint::Raw(c) => generate_constraint_raw(&f.ident, c),\n        _ => panic!(\"Invariant violation\"),\n    }\n}\n\nfn generate_constraint_address(f: &Field, c: &ConstraintAddress) -> proc_macro2::TokenStream {\n    let field = &f.ident;\n    let addr = &c.address;\n    let error = generate_custom_error(\n        field,\n        &c.error,\n        quote! { ConstraintAddress },\n        &Some(&(quote! { actual }, quote! { expected })),\n    );\n    quote! {\n        {\n            let actual = #field.key();\n            let expected = #addr;\n            if actual != expected {\n                return #error;\n            }\n        }\n    }\n}\n\npub fn generate_constraint_init(\n    f: &Field,\n    c: &ConstraintInitGroup,\n    accs: &AccountsStruct,\n) -> proc_macro2::TokenStream {\n    generate_constraint_init_group(f, c, accs)\n}",
    "pub fn generate_constraint_zeroed(\n    f: &Field,\n    _c: &ConstraintZeroed,\n    accs: &AccountsStruct,\n) -> proc_macro2::TokenStream {\n    let account_ty = f.account_ty();\n    let discriminator = quote! { #account_ty::DISCRIMINATOR };\n\n    let field = &f.ident;\n    let name_str = field.to_string();\n    let ty_decl = f.ty_decl(true);\n    let from_account_info = f.from_account_info(None, false);\n\n    // Require `zero` constraint accounts to be unique by:\n    //\n    // 1. Getting the names of all accounts that have the `zero` or the `init` constraints and are\n    //    declared before the current field (in order to avoid checking the same field).\n    // 2. Comparing the key of the current field with all the previous fields' keys.\n    // 3. Returning an error if a match is found.\n    let unique_account_checks = accs\n        .fields\n        .iter()\n        .filter_map(|af| match af {\n            AccountField::Field(field) => Some(field),\n            _ => None,\n        })\n        .take_while(|field| field.ident != f.ident)\n        .filter(|field| field.constraints.is_zeroed() || field.constraints.init.is_some())\n        .map(|other_field| {\n            let other = &other_field.ident;\n            let err = quote! {\n                Err(\n                    anchor_lang::error::Error::from(\n                        anchor_lang::error::ErrorCode::ConstraintZero\n                    ).with_account_name(#name_str)\n                )\n            }",
    "pub fn generate_constraint_close(\n    f: &Field,\n    c: &ConstraintClose,\n    accs: &AccountsStruct,\n) -> proc_macro2::TokenStream {\n    let field = &f.ident;\n    let name_str = field.to_string();\n    let target = &c.sol_dest;\n    let target_optional_check =\n        OptionalCheckScope::new_with_field(accs, field).generate_check(target);\n    quote! {\n        {\n            #target_optional_check\n            if #field.key() == #target.key() {\n                return Err(anchor_lang::error::Error::from(anchor_lang::error::ErrorCode::ConstraintClose).with_account_name(#name_str));\n            }\n        }\n    }\n}\n\npub fn generate_constraint_mut(f: &Field, c: &ConstraintMut) -> proc_macro2::TokenStream {\n    let ident = &f.ident;\n    let account_ref = generate_account_ref(f);\n    let error = generate_custom_error(ident, &c.error, quote! { ConstraintMut }, &None);\n    quote! {\n        if !#account_ref.is_writable {\n            return #error;\n        }\n    }\n}\n\npub fn generate_constraint_has_one(\n    f: &Field,\n    c: &ConstraintHasOne,\n    accs: &AccountsStruct,\n) -> proc_macro2::TokenStream {\n    let target = &c.join_target;\n    let ident = &f.ident;\n    let field = match &f.ty {\n        Ty::AccountLoader(_) => quote! {#ident.load()?},\n        _ => quote! {#ident},\n    };\n    let my_key = match &f.ty {\n        Ty::LazyAccount(_) => {\n            let load_ident = format_ident!(\"load_{}\", target.to_token_stream().to_string());\n            quote! { *#field.#load_ident()? }\n        }\n        _ => quote! { #field.#target },\n    };\n    let error = generate_custom_error(\n        ident,\n        &c.error,\n        quote! { ConstraintHasOne },\n        &Some(&(quote! { my_key }, quote! { target_key })),\n    );\n    let target_optional_check =\n        OptionalCheckScope::new_with_field(accs, &field).generate_check(target);\n\n    quote! {\n        {\n            #target_optional_check\n            let my_key = #my_key;\n            let target_key = #target.key();\n            if my_key != target_key {\n                return #error;\n            }\n        }\n    }\n}\n\npub fn generate_constraint_signer(f: &Field, c: &ConstraintSigner) -> proc_macro2::TokenStream {\n    let ident = &f.ident;\n    let account_ref = generate_account_ref(f);\n\n    let error = generate_custom_error(ident, &c.error, quote! { ConstraintSigner }, &None);\n    quote! {\n        if !#account_ref.is_signer {\n            return #error;\n        }\n    }\n}\n\npub fn generate_constraint_raw(ident: &Ident, c: &ConstraintRaw) -> proc_macro2::TokenStream {\n    let raw = &c.raw;\n    let error = generate_custom_error(ident, &c.error, quote! { ConstraintRaw }, &None);\n    quote! {\n        if !(#raw) {\n            return #error;\n        }\n    }\n}\n\npub fn generate_constraint_owner(f: &Field, c: &ConstraintOwner) -> proc_macro2::TokenStream {\n    let ident = &f.ident;\n    let maybe_deref = match &f.ty {\n        Ty::Account(AccountTy { boxed, .. })\n        | Ty::InterfaceAccount(InterfaceAccountTy { boxed, .. }) => *boxed,\n        _ => false,\n    }\n    .then(|| quote!(*))\n    .unwrap_or_default();\n    let owner_address = &c.owner_address;\n    let error = generate_custom_error(\n        ident,\n        &c.error,\n        quote! { ConstraintOwner },\n        &Some(&(quote! { *my_owner }, quote! { owner_address })),\n    );\n\n    quote! {\n        {\n            let my_owner = AsRef::<AccountInfo>::as_ref(& #maybe_deref #ident).owner;\n            let owner_address = #owner_address;\n            if my_owner != &owner_address {\n                return #error;\n            }\n        }\n    }\n}\n\npub fn generate_constraint_rent_exempt(\n    f: &Field,\n    c: &ConstraintRentExempt,\n) -> proc_macro2::TokenStream {\n    let ident = &f.ident;\n    let name_str = ident.to_string();\n    let info = quote! {\n        #ident.to_account_info()\n    }",
    "pub fn new(accounts: &'a AccountsStruct) -> Self {\n        Self {\n            seen: HashSet::new(),\n            accounts,\n        }\n    }\n    pub fn new_with_field(accounts: &'a AccountsStruct, field: impl ToString) -> Self {\n        let mut check_scope = Self::new(accounts);\n        check_scope.seen.insert(field.to_string());\n        check_scope\n    }\n    pub fn generate_check(&mut self, field: impl ToTokens) -> TokenStream {\n        let field_name = parser::tts_to_string(&field);\n        if self.seen.contains(&field_name) {\n            quote! {}\n        } else {\n            self.seen.insert(field_name.clone());\n            if self.accounts.is_field_optional(&field) {\n                quote! {\n                    let #field = if let Some(ref account) = #field {\n                        account\n                    } else {\n                        return Err(anchor_lang::error::Error::from(anchor_lang::error::ErrorCode::ConstraintAccountIsNone).with_account_name(#field_name));\n                    };\n                }\n            } else {\n                quote! {}\n            }\n        }\n    }\n}\n\nfn generate_get_token_account_space(mint: &Expr) -> proc_macro2::TokenStream {\n    quote! {\n        {\n            let mint_info = #mint.to_account_info();\n            if *mint_info.owner == ::anchor_spl::token_2022::Token2022::id() {\n                use ::anchor_spl::token_2022::spl_token_2022::extension::{BaseStateWithExtensions, ExtensionType, StateWithExtensions};\n                use ::anchor_spl::token_2022::spl_token_2022::state::{Account, Mint};\n                let mint_data = mint_info.try_borrow_data()?;\n                let mint_state = StateWithExtensions::<Mint>::unpack(&mint_data)?;\n                let mint_extensions = mint_state.get_extension_types()?;\n                let required_extensions = ExtensionType::get_required_init_account_extensions(&mint_extensions);\n                ExtensionType::try_calculate_account_len::<Account>(&required_extensions)?\n            } else {\n                ::anchor_spl::token::TokenAccount::LEN\n            }\n        }\n    }\n}\n\n// Generated code to create an account with with system program with the\n// given `space` amount of data, owned by `owner`.\n//\n// `seeds_with_nonce` should be given for creating PDAs. Otherwise it's an\n// empty stream.\n//\n// This should only be run within scopes where `system_program` is not Optional\nfn generate_create_account(\n    field: &Ident,\n    space: proc_macro2::TokenStream,\n    owner: proc_macro2::TokenStream,\n    payer: proc_macro2::TokenStream,\n    seeds_with_nonce: proc_macro2::TokenStream,\n) -> proc_macro2::TokenStream {\n    // Field, payer, and system program are already validated to not be an Option at this point\n    quote! {\n        // If the account being initialized already has lamports, then\n        // return them all back to the payer so that the account has\n        // zero lamports when the system program's create instruction\n        // is eventually called.\n        let __current_lamports = #field.lamports();\n        if __current_lamports == 0 {\n            // Create the token account with right amount of lamports and space, and the correct owner.\n            let space = #space;\n            let lamports = __anchor_rent.minimum_balance(space);\n            let cpi_accounts = anchor_lang::system_program::CreateAccount {\n                from: #payer.to_account_info(),\n                to: #field.to_account_info()\n            }",
    "pub fn generate_constraint_executable(\n    f: &Field,\n    _c: &ConstraintExecutable,\n) -> proc_macro2::TokenStream {\n    let name_str = f.ident.to_string();\n    let account_ref = generate_account_ref(f);\n\n    // because we are only acting on the field, we know it isnt optional at this point\n    // as it was unwrapped in `generate_constraint`\n    quote! {\n        if !#account_ref.executable {\n            return Err(anchor_lang::error::Error::from(anchor_lang::error::ErrorCode::ConstraintExecutable).with_account_name(#name_str));\n        }\n    }\n}\n\nfn generate_custom_error(\n    account_name: &Ident,\n    custom_error: &Option<Expr>,\n    error: proc_macro2::TokenStream,\n    compared_values: &Option<&(proc_macro2::TokenStream, proc_macro2::TokenStream)>,\n) -> proc_macro2::TokenStream {\n    let account_name = account_name.to_string();\n    let mut error = match custom_error {\n        Some(error) => {\n            quote! { anchor_lang::error::Error::from(#error).with_account_name(#account_name) }",
    "pub fn generate(accs: &AccountsStruct) -> proc_macro2::TokenStream {\n    let name = &accs.ident;\n    let ParsedGenerics {\n        combined_generics,\n        trait_generics,\n        struct_generics,\n        where_clause,\n    } = generics(accs);\n\n    let on_save: Vec<proc_macro2::TokenStream> = accs\n        .fields\n        .iter()\n        .map(|af: &AccountField| match af {\n            AccountField::CompositeField(s) => {\n                let name = &s.ident;\n                let name_str = name.to_string();\n                quote! {\n                    anchor_lang::AccountsExit::exit(&self.#name, program_id)\n                        .map_err(|e| e.with_account_name(#name_str))?;\n                }\n            }\n            AccountField::Field(f) => {\n                let ident = &f.ident;\n                let name_str = ident.to_string();\n                if f.constraints.is_close() {\n                    let close_target = &f.constraints.close.as_ref().unwrap().sol_dest;\n                    let close_target_optional_check =\n                        OptionalCheckScope::new(accs).generate_check(close_target);\n\n                    quote! {\n                        {\n                            let #close_target = &self.#close_target;\n                            #close_target_optional_check\n                            anchor_lang::AccountsClose::close(\n                                &self.#ident,\n                                #close_target.to_account_info(),\n                            ).map_err(|e| e.with_account_name(#name_str))?;\n                        }\n                    }\n                } else {\n                    match f.constraints.is_mutable() {\n                        false => quote! {},\n                        true => match &f.ty {\n                            // `LazyAccount` is special because it has a custom `exit` method.\n                            Ty::LazyAccount(_) => quote! {\n                                self.#ident.exit(program_id)\n                                    .map_err(|e| e.with_account_name(#name_str))?;\n                            },\n                            _ => quote! {\n                                anchor_lang::AccountsExit::exit(&self.#ident, program_id)\n                                    .map_err(|e| e.with_account_name(#name_str))?;\n                            },\n                        },\n                    }\n                }\n            }\n        })\n        .collect();\n    quote! {\n        #[automatically_derived]\n        impl<#combined_generics> anchor_lang::AccountsExit<#trait_generics> for #name<#struct_generics> #where_clause{\n            fn exit(&self, program_id: &anchor_lang::solana_program::pubkey::Pubkey) -> anchor_lang::Result<()> {\n                #(#on_save)*\n                Ok(())\n            }",
    "pub fn generate(accs: &AccountsStruct) -> proc_macro2::TokenStream {\n    let impl_try_accounts = try_accounts::generate(accs);\n    let impl_to_account_infos = to_account_infos::generate(accs);\n    let impl_to_account_metas = to_account_metas::generate(accs);\n    let impl_exit = exit::generate(accs);\n    let bumps_struct = bumps::generate(accs);\n\n    let __client_accounts_mod = __client_accounts::generate(accs, quote!(crate::ID));\n    let __cpi_client_accounts_mod = __cpi_client_accounts::generate(accs, quote!(crate::ID));\n\n    let ret = quote! {\n        #impl_try_accounts\n        #impl_to_account_infos\n        #impl_to_account_metas\n        #impl_exit\n        #bumps_struct\n\n        #__client_accounts_mod\n        #__cpi_client_accounts_mod\n    };\n\n    #[cfg(feature = \"idl-build\")]\n    {\n        let idl_build_impl = crate::idl::gen_idl_build_impl_accounts_struct(accs);\n        return quote! {\n            #ret\n            #idl_build_impl\n        };\n    }\n\n    #[allow(unreachable_code)]\n    ret\n}\n\nfn generics(accs: &AccountsStruct) -> ParsedGenerics {\n    let trait_lifetime = accs\n        .generics\n        .lifetimes()\n        .next()\n        .cloned()\n        .unwrap_or_else(|| syn::parse_str(\"'info\").expect(\"Could not parse lifetime\"));\n\n    let mut where_clause = accs.generics.where_clause.clone().unwrap_or(WhereClause {\n        where_token: Default::default(),\n        predicates: Default::default(),\n    });\n    for lifetime in accs.generics.lifetimes().map(|def| &def.lifetime) {\n        where_clause\n            .predicates\n            .push(WherePredicate::Lifetime(PredicateLifetime {\n                lifetime: lifetime.clone(),\n                colon_token: Default::default(),\n                bounds: iter::once(trait_lifetime.lifetime.clone()).collect(),\n            }))\n    }",
    "pub fn generate(accs: &AccountsStruct) -> proc_macro2::TokenStream {\n    let name = &accs.ident;\n\n    let to_acc_metas: Vec<proc_macro2::TokenStream> = accs\n        .fields\n        .iter()\n        .map(|f: &AccountField| {\n            let (name, is_signer, is_optional) = match f {\n                AccountField::CompositeField(s) => (&s.ident, quote! {None}, false),\n                AccountField::Field(f) => {\n                    let is_signer = match f.constraints.is_signer() {\n                        false => quote! {None},\n                        true => quote! {Some(true)}",
    "pub fn generate(accs: &AccountsStruct) -> proc_macro2::TokenStream {\n    let name = &accs.ident;\n    let ParsedGenerics {\n        combined_generics,\n        trait_generics,\n        struct_generics,\n        where_clause,\n    } = generics(accs);\n\n    // Deserialization for each field\n    let deser_fields: Vec<proc_macro2::TokenStream> = accs\n        .fields\n        .iter()\n        .map(|af: &AccountField| {\n            match af {\n                AccountField::CompositeField(s) => {\n                    let name = &s.ident;\n                    let ty = &s.raw_field.ty;\n                    quote! {\n                        #[cfg(feature = \"anchor-debug\")]\n                        ::solana_program::log::sol_log(stringify!(#name));\n                        let #name: #ty = anchor_lang::Accounts::try_accounts(__program_id, __accounts, __ix_data, &mut __bumps.#name, __reallocs)?;\n                    }\n                }\n                AccountField::Field(f) => {\n                    // `init` and `zero` accounts are special cased as they are\n                    // deserialized by constraints. Here, we just take out the\n                    // AccountInfo for later use at constraint validation time.\n                    if is_init(af) || f.constraints.zeroed.is_some()  {\n                        let name = &f.ident;\n                        // Optional accounts have slightly different behavior here and\n                        // we can't leverage the try_accounts implementation for zero and init.\n                        if f.is_optional {\n                            // Thus, this block essentially reimplements the try_accounts \n                            // behavior with optional accounts minus the deserialziation.\n                            let empty_behavior = if cfg!(feature = \"allow-missing-optionals\") {\n                                quote!{ None }\n                            } else {\n                                quote!{ return Err(anchor_lang::error::ErrorCode::AccountNotEnoughKeys.into()); }\n                            };\n                            quote! {\n                                let #name = if __accounts.is_empty() {\n                                    #empty_behavior\n                                } else if __accounts[0].key == __program_id {\n                                    *__accounts = &__accounts[1..];\n                                    None\n                                } else {\n                                    let account = &__accounts[0];\n                                    *__accounts = &__accounts[1..];\n                                    Some(account)\n                                }",
    "pub fn generate(\n    accs: &AccountsStruct,\n    program_id: proc_macro2::TokenStream,\n) -> proc_macro2::TokenStream {\n    let name = &accs.ident;\n    let account_mod_name: proc_macro2::TokenStream = format!(\n        \"__client_accounts_{}\",\n        accs.ident.to_string().to_snake_case()\n    )\n    .parse()\n    .unwrap();\n\n    let account_struct_fields: Vec<proc_macro2::TokenStream> = accs\n        .fields\n        .iter()\n        .map(|f: &AccountField| match f {\n            AccountField::CompositeField(s) => {\n                let name = &s.ident;\n                let docs = if let Some(ref docs) = s.docs {\n                    docs.iter()\n                        .map(|docs_line| {\n                            proc_macro2::TokenStream::from_str(&format!(\n                                \"#[doc = r#\\\"{docs_line}\\\"#]\"\n                            ))\n                            .unwrap()\n                        }",
    "pub fn generate(\n    accs: &AccountsStruct,\n    program_id: proc_macro2::TokenStream,\n) -> proc_macro2::TokenStream {\n    let name = &accs.ident;\n    let account_mod_name: proc_macro2::TokenStream = format!(\n        \"__cpi_client_accounts_{}\",\n        accs.ident.to_string().to_snake_case()\n    )\n    .parse()\n    .unwrap();\n\n    let account_struct_fields: Vec<proc_macro2::TokenStream> = accs\n        .fields\n        .iter()\n        .map(|f: &AccountField| match f {\n            AccountField::CompositeField(s) => {\n                let name = &s.ident;\n                let docs = if let Some(ref docs) = s.docs {\n                    docs.iter()\n                        .map(|docs_line| {\n                            proc_macro2::TokenStream::from_str(&format!(\n                                \"#[doc = r#\\\"{docs_line}\\\"#]\"\n                            ))\n                            .unwrap()\n                        }",
    "pub fn sighash(namespace: &str, name: &str) -> [u8; 8] {\n    let preimage = format!(\"{namespace}:{name}\");\n\n    let mut sighash = [0u8; 8];\n    sighash.copy_from_slice(&crate::hash::hash(preimage.as_bytes()).to_bytes()[..8]);\n    sighash\n}\n\npub fn gen_discriminator(namespace: &str, name: impl ToString) -> proc_macro2::TokenStream {\n    let discriminator = sighash(namespace, name.to_string().as_str());\n    format!(\"&{:?}\", discriminator).parse().unwrap()\n}",
    "pub fn generate_ix_variant(name: &str, args: &[IxArg]) -> proc_macro2::TokenStream {\n    let ix_arg_names: Vec<&syn::Ident> = args.iter().map(|arg| &arg.name).collect();\n    let ix_name_camel = generate_ix_variant_name(name);\n\n    if args.is_empty() {\n        quote! {\n            #ix_name_camel\n        }\n    } else {\n        quote! {\n            #ix_name_camel {\n                #(#ix_arg_names),*\n            }\n        }\n    }\n}\n\npub fn generate_ix_variant_name(name: &str) -> proc_macro2::TokenStream {\n    let n = name.to_camel_case();\n    n.parse().unwrap()\n}",
    "pub fn generate(program: &Program) -> proc_macro2::TokenStream {\n    // Generate cpi methods for global methods.\n    let global_cpi_methods: Vec<proc_macro2::TokenStream> = program\n        .ixs\n        .iter()\n        .map(|ix| {\n            let accounts_ident: proc_macro2::TokenStream = format!(\"crate::cpi::accounts::{}\", &ix.anchor_ident.to_string()).parse().unwrap();\n            let cpi_method = {\n                let name = &ix.raw_method.sig.ident;\n                let name_str = name.to_string();\n                let ix_variant = generate_ix_variant(&name_str, &ix.args);\n                let method_name = &ix.ident;\n                let args: Vec<&syn::PatType> = ix.args.iter().map(|arg| &arg.raw_arg).collect();\n                let discriminator = {\n                    let name = generate_ix_variant_name(&name_str);\n                    quote! { <instruction::#name as anchor_lang::Discriminator>::DISCRIMINATOR }\n                };\n                let ret_type = &ix.returns.ty.to_token_stream();\n                let ix_cfgs = &ix.cfgs;\n                let (method_ret, maybe_return) = match ret_type.to_string().as_str() {\n                    \"()\" => (quote! {anchor_lang::Result<()> }, quote! { Ok(()) }",
    "pub fn get(&self) -> T {\n                    let (_key, data) = anchor_lang::solana_program::program::get_return_data().unwrap();\n                    T::try_from_slice(&data).unwrap()\n                }",
    "pub fn generate(program: &Program) -> proc_macro2::TokenStream {\n    // Dispatch all global instructions.\n    let global_ixs = program.ixs.iter().map(|ix| {\n        let ix_method_name = &ix.raw_method.sig.ident;\n        let ix_name_camel: proc_macro2::TokenStream = ix_method_name\n            .to_string()\n            .to_camel_case()\n            .parse()\n            .expect(\"Failed to parse ix method name in camel as `TokenStream`\");\n        let discriminator = quote! { instruction::#ix_name_camel::DISCRIMINATOR };\n        let ix_cfgs = &ix.cfgs;\n\n        quote! {\n            #(#ix_cfgs)*\n            if data.starts_with(#discriminator) {\n                return __private::__global::#ix_method_name(\n                    program_id,\n                    accounts,\n                    &data[#discriminator.len()..],\n                )\n            }",
    "pub fn generate(program: &Program) -> proc_macro2::TokenStream {\n    let name: proc_macro2::TokenStream = program.name.to_string().to_camel_case().parse().unwrap();\n    quote! {\n        #[cfg(not(feature = \"no-entrypoint\"))]\n        anchor_lang::solana_program::entrypoint!(entry);\n        /// The Anchor codegen exposes a programming model where a user defines\n        /// a set of methods inside of a `#[program]` module in a way similar\n        /// to writing RPC request handlers. The macro then generates a bunch of\n        /// code wrapping these user defined methods into something that can be\n        /// executed on Solana.\n        ///\n        /// These methods fall into one category for now.\n        ///\n        /// Global methods - regular methods inside of the `#[program]`.\n        ///\n        /// Care must be taken by the codegen to prevent collisions between\n        /// methods in these different namespaces. For this reason, Anchor uses\n        /// a variant of sighash to perform method dispatch, rather than\n        /// something like a simple enum variant discriminator.\n        ///\n        /// The execution flow of the generated code can be roughly outlined:\n        ///\n        /// * Start program via the entrypoint.\n        /// * Check whether the declared program id matches the input program\n        ///   id. If it's not, return an error.\n        /// * Find and invoke the method based on whether the instruction data\n        ///   starts with the method's discriminator.\n        /// * Run the method handler wrapper. This wraps the code the user\n        ///   actually wrote, deserializing the accounts, constructing the\n        ///   context, invoking the user's code, and finally running the exit\n        ///   routine, which typically persists account changes.\n        ///\n        /// The `entry` function here, defines the standard entry to a Solana\n        /// program, where execution begins.\n        pub fn entry<'info>(program_id: &Pubkey, accounts: &'info [AccountInfo<'info>], data: &[u8]) -> anchor_lang::solana_program::entrypoint::ProgramResult {\n            try_entry(program_id, accounts, data).map_err(|e| {\n                e.log();\n                e.into()\n            }",
    "pub fn generate(program: &Program) -> proc_macro2::TokenStream {\n    let program_name = &program.name;\n    // A constant token stream that stores the accounts and functions, required to live\n    // inside the target program in order to get the program ID.\n    let idl_accounts_and_functions = idl_accounts_and_functions();\n    let non_inlined_idl: proc_macro2::TokenStream = {\n        quote! {\n            // Entry for all IDL related instructions. Use the \"no-idl\" feature\n            // to eliminate this code, for example, if one wants to make the\n            // IDL no longer mutable or if one doesn't want to store the IDL\n            // on chain.\n            #[inline(never)]\n            #[cfg(not(feature = \"no-idl\"))]\n            pub fn __idl_dispatch<'info>(program_id: &Pubkey, accounts: &'info [AccountInfo<'info>], idl_ix_data: &[u8]) -> anchor_lang::Result<()> {\n                let mut accounts = accounts;\n                let mut data: &[u8] = idl_ix_data;\n\n                let ix = anchor_lang::idl::IdlInstruction::deserialize(&mut data)\n                    .map_err(|_| anchor_lang::error::ErrorCode::InstructionDidNotDeserialize)?;\n\n                match ix {\n                    anchor_lang::idl::IdlInstruction::Create { data_len } => {\n                        let mut bumps = <IdlCreateAccounts as anchor_lang::Bumps>::Bumps::default();\n                        let mut reallocs = std::collections::BTreeSet::new();\n                        let mut accounts =\n                            IdlCreateAccounts::try_accounts(program_id, &mut accounts, &[], &mut bumps, &mut reallocs)?;\n                        __idl_create_account(program_id, &mut accounts, data_len)?;\n                        accounts.exit(program_id)?;\n                    },\n                    anchor_lang::idl::IdlInstruction::Resize { data_len } => {\n                        let mut bumps = <IdlResizeAccount as anchor_lang::Bumps>::Bumps::default();\n                        let mut reallocs = std::collections::BTreeSet::new();\n                        let mut accounts =\n                            IdlResizeAccount::try_accounts(program_id, &mut accounts, &[], &mut bumps, &mut reallocs)?;\n                        __idl_resize_account(program_id, &mut accounts, data_len)?;\n                        accounts.exit(program_id)?;\n                    },\n                    anchor_lang::idl::IdlInstruction::Close => {\n                        let mut bumps = <IdlCloseAccount as anchor_lang::Bumps>::Bumps::default();\n                        let mut reallocs = std::collections::BTreeSet::new();\n                        let mut accounts =\n                            IdlCloseAccount::try_accounts(program_id, &mut accounts, &[], &mut bumps, &mut reallocs)?;\n                        __idl_close_account(program_id, &mut accounts)?;\n                        accounts.exit(program_id)?;\n                    },\n                    anchor_lang::idl::IdlInstruction::CreateBuffer => {\n                        let mut bumps = <IdlCreateBuffer as anchor_lang::Bumps>::Bumps::default();\n                        let mut reallocs = std::collections::BTreeSet::new();\n                        let mut accounts =\n                            IdlCreateBuffer::try_accounts(program_id, &mut accounts, &[], &mut bumps, &mut reallocs)?;\n                        __idl_create_buffer(program_id, &mut accounts)?;\n                        accounts.exit(program_id)?;\n                    },\n                    anchor_lang::idl::IdlInstruction::Write { data } => {\n                        let mut bumps = <IdlAccounts as anchor_lang::Bumps>::Bumps::default();\n                        let mut reallocs = std::collections::BTreeSet::new();\n                        let mut accounts =\n                            IdlAccounts::try_accounts(program_id, &mut accounts, &[], &mut bumps, &mut reallocs)?;\n                        __idl_write(program_id, &mut accounts, data)?;\n                        accounts.exit(program_id)?;\n                    },\n                    anchor_lang::idl::IdlInstruction::SetAuthority { new_authority } => {\n                        let mut bumps = <IdlAccounts as anchor_lang::Bumps>::Bumps::default();\n                        let mut reallocs = std::collections::BTreeSet::new();\n                        let mut accounts =\n                            IdlAccounts::try_accounts(program_id, &mut accounts, &[], &mut bumps, &mut reallocs)?;\n                        __idl_set_authority(program_id, &mut accounts, new_authority)?;\n                        accounts.exit(program_id)?;\n                    },\n                    anchor_lang::idl::IdlInstruction::SetBuffer => {\n                        let mut bumps = <IdlSetBuffer as anchor_lang::Bumps>::Bumps::default();\n                        let mut reallocs = std::collections::BTreeSet::new();\n                        let mut accounts =\n                            IdlSetBuffer::try_accounts(program_id, &mut accounts, &[], &mut bumps, &mut reallocs)?;\n                        __idl_set_buffer(program_id, &mut accounts)?;\n                        accounts.exit(program_id)?;\n                    },\n                }\n                Ok(())\n            }",
    "pub fn __event_dispatch(\n                    program_id: &Pubkey,\n                    accounts: &[AccountInfo],\n                    event_data: &[u8],\n                ) -> anchor_lang::Result<()> {\n                    let given_event_authority = next_account_info(&mut accounts.iter())?;\n                    if !given_event_authority.is_signer {\n                        return Err(anchor_lang::error::Error::from(\n                            anchor_lang::error::ErrorCode::ConstraintSigner,\n                        )\n                        .with_account_name(#authority_name));\n                    }\n\n                    let (expected_event_authority, _) =\n                        Pubkey::find_program_address(&[#authority_seeds], &program_id);\n                    if given_event_authority.key() != expected_event_authority {\n                        return Err(anchor_lang::error::Error::from(\n                            anchor_lang::error::ErrorCode::ConstraintSeeds,\n                        )\n                        .with_account_name(#authority_name)\n                        .with_pubkeys((given_event_authority.key(), expected_event_authority)));\n                    }\n\n                    Ok(())\n                }",
    "pub fn idl_accounts_and_functions() -> proc_macro2::TokenStream {\n    quote! {\n        use anchor_lang::idl::ERASED_AUTHORITY;\n\n        #[account(\"internal\")]\n        #[derive(Debug)]\n        pub struct IdlAccount {\n            // Address that can modify the IDL.\n            pub authority: Pubkey,\n            // Length of compressed idl bytes.\n            pub data_len: u32,\n            // Followed by compressed idl bytes.\n        }\n\n        impl IdlAccount {\n            pub fn address(program_id: &Pubkey) -> Pubkey {\n                let program_signer = Pubkey::find_program_address(&[], program_id).0;\n                Pubkey::create_with_seed(&program_signer, IdlAccount::seed(), program_id)\n                    .expect(\"Seed is always valid\")\n            }",
    "pub fn seed() -> &'static str {\n                \"anchor:idl\"\n            }\n        }\n\n        // Hacky workaround because of some internals to how account attribute\n        // works. Namespaces are the root of most of the problem.\n        impl anchor_lang::Owner for IdlAccount {\n            fn owner() -> Pubkey {\n                crate::ID\n            }\n        }\n\n        // Accounts for the Create instruction.\n        #[derive(Accounts)]\n        pub struct IdlCreateAccounts<'info> {\n            // Payer of the transaction.\n            #[account(signer)]\n            pub from: AccountInfo<'info>,\n            // The deterministically defined \"state\" account being created via\n            // `create_account_with_seed`.\n            #[account(mut)]\n            pub to: AccountInfo<'info>,\n            // The program-derived-address signing off on the account creation.\n            // Seeds = &[] + bump seed.\n            #[account(seeds = [], bump)]\n            pub base: AccountInfo<'info>,\n            // The system program.\n            pub system_program: Program<'info, System>,\n            // The program whose state is being constructed.\n            #[account(executable)]\n            pub program: AccountInfo<'info>,\n        }\n\n        // Accounts for Idl instructions.\n        #[derive(Accounts)]\n        pub struct IdlAccounts<'info> {\n            #[account(mut, has_one = authority)]\n            pub idl: Account<'info, IdlAccount>,\n            #[account(constraint = authority.key != &ERASED_AUTHORITY)]\n            pub authority: Signer<'info>,\n        }\n\n        // Accounts for resize account instruction\n        #[derive(Accounts)]\n        pub struct IdlResizeAccount<'info> {\n            #[account(mut, has_one = authority)]\n            pub idl: Account<'info, IdlAccount>,\n            #[account(mut, constraint = authority.key != &ERASED_AUTHORITY)]\n            pub authority: Signer<'info>,\n            pub system_program: Program<'info, System>,\n        }\n\n        // Accounts for creating an idl buffer.\n        #[derive(Accounts)]\n        pub struct IdlCreateBuffer<'info> {\n            #[account(zero)]\n            pub buffer: Account<'info, IdlAccount>,\n            #[account(constraint = authority.key != &ERASED_AUTHORITY)]\n            pub authority: Signer<'info>,\n        }\n\n        // Accounts for upgrading the canonical IdlAccount with the buffer.\n        #[derive(Accounts)]\n        pub struct IdlSetBuffer<'info> {\n            // The buffer with the new idl data.\n            #[account(mut, constraint = buffer.authority == idl.authority)]\n            pub buffer: Account<'info, IdlAccount>,\n            // The idl account to be updated with the buffer's data.\n            #[account(mut, has_one = authority)]\n            pub idl: Account<'info, IdlAccount>,\n            #[account(constraint = authority.key != &ERASED_AUTHORITY)]\n            pub authority: Signer<'info>,\n        }\n\n        // Accounts for closing the canonical Idl buffer.\n        #[derive(Accounts)]\n        pub struct IdlCloseAccount<'info> {\n            #[account(mut, has_one = authority, close = sol_destination)]\n            pub account: Account<'info, IdlAccount>,\n            #[account(constraint = authority.key != &ERASED_AUTHORITY)]\n            pub authority: Signer<'info>,\n            #[account(mut)]\n            pub sol_destination: AccountInfo<'info>,\n        }\n\n\n        use std::cell::{Ref, RefMut};\n\n        pub trait IdlTrailingData<'info> {\n            fn trailing_data(self) -> Ref<'info, [u8]>;\n            fn trailing_data_mut(self) -> RefMut<'info, [u8]>;\n        }\n\n        impl<'a, 'info: 'a> IdlTrailingData<'a> for &'a Account<'info, IdlAccount> {\n            fn trailing_data(self) -> Ref<'a, [u8]> {\n                let info: &AccountInfo<'info> = self.as_ref();\n                Ref::map(info.try_borrow_data().unwrap(), |d| &d[44..])\n            }",
    "pub fn __idl_create_account(\n            program_id: &Pubkey,\n            accounts: &mut IdlCreateAccounts,\n            data_len: u64,\n        ) -> anchor_lang::Result<()> {\n            #[cfg(not(feature = \"no-log-ix-name\"))]\n            anchor_lang::prelude::msg!(\"Instruction: IdlCreateAccount\");\n\n            if program_id != accounts.program.key {\n                return Err(anchor_lang::error::ErrorCode::IdlInstructionInvalidProgram.into());\n            }\n            // Create the IDL's account.\n            let from = accounts.from.key;\n            let (base, nonce) = Pubkey::find_program_address(&[], program_id);\n            let seed = IdlAccount::seed();\n            let owner = accounts.program.key;\n            let to = Pubkey::create_with_seed(&base, seed, owner).unwrap();\n            // Space: account discriminator || authority pubkey || vec len || vec data\n            let space = std::cmp::min(\n                IdlAccount::DISCRIMINATOR.len() + 32 + 4 + data_len as usize,\n                10_000\n            );\n            let rent = Rent::get()?;\n            let lamports = rent.minimum_balance(space);\n            let seeds = &[&[nonce][..]];\n            let ix = anchor_lang::solana_program::system_instruction::create_account_with_seed(\n                from,\n                &to,\n                &base,\n                seed,\n                lamports,\n                space as u64,\n                owner,\n            );\n            anchor_lang::solana_program::program::invoke_signed(\n                &ix,\n                &[\n                    accounts.from.clone(),\n                    accounts.to.clone(),\n                    accounts.base.clone(),\n                    accounts.system_program.to_account_info(),\n                ],\n                &[seeds],\n            )?;\n\n            // Deserialize the newly created account.\n            let mut idl_account = {\n                let mut account_data =  accounts.to.try_borrow_data()?;\n                let mut account_data_slice: &[u8] = &account_data;\n                IdlAccount::try_deserialize_unchecked(\n                    &mut account_data_slice,\n                )?\n            };\n\n            // Set the authority.\n            idl_account.authority = *accounts.from.key;\n\n            // Store the new account data.\n            let mut data = accounts.to.try_borrow_mut_data()?;\n            let dst: &mut [u8] = &mut data;\n            let mut cursor = std::io::Cursor::new(dst);\n            idl_account.try_serialize(&mut cursor)?;\n\n            Ok(())\n        }",
    "pub fn __idl_resize_account(\n            program_id: &Pubkey,\n            accounts: &mut IdlResizeAccount,\n            data_len: u64,\n        ) -> anchor_lang::Result<()> {\n            #[cfg(not(feature = \"no-log-ix-name\"))]\n            anchor_lang::prelude::msg!(\"Instruction: IdlResizeAccount\");\n\n            let data_len: usize = data_len as usize;\n\n            // We're not going to support increasing the size of accounts that already contain data\n            // because that would be messy and possibly dangerous\n            if accounts.idl.data_len != 0 {\n                return Err(anchor_lang::error::ErrorCode::IdlAccountNotEmpty.into());\n            }\n\n            let idl_ref = AsRef::<AccountInfo>::as_ref(&accounts.idl);\n            let new_account_space = idl_ref.data_len().checked_add(std::cmp::min(\n                data_len\n                    .checked_sub(idl_ref.data_len())\n                    .expect(\"data_len should always be >= the current account space\"),\n                10_000,\n            ))\n            .unwrap();\n\n            if new_account_space > idl_ref.data_len() {\n                let sysvar_rent = Rent::get()?;\n                let new_rent_minimum = sysvar_rent.minimum_balance(new_account_space);\n                anchor_lang::system_program::transfer(\n                    anchor_lang::context::CpiContext::new(\n                        accounts.system_program.to_account_info(),\n                        anchor_lang::system_program::Transfer {\n                            from: accounts.authority.to_account_info(),\n                            to: accounts.idl.to_account_info(),\n                        },\n                    ),\n                    new_rent_minimum\n                        .checked_sub(idl_ref.lamports())\n                        .unwrap(),\n                )?;\n                idl_ref.realloc(new_account_space, false)?;\n            }\n\n            Ok(())\n\n        }",
    "pub fn __idl_close_account(\n            program_id: &Pubkey,\n            accounts: &mut IdlCloseAccount,\n        ) -> anchor_lang::Result<()> {\n            #[cfg(not(feature = \"no-log-ix-name\"))]\n            anchor_lang::prelude::msg!(\"Instruction: IdlCloseAccount\");\n\n            Ok(())\n        }",
    "pub fn __idl_create_buffer(\n            program_id: &Pubkey,\n            accounts: &mut IdlCreateBuffer,\n        ) -> anchor_lang::Result<()> {\n            #[cfg(not(feature = \"no-log-ix-name\"))]\n            anchor_lang::prelude::msg!(\"Instruction: IdlCreateBuffer\");\n\n            let mut buffer = &mut accounts.buffer;\n            buffer.authority = *accounts.authority.key;\n            Ok(())\n        }",
    "pub fn __idl_write(\n            program_id: &Pubkey,\n            accounts: &mut IdlAccounts,\n            idl_data: Vec<u8>,\n        ) -> anchor_lang::Result<()> {\n            #[cfg(not(feature = \"no-log-ix-name\"))]\n            anchor_lang::prelude::msg!(\"Instruction: IdlWrite\");\n\n            let prev_len: usize = ::std::convert::TryInto::<usize>::try_into(accounts.idl.data_len).unwrap();\n            let new_len: usize = prev_len.checked_add(idl_data.len()).unwrap() as usize;\n            accounts.idl.data_len = accounts.idl.data_len.checked_add(::std::convert::TryInto::<u32>::try_into(idl_data.len()).unwrap()).unwrap();\n\n            use IdlTrailingData;\n            let mut idl_bytes = accounts.idl.trailing_data_mut();\n            let idl_expansion = &mut idl_bytes[prev_len..new_len];\n            require_eq!(idl_expansion.len(), idl_data.len());\n            idl_expansion.copy_from_slice(&idl_data[..]);\n\n            Ok(())\n        }",
    "pub fn __idl_set_authority(\n            program_id: &Pubkey,\n            accounts: &mut IdlAccounts,\n            new_authority: Pubkey,\n        ) -> anchor_lang::Result<()> {\n            #[cfg(not(feature = \"no-log-ix-name\"))]\n            anchor_lang::prelude::msg!(\"Instruction: IdlSetAuthority\");\n\n            accounts.idl.authority = new_authority;\n            Ok(())\n        }",
    "pub fn __idl_set_buffer(\n            program_id: &Pubkey,\n            accounts: &mut IdlSetBuffer,\n        ) -> anchor_lang::Result<()> {\n            #[cfg(not(feature = \"no-log-ix-name\"))]\n            anchor_lang::prelude::msg!(\"Instruction: IdlSetBuffer\");\n\n            accounts.idl.data_len = accounts.buffer.data_len;\n\n            use IdlTrailingData;\n            let buffer_len = ::std::convert::TryInto::<usize>::try_into(accounts.buffer.data_len).unwrap();\n            let mut target = accounts.idl.trailing_data_mut();\n            let source = &accounts.buffer.trailing_data()[..buffer_len];\n            require_gte!(target.len(), buffer_len);\n            target[..buffer_len].copy_from_slice(source);\n            // zero the remainder of target?\n\n            Ok(())\n        }",
    "pub fn generate(program: &Program) -> proc_macro2::TokenStream {\n    let variants: Vec<proc_macro2::TokenStream> = program\n        .ixs\n        .iter()\n        .map(|ix| {\n            let name = &ix.raw_method.sig.ident.to_string();\n            let ix_cfgs = &ix.cfgs;\n            let ix_name_camel =\n                proc_macro2::Ident::new(&name.to_camel_case(), ix.raw_method.sig.ident.span());\n            let raw_args: Vec<proc_macro2::TokenStream> = ix\n                .args\n                .iter()\n                .map(|arg| {\n                    format!(\"pub {}\", parser::tts_to_string(&arg.raw_arg))\n                        .parse()\n                        .unwrap()\n                }",
    "pub fn gen_idl_build_impl_accounts_struct(accounts: &AccountsStruct) -> TokenStream {\n    let resolution = option_env!(\"ANCHOR_IDL_BUILD_RESOLUTION\")\n        .map(|val| val == \"TRUE\")\n        .unwrap_or_default();\n    let no_docs = get_no_docs();\n    let idl = get_idl_module_path();\n\n    let ident = &accounts.ident;\n    let (impl_generics, ty_generics, where_clause) = accounts.generics.split_for_impl();\n\n    let (accounts, defined) = accounts\n        .fields\n        .iter()\n        .map(|acc| match acc {\n            AccountField::Field(acc) => {\n                let name = acc.ident.to_string();\n                let writable = acc.constraints.is_mutable();\n                let signer = match acc.ty {\n                    Ty::Signer => true,\n                    _ => acc.constraints.is_signer(),\n                };\n                let optional = acc.is_optional;\n                let docs = match &acc.docs {\n                    Some(docs) if !no_docs => quote! { vec![#(#docs.into()),*] },\n                    _ => quote! { vec![] },\n                };\n\n                let (address, pda, relations) = if resolution {\n                    (\n                        get_address(acc),\n                        get_pda(acc, accounts),\n                        get_relations(acc, accounts),\n                    )\n                }",
    "pub fn __anchor_private_gen_idl_accounts(\n                accounts: &mut std::collections::BTreeMap<String, #idl::IdlAccount>,\n                types: &mut std::collections::BTreeMap<String, #idl::IdlTypeDef>,\n            ) -> Vec<#idl::IdlInstructionAccountItem> {\n                #(\n                    if let Some(ty) = <#defined>::create_type() {\n                        let account = #idl::IdlAccount {\n                            name: ty.name.clone(),\n                            discriminator: #defined::DISCRIMINATOR.into(),\n                        };\n                        accounts.insert(account.name.clone(), account);\n                        types.insert(ty.name.clone(), ty);\n                        <#defined>::insert_types(types);\n                    }\n                );*\n\n                vec![#(#accounts),*]\n            }\n        }\n    }\n}\n\nfn get_address(acc: &Field) -> TokenStream {\n    match &acc.ty {\n        Ty::Program(_) | Ty::Sysvar(_) => {\n            let ty = acc.account_ty();\n            let id_trait = matches!(acc.ty, Ty::Program(_))\n                .then(|| quote!(anchor_lang::Id))\n                .unwrap_or_else(|| quote!(anchor_lang::solana_program::sysvar::SysvarId));\n            quote! { Some(<#ty as #id_trait>::id().to_string()) }",
    "pub fn find_path(name: &str, path: impl AsRef<Path>) -> Result<PathBuf> {\n    let path = path.as_ref();\n    for ancestor in path.ancestors() {\n        let file_path = ancestor.join(name);\n        if file_path.exists() {\n            return file_path.canonicalize().map_err(Into::into);\n        }\n    }\n\n    Err(anyhow!(\"Path ({path:?}) not found\"))\n}",
    "pub fn get_no_docs() -> bool {\n    option_env!(\"ANCHOR_IDL_BUILD_NO_DOCS\")\n        .map(|val| val == \"TRUE\")\n        .unwrap_or_default()\n}",
    "pub fn get_program_path() -> Result<PathBuf> {\n    std::env::var(\"ANCHOR_IDL_BUILD_PROGRAM_PATH\")\n        .map(PathBuf::from)\n        .map_err(|_| anyhow!(\"Failed to get program path\"))\n}",
    "pub fn get_idl_module_path() -> TokenStream {\n    quote!(anchor_lang::idl::types)\n}",
    "pub fn get_serde_json_module_path() -> TokenStream {\n    quote!(anchor_lang::idl::serde_json)\n}",
    "pub fn impl_idl_build_struct(item: &syn::ItemStruct) -> TokenStream {\n    impl_idl_build(&item.ident, &item.generics, gen_idl_type_def_struct(item))\n}",
    "pub fn impl_idl_build_enum(item: &syn::ItemEnum) -> TokenStream {\n    impl_idl_build(&item.ident, &item.generics, gen_idl_type_def_enum(item))\n}",
    "pub fn impl_idl_build_union(item: &syn::ItemUnion) -> TokenStream {\n    impl_idl_build(\n        &item.ident,\n        &item.generics,\n        Err(anyhow!(\"Unions are not supported\")),\n    )\n}",
    "pub fn gen_idl_type_def_struct(\n    strct: &syn::ItemStruct,\n) -> Result<(TokenStream, Vec<syn::TypePath>)> {\n    gen_idl_type_def(&strct.attrs, &strct.generics, |generic_params| {\n        let no_docs = get_no_docs();\n        let idl = get_idl_module_path();\n\n        let (fields, defined) = match &strct.fields {\n            syn::Fields::Unit => (quote! { None }, vec![]),\n            syn::Fields::Named(fields) => {\n                let (fields, defined) = fields\n                    .named\n                    .iter()\n                    .map(|f| gen_idl_field(f, generic_params, no_docs))\n                    .collect::<Result<Vec<_>>>()?\n                    .into_iter()\n                    .unzip::<_, _, Vec<_>, Vec<_>>();\n\n                (\n                    quote! { Some(#idl::IdlDefinedFields::Named(vec![#(#fields),*])) }",
    "pub fn gen_idl_type(\n    ty: &syn::Type,\n    generic_params: &[syn::Ident],\n) -> Result<(TokenStream, Vec<syn::TypePath>)> {\n    let idl = get_idl_module_path();\n\n    fn the_only_segment_is(path: &syn::TypePath, cmp: &str) -> bool {\n        if path.path.segments.len() != 1 {\n            return false;\n        };\n        return get_first_segment(path).ident == cmp;\n    }\n\n    fn get_angle_bracketed_type_args(seg: &syn::PathSegment) -> Vec<&syn::Type> {\n        match &seg.arguments {\n            syn::PathArguments::AngleBracketed(ab) => ab\n                .args\n                .iter()\n                .filter_map(|arg| match arg {\n                    syn::GenericArgument::Type(ty) => Some(ty),\n                    _ => None,\n                })\n                .collect(),\n            _ => panic!(\"No angle bracket for {seg:#?}\"),\n        }\n    }\n\n    match ty {\n        syn::Type::Path(path) if the_only_segment_is(path, \"bool\") => {\n            Ok((quote! { #idl::IdlType::Bool }, vec![]))\n        }",
    "pub fn gen_idl_print_fn_error(error: &Error) -> TokenStream {\n    let idl = get_idl_module_path();\n\n    let fn_name = format_ident!(\n        \"__anchor_private_print_idl_error_{}\",\n        error.ident.to_string().to_snake_case()\n    );\n\n    let error_codes = error\n        .codes\n        .iter()\n        .map(|code| {\n            let id = code.id;\n            let name = code.ident.to_string();\n            let msg = match &code.msg {\n                Some(msg) => quote! { Some(#msg.into()) }",
    "pub fn gen_idl_print_fn_event(event_struct: &syn::ItemStruct) -> TokenStream {\n    let idl = get_idl_module_path();\n    let serde_json = get_serde_json_module_path();\n\n    let ident = &event_struct.ident;\n    let fn_name = format_ident!(\n        \"__anchor_private_print_idl_event_{}\",\n        ident.to_string().to_snake_case()\n    );\n    let idl_build_impl = impl_idl_build_event(event_struct);\n\n    let print_ts = gen_print_section(\n        \"event\",\n        quote! {\n            #serde_json::json!({\n                \"event\": event,\n                \"types\": types.into_values().collect::<Vec<_>>()\n            }",
    "pub fn get_external_type(name: &str, path: impl AsRef<Path>) -> Result<Option<syn::Type>> {\n    let use_path = get_uses(path.as_ref())?\n        .into_iter()\n        .find(|u| u.split(\"::\").last().unwrap() == name)\n        .ok_or_else(|| anyhow!(\"`{name}` not found in use statements\"))?;\n\n    // Get crate name and version from lock file\n    let program_path = get_program_path()?;\n    let lock_path = find_path(\"Cargo.lock\", program_path)?;\n    let lock_file = parse_lock_file(lock_path)?;\n    let registry_path = get_registry_path()?;\n\n    recursively_find_type(name, &use_path, &registry_path, &lock_file)\n}",
    "pub fn gen_idl_print_fn_program(program: &Program) -> TokenStream {\n    check_safety_comments().unwrap_or_else(|e| panic!(\"Safety checks failed: {e}\"));\n\n    let idl = get_idl_module_path();\n    let no_docs = get_no_docs();\n\n    let name = program.name.to_string();\n    let docs = match &program.docs {\n        Some(docs) if !no_docs => quote! { vec![#(#docs.into()),*] },\n        _ => quote! { vec![] },\n    };\n\n    let result = program\n        .ixs\n        .iter()\n        .map(|ix| {\n            let name = ix.ident.to_string();\n            let name_pascal = format_ident!(\"{}\", name.to_camel_case());\n            let ctx_ident = &ix.anchor_ident;\n            let cfgs = &ix.cfgs;\n\n            let docs = match &ix.docs {\n                Some(docs) if !no_docs => quote! { vec![#(#docs.into()),*] },\n                _ => quote! { vec![] },\n            };\n\n            let (args, mut defined) = ix\n                .args\n                .iter()\n                .map(|arg| {\n                    let name = arg.name.to_string();\n                    let docs = match docs::parse(&arg.raw_arg.attrs) {\n                        Some(docs) if !no_docs => quote! { vec![#(#docs.into()),*] },\n                        _ => quote! { vec![] },\n                    };\n                    let (ty, defined) = gen_idl_type(&arg.raw_arg.ty, &[])\n                        .map_err(|_| syn::Error::new(arg.raw_arg.ty.span(), \"Unsupported type\"))?;\n\n                    Ok((\n                        quote! {\n                            #idl::IdlField {\n                                name: #name.into(),\n                                docs: #docs,\n                                ty: #ty,\n                            }\n                        },\n                        defined,\n                    ))\n                }",
    "pub fn __anchor_private_print_idl_program() {\n            #fn_body\n        }\n    }\n}\n\n/// Check safety comments.\nfn check_safety_comments() -> Result<()> {\n    let skip_lint = option_env!(\"ANCHOR_IDL_BUILD_SKIP_LINT\")\n        .map(|val| val == \"TRUE\")\n        .unwrap_or_default();\n    if skip_lint {\n        return Ok(());\n    }\n\n    let program_path = get_program_path();\n    if program_path.is_err() {\n        // Getting the program path can fail in the following scenarios:\n        //\n        // - Anchor CLI version is incompatible with the current version\n        // - The error is coming from Rust Analyzer when the user has `idl-build` feature enabled,\n        // likely due to enabling all features (https://github.com/coral-xyz/anchor/issues/3042)\n        //\n        // For the first case, we have a warning when the user is using different versions of the\n        // lang and CLI crate. For the second case, users would either have to disable the\n        // `idl-build` feature, or define the program path environment variable in Rust Analyzer\n        // settings.\n        //\n        // Given this feature is not a critical one, and it works by default with `anchor build`,\n        // we can fail silently in the case of an error rather than panicking.\n        return Ok(());\n    }\n\n    program_path\n        .map(|path| path.join(\"src\").join(\"lib.rs\"))\n        .map(CrateContext::parse)?\n        .map_err(|e| anyhow!(\"Failed to parse crate: {e}\"))?\n        .safety_checks()\n}",
    "pub fn parse(root: impl AsRef<Path>) -> Result<Self> {\n        Ok(CrateContext {\n            modules: ParsedModule::parse_recursive(root.as_ref())?,\n        })\n    }",
    "pub fn consts(&self) -> impl Iterator<Item = &syn::ItemConst> {\n        self.modules.iter().flat_map(|(_, ctx)| ctx.consts())\n    }",
    "pub fn impl_consts(&self) -> impl Iterator<Item = (&Ident, &syn::ImplItemConst)> {\n        self.modules.iter().flat_map(|(_, ctx)| ctx.impl_consts())\n    }",
    "pub fn structs(&self) -> impl Iterator<Item = &syn::ItemStruct> {\n        self.modules.iter().flat_map(|(_, ctx)| ctx.structs())\n    }",
    "pub fn enums(&self) -> impl Iterator<Item = &syn::ItemEnum> {\n        self.modules.iter().flat_map(|(_, ctx)| ctx.enums())\n    }",
    "pub fn type_aliases(&self) -> impl Iterator<Item = &syn::ItemType> {\n        self.modules.iter().flat_map(|(_, ctx)| ctx.type_aliases())\n    }",
    "pub fn modules(&self) -> impl Iterator<Item = ModuleContext> {\n        self.modules.values().map(|detail| ModuleContext { detail })\n    }",
    "pub fn root_module(&self) -> ModuleContext {\n        ModuleContext {\n            detail: self.modules.get(\"crate\").unwrap(),\n        }\n    }\n\n    // Perform Anchor safety checks on the parsed create\n    pub fn safety_checks(&self) -> Result<()> {\n        // Check all structs for unsafe field types, i.e. AccountInfo and UncheckedAccount.\n        for ctx in self.modules.values() {\n            for unsafe_field in ctx.unsafe_struct_fields() {\n                // Check if unsafe field type has been documented with a /// SAFETY: doc string.\n                let is_documented = unsafe_field.attrs.iter().any(|attr| {\n                    attr.tokens.clone().into_iter().any(|token| match token {\n                        // Check for doc comments containing CHECK\n                        proc_macro2::TokenTree::Literal(s) => s.to_string().contains(\"CHECK\"),\n                        _ => false,\n                    })\n                }",
    "pub fn items(&self) -> impl Iterator<Item = &syn::Item> {\n        self.detail.items.iter()\n    }",
    "pub fn parse(attrs: &[syn::Attribute]) -> Option<Vec<String>> {\n    let doc_strings: Vec<String> = attrs\n        .iter()\n        .filter_map(|attr| match attr.parse_meta() {\n            Ok(NameValue(meta)) => {\n                if meta.path.is_ident(\"doc\") {\n                    if let Str(doc) = meta.lit {\n                        let val = doc.value().trim().to_string();\n                        if val.starts_with(\"CHECK:\") {\n                            return None;\n                        }\n                        return Some(val);\n                    }\n                }\n                None\n            }\n            _ => None,\n        })\n        .collect();\n    if doc_strings.is_empty() {\n        None\n    } else {\n        Some(doc_strings)\n    }",
    "pub fn parse(error_enum: &mut syn::ItemEnum, args: Option<ErrorArgs>) -> Error {\n    let ident = error_enum.ident.clone();\n    let mut last_discriminant = 0;\n    let codes: Vec<ErrorCode> = error_enum\n        .variants\n        .iter_mut()\n        .map(|variant: &mut syn::Variant| {\n            let msg = parse_error_attribute(variant);\n            let ident = variant.ident.clone();\n            let id = match &variant.discriminant {\n                None => last_discriminant,\n                Some((_, disc)) => match disc {\n                    syn::Expr::Lit(expr_lit) => match &expr_lit.lit {\n                        syn::Lit::Int(int) => {\n                            int.base10_parse::<u32>().expect(\"Must be a base 10 number\")\n                        }",
    "pub fn parse(_attrs: &[syn::Attribute]) -> Option<[u8; 8]> {\n    None\n}\n\n#[cfg(feature = \"interface-instructions\")]\npub fn parse(attrs: &[syn::Attribute]) -> Option<[u8; 8]> {\n    let interfaces: Vec<[u8; 8]> = attrs\n        .iter()\n        .filter_map(|attr| {\n            if attr.path.is_ident(\"interface\") {\n                if let Ok(Meta::List(meta_list)) = attr.parse_meta() {\n                    if let Some(NestedMeta::Meta(Meta::Path(path))) = meta_list.nested.first() {\n                        return Some(parse_interface_instruction(path));\n                    }\n                }\n                panic!(\n                    \"Failed to parse interface instruction:\\n{}\",\n                    quote::quote!(#attr)\n                );\n            }\n            None\n        })\n        .collect();\n    if interfaces.len() > 1 {\n        panic!(\"An instruction can only implement one interface instruction\");\n    } else if interfaces.is_empty() {\n        None\n    } else {\n        Some(interfaces[0])\n    }",
    "pub fn parse(f: &syn::Field, f_ty: Option<&Ty>) -> ParseResult<ConstraintGroup> {\n    let mut constraints = ConstraintGroupBuilder::new(f_ty);\n    for attr in f.attrs.iter().filter(is_account) {\n        for c in attr.parse_args_with(Punctuated::<ConstraintToken, Comma>::parse_terminated)? {\n            constraints.add(c)?;\n        }\n    }\n    let account_constraints = constraints.build()?;\n\n    Ok(account_constraints)\n}",
    "pub fn is_account(attr: &&syn::Attribute) -> bool {\n    attr.path\n        .get_ident()\n        .is_some_and(|ident| ident == \"account\")\n}",
    "pub fn parse_token(stream: ParseStream) -> ParseResult<ConstraintToken> {\n    let ident = stream.call(Ident::parse_any)?;\n    let kw = ident.to_string();\n\n    let c = match kw.as_str() {\n        \"init\" => ConstraintToken::Init(Context::new(\n            ident.span(),\n            ConstraintInit { if_needed: false },\n        )),\n        \"init_if_needed\" => ConstraintToken::Init(Context::new(\n            ident.span(),\n            ConstraintInit { if_needed: true },\n        )),\n        \"zero\" => ConstraintToken::Zeroed(Context::new(ident.span(), ConstraintZeroed {})),\n        \"mut\" => ConstraintToken::Mut(Context::new(\n            ident.span(),\n            ConstraintMut {\n                error: parse_optional_custom_error(&stream)?,\n            },\n        )),\n        \"signer\" => ConstraintToken::Signer(Context::new(\n            ident.span(),\n            ConstraintSigner {\n                error: parse_optional_custom_error(&stream)?,\n            },\n        )),\n        \"executable\" => {\n            ConstraintToken::Executable(Context::new(ident.span(), ConstraintExecutable {}))\n        }",
    "pub fn new(f_ty: Option<&'ty Ty>) -> Self {\n        Self {\n            f_ty,\n            init: None,\n            zeroed: None,\n            mutable: None,\n            signer: None,\n            has_one: Vec::new(),\n            raw: Vec::new(),\n            owner: None,\n            rent_exempt: None,\n            seeds: None,\n            executable: None,\n            payer: None,\n            space: None,\n            close: None,\n            address: None,\n            token_mint: None,\n            token_authority: None,\n            token_token_program: None,\n            associated_token_mint: None,\n            associated_token_authority: None,\n            associated_token_token_program: None,\n            mint_authority: None,\n            mint_freeze_authority: None,\n            mint_decimals: None,\n            mint_token_program: None,\n            extension_group_pointer_authority: None,\n            extension_group_pointer_group_address: None,\n            extension_group_member_pointer_authority: None,\n            extension_group_member_pointer_member_address: None,\n            extension_metadata_pointer_authority: None,\n            extension_metadata_pointer_metadata_address: None,\n            extension_close_authority: None,\n            extension_transfer_hook_authority: None,\n            extension_transfer_hook_program_id: None,\n            extension_permanent_delegate: None,\n            bump: None,\n            program_seed: None,\n            realloc: None,\n            realloc_payer: None,\n            realloc_zero: None,\n        }\n    }\n\n    pub fn build(mut self) -> ParseResult<ConstraintGroup> {\n        // Init.\n        if let Some(i) = &self.init {\n            if cfg!(not(feature = \"init-if-needed\")) && i.if_needed {\n                return Err(ParseError::new(\n                    i.span(),\n                    \"init_if_needed requires that anchor-lang be imported \\\n                    with the init-if-needed cargo feature enabled. \\\n                    Carefully read the init_if_needed docs before using this feature \\\n                    to make sure you know how to protect yourself against \\\n                    re-initialization attacks.\",\n                ));\n            }\n\n            match self.mutable {\n                Some(m) => {\n                    return Err(ParseError::new(\n                        m.span(),\n                        \"mut cannot be provided with init\",\n                    ))\n                }",
    "pub fn add(&mut self, c: ConstraintToken) -> ParseResult<()> {\n        match c {\n            ConstraintToken::Init(c) => self.add_init(c),\n            ConstraintToken::Zeroed(c) => self.add_zeroed(c),\n            ConstraintToken::Mut(c) => self.add_mut(c),\n            ConstraintToken::Signer(c) => self.add_signer(c),\n            ConstraintToken::HasOne(c) => self.add_has_one(c),\n            ConstraintToken::Raw(c) => self.add_raw(c),\n            ConstraintToken::Owner(c) => self.add_owner(c),\n            ConstraintToken::RentExempt(c) => self.add_rent_exempt(c),\n            ConstraintToken::Seeds(c) => self.add_seeds(c),\n            ConstraintToken::Executable(c) => self.add_executable(c),\n            ConstraintToken::Payer(c) => self.add_payer(c),\n            ConstraintToken::Space(c) => self.add_space(c),\n            ConstraintToken::Close(c) => self.add_close(c),\n            ConstraintToken::Address(c) => self.add_address(c),\n            ConstraintToken::TokenAuthority(c) => self.add_token_authority(c),\n            ConstraintToken::TokenMint(c) => self.add_token_mint(c),\n            ConstraintToken::TokenTokenProgram(c) => self.add_token_token_program(c),\n            ConstraintToken::AssociatedTokenAuthority(c) => self.add_associated_token_authority(c),\n            ConstraintToken::AssociatedTokenMint(c) => self.add_associated_token_mint(c),\n            ConstraintToken::AssociatedTokenTokenProgram(c) => {\n                self.add_associated_token_token_program(c)\n            }",
    "pub fn get() -> Self {\n        Self {\n            name: \"event_authority\",\n            seeds: quote! {b\"__event_authority\"},\n        }\n    }\n\n    /// Returns the name without surrounding quotes.\n    pub fn name_token_stream(&self) -> proc_macro2::TokenStream {\n        let name_token_stream = syn::parse_str::<syn::Expr>(self.name).unwrap();\n        quote! {#name_token_stream}\n    }\n}\n\n/// Add necessary event CPI accounts to the given accounts struct.\npub fn add_event_cpi_accounts(\n    accounts_struct: &syn::ItemStruct,\n) -> syn::parse::Result<syn::ItemStruct> {\n    let syn::ItemStruct {\n        attrs,\n        vis,\n        struct_token,\n        ident,\n        generics,\n        fields,\n        ..\n    } = accounts_struct;\n\n    let fields = fields.into_iter().collect::<Vec<_>>();\n\n    let info_lifetime = generics\n        .lifetimes()\n        .next()\n        .map(|lifetime| quote! {#lifetime})\n        .unwrap_or(quote! {'info});\n    let generics = generics\n        .lt_token\n        .map(|_| quote! {#generics})\n        .unwrap_or(quote! {<'info>});\n\n    let authority = EventAuthority::get();\n    let authority_name = authority.name_token_stream();\n    let authority_seeds = authority.seeds;\n\n    let accounts_struct = quote! {\n        #(#attrs)*\n        #vis #struct_token #ident #generics {\n            #(#fields,)*\n\n            /// CHECK: Only the event authority can invoke self-CPI\n            #[account(seeds = [#authority_seeds], bump)]\n            pub #authority_name: AccountInfo<#info_lifetime>,\n            /// CHECK: Self-CPI will fail if the program is not the current program\n            pub program: AccountInfo<#info_lifetime>,\n        }\n    };\n    syn::parse2(accounts_struct)\n}",
    "pub fn parse(accounts_struct: &syn::ItemStruct) -> ParseResult<AccountsStruct> {\n    let instruction_api: Option<Punctuated<Expr, Comma>> = accounts_struct\n        .attrs\n        .iter()\n        .find(|a| {\n            a.path\n                .get_ident()\n                .is_some_and(|ident| ident == \"instruction\")\n        }",
    "pub fn parse_account_field(f: &syn::Field) -> ParseResult<AccountField> {\n    let ident = f.ident.clone().unwrap();\n    let docs = docs::parse(&f.attrs);\n    let account_field = match is_field_primitive(f)? {\n        true => {\n            let (ty, is_optional) = parse_ty(f)?;\n            let account_constraints = constraints::parse(f, Some(&ty))?;\n            AccountField::Field(Field {\n                ident,\n                ty,\n                is_optional,\n                constraints: account_constraints,\n                docs,\n            })\n        }",
    "pub fn parse(program_mod: &syn::ItemMod) -> ParseResult<(Vec<Ix>, Option<FallbackFn>)> {\n    let mod_content = &program_mod\n        .content\n        .as_ref()\n        .ok_or_else(|| ParseError::new(program_mod.span(), \"program content not provided\"))?\n        .1;\n\n    let ixs = mod_content\n        .iter()\n        .filter_map(|item| match item {\n            syn::Item::Fn(item_fn) => {\n                let (ctx, _) = parse_args(item_fn).ok()?;\n                ctx_accounts_ident(&ctx.raw_arg).ok()?;\n                Some(item_fn)\n            }",
    "pub fn parse_args(method: &syn::ItemFn) -> ParseResult<(IxArg, Vec<IxArg>)> {\n    let mut args: Vec<IxArg> = method\n        .sig\n        .inputs\n        .iter()\n        .map(|arg: &syn::FnArg| match arg {\n            syn::FnArg::Typed(arg) => {\n                let docs = docs::parse(&arg.attrs);\n                let ident = match &*arg.pat {\n                    syn::Pat::Ident(ident) => &ident.ident,\n                    _ => return Err(ParseError::new(arg.pat.span(), \"expected argument name\")),\n                };\n                Ok(IxArg {\n                    name: ident.clone(),\n                    docs,\n                    raw_arg: arg.clone(),\n                })\n            }",
    "pub fn parse_return(method: &syn::ItemFn) -> ParseResult<IxReturn> {\n    match method.sig.output {\n        syn::ReturnType::Type(_, ref ty) => {\n            let ty = match ty.as_ref() {\n                syn::Type::Path(ty) => ty,\n                _ => return Err(ParseError::new(ty.span(), \"expected a return type\")),\n            };\n            // Assume unit return by default\n            let default_generic_arg = syn::GenericArgument::Type(syn::parse_str(\"()\").unwrap());\n            let generic_args = match &ty.path.segments.last().unwrap().arguments {\n                syn::PathArguments::AngleBracketed(params) => params.args.iter().last().unwrap(),\n                _ => &default_generic_arg,\n            };\n            let ty = match generic_args {\n                syn::GenericArgument::Type(ty) => ty.clone(),\n                _ => {\n                    return Err(ParseError::new(\n                        ty.span(),\n                        \"expected generic return type to be a type\",\n                    ))\n                }",
    "pub fn parse(program_mod: syn::ItemMod) -> ParseResult<Program> {\n    let docs = docs::parse(&program_mod.attrs);\n    let (ixs, fallback_fn) = instructions::parse(&program_mod)?;\n    Ok(Program {\n        ixs,\n        name: program_mod.ident.clone(),\n        docs,\n        program_mod,\n        fallback_fn,\n    })\n}",
    "pub fn amount(account: &AccountInfo) -> Result<u64> {\n        let bytes = account.try_borrow_data()?;\n        let mut amount_bytes = [0u8; 8];\n        amount_bytes.copy_from_slice(&bytes[64..72]);\n        Ok(u64::from_le_bytes(amount_bytes))\n    }",
    "pub fn mint(account: &AccountInfo) -> Result<Pubkey> {\n        let bytes = account.try_borrow_data()?;\n        let mut mint_bytes = [0u8; 32];\n        mint_bytes.copy_from_slice(&bytes[..32]);\n        Ok(Pubkey::new_from_array(mint_bytes))\n    }",
    "pub fn authority(account: &AccountInfo) -> Result<Pubkey> {\n        let bytes = account.try_borrow_data()?;\n        let mut owner_bytes = [0u8; 32];\n        owner_bytes.copy_from_slice(&bytes[32..64]);\n        Ok(Pubkey::new_from_array(owner_bytes))\n    }",
    "pub fn find_mint_account_size(extensions: Option<&ExtensionsVec>) -> anchor_lang::Result<usize> {\n    if let Some(extensions) = extensions {\n        Ok(ExtensionType::try_calculate_account_len::<\n            spl_token_2022::state::Mint,\n        >(extensions)?)\n    }",
    "pub fn initialize(\n        ctx: Context<Initialize>,\n        balance: f32,\n        amount: u32,\n        memo: String,\n        values: Vec<u128>,\n    ) -> Result<()> {\n        let my_account = &mut ctx.accounts.my_account;\n\n        my_account.balance = balance;\n        my_account.delegate_pubkey = ctx.accounts.user.key().clone();\n        my_account.sub = Sub {\n            values,\n            state: State::Confirmed { amount, memo },\n        };\n\n        Ok(())\n    }",
    "pub fn initialize(_ctx: Context<Initialize>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn uninitialize(_ctx: Context<Initialize>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn assert_is_ata(ata: &AccountInfo, wallet: &Pubkey, mint: &Pubkey) -> Result<Account> {\n    assert_owned_by(ata, &spl_token::id())?;\n    let ata_account: Account = assert_initialized(ata)?;\n    assert_keys_equal(ata_account.owner, *wallet)?;\n    assert_keys_equal(get_associated_token_address(wallet, mint), *ata.key)?;\n    Ok(ata_account)\n}",
    "pub fn assert_valid_delegation(\n    src_account: &AccountInfo,\n    dst_account: &AccountInfo,\n    src_wallet: &AccountInfo,\n    dst_wallet: &AccountInfo,\n    transfer_authority: &AccountInfo,\n    mint: &anchor_lang::accounts::account::Account<Mint>,\n    paysize: u64,\n) -> Result<()> {\n    match Account::unpack(&src_account.data.borrow()) {\n        Ok(token_account) => {\n            // Ensure that the delegated amount is exactly equal to the maker_size\n            msg!(\n                \"Delegate {}\",\n                token_account.delegate.unwrap_or(*src_wallet.key)\n            );\n            msg!(\"Delegated Amount {}\", token_account.delegated_amount);\n            if token_account.delegated_amount != paysize {\n                return Err(ProgramError::InvalidAccountData.into());\n            }\n            // Ensure that authority is the delegate of this token account\n            msg!(\"Authority key matches\");\n            if token_account.delegate != COption::Some(*transfer_authority.key) {\n                return Err(ProgramError::InvalidAccountData.into());\n            }\n\n            msg!(\"Delegate matches\");\n            assert_is_ata(src_account, src_wallet.key, &mint.key())?;\n            assert_is_ata(dst_account, dst_wallet.key, &mint.key())?;\n            msg!(\"ATAs match\")\n        }",
    "pub fn assert_keys_equal(key1: Pubkey, key2: Pubkey) -> Result<()> {\n    if key1 != key2 {\n        err!(ErrorCode::PublicKeyMismatch)\n    }",
    "pub fn assert_owned_by(account: &AccountInfo, owner: &Pubkey) -> Result<()> {\n    if account.owner != owner {\n        err!(ErrorCode::IncorrectOwner)\n    }",
    "pub fn get_mint_from_token_account(token_account_info: &AccountInfo) -> Result<Pubkey> {\n    // TokeAccount layout:   mint(32), owner(32), ...\n    let data = token_account_info.try_borrow_data()?;\n    let mint_data = array_ref![data, 0, 32];\n    Ok(Pubkey::new_from_array(*mint_data))\n}",
    "pub fn get_delegate_from_token_account(token_account_info: &AccountInfo) -> Result<Option<Pubkey>> {\n    // TokeAccount layout:   mint(32), owner(32), ...\n    let data = token_account_info.try_borrow_data()?;\n    let key_data = array_ref![data, 76, 32];\n    let coption_data = u32::from_le_bytes(*array_ref![data, 72, 4]);\n    if coption_data == 0 {\n        Ok(None)\n    }",
    "pub fn assert_derivation(program_id: &Pubkey, account: &AccountInfo, path: &[&[u8]]) -> Result<u8> {\n    let (key, bump) = Pubkey::find_program_address(&path, program_id);\n    if key != *account.key {\n        return err!(ErrorCode::DerivedKeyInvalid);\n    }\n    Ok(bump)\n}",
    "pub fn account_info1(_ctx: Context<AccountInfo1>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn account_info2(_ctx: Context<AccountInfo2>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn account_info4(_ctx: Context<AccountInfo4>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn account_info8(_ctx: Context<AccountInfo8>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn account_empty_init1(_ctx: Context<AccountEmptyInit1>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn account_empty_init2(_ctx: Context<AccountEmptyInit2>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn account_empty_init4(_ctx: Context<AccountEmptyInit4>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn account_empty_init8(_ctx: Context<AccountEmptyInit8>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn account_empty1(_ctx: Context<AccountEmpty1>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn account_empty2(_ctx: Context<AccountEmpty2>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn account_empty4(_ctx: Context<AccountEmpty4>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn account_empty8(_ctx: Context<AccountEmpty8>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn account_sized_init1(_ctx: Context<AccountSizedInit1>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn account_sized_init2(_ctx: Context<AccountSizedInit2>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn account_sized_init4(_ctx: Context<AccountSizedInit4>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn account_sized_init8(_ctx: Context<AccountSizedInit8>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn account_sized1(_ctx: Context<AccountSized1>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn account_sized2(_ctx: Context<AccountSized2>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn account_sized4(_ctx: Context<AccountSized4>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn account_sized8(_ctx: Context<AccountSized8>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn account_unsized_init1(_ctx: Context<AccountUnsizedInit1>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn account_unsized_init2(_ctx: Context<AccountUnsizedInit2>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn account_unsized_init4(_ctx: Context<AccountUnsizedInit4>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn account_unsized_init8(_ctx: Context<AccountUnsizedInit8>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn account_unsized1(_ctx: Context<AccountUnsized1>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn account_unsized2(_ctx: Context<AccountUnsized2>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn account_unsized4(_ctx: Context<AccountUnsized4>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn account_unsized8(_ctx: Context<AccountUnsized8>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn boxed_account_empty_init1(_ctx: Context<BoxedAccountEmptyInit1>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn boxed_account_empty_init2(_ctx: Context<BoxedAccountEmptyInit2>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn boxed_account_empty_init4(_ctx: Context<BoxedAccountEmptyInit4>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn boxed_account_empty_init8(_ctx: Context<BoxedAccountEmptyInit8>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn boxed_account_empty1(_ctx: Context<BoxedAccountEmpty1>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn boxed_account_empty2(_ctx: Context<BoxedAccountEmpty2>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn boxed_account_empty4(_ctx: Context<BoxedAccountEmpty4>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn boxed_account_empty8(_ctx: Context<BoxedAccountEmpty8>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn boxed_account_sized_init1(_ctx: Context<BoxedAccountSizedInit1>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn boxed_account_sized_init2(_ctx: Context<BoxedAccountSizedInit2>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn boxed_account_sized_init4(_ctx: Context<BoxedAccountSizedInit4>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn boxed_account_sized_init8(_ctx: Context<BoxedAccountSizedInit8>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn boxed_account_sized1(_ctx: Context<BoxedAccountSized1>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn boxed_account_sized2(_ctx: Context<BoxedAccountSized2>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn boxed_account_sized4(_ctx: Context<BoxedAccountSized4>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn boxed_account_sized8(_ctx: Context<BoxedAccountSized8>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn boxed_account_unsized_init1(_ctx: Context<BoxedAccountUnsizedInit1>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn boxed_account_unsized_init2(_ctx: Context<BoxedAccountUnsizedInit2>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn boxed_account_unsized_init4(_ctx: Context<BoxedAccountUnsizedInit4>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn boxed_account_unsized_init8(_ctx: Context<BoxedAccountUnsizedInit8>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn boxed_account_unsized1(_ctx: Context<BoxedAccountUnsized1>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn boxed_account_unsized2(_ctx: Context<BoxedAccountUnsized2>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn boxed_account_unsized4(_ctx: Context<BoxedAccountUnsized4>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn boxed_account_unsized8(_ctx: Context<BoxedAccountUnsized8>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn boxed_interface_account_mint1(_ctx: Context<BoxedInterfaceAccountMint1>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn boxed_interface_account_mint2(_ctx: Context<BoxedInterfaceAccountMint2>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn boxed_interface_account_mint4(_ctx: Context<BoxedInterfaceAccountMint4>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn boxed_interface_account_mint8(_ctx: Context<BoxedInterfaceAccountMint8>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn boxed_interface_account_token1(\n        _ctx: Context<BoxedInterfaceAccountToken1>,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn boxed_interface_account_token2(\n        _ctx: Context<BoxedInterfaceAccountToken2>,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn boxed_interface_account_token4(\n        _ctx: Context<BoxedInterfaceAccountToken4>,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn boxed_interface_account_token8(\n        _ctx: Context<BoxedInterfaceAccountToken8>,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn interface_account_mint1(_ctx: Context<InterfaceAccountMint1>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn interface_account_mint2(_ctx: Context<InterfaceAccountMint2>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn interface_account_mint4(_ctx: Context<InterfaceAccountMint4>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn interface_account_mint8(_ctx: Context<InterfaceAccountMint8>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn interface_account_token1(_ctx: Context<InterfaceAccountToken1>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn interface_account_token2(_ctx: Context<InterfaceAccountToken2>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn interface_account_token4(_ctx: Context<InterfaceAccountToken4>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn interface1(_ctx: Context<Interface1>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn interface2(_ctx: Context<Interface2>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn interface4(_ctx: Context<Interface4>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn interface8(_ctx: Context<Interface8>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn program1(_ctx: Context<Program1>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn program2(_ctx: Context<Program2>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn program4(_ctx: Context<Program4>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn program8(_ctx: Context<Program8>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn signer1(_ctx: Context<Signer1>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn signer2(_ctx: Context<Signer2>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn signer4(_ctx: Context<Signer4>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn signer8(_ctx: Context<Signer8>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn system_account1(_ctx: Context<SystemAccount1>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn system_account2(_ctx: Context<SystemAccount2>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn system_account4(_ctx: Context<SystemAccount4>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn system_account8(_ctx: Context<SystemAccount8>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn unchecked_account1(_ctx: Context<UncheckedAccount1>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn unchecked_account2(_ctx: Context<UncheckedAccount2>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn unchecked_account4(_ctx: Context<UncheckedAccount4>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn unchecked_account8(_ctx: Context<UncheckedAccount8>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn set_admin_settings(ctx: Context<SetAdminSettings>, admin_data: u64) -> Result<()> {\n        match *ctx.accounts.program {\n            UpgradeableLoaderState::Program {\n                programdata_address,\n            } => {\n                if programdata_address != ctx.accounts.program_data.key() {\n                    return err!(CustomError::InvalidProgramDataAddress);\n                }\n            }\n            _ => {\n                return err!(CustomError::AccountNotProgram);\n            }\n        };\n        ctx.accounts.settings.admin_data = admin_data;\n        Ok(())\n    }",
    "pub fn set_admin_settings_use_program_state(\n        ctx: Context<SetAdminSettingsUseProgramState>,\n        admin_data: u64,\n    ) -> Result<()> {\n        ctx.accounts.settings.admin_data = admin_data;\n        Ok(())\n    }",
    "pub fn create_check(\n        ctx: Context<CreateCheck>,\n        amount: u64,\n        memo: Option<String>,\n        nonce: u8,\n    ) -> Result<()> {\n        // Transfer funds to the check.\n        let cpi_accounts = Transfer {\n            from: ctx.accounts.from.to_account_info(),\n            to: ctx.accounts.vault.to_account_info(),\n            authority: ctx.accounts.owner.clone(),\n        };\n        let cpi_program = ctx.accounts.token_program.clone();\n        let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);\n        token::transfer(cpi_ctx, amount)?;\n\n        // Print the check.\n        let check = &mut ctx.accounts.check;\n        check.amount = amount;\n        check.from = *ctx.accounts.from.to_account_info().key;\n        check.to = *ctx.accounts.to.to_account_info().key;\n        check.vault = *ctx.accounts.vault.to_account_info().key;\n        check.nonce = nonce;\n        check.memo = memo;\n\n        Ok(())\n    }",
    "pub fn cash_check(ctx: Context<CashCheck>) -> Result<()> {\n        let seeds = &[\n            ctx.accounts.check.to_account_info().key.as_ref(),\n            &[ctx.accounts.check.nonce],\n        ];\n        let signer = &[&seeds[..]];\n        let cpi_accounts = Transfer {\n            from: ctx.accounts.vault.to_account_info(),\n            to: ctx.accounts.to.to_account_info(),\n            authority: ctx.accounts.check_signer.clone(),\n        };\n        let cpi_program = ctx.accounts.token_program.clone();\n        let cpi_ctx = CpiContext::new_with_signer(cpi_program, cpi_accounts, signer);\n        token::transfer(cpi_ctx, ctx.accounts.check.amount)?;\n        // Burn the check for one time use.\n        ctx.accounts.check.burned = true;\n        Ok(())\n    }",
    "pub fn cancel_check(ctx: Context<CancelCheck>) -> Result<()> {\n        let seeds = &[\n            ctx.accounts.check.to_account_info().key.as_ref(),\n            &[ctx.accounts.check.nonce],\n        ];\n        let signer = &[&seeds[..]];\n        let cpi_accounts = Transfer {\n            from: ctx.accounts.vault.to_account_info(),\n            to: ctx.accounts.from.to_account_info(),\n            authority: ctx.accounts.check_signer.clone(),\n        };\n        let cpi_program = ctx.accounts.token_program.clone();\n        let cpi_ctx = CpiContext::new_with_signer(cpi_program, cpi_accounts, signer);\n        token::transfer(cpi_ctx, ctx.accounts.check.amount)?;\n        ctx.accounts.check.burned = true;\n        Ok(())\n    }",
    "pub fn accounts(ctx: &Context<CreateCheck>, nonce: u8) -> Result<()> {\n        let signer = Pubkey::create_program_address(\n            &[ctx.accounts.check.to_account_info().key.as_ref(), &[nonce]],\n            ctx.program_id,\n        )\n        .map_err(|_| error!(ErrorCode::InvalidCheckNonce))?;\n        if &signer != ctx.accounts.check_signer.to_account_info().key {\n            return err!(ErrorCode::InvalidCheckSigner);\n        }\n        Ok(())\n    }",
    "pub fn create_officer(\n        ctx: Context<CreateOfficer>,\n        bumps: OfficerBumps,\n        d: Distribution,\n        registrar: Pubkey,\n        msrm_registrar: Pubkey,\n    ) -> Result<()> {\n        let officer = &mut ctx.accounts.officer;\n        officer.authority = *ctx.accounts.authority.key;\n        officer.swap_program = *ctx.accounts.swap_program.key;\n        officer.dex_program = ctx.accounts.dex_program.key();\n        officer.distribution = d;\n        officer.registrar = registrar;\n        officer.msrm_registrar = msrm_registrar;\n        officer.stake = *ctx.accounts.stake.to_account_info().key;\n        officer.treasury = *ctx.accounts.treasury.to_account_info().key;\n        officer.srm_vault = *ctx.accounts.srm_vault.to_account_info().key;\n        officer.bumps = bumps;\n        emit!(OfficerDidCreate {\n            pubkey: *officer.to_account_info().key,\n        });\n        Ok(())\n    }",
    "pub fn authorize_market(ctx: Context<AuthorizeMarket>, bump: u8) -> Result<()> {\n        ctx.accounts.market_auth.bump = bump;\n        Ok(())\n    }",
    "pub fn revoke_market(_ctx: Context<RevokeMarket>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn create_officer_token(_ctx: Context<CreateOfficerToken>, _bump: u8) -> Result<()> {\n        Ok(())\n    }",
    "pub fn create_officer_open_orders(\n        ctx: Context<CreateOfficerOpenOrders>,\n        _bump: u8,\n    ) -> Result<()> {\n        let seeds = [\n            ctx.accounts.dex_program.key.as_ref(),\n            &[ctx.accounts.officer.bumps.bump],\n        ];\n        let cpi_ctx = CpiContext::from(&*ctx.accounts);\n        dex::init_open_orders(cpi_ctx.with_signer(&[&seeds])).map_err(Into::into)\n    }",
    "pub fn set_distribution(ctx: Context<SetDistribution>, d: Distribution) -> Result<()> {\n        ctx.accounts.officer.distribution = d.clone();\n        emit!(DistributionDidChange { distribution: d });\n        Ok(())\n    }",
    "pub fn create_user(ctx: Context<CreateUser>, name: String) -> Result<()> {\n        ctx.accounts.user.name = name;\n        ctx.accounts.user.authority = *ctx.accounts.authority.key;\n        ctx.accounts.user.bump = ctx.bumps.user;\n        Ok(())\n    }",
    "pub fn create_chat_room(ctx: Context<CreateChatRoom>, name: String) -> Result<()> {\n        let given_name = name.as_bytes();\n        let mut name = [0u8; 280];\n        name[..given_name.len()].copy_from_slice(given_name);\n        let mut chat = ctx.accounts.chat_room.load_init()?;\n        chat.name = name;\n        Ok(())\n    }",
    "pub fn send_message(ctx: Context<SendMessage>, msg: String) -> Result<()> {\n        let mut chat = ctx.accounts.chat_room.load_mut()?;\n        chat.append({\n            let src = msg.as_bytes();\n            let mut data = [0u8; 280];\n            data[..src.len()].copy_from_slice(src);\n            Message {\n                from: *ctx.accounts.user.to_account_info().key,\n                data,\n            }\n        });\n        Ok(())\n    }",
    "pub fn initialize(_ctx: Context<Initialize>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn composite_update(\n        ctx: Context<CompositeUpdate>,\n        dummy_a: u64,\n        dummy_b: u64,\n    ) -> Result<()> {\n        let a = &mut ctx.accounts.foo.dummy_a;\n        let b = &mut ctx.accounts.bar.dummy_b;\n\n        a.data = dummy_a;\n        b.data = dummy_b;\n\n        Ok(())\n    }",
    "pub fn initialize(ctx: Context<Initialize>) -> Result<()> {\n        let account = &mut ctx.accounts.account;\n        account.value = 10;\n        Ok(())\n    }",
    "pub fn return_u64(_ctx: Context<CpiReturn>) -> Result<u64> {\n        Ok(10)\n    }",
    "pub fn return_struct(_ctx: Context<CpiReturn>) -> Result<StructReturn> {\n        let s = StructReturn { value: 11 };\n        Ok(s)\n    }",
    "pub fn return_vec(_ctx: Context<CpiReturn>) -> Result<Vec<u8>> {\n        Ok(vec![12, 13, 14, 100])\n    }",
    "pub fn return_u64_from_account(ctx: Context<CpiReturn>) -> Result<u64> {\n        let account = &ctx.accounts.account;\n        Ok(account.value)\n    }",
    "pub fn cpi_call_return_u64(ctx: Context<CpiReturnContext>) -> Result<()> {\n        let cpi_program = ctx.accounts.cpi_return_program.to_account_info();\n        let cpi_accounts = CpiReturn {\n            account: ctx.accounts.cpi_return.to_account_info(),\n        };\n        let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);\n        let result = callee::cpi::return_u64(cpi_ctx)?;\n        let solana_return = result.get();\n        anchor_lang::solana_program::log::sol_log_data(&[&solana_return.try_to_vec().unwrap()]);\n        Ok(())\n    }",
    "pub fn cpi_call_return_struct(ctx: Context<CpiReturnContext>) -> Result<()> {\n        let cpi_program = ctx.accounts.cpi_return_program.to_account_info();\n        let cpi_accounts = CpiReturn {\n            account: ctx.accounts.cpi_return.to_account_info(),\n        };\n        let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);\n        let result = callee::cpi::return_struct(cpi_ctx)?;\n        let solana_return = result.get();\n        anchor_lang::solana_program::log::sol_log_data(&[&solana_return.try_to_vec().unwrap()]);\n        Ok(())\n    }",
    "pub fn cpi_call_return_vec(ctx: Context<CpiReturnContext>) -> Result<()> {\n        let cpi_program = ctx.accounts.cpi_return_program.to_account_info();\n        let cpi_accounts = CpiReturn {\n            account: ctx.accounts.cpi_return.to_account_info(),\n        };\n        let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);\n        let result = callee::cpi::return_vec(cpi_ctx)?;\n        let solana_return = result.get();\n        anchor_lang::solana_program::log::sol_log_data(&[&solana_return.try_to_vec().unwrap()]);\n        Ok(())\n    }",
    "pub fn return_u64(ctx: Context<ReturnContext>) -> Result<u64> {\n        Ok(99)\n    }",
    "pub fn return_struct(ctx: Context<ReturnContext>) -> Result<Struct> {\n        Ok(Struct { a: 1, b: 2 })\n    }",
    "pub fn return_vec(ctx: Context<ReturnContext>) -> Result<Vec<u64>> {\n        Ok(vec![1, 2, 3])\n    }",
    "pub fn create_account(\n        ctx: Context<CreateAccount>,\n        lamports: u64,\n        space: u64,\n        owner: Pubkey,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn assign(ctx: Context<Assign>, owner: Pubkey) -> Result<()> {\n        Ok(())\n    }",
    "pub fn transfer(ctx: Context<Transfer>, lamports: u64) -> Result<()> {\n        Ok(())\n    }",
    "pub fn create_account_with_seed(\n        ctx: Context<CreateAccountWithSeed>,\n        base: Pubkey,\n        seed: String,\n        lamports: u64,\n        space: u64,\n        owner: Pubkey,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn advance_nonce_account(\n        ctx: Context<AdvanceNonceAccount>,\n        authorized: Pubkey,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn withdraw_nonce_account(ctx: Context<WithdrawNonceAccount>, lamports: u64) -> Result<()> {\n        Ok(())\n    }",
    "pub fn initialize_nonce_account(\n        ctx: Context<InitializeNonceAccount>,\n        authorized: Pubkey,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn authorize_nonce_account(\n        ctx: Context<AuthorizeNonceAccount>,\n        authorized: Pubkey,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn allocate(ctx: Context<Allocate>, space: u64) -> Result<()> {\n        Ok(())\n    }",
    "pub fn allocate_with_seed(\n        ctx: Context<AllocateWithSeed>,\n        base: Pubkey,\n        seed: String,\n        space: u64,\n        owner: Pubkey,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn assign_with_seed(\n        ctx: Context<AssignWithSeed>,\n        base: Pubkey,\n        seed: String,\n        owner: Pubkey,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn transfer_with_seed(\n        ctx: Context<TransferWithSeed>,\n        lamports: u64,\n        seed: String,\n        owner: Pubkey,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn check_accounts(_ctx: Context<CheckAccounts>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn int(_ctx: Context<DefaultIx>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn array(_ctx: Context<DefaultIx>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn byte_str(_ctx: Context<DefaultIx>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn constant(_ctx: Context<DefaultIx>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn const_fn(_ctx: Context<DefaultIx>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn account(ctx: Context<CustomAccountIx>, field: u8) -> Result<()> {\n        ctx.accounts.my_account.field = field;\n        Ok(())\n    }",
    "pub fn event(_ctx: Context<DefaultIx>, field: u8) -> Result<()> {\n        emit!(MyEvent { field });\n        Ok(())\n    }",
    "pub fn initialize(_ctx: Context<Initialize>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn cpi(ctx: Context<Cpi>, value: u32) -> Result<()> {\n        let cpi_my_account = &mut ctx.accounts.cpi_my_account;\n        require_keys_eq!(external::accounts::MyAccount::owner(), external::ID);\n        require_eq!(cpi_my_account.field, 0);\n\n        let cpi_ctx = CpiContext::new(\n            ctx.accounts.external_program.to_account_info(),\n            external::cpi::accounts::Update {\n                authority: ctx.accounts.authority.to_account_info(),\n                my_account: cpi_my_account.to_account_info(),\n            },\n        );\n        external::cpi::update(cpi_ctx, value)?;\n\n        cpi_my_account.reload()?;\n        require_eq!(cpi_my_account.field, value);\n\n        Ok(())\n    }",
    "pub fn cpi_composite(ctx: Context<Cpi>, value: u32) -> Result<()> {\n        let cpi_my_account = &mut ctx.accounts.cpi_my_account;\n\n        // Composite accounts that's also an instruction\n        let cpi_ctx = CpiContext::new(\n            ctx.accounts.external_program.to_account_info(),\n            external::cpi::accounts::UpdateComposite {\n                update: external::cpi::accounts::Update {\n                    authority: ctx.accounts.authority.to_account_info(),\n                    my_account: cpi_my_account.to_account_info(),\n                },\n            },\n        );\n        external::cpi::update_composite(cpi_ctx, 42)?;\n        cpi_my_account.reload()?;\n        require_eq!(cpi_my_account.field, 42);\n\n        // Composite accounts but not an actual instruction\n        let cpi_ctx = CpiContext::new(\n            ctx.accounts.external_program.to_account_info(),\n            external::cpi::accounts::UpdateNonInstructionComposite {\n                non_instruction_update: external::cpi::accounts::NonInstructionUpdate {\n                    authority: ctx.accounts.authority.to_account_info(),\n                    my_account: cpi_my_account.to_account_info(),\n                    program: ctx.accounts.external_program.to_account_info(),\n                },\n            },\n        );\n        external::cpi::update_non_instruction_composite(cpi_ctx, value)?;\n        cpi_my_account.reload()?;\n        require_eq!(cpi_my_account.field, value);\n\n        Ok(())\n    }",
    "pub fn account_utils(_ctx: Context<Utils>) -> Result<()> {\n        use external::utils::Account;\n\n        // Empty\n        if Account::try_from_bytes(&[]).is_ok() {\n            return Err(ProgramError::Custom(0).into());\n        }\n\n        const DISC: &[u8] = external::accounts::MyAccount::DISCRIMINATOR;\n\n        // Correct discriminator but invalid data\n        if Account::try_from_bytes(DISC).is_ok() {\n            return Err(ProgramError::Custom(1).into());\n        };\n\n        // Correct discriminator and valid data\n        match Account::try_from_bytes(&[DISC, &[1, 0, 0, 0]].concat()) {\n            Ok(Account::MyAccount(my_account)) => require_eq!(my_account.field, 1),\n            Err(e) => return Err(e.into()),\n        }\n\n        Ok(())\n    }",
    "pub fn event_utils(_ctx: Context<Utils>) -> Result<()> {\n        use external::utils::Event;\n\n        // Empty\n        if Event::try_from_bytes(&[]).is_ok() {\n            return Err(ProgramError::Custom(0).into());\n        }\n\n        const DISC: &[u8] = external::events::MyEvent::DISCRIMINATOR;\n\n        // Correct discriminator but invalid data\n        if Event::try_from_bytes(DISC).is_ok() {\n            return Err(ProgramError::Custom(1).into());\n        };\n\n        // Correct discriminator and valid data\n        match Event::try_from_bytes(&[DISC, &[1, 0, 0, 0]].concat()) {\n            Ok(Event::MyEvent(my_event)) => require_eq!(my_event.value, 1),\n            Err(e) => return Err(e.into()),\n        }\n\n        Ok(())\n    }",
    "pub fn init(_ctx: Context<Init>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn update(ctx: Context<Update>, value: u32) -> Result<()> {\n        ctx.accounts.my_account.field = value;\n        Ok(())\n    }",
    "pub fn update_composite(ctx: Context<UpdateComposite>, value: u32) -> Result<()> {\n        ctx.accounts.update.my_account.field = value;\n        Ok(())\n    }",
    "pub fn update_non_instruction_composite(\n        ctx: Context<UpdateNonInstructionComposite>,\n        value: u32,\n    ) -> Result<()> {\n        ctx.accounts.non_instruction_update.my_account.field = value;\n        Ok(())\n    }",
    "pub fn test_compilation_defined_type_param(\n        _ctx: Context<TestCompilation>,\n        _my_account: MyAccount,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_compilation_return_type(_ctx: Context<TestCompilation>) -> Result<bool> {\n        Ok(true)\n    }",
    "pub fn test_compilation_data_as_parameter_name(\n        _ctx: Context<TestCompilation>,\n        data: Vec<u8>,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_compilation_no_accounts(_ctx: Context<TestCompilationNoAccounts>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn hello(_ctx: Context<Hello>) -> Result<()> {\n        err!(MyError::Hello)\n    }",
    "pub fn hello_no_msg(_ctx: Context<Hello>) -> Result<()> {\n        err!(MyError::HelloNoMsg)\n    }",
    "pub fn hello_next(_ctx: Context<Hello>) -> Result<()> {\n        err!(MyError::HelloNext)\n    }",
    "pub fn test_require(_ctx: Context<Hello>) -> Result<()> {\n        require!(false, MyError::Hello);\n        Ok(())\n    }",
    "pub fn test_err(_ctx: Context<Hello>) -> Result<()> {\n        err!(MyError::Hello)\n    }",
    "pub fn test_program_error(_ctx: Context<Hello>) -> Result<()> {\n        Err(ProgramError::InvalidAccountData.into())\n    }",
    "pub fn test_program_error_with_source(_ctx: Context<Hello>) -> Result<()> {\n        Err(Error::from(ProgramError::InvalidAccountData).with_source(source!()))\n    }",
    "pub fn mut_error(_ctx: Context<MutError>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn has_one_error(_ctx: Context<HasOneError>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn signer_error(_ctx: Context<SignerError>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn raw_custom_error(_ctx: Context<RawCustomError>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn account_not_initialized_error(_ctx: Context<AccountNotInitializedError>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn account_owned_by_wrong_program_error(\n        _ctx: Context<AccountOwnedByWrongProgramError>,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn require_eq(_ctx: Context<RequireEq>) -> Result<()> {\n        require_eq!(5241, 124124124, MyError::ValueMismatch);\n        Ok(())\n    }",
    "pub fn require_eq_default_error(_ctx: Context<RequireEq>) -> Result<()> {\n        require_eq!(5241, 124124124);\n        Ok(())\n    }",
    "pub fn require_neq(_ctx: Context<RequireNeq>) -> Result<()> {\n        require_neq!(500, 500, MyError::ValueMatch);\n        Ok(())\n    }",
    "pub fn require_neq_default_error(_ctx: Context<RequireNeq>) -> Result<()> {\n        require_neq!(500, 500);\n        Ok(())\n    }",
    "pub fn require_keys_eq(ctx: Context<RequireKeysEq>) -> Result<()> {\n        require_keys_eq!(\n            ctx.accounts.some_account.key(),\n            *ctx.program_id,\n            MyError::ValueMismatch\n        );\n        Ok(())\n    }",
    "pub fn require_keys_eq_default_error(ctx: Context<RequireKeysEq>) -> Result<()> {\n        require_keys_eq!(ctx.accounts.some_account.key(), *ctx.program_id);\n        Ok(())\n    }",
    "pub fn require_keys_neq(ctx: Context<RequireKeysNeq>) -> Result<()> {\n        require_keys_neq!(\n            ctx.accounts.some_account.key(),\n            *ctx.program_id,\n            MyError::ValueMatch\n        );\n        Ok(())\n    }",
    "pub fn require_keys_neq_default_error(ctx: Context<RequireKeysNeq>) -> Result<()> {\n        require_keys_neq!(ctx.accounts.some_account.key(), *ctx.program_id);\n        Ok(())\n    }",
    "pub fn require_gt(_ctx: Context<RequireGt>) -> Result<()> {\n        require_gt!(5, 10, MyError::ValueLessOrEqual);\n        Ok(())\n    }",
    "pub fn require_gt_default_error(_ctx: Context<RequireGt>) -> Result<()> {\n        require_gt!(10, 10);\n        Ok(())\n    }",
    "pub fn require_gte(_ctx: Context<RequireGt>) -> Result<()> {\n        require_gte!(5, 10, MyError::ValueLess);\n        Ok(())\n    }",
    "pub fn require_gte_default_error(_ctx: Context<RequireGt>) -> Result<()> {\n        require_gte!(5, 10);\n        Ok(())\n    }",
    "pub fn try_into_integer(_ctx: Context<Hello>) -> Result<i64> {\n        Ok(u64::MAX.try_into()?)\n    }",
    "pub fn initialize_escrow(\n        ctx: Context<InitializeEscrow>,\n        initializer_amount: u64,\n        taker_amount: u64,\n    ) -> Result<()> {\n        ctx.accounts.escrow_account.initializer_key = *ctx.accounts.initializer.key;\n        ctx.accounts\n            .escrow_account\n            .initializer_deposit_token_account = *ctx\n            .accounts\n            .initializer_deposit_token_account\n            .to_account_info()\n            .key;\n        ctx.accounts\n            .escrow_account\n            .initializer_receive_token_account = *ctx\n            .accounts\n            .initializer_receive_token_account\n            .to_account_info()\n            .key;\n        ctx.accounts.escrow_account.initializer_amount = initializer_amount;\n        ctx.accounts.escrow_account.taker_amount = taker_amount;\n\n        let (pda, _bump_seed) = Pubkey::find_program_address(&[ESCROW_PDA_SEED], ctx.program_id);\n        token_interface::set_authority(\n            ctx.accounts.into(),\n            AuthorityType::AccountOwner,\n            Some(pda),\n        )?;\n        Ok(())\n    }",
    "pub fn cancel_escrow(ctx: Context<CancelEscrow>) -> Result<()> {\n        let (_pda, bump_seed) = Pubkey::find_program_address(&[ESCROW_PDA_SEED], ctx.program_id);\n        let seeds = &[&ESCROW_PDA_SEED[..], &[bump_seed]];\n\n        token_interface::set_authority(\n            ctx.accounts\n                .into_set_authority_context()\n                .with_signer(&[&seeds[..]]),\n            AuthorityType::AccountOwner,\n            Some(ctx.accounts.escrow_account.initializer_key),\n        )?;\n\n        Ok(())\n    }",
    "pub fn exchange(ctx: Context<Exchange>) -> Result<()> {\n        // Transferring from initializer to taker\n        let (_pda, bump_seed) = Pubkey::find_program_address(&[ESCROW_PDA_SEED], ctx.program_id);\n        let seeds = &[&ESCROW_PDA_SEED[..], &[bump_seed]];\n\n        token_interface::transfer_checked(\n            ctx.accounts\n                .into_transfer_to_taker_context()\n                .with_signer(&[&seeds[..]]),\n            ctx.accounts.escrow_account.initializer_amount,\n            ctx.accounts.receive_mint.decimals,\n        )?;\n\n        token_interface::transfer_checked(\n            ctx.accounts.into_transfer_to_initializer_context(),\n            ctx.accounts.escrow_account.taker_amount,\n            ctx.accounts.deposit_mint.decimals,\n        )?;\n\n        token_interface::set_authority(\n            ctx.accounts\n                .into_set_authority_context()\n                .with_signer(&[&seeds[..]]),\n            AuthorityType::AccountOwner,\n            Some(ctx.accounts.escrow_account.initializer_key),\n        )?;\n\n        Ok(())\n    }",
    "pub fn initialize(_ctx: Context<Initialize>) -> Result<()> {\n        emit!(MyEvent {\n            data: 5,\n            label: \"hello\".to_string(),\n        });\n        Ok(())\n    }",
    "pub fn test_event(_ctx: Context<TestEvent>) -> Result<()> {\n        emit!(MyOtherEvent {\n            data: 6,\n            label: \"bye\".to_string(),\n        });\n        Ok(())\n    }",
    "pub fn test_event_cpi(ctx: Context<TestEventCpi>) -> Result<()> {\n        emit_cpi!(MyOtherEvent {\n            data: 7,\n            label: \"cpi\".to_string(),\n        });\n        Ok(())\n    }",
    "pub fn create(ctx: Context<Create>, data_f32: f32, data_f64: f64) -> Result<()> {\n        let account = &mut ctx.accounts.account;\n        let authority = &mut ctx.accounts.authority;\n\n        account.data_f32 = data_f32;\n        account.data_f64 = data_f64;\n        account.authority = authority.key();\n\n        Ok(())\n    }",
    "pub fn update(ctx: Context<Update>, data_f32: f32, data_f64: f64) -> Result<()> {\n        let account = &mut ctx.accounts.account;\n\n        account.data_f32 = data_f32;\n        account.data_f64 = data_f64;\n\n        Ok(())\n    }",
    "pub fn test_idl_doc_parse(_ctx: Context<TestIdlDocParse>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn initialize(_ctx: Context<Initialize>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn generic(\n        ctx: Context<GenericCtx>,\n        generic_field: GenericType<u32, u64, 10>,\n    ) -> Result<()> {\n        ctx.accounts.generic_acc.data = generic_field;\n        Ok(())\n    }",
    "pub fn initialize(ctx: Context<Initialize>) -> Result<()> {\n        ctx.accounts.state.set_inner(State::default());\n        Ok(())\n    }",
    "pub fn initialize_with_values(\n        ctx: Context<Initialize>,\n        bool_field: bool,\n        u8_field: u8,\n        i8_field: i8,\n        u16_field: u16,\n        i16_field: i16,\n        u32_field: u32,\n        i32_field: i32,\n        f32_field: f32,\n        u64_field: u64,\n        i64_field: i64,\n        f64_field: f64,\n        u128_field: u128,\n        i128_field: i128,\n        bytes_field: Vec<u8>,\n        string_field: String,\n        pubkey_field: Pubkey,\n        vec_field: Vec<u64>,\n        vec_struct_field: Vec<FooStruct>,\n        option_field: Option<bool>,\n        option_struct_field: Option<FooStruct>,\n        struct_field: FooStruct,\n        array_field: [bool; 3],\n        enum_field_1: FooEnum,\n        enum_field_2: FooEnum,\n        enum_field_3: FooEnum,\n        enum_field_4: FooEnum,\n    ) -> Result<()> {\n        ctx.accounts.state.set_inner(State {\n            bool_field,\n            u8_field,\n            i8_field,\n            u16_field,\n            i16_field,\n            u32_field,\n            i32_field,\n            f32_field,\n            u64_field,\n            i64_field,\n            f64_field,\n            u128_field,\n            i128_field,\n            bytes_field,\n            string_field,\n            pubkey_field,\n            vec_field,\n            vec_struct_field,\n            option_field,\n            option_struct_field,\n            struct_field,\n            array_field,\n            enum_field_1,\n            enum_field_2,\n            enum_field_3,\n            enum_field_4,\n        });\n\n        Ok(())\n    }",
    "pub fn initialize_with_values2(\n        ctx: Context<Initialize2>,\n        vec_of_option: Vec<Option<u64>>,\n        box_field: Box<bool>,\n    ) -> Result<SomeRetStruct> {\n        ctx.accounts.state.set_inner(State2 {\n            vec_of_option,\n            box_field,\n        });\n        Ok(SomeRetStruct { some_field: 3 })\n    }",
    "pub fn cause_error(_ctx: Context<CauseError>) -> Result<()> {\n        Err(error!(ErrorCode::SomeError))\n    }",
    "pub fn no_case_conversion(ctx: Context<NoCaseConversion>, field_name: u8) -> Result<()> {\n        ctx.accounts.case_conversion_account.field_name = field_name;\n        emit!(SimpleEvent { field_name });\n        Ok(())\n    }",
    "pub fn empty(_ctx: Context<Empty>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn primitive_types(\n        ctx: Context<PrimitiveTypes>,\n        bool: bool,\n        i8: i8,\n        i16: i16,\n        i32: i32,\n        i64: i64,\n        i128: i128,\n        u8: u8,\n        u16: u16,\n        u32: u32,\n        u64: u64,\n        u128: u128,\n        f32: f32,\n        f64: f64,\n        pubkey: Pubkey,\n    ) -> Result<()> {\n        ctx.accounts.account.bool = bool;\n\n        ctx.accounts.account.i8 = i8;\n        ctx.accounts.account.i16 = i16;\n        ctx.accounts.account.i32 = i32;\n        ctx.accounts.account.i64 = i64;\n        ctx.accounts.account.i128 = i128;\n\n        ctx.accounts.account.u8 = u8;\n        ctx.accounts.account.u16 = u16;\n        ctx.accounts.account.u32 = u32;\n        ctx.accounts.account.u64 = u64;\n        ctx.accounts.account.u128 = u128;\n\n        ctx.accounts.account.f32 = f32;\n        ctx.accounts.account.f64 = f64;\n\n        ctx.accounts.account.pubkey = pubkey;\n        Ok(())\n    }",
    "pub fn unsized_types(ctx: Context<UnsizedTypes>, string: String, bytes: Vec<u8>) -> Result<()> {\n        ctx.accounts.account.string = string;\n        ctx.accounts.account.bytes = bytes;\n        Ok(())\n    }",
    "pub fn strct(\n        ctx: Context<Struct>,\n        unit: UnitStruct,\n        named: NamedStruct,\n        tuple: TupleStruct,\n    ) -> Result<()> {\n        ctx.accounts.account.unit = unit;\n        ctx.accounts.account.named = named;\n        ctx.accounts.account.tuple = tuple;\n        Ok(())\n    }",
    "pub fn enm(ctx: Context<Enum>, full_enum: FullEnum) -> Result<()> {\n        ctx.accounts.account.full_enum = full_enum;\n        Ok(())\n    }",
    "pub fn type_alias(\n        ctx: Context<TypeAlias>,\n        alias_u8: AliasU8,\n        alias_u8_array: AliasU8Array,\n        alias_struct: AliasStruct,\n        alias_vec_string: AliasVec<String>,\n        alias_option_vec_pubkey: AliasOptionVec<Pubkey>,\n        alias_generic_const: AliasGenericConst<4>,\n        alias_multiple_generics_mixed: AliasMultipleGenericMixed<bool, 2>,\n        alias_external: UnixTimestamp,\n    ) -> Result<()> {\n        ctx.accounts.account.alias_u8 = alias_u8;\n        ctx.accounts.account.alias_u8_array = alias_u8_array;\n        ctx.accounts.account.alias_struct = alias_struct;\n        ctx.accounts.account.alias_vec_string = alias_vec_string;\n        ctx.accounts.account.alias_option_vec_pubkey = alias_option_vec_pubkey;\n        ctx.accounts.account.alias_generic_const = alias_generic_const;\n        ctx.accounts.account.alias_multiple_generics_mixed = alias_multiple_generics_mixed;\n        ctx.accounts.account.alias_external = alias_external;\n        Ok(())\n    }",
    "pub fn account_and_event_arg_and_field(\n        ctx: Context<AccountAndEventArgAndField>,\n        account: AccountAndEventFieldAccount,\n    ) -> Result<()> {\n        *ctx.accounts.account = account;\n        Ok(())\n    }",
    "pub fn generic(ctx: Context<Generic>, generic_arg: GenericStruct<u16, 4>) -> Result<()> {\n        ctx.accounts.my_account.field = generic_arg;\n        Ok(())\n    }",
    "pub fn generic_custom_struct(\n        ctx: Context<GenericCustomStruct>,\n        generic_arg: GenericStruct<SomeStruct, 4>,\n    ) -> Result<()> {\n        ctx.accounts.my_account.field = generic_arg;\n        Ok(())\n    }",
    "pub fn full_path(\n        ctx: Context<FullPath>,\n        named_struct: NamedStruct,\n        some_module_named_struct: some_module::NamedStruct,\n    ) -> Result<()> {\n        ctx.accounts.account.named_struct = named_struct;\n        ctx.accounts.account.some_module_named_struct = some_module_named_struct;\n        Ok(())\n    }",
    "pub fn external(ctx: Context<External>, my_struct: external::MyStruct) -> Result<()> {\n        ctx.accounts.account.my_struct = my_struct;\n        Ok(())\n    }",
    "pub fn external_non_anchor(\n        ctx: Context<ExternalNonAnchor>,\n        feature: wrapped::Feature,\n    ) -> Result<()> {\n        ctx.accounts.account.feature = feature;\n        Ok(())\n    }",
    "pub fn init_base(ctx: Context<InitBase>) -> Result<()> {\n        ctx.accounts.account.my_account = ctx.accounts.my_account.key();\n        ctx.accounts.account.bump = ctx.bumps.account;\n        Ok(())\n    }",
    "pub fn test_relation(_ctx: Context<TestRelation>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn initialize_pool(\n        ctx: Context<InitializePool>,\n        ido_name: String,\n        _bumps: PoolBumps, // No longer used.\n        num_ido_tokens: u64,\n        ido_times: IdoTimes,\n    ) -> Result<()> {\n        msg!(\"INITIALIZE POOL\");\n\n        let ido_account = &mut ctx.accounts.ido_account;\n\n        let name_bytes = ido_name.as_bytes();\n        let mut name_data = [b' '; 10];\n        name_data[..name_bytes.len()].copy_from_slice(name_bytes);\n\n        ido_account.ido_name = name_data;\n        ido_account.bumps = PoolBumps {\n            ido_account: ctx.bumps.ido_account,\n            redeemable_mint: ctx.bumps.redeemable_mint,\n            pool_watermelon: ctx.bumps.pool_watermelon,\n            pool_usdc: ctx.bumps.pool_usdc,\n        };\n        ido_account.ido_authority = ctx.accounts.ido_authority.key();\n\n        ido_account.usdc_mint = ctx.accounts.usdc_mint.key();\n        ido_account.redeemable_mint = ctx.accounts.redeemable_mint.key();\n        ido_account.watermelon_mint = ctx.accounts.watermelon_mint.key();\n        ido_account.pool_usdc = ctx.accounts.pool_usdc.key();\n        ido_account.pool_watermelon = ctx.accounts.pool_watermelon.key();\n\n        ido_account.num_ido_tokens = num_ido_tokens;\n        ido_account.ido_times = ido_times;\n\n        // Transfer Watermelon from ido_authority to pool account.\n        let cpi_accounts = Transfer {\n            from: ctx.accounts.ido_authority_watermelon.to_account_info(),\n            to: ctx.accounts.pool_watermelon.to_account_info(),\n            authority: ctx.accounts.ido_authority.to_account_info(),\n        };\n        let cpi_program = ctx.accounts.token_program.to_account_info();\n        let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);\n        token::transfer(cpi_ctx, num_ido_tokens)?;\n\n        Ok(())\n    }",
    "pub fn init_user_redeemable(ctx: Context<InitUserRedeemable>) -> Result<()> {\n        msg!(\"INIT USER REDEEMABLE\");\n        Ok(())\n    }",
    "pub fn exchange_usdc_for_redeemable(\n        ctx: Context<ExchangeUsdcForRedeemable>,\n        amount: u64,\n    ) -> Result<()> {\n        msg!(\"EXCHANGE USDC FOR REDEEMABLE\");\n        // While token::transfer will check this, we prefer a verbose err msg.\n        if ctx.accounts.user_usdc.amount < amount {\n            return err!(ErrorCode::LowUsdc);\n        }\n\n        // Transfer user's USDC to pool USDC account.\n        let cpi_accounts = Transfer {\n            from: ctx.accounts.user_usdc.to_account_info(),\n            to: ctx.accounts.pool_usdc.to_account_info(),\n            authority: ctx.accounts.user_authority.to_account_info(),\n        };\n        let cpi_program = ctx.accounts.token_program.to_account_info();\n        let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);\n        token::transfer(cpi_ctx, amount)?;\n\n        // Mint Redeemable to user Redeemable account.\n        let ido_name = ctx.accounts.ido_account.ido_name.as_ref();\n        let seeds = &[\n            ido_name.trim_ascii_whitespace(),\n            &[ctx.accounts.ido_account.bumps.ido_account],\n        ];\n        let signer = &[&seeds[..]];\n        let cpi_accounts = MintTo {\n            mint: ctx.accounts.redeemable_mint.to_account_info(),\n            to: ctx.accounts.user_redeemable.to_account_info(),\n            authority: ctx.accounts.ido_account.to_account_info(),\n        };\n        let cpi_program = ctx.accounts.token_program.to_account_info();\n        let cpi_ctx = CpiContext::new_with_signer(cpi_program, cpi_accounts, signer);\n        token::mint_to(cpi_ctx, amount)?;\n\n        Ok(())\n    }",
    "pub fn init_escrow_usdc(ctx: Context<InitEscrowUsdc>) -> Result<()> {\n        msg!(\"INIT ESCROW USDC\");\n        Ok(())\n    }",
    "pub fn exchange_redeemable_for_usdc(\n        ctx: Context<ExchangeRedeemableForUsdc>,\n        amount: u64,\n    ) -> Result<()> {\n        msg!(\"EXCHANGE REDEEMABLE FOR USDC\");\n        // While token::burn will check this, we prefer a verbose err msg.\n        if ctx.accounts.user_redeemable.amount < amount {\n            return err!(ErrorCode::LowRedeemable);\n        }\n\n        let ido_name = ctx.accounts.ido_account.ido_name.as_ref();\n        let seeds = &[\n            ido_name.trim_ascii_whitespace(),\n            &[ctx.accounts.ido_account.bumps.ido_account],\n        ];\n        let signer = &[&seeds[..]];\n\n        // Burn the user's redeemable tokens.\n        let cpi_accounts = Burn {\n            mint: ctx.accounts.redeemable_mint.to_account_info(),\n            from: ctx.accounts.user_redeemable.to_account_info(),\n            authority: ctx.accounts.ido_account.to_account_info(),\n        };\n        let cpi_program = ctx.accounts.token_program.to_account_info();\n        let cpi_ctx = CpiContext::new_with_signer(cpi_program, cpi_accounts, signer);\n        token::burn(cpi_ctx, amount)?;\n\n        // Transfer USDC from pool account to the user's escrow account.\n        let cpi_accounts = Transfer {\n            from: ctx.accounts.pool_usdc.to_account_info(),\n            to: ctx.accounts.escrow_usdc.to_account_info(),\n            authority: ctx.accounts.ido_account.to_account_info(),\n        };\n        let cpi_program = ctx.accounts.token_program.to_account_info();\n        let cpi_ctx = CpiContext::new_with_signer(cpi_program, cpi_accounts, signer);\n        token::transfer(cpi_ctx, amount)?;\n\n        Ok(())\n    }",
    "pub fn exchange_redeemable_for_watermelon(\n        ctx: Context<ExchangeRedeemableForWatermelon>,\n        amount: u64,\n    ) -> Result<()> {\n        msg!(\"EXCHANGE REDEEMABLE FOR WATERMELON\");\n        // While token::burn will check this, we prefer a verbose err msg.\n        if ctx.accounts.user_redeemable.amount < amount {\n            return err!(ErrorCode::LowRedeemable);\n        }\n\n        // Calculate watermelon tokens due.\n        let watermelon_amount = (amount as u128)\n            .checked_mul(ctx.accounts.pool_watermelon.amount as u128)\n            .unwrap()\n            .checked_div(ctx.accounts.redeemable_mint.supply as u128)\n            .unwrap();\n\n        let ido_name = ctx.accounts.ido_account.ido_name.as_ref();\n        let seeds = &[\n            ido_name.trim_ascii_whitespace(),\n            &[ctx.accounts.ido_account.bumps.ido_account],\n        ];\n        let signer = &[&seeds[..]];\n\n        // Burn the user's redeemable tokens.\n        let cpi_accounts = Burn {\n            mint: ctx.accounts.redeemable_mint.to_account_info(),\n            from: ctx.accounts.user_redeemable.to_account_info(),\n            authority: ctx.accounts.ido_account.to_account_info(),\n        };\n        let cpi_program = ctx.accounts.token_program.to_account_info();\n        let cpi_ctx = CpiContext::new_with_signer(cpi_program, cpi_accounts, signer);\n        token::burn(cpi_ctx, amount)?;\n\n        // Transfer Watermelon from pool account to user.\n        let cpi_accounts = Transfer {\n            from: ctx.accounts.pool_watermelon.to_account_info(),\n            to: ctx.accounts.user_watermelon.to_account_info(),\n            authority: ctx.accounts.ido_account.to_account_info(),\n        };\n        let cpi_program = ctx.accounts.token_program.to_account_info();\n        let cpi_ctx = CpiContext::new_with_signer(cpi_program, cpi_accounts, signer);\n        token::transfer(cpi_ctx, watermelon_amount as u64)?;\n\n        // Send rent back to user if account is empty\n        ctx.accounts.user_redeemable.reload()?;\n        if ctx.accounts.user_redeemable.amount == 0 {\n            let cpi_accounts = CloseAccount {\n                account: ctx.accounts.user_redeemable.to_account_info(),\n                destination: ctx.accounts.user_authority.clone(),\n                authority: ctx.accounts.ido_account.to_account_info(),\n            };\n            let cpi_program = ctx.accounts.token_program.to_account_info();\n            let cpi_ctx = CpiContext::new_with_signer(cpi_program, cpi_accounts, signer);\n            token::close_account(cpi_ctx)?;\n        }\n\n        Ok(())\n    }",
    "pub fn withdraw_pool_usdc(ctx: Context<WithdrawPoolUsdc>) -> Result<()> {\n        msg!(\"WITHDRAW POOL USDC\");\n        // Transfer total USDC from pool account to ido_authority account.\n        let ido_name = ctx.accounts.ido_account.ido_name.as_ref();\n        let seeds = &[\n            ido_name.trim_ascii_whitespace(),\n            &[ctx.accounts.ido_account.bumps.ido_account],\n        ];\n        let signer = &[&seeds[..]];\n        let cpi_accounts = Transfer {\n            from: ctx.accounts.pool_usdc.to_account_info(),\n            to: ctx.accounts.ido_authority_usdc.to_account_info(),\n            authority: ctx.accounts.ido_account.to_account_info(),\n        };\n        let cpi_program = ctx.accounts.token_program.to_account_info();\n        let cpi_ctx = CpiContext::new_with_signer(cpi_program, cpi_accounts, signer);\n        token::transfer(cpi_ctx, ctx.accounts.pool_usdc.amount)?;\n\n        Ok(())\n    }",
    "pub fn withdraw_from_escrow(ctx: Context<WithdrawFromEscrow>, amount: u64) -> Result<()> {\n        msg!(\"WITHDRAW FROM ESCROW\");\n        // While token::transfer will check this, we prefer a verbose err msg.\n        if ctx.accounts.escrow_usdc.amount < amount {\n            return err!(ErrorCode::LowUsdc);\n        }\n\n        let ido_name = ctx.accounts.ido_account.ido_name.as_ref();\n        let seeds = &[\n            ido_name.trim_ascii_whitespace(),\n            &[ctx.accounts.ido_account.bumps.ido_account],\n        ];\n        let signer = &[&seeds[..]];\n\n        // Transfer USDC from user's escrow account to user's USDC account.\n        let cpi_accounts = Transfer {\n            from: ctx.accounts.escrow_usdc.to_account_info(),\n            to: ctx.accounts.user_usdc.to_account_info(),\n            authority: ctx.accounts.ido_account.to_account_info(),\n        };\n        let cpi_program = ctx.accounts.token_program.to_account_info();\n        let cpi_ctx = CpiContext::new_with_signer(cpi_program, cpi_accounts, signer);\n        token::transfer(cpi_ctx, amount)?;\n\n        // Send rent back to user if account is empty\n        ctx.accounts.escrow_usdc.reload()?;\n        if ctx.accounts.escrow_usdc.amount == 0 {\n            let cpi_accounts = CloseAccount {\n                account: ctx.accounts.escrow_usdc.to_account_info(),\n                destination: ctx.accounts.user_authority.clone(),\n                authority: ctx.accounts.ido_account.to_account_info(),\n            };\n            let cpi_program = ctx.accounts.token_program.to_account_info();\n            let cpi_ctx = CpiContext::new_with_signer(cpi_program, cpi_accounts, signer);\n            token::close_account(cpi_ctx)?;\n        }\n\n        Ok(())\n    }",
    "pub fn init(ctx: Context<Init>) -> Result<()> {\n        let mut my_account = ctx.accounts.my_account.load_mut()?;\n        my_account.authority = ctx.accounts.authority.key();\n\n        for _ in 0..MAX_DATA_LEN {\n            my_account.dynamic.push(ctx.accounts.authority.key());\n        }\n\n        Ok(())\n    }",
    "pub fn read(ctx: Context<Read>) -> Result<()> {\n        // Cached load due to the `has_one` constraint\n        let authority = ctx.accounts.my_account.load_authority()?;\n        msg!(\"Authority: {}\", authority);\n        Ok(())\n    }",
    "pub fn write(ctx: Context<Write>, new_authority: Pubkey) -> Result<()> {\n        // Cached load due to the `has_one` constraint\n        *ctx.accounts.my_account.load_mut_authority()? = new_authority;\n        Ok(())\n    }",
    "pub fn available_for_withdrawal(vesting: &Vesting, current_ts: i64) -> u64 {\n    std::cmp::min(outstanding_vested(vesting, current_ts), balance(vesting))\n}",
    "pub fn new(ctx: Context<Auth>) -> Result<Self> {\n            let mut whitelist = vec![];\n            whitelist.resize(Self::WHITELIST_SIZE, Default::default());\n            Ok(Lockup {\n                authority: *ctx.accounts.authority.key,\n                whitelist,\n            })\n        }",
    "pub fn whitelist_add(&mut self, ctx: Context<Auth>, entry: WhitelistEntry) -> Result<()> {\n            if self.whitelist.len() == Self::WHITELIST_SIZE {\n                return err!(ErrorCode::WhitelistFull);\n            }\n            if self.whitelist.contains(&entry) {\n                return err!(ErrorCode::WhitelistEntryAlreadyExists);\n            }\n            self.whitelist.push(entry);\n            Ok(())\n        }",
    "pub fn whitelist_delete(\n            &mut self,\n            ctx: Context<Auth>,\n            entry: WhitelistEntry,\n        ) -> Result<()> {\n            if !self.whitelist.contains(&entry) {\n                return err!(ErrorCode::WhitelistEntryNotFound);\n            }\n            self.whitelist.retain(|e| e != &entry);\n            Ok(())\n        }",
    "pub fn set_authority(&mut self, ctx: Context<Auth>, new_authority: Pubkey) -> Result<()> {\n            self.authority = new_authority;\n            Ok(())\n        }",
    "pub fn create_vesting(\n        ctx: Context<CreateVesting>,\n        beneficiary: Pubkey,\n        deposit_amount: u64,\n        nonce: u8,\n        start_ts: i64,\n        end_ts: i64,\n        period_count: u64,\n        realizor: Option<Realizor>,\n    ) -> Result<()> {\n        if deposit_amount == 0 {\n            return err!(ErrorCode::InvalidDepositAmount);\n        }\n        if !is_valid_schedule(start_ts, end_ts, period_count) {\n            return err!(ErrorCode::InvalidSchedule);\n        }\n        let vesting = &mut ctx.accounts.vesting;\n        vesting.beneficiary = beneficiary;\n        vesting.mint = ctx.accounts.vault.mint;\n        vesting.vault = *ctx.accounts.vault.to_account_info().key;\n        vesting.period_count = period_count;\n        vesting.start_balance = deposit_amount;\n        vesting.end_ts = end_ts;\n        vesting.start_ts = start_ts;\n        vesting.created_ts = ctx.accounts.clock.unix_timestamp;\n        vesting.outstanding = deposit_amount;\n        vesting.whitelist_owned = 0;\n        vesting.grantor = *ctx.accounts.depositor_authority.key;\n        vesting.nonce = nonce;\n        vesting.realizor = realizor;\n\n        token::transfer(ctx.accounts.into(), deposit_amount)?;\n\n        Ok(())\n    }",
    "pub fn withdraw(ctx: Context<Withdraw>, amount: u64) -> Result<()> {\n        // Has the given amount vested?\n        if amount\n            > calculator::available_for_withdrawal(\n                &ctx.accounts.vesting,\n                ctx.accounts.clock.unix_timestamp,\n            )\n        {\n            return err!(ErrorCode::InsufficientWithdrawalBalance);\n        }\n\n        // Transfer funds out.\n        let seeds = &[\n            ctx.accounts.vesting.to_account_info().key.as_ref(),\n            &[ctx.accounts.vesting.nonce],\n        ];\n        let signer = &[&seeds[..]];\n        let cpi_ctx = CpiContext::from(&*ctx.accounts).with_signer(signer);\n        token::transfer(cpi_ctx, amount)?;\n\n        // Bookeeping.\n        let vesting = &mut ctx.accounts.vesting;\n        vesting.outstanding -= amount;\n\n        Ok(())\n    }",
    "pub fn available_for_withdrawal(ctx: Context<AvailableForWithdrawal>) -> Result<()> {\n        let available = calculator::available_for_withdrawal(\n            &ctx.accounts.vesting,\n            ctx.accounts.clock.unix_timestamp,\n        );\n        // Log as string so that JS can read as a BN.\n        msg!(&format!(\"{{ \\\"result\\\": \\\"{}\\\" }}\", available));\n        Ok(())\n    }",
    "pub fn is_valid_schedule(start_ts: i64, end_ts: i64, period_count: u64) -> bool {\n    if end_ts <= start_ts {\n        return false;\n    }\n    if period_count > (end_ts - start_ts) as u64 {\n        return false;\n    }\n    if period_count == 0 {\n        return false;\n    }\n    true\n}\n\n// Returns Ok if the locked vesting account has been \"realized\". Realization\n// is application dependent. For example, in the case of staking, one must first\n// unstake before being able to earn locked tokens.\nfn is_realized(ctx: &Context<Withdraw>) -> Result<()> {\n    if let Some(realizor) = &ctx.accounts.vesting.realizor {\n        let cpi_program = {\n            let p = ctx.remaining_accounts[0].clone();\n            if p.key != &realizor.program {\n                return err!(ErrorCode::InvalidLockRealizor);\n            }\n            p\n        };\n        let cpi_accounts = ctx.remaining_accounts.to_vec()[1..].to_vec();\n        let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);\n        let vesting = (*ctx.accounts.vesting).clone();\n        realize_lock::is_realized(cpi_ctx, vesting)\n            .map_err(|_| error!(ErrorCode::UnrealizedVesting))?;\n    }\n    Ok(())\n}",
    "pub fn new(ctx: Context<Ctor>) -> Result<Self> {\n            Ok(Registry {\n                lockup_program: *ctx.accounts.lockup_program.key,\n            })\n        }",
    "pub fn set_lockup_program(\n            &mut self,\n            ctx: Context<SetLockupProgram>,\n            lockup_program: Pubkey,\n        ) -> Result<()> {\n            // Hard code the authority because the first version of this program\n            // did not set an authority account in the global state.\n            //\n            // When removing the program's upgrade authority, one should remove\n            // this method first, redeploy, then remove the upgrade authority.\n            let expected: Pubkey = \"HUgFuN4PbvF5YzjDSw9dQ8uTJUcwm2ANsMXwvRdY4ABx\"\n                .parse()\n                .unwrap();\n            if ctx.accounts.authority.key != &expected {\n                return err!(ErrorCode::InvalidProgramAuthority);\n            }\n\n            self.lockup_program = lockup_program;\n\n            Ok(())\n        }",
    "pub fn initialize(\n        ctx: Context<Initialize>,\n        mint: Pubkey,\n        authority: Pubkey,\n        nonce: u8,\n        withdrawal_timelock: i64,\n        stake_rate: u64,\n        reward_q_len: u32,\n    ) -> Result<()> {\n        let registrar = &mut ctx.accounts.registrar;\n\n        registrar.authority = authority;\n        registrar.nonce = nonce;\n        registrar.mint = mint;\n        registrar.pool_mint = *ctx.accounts.pool_mint.to_account_info().key;\n        registrar.stake_rate = stake_rate;\n        registrar.reward_event_q = *ctx.accounts.reward_event_q.to_account_info().key;\n        registrar.withdrawal_timelock = withdrawal_timelock;\n\n        let reward_q = &mut ctx.accounts.reward_event_q;\n        reward_q\n            .events\n            .resize(reward_q_len as usize, Default::default());\n\n        Ok(())\n    }",
    "pub fn update_registrar(\n        ctx: Context<UpdateRegistrar>,\n        new_authority: Option<Pubkey>,\n        withdrawal_timelock: Option<i64>,\n    ) -> Result<()> {\n        let registrar = &mut ctx.accounts.registrar;\n\n        if let Some(new_authority) = new_authority {\n            registrar.authority = new_authority;\n        }\n\n        if let Some(withdrawal_timelock) = withdrawal_timelock {\n            registrar.withdrawal_timelock = withdrawal_timelock;\n        }\n\n        Ok(())\n    }",
    "pub fn create_member(ctx: Context<CreateMember>, nonce: u8) -> Result<()> {\n        let member = &mut ctx.accounts.member;\n        member.registrar = *ctx.accounts.registrar.to_account_info().key;\n        member.beneficiary = *ctx.accounts.beneficiary.key;\n        member.balances = (&ctx.accounts.balances).into();\n        member.balances_locked = (&ctx.accounts.balances_locked).into();\n        member.nonce = nonce;\n        Ok(())\n    }",
    "pub fn update_member(ctx: Context<UpdateMember>, metadata: Option<Pubkey>) -> Result<()> {\n        let member = &mut ctx.accounts.member;\n        if let Some(m) = metadata {\n            member.metadata = m;\n        }\n        Ok(())\n    }",
    "pub fn deposit(ctx: Context<Deposit>, amount: u64) -> Result<()> {\n        token::transfer(ctx.accounts.into(), amount).map_err(Into::into)\n    }",
    "pub fn deposit_locked(ctx: Context<DepositLocked>, amount: u64) -> Result<()> {\n        token::transfer(ctx.accounts.into(), amount).map_err(Into::into)\n    }",
    "pub fn stake(ctx: Context<Stake>, spt_amount: u64, locked: bool) -> Result<()> {\n        let balances = {\n            if locked {\n                &ctx.accounts.balances_locked\n            } else {\n                &ctx.accounts.balances\n            }\n        };\n\n        // Transfer tokens into the stake vault.\n        {\n            let seeds = &[\n                ctx.accounts.registrar.to_account_info().key.as_ref(),\n                ctx.accounts.member.to_account_info().key.as_ref(),\n                &[ctx.accounts.member.nonce],\n            ];\n            let member_signer = &[&seeds[..]];\n            let cpi_ctx = CpiContext::new_with_signer(\n                ctx.accounts.token_program.clone(),\n                token::Transfer {\n                    from: balances.vault.to_account_info(),\n                    to: balances.vault_stake.to_account_info(),\n                    authority: ctx.accounts.member_signer.to_account_info(),\n                },\n                member_signer,\n            );\n            // Convert from stake-token units to mint-token units.\n            let token_amount = spt_amount\n                .checked_mul(ctx.accounts.registrar.stake_rate)\n                .unwrap();\n            token::transfer(cpi_ctx, token_amount)?;\n        }\n\n        // Mint pool tokens to the staker.\n        {\n            let seeds = &[\n                ctx.accounts.registrar.to_account_info().key.as_ref(),\n                &[ctx.accounts.registrar.nonce],\n            ];\n            let registrar_signer = &[&seeds[..]];\n\n            let cpi_ctx = CpiContext::new_with_signer(\n                ctx.accounts.token_program.clone(),\n                token::MintTo {\n                    mint: ctx.accounts.pool_mint.to_account_info(),\n                    to: balances.spt.to_account_info(),\n                    authority: ctx.accounts.registrar_signer.to_account_info(),\n                },\n                registrar_signer,\n            );\n            token::mint_to(cpi_ctx, spt_amount)?;\n        }\n\n        // Update stake timestamp.\n        let member = &mut ctx.accounts.member;\n        member.last_stake_ts = ctx.accounts.clock.unix_timestamp;\n\n        Ok(())\n    }",
    "pub fn start_unstake(ctx: Context<StartUnstake>, spt_amount: u64, locked: bool) -> Result<()> {\n        let balances = {\n            if locked {\n                &ctx.accounts.balances_locked\n            } else {\n                &ctx.accounts.balances\n            }\n        };\n\n        // Program signer.\n        let seeds = &[\n            ctx.accounts.registrar.to_account_info().key.as_ref(),\n            ctx.accounts.member.to_account_info().key.as_ref(),\n            &[ctx.accounts.member.nonce],\n        ];\n        let member_signer = &[&seeds[..]];\n\n        // Burn pool tokens.\n        {\n            let cpi_ctx = CpiContext::new_with_signer(\n                ctx.accounts.token_program.clone(),\n                token::Burn {\n                    mint: ctx.accounts.pool_mint.to_account_info(),\n                    from: balances.spt.to_account_info(),\n                    authority: ctx.accounts.member_signer.to_account_info(),\n                },\n                member_signer,\n            );\n            token::burn(cpi_ctx, spt_amount)?;\n        }\n\n        // Convert from stake-token units to mint-token units.\n        let token_amount = spt_amount\n            .checked_mul(ctx.accounts.registrar.stake_rate)\n            .unwrap();\n\n        // Transfer tokens from the stake to pending vault.\n        {\n            let cpi_ctx = CpiContext::new_with_signer(\n                ctx.accounts.token_program.clone(),\n                token::Transfer {\n                    from: balances.vault_stake.to_account_info(),\n                    to: balances.vault_pw.to_account_info(),\n                    authority: ctx.accounts.member_signer.to_account_info(),\n                },\n                member_signer,\n            );\n            token::transfer(cpi_ctx, token_amount)?;\n        }\n\n        // Print receipt.\n        let pending_withdrawal = &mut ctx.accounts.pending_withdrawal;\n        pending_withdrawal.burned = false;\n        pending_withdrawal.member = *ctx.accounts.member.to_account_info().key;\n        pending_withdrawal.start_ts = ctx.accounts.clock.unix_timestamp;\n        pending_withdrawal.end_ts =\n            ctx.accounts.clock.unix_timestamp + ctx.accounts.registrar.withdrawal_timelock;\n        pending_withdrawal.amount = token_amount;\n        pending_withdrawal.pool = ctx.accounts.registrar.pool_mint;\n        pending_withdrawal.registrar = *ctx.accounts.registrar.to_account_info().key;\n        pending_withdrawal.locked = locked;\n\n        // Update stake timestamp.\n        let member = &mut ctx.accounts.member;\n        member.last_stake_ts = ctx.accounts.clock.unix_timestamp;\n\n        Ok(())\n    }",
    "pub fn end_unstake(ctx: Context<EndUnstake>) -> Result<()> {\n        if ctx.accounts.pending_withdrawal.end_ts > ctx.accounts.clock.unix_timestamp {\n            return err!(ErrorCode::UnstakeTimelock);\n        }\n\n        // Select which balance set this affects.\n        let balances = {\n            if ctx.accounts.pending_withdrawal.locked {\n                &ctx.accounts.member.balances_locked\n            } else {\n                &ctx.accounts.member.balances\n            }\n        };\n        // Check the vaults given are correct.\n        if &balances.vault != ctx.accounts.vault.key {\n            return err!(ErrorCode::InvalidVault);\n        }\n        if &balances.vault_pw != ctx.accounts.vault_pw.key {\n            return err!(ErrorCode::InvalidVault);\n        }\n\n        // Transfer tokens between vaults.\n        {\n            let seeds = &[\n                ctx.accounts.registrar.to_account_info().key.as_ref(),\n                ctx.accounts.member.to_account_info().key.as_ref(),\n                &[ctx.accounts.member.nonce],\n            ];\n            let signer = &[&seeds[..]];\n            let cpi_ctx = CpiContext::new_with_signer(\n                ctx.accounts.token_program.clone(),\n                Transfer {\n                    from: ctx.accounts.vault_pw.to_account_info(),\n                    to: ctx.accounts.vault.to_account_info(),\n                    authority: ctx.accounts.member_signer.clone(),\n                },\n                signer,\n            );\n            token::transfer(cpi_ctx, ctx.accounts.pending_withdrawal.amount)?;\n        }\n\n        // Burn the pending withdrawal receipt.\n        let pending_withdrawal = &mut ctx.accounts.pending_withdrawal;\n        pending_withdrawal.burned = true;\n\n        Ok(())\n    }",
    "pub fn withdraw(ctx: Context<Withdraw>, amount: u64) -> Result<()> {\n        let seeds = &[\n            ctx.accounts.registrar.to_account_info().key.as_ref(),\n            ctx.accounts.member.to_account_info().key.as_ref(),\n            &[ctx.accounts.member.nonce],\n        ];\n        let signer = &[&seeds[..]];\n        let cpi_accounts = Transfer {\n            from: ctx.accounts.vault.to_account_info(),\n            to: ctx.accounts.depositor.to_account_info(),\n            authority: ctx.accounts.member_signer.clone(),\n        };\n        let cpi_program = ctx.accounts.token_program.clone();\n        let cpi_ctx = CpiContext::new_with_signer(cpi_program, cpi_accounts, signer);\n\n        token::transfer(cpi_ctx, amount).map_err(Into::into)\n    }",
    "pub fn withdraw_locked(ctx: Context<WithdrawLocked>, amount: u64) -> Result<()> {\n        let seeds = &[\n            ctx.accounts.registrar.to_account_info().key.as_ref(),\n            ctx.accounts.member.to_account_info().key.as_ref(),\n            &[ctx.accounts.member.nonce],\n        ];\n        let signer = &[&seeds[..]];\n        let cpi_accounts = Transfer {\n            from: ctx.accounts.member_vault.to_account_info(),\n            to: ctx.accounts.vesting_vault.to_account_info(),\n            authority: ctx.accounts.member_signer.clone(),\n        };\n        let cpi_program = ctx.accounts.token_program.clone();\n        let cpi_ctx = CpiContext::new_with_signer(cpi_program, cpi_accounts, signer);\n\n        token::transfer(cpi_ctx, amount).map_err(Into::into)\n    }",
    "pub fn drop_reward(\n        ctx: Context<DropReward>,\n        kind: RewardVendorKind,\n        total: u64,\n        expiry_ts: i64,\n        expiry_receiver: Pubkey,\n        nonce: u8,\n    ) -> Result<()> {\n        if total < ctx.accounts.pool_mint.supply {\n            return err!(ErrorCode::InsufficientReward);\n        }\n        if ctx.accounts.clock.unix_timestamp >= expiry_ts {\n            return err!(ErrorCode::InvalidExpiry);\n        }\n        if let RewardVendorKind::Locked {\n            start_ts,\n            end_ts,\n            period_count,\n        } = kind\n        {\n            if !lockup::is_valid_schedule(start_ts, end_ts, period_count) {\n                return err!(ErrorCode::InvalidVestingSchedule);\n            }\n        }\n\n        // Transfer funds into the vendor's vault.\n        token::transfer(ctx.accounts.into(), total)?;\n\n        // Add the event to the reward queue.\n        let reward_q = &mut ctx.accounts.reward_event_q;\n        let cursor = reward_q.append(RewardEvent {\n            vendor: *ctx.accounts.vendor.to_account_info().key,\n            ts: ctx.accounts.clock.unix_timestamp,\n            locked: kind != RewardVendorKind::Unlocked,\n        })?;\n\n        // Initialize the vendor.\n        let vendor = &mut ctx.accounts.vendor;\n        vendor.registrar = *ctx.accounts.registrar.to_account_info().key;\n        vendor.vault = *ctx.accounts.vendor_vault.to_account_info().key;\n        vendor.mint = ctx.accounts.vendor_vault.mint;\n        vendor.nonce = nonce;\n        vendor.pool_token_supply = ctx.accounts.pool_mint.supply;\n        vendor.reward_event_q_cursor = cursor;\n        vendor.start_ts = ctx.accounts.clock.unix_timestamp;\n        vendor.expiry_ts = expiry_ts;\n        vendor.expiry_receiver = expiry_receiver;\n        vendor.from = *ctx.accounts.depositor_authority.key;\n        vendor.total = total;\n        vendor.expired = false;\n        vendor.kind = kind;\n\n        Ok(())\n    }",
    "pub fn claim_reward(ctx: Context<ClaimReward>) -> Result<()> {\n        if RewardVendorKind::Unlocked != ctx.accounts.cmn.vendor.kind {\n            return err!(ErrorCode::ExpectedUnlockedVendor);\n        }\n        // Reward distribution.\n        let spt_total =\n            ctx.accounts.cmn.balances.spt.amount + ctx.accounts.cmn.balances_locked.spt.amount;\n        let reward_amount = spt_total\n            .checked_mul(ctx.accounts.cmn.vendor.total)\n            .unwrap()\n            .checked_div(ctx.accounts.cmn.vendor.pool_token_supply)\n            .unwrap();\n        assert!(reward_amount > 0);\n\n        // Send reward to the given token account.\n        let seeds = &[\n            ctx.accounts.cmn.registrar.to_account_info().key.as_ref(),\n            ctx.accounts.cmn.vendor.to_account_info().key.as_ref(),\n            &[ctx.accounts.cmn.vendor.nonce],\n        ];\n        let signer = &[&seeds[..]];\n        let cpi_ctx = CpiContext::new_with_signer(\n            ctx.accounts.cmn.token_program.clone(),\n            token::Transfer {\n                from: ctx.accounts.cmn.vault.to_account_info(),\n                to: ctx.accounts.to.to_account_info(),\n                authority: ctx.accounts.cmn.vendor_signer.to_account_info(),\n            },\n            signer,\n        );\n        token::transfer(cpi_ctx, reward_amount)?;\n\n        // Update member as having processed the reward.\n        let member = &mut ctx.accounts.cmn.member;\n        member.rewards_cursor = ctx.accounts.cmn.vendor.reward_event_q_cursor + 1;\n\n        Ok(())\n    }",
    "pub fn expire_reward(ctx: Context<ExpireReward>) -> Result<()> {\n        if ctx.accounts.clock.unix_timestamp < ctx.accounts.vendor.expiry_ts {\n            return err!(ErrorCode::VendorNotYetExpired);\n        }\n\n        // Send all remaining funds to the expiry receiver's token.\n        let seeds = &[\n            ctx.accounts.registrar.to_account_info().key.as_ref(),\n            ctx.accounts.vendor.to_account_info().key.as_ref(),\n            &[ctx.accounts.vendor.nonce],\n        ];\n        let signer = &[&seeds[..]];\n        let cpi_ctx = CpiContext::new_with_signer(\n            ctx.accounts.token_program.clone(),\n            token::Transfer {\n                to: ctx.accounts.expiry_receiver_token.to_account_info(),\n                from: ctx.accounts.vault.to_account_info(),\n                authority: ctx.accounts.vendor_signer.to_account_info(),\n            },\n            signer,\n        );\n        token::transfer(cpi_ctx, ctx.accounts.vault.amount)?;\n\n        // Burn the vendor.\n        let vendor = &mut ctx.accounts.vendor;\n        vendor.expired = true;\n\n        Ok(())\n    }",
    "pub fn append(&mut self, event: RewardEvent) -> Result<u32> {\n        let cursor = self.head;\n\n        // Insert into next available slot.\n        let h_idx = self.index_of(self.head);\n        self.events[h_idx] = event;\n\n        // Update head and tail counters.\n        let is_full = self.index_of(self.head + 1) == self.index_of(self.tail);\n        if is_full {\n            self.tail += 1;\n        }\n        self.head += 1;\n\n        Ok(cursor)\n    }",
    "pub fn index_of(&self, counter: u32) -> usize {\n        counter as usize % self.capacity()\n    }",
    "pub fn capacity(&self) -> usize {\n        self.events.len()\n    }",
    "pub fn get(&self, cursor: u32) -> &RewardEvent {\n        &self.events[cursor as usize % self.capacity()]\n    }\n\n    pub fn head(&self) -> u32 {\n        self.head\n    }\n\n    pub fn tail(&self) -> u32 {\n        self.tail\n    }\n}\n\n#[derive(Default, Clone, Copy, Debug, AnchorSerialize, AnchorDeserialize)]\npub struct RewardEvent {\n    vendor: Pubkey,\n    ts: i64,\n    locked: bool,\n}\n\n#[account]\npub struct RewardVendor {\n    pub registrar: Pubkey,\n    pub vault: Pubkey,\n    pub mint: Pubkey,\n    pub nonce: u8,\n    pub pool_token_supply: u64,\n    pub reward_event_q_cursor: u32,\n    pub start_ts: i64,\n    pub expiry_ts: i64,\n    pub expiry_receiver: Pubkey,\n    pub from: Pubkey,\n    pub total: u64,\n    pub expired: bool,\n    pub kind: RewardVendorKind,\n}\n\n#[derive(AnchorSerialize, AnchorDeserialize, Clone, PartialEq)]\npub enum RewardVendorKind {\n    Unlocked,\n    Locked {\n        start_ts: i64,\n        end_ts: i64,\n        period_count: u64,\n    },\n}\n\n#[error_code]\npub enum ErrorCode {\n    #[msg(\"The given reward queue has already been initialized.\")]\n    RewardQAlreadyInitialized,\n    #[msg(\"The nonce given doesn't derive a valid program address.\")]\n    InvalidNonce,\n    #[msg(\"Invalid pool mint authority\")]\n    InvalidPoolMintAuthority,\n    #[msg(\"Member signer doesn't match the derived address.\")]\n    InvalidMemberSigner,\n    #[msg(\"The given vault owner must match the signing depositor.\")]\n    InvalidVaultDeposit,\n    #[msg(\"The signing depositor doesn't match either of the balance accounts\")]\n    InvalidDepositor,\n    #[msg(\"The vault given does not match the vault expected.\")]\n    InvalidVault,\n    #[msg(\"Invalid vault owner.\")]\n    InvalidVaultOwner,\n    #[msg(\"An unknown error has occurred.\")]\n    Unknown,\n    #[msg(\"The unstake timelock has not yet expired.\")]\n    UnstakeTimelock,\n    #[msg(\"Reward vendors must have at least one token unit per pool token\")]\n    InsufficientReward,\n    #[msg(\"Reward expiry must be after the current clock timestamp.\")]\n    InvalidExpiry,\n    #[msg(\"The reward vendor has been expired.\")]\n    VendorExpired,\n    #[msg(\"This reward has already been processed.\")]\n    CursorAlreadyProcessed,\n    #[msg(\"The account was not staked at the time of this reward.\")]\n    NotStakedDuringDrop,\n    #[msg(\"The vendor is not yet eligible for expiry.\")]\n    VendorNotYetExpired,\n    #[msg(\"Please collect your reward before otherwise using the program.\")]\n    RewardsNeedsProcessing,\n    #[msg(\"Locked reward vendor expected but an unlocked vendor was given.\")]\n    ExpectedLockedVendor,\n    #[msg(\"Unlocked reward vendor expected but a locked vendor was given.\")]\n    ExpectedUnlockedVendor,\n    #[msg(\"Locked deposit from an invalid deposit authority.\")]\n    InvalidVestingSigner,\n    #[msg(\"Locked rewards cannot be realized until one unstaked all tokens.\")]\n    UnrealizedReward,\n    #[msg(\"The beneficiary doesn't match.\")]\n    InvalidBeneficiary,\n    #[msg(\"The given member account does not match the realizor metadata.\")]\n    InvalidRealizorMetadata,\n    #[msg(\"Invalid vesting schedule for the locked reward.\")]\n    InvalidVestingSchedule,\n    #[msg(\"Please specify the correct authority for this program.\")]\n    InvalidProgramAuthority,\n}\n\nimpl<'a, 'b, 'c, 'info> From<&mut Deposit<'info>>\n    for CpiContext<'a, 'b, 'c, 'info, Transfer<'info>>\n{\n    fn from(accounts: &mut Deposit<'info>) -> CpiContext<'a, 'b, 'c, 'info, Transfer<'info>> {\n        let cpi_accounts = Transfer {\n            from: accounts.depositor.clone(),\n            to: accounts.vault.to_account_info(),\n            authority: accounts.depositor_authority.clone(),\n        };\n        let cpi_program = accounts.token_program.clone();\n        CpiContext::new(cpi_program, cpi_accounts)\n    }",
    "pub fn initialize(ctx: Context<Initialize>, _val: u8) -> Result<()> {\n        ctx.accounts.acc.val = 1000;\n        Ok(())\n    }",
    "pub fn second_initialize(ctx: Context<SecondInitialize>, _val: u8) -> Result<()> {\n        ctx.accounts.acc.other_val = 2000;\n        Ok(())\n    }",
    "pub fn close(ctx: Context<Close>) -> Result<()> {\n        ctx.accounts.acc.val = 5000;\n        Ok(())\n    }",
    "pub fn transfer(ctx: Context<Transfer>, amount: u64) -> Result<()> {\n        let pda = &ctx.accounts.pda;\n        let signer = &ctx.accounts.signer;\n\n        // Transfer **to** PDA\n        {\n            // Get the balance of the PDA **before** the transfer to PDA\n            let pda_balance_before = pda.get_lamports();\n\n            // Transfer to the PDA\n            anchor_lang::system_program::transfer(\n                CpiContext::new(\n                    ctx.accounts.system_program.to_account_info(),\n                    anchor_lang::system_program::Transfer {\n                        from: signer.to_account_info(),\n                        to: pda.to_account_info(),\n                    },\n                ),\n                amount,\n            )?;\n\n            // Get the balance of the PDA **after** the transfer to PDA\n            let pda_balance_after = pda.get_lamports();\n\n            // Validate balance\n            require_eq!(pda_balance_after, pda_balance_before + amount);\n        }\n\n        // Transfer **from** PDA\n        {\n            // Get the balance of the PDA **before** the transfer from PDA\n            let pda_balance_before = pda.get_lamports();\n\n            // Transfer from the PDA\n            pda.sub_lamports(amount)?;\n            signer.add_lamports(amount)?;\n\n            // Get the balance of the PDA **after** the transfer from PDA\n            let pda_balance_after = pda.get_lamports();\n\n            // Validate balance\n            require_eq!(pda_balance_after, pda_balance_before - amount);\n        }\n\n        Ok(())\n    }",
    "pub fn overflow(ctx: Context<Overflow>) -> Result<()> {\n        let pda = &ctx.accounts.pda;\n\n        match pda.add_lamports(u64::MAX) {\n            Err(e) => assert_eq!(e, ProgramError::ArithmeticOverflow.into()),\n            _ => unreachable!(),\n        }\n\n        match pda.sub_lamports(u64::MAX) {\n            Err(e) => assert_eq!(e, ProgramError::ArithmeticOverflow.into()),\n            _ => unreachable!(),\n        }\n\n        Ok(())\n    }",
    "pub fn initialize(ctx: Context<Initialize>, udata: u128, idata: i128) -> Result<()> {\n        ctx.accounts.data.udata = udata;\n        ctx.accounts.data.idata = idata;\n        Ok(())\n    }",
    "pub fn initialize_no_rent_exempt(_ctx: Context<InitializeNoRentExempt>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn initialize_skip_rent_exempt(_ctx: Context<InitializeSkipRentExempt>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_owner(_ctx: Context<TestOwner>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_executable(_ctx: Context<TestExecutable>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_simulate(_ctx: Context<TestSimulate>, data: u32) -> Result<()> {\n        emit!(E1 { data });\n        emit!(E2 { data: 1234 });\n        emit!(E3 { data: 9 });\n        emit!(E5 {\n            data: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n        });\n        emit!(E6 {\n            data: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\n        });\n        Ok(())\n    }",
    "pub fn test_const_array_size(ctx: Context<TestConstArraySize>, data: u8) -> Result<()> {\n        ctx.accounts.data.data[0] = data;\n        Ok(())\n    }",
    "pub fn test_const_ix_data_size(\n        ctx: Context<TestConstIxDataSize>,\n        data: [u8; MAX_SIZE],\n    ) -> Result<()> {\n        ctx.accounts.data.data = data;\n        Ok(())\n    }",
    "pub fn test_close(_ctx: Context<TestClose>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_close_twice(ctx: Context<TestCloseTwice>) -> Result<()> {\n        let data_account = &ctx.accounts.data;\n        let sol_dest_info = ctx.accounts.sol_dest.to_account_info();\n        data_account.close(sol_dest_info)?;\n        let data_account_info: &AccountInfo = data_account.as_ref();\n        require_keys_eq!(*data_account_info.owner, System::id());\n        Ok(())\n    }",
    "pub fn test_close_mut(ctx: Context<TestCloseMut>) -> Result<()> {\n        let data_account = &ctx.accounts.data;\n        let sol_dest_info = ctx.accounts.sol_dest.to_account_info();\n        data_account.close(sol_dest_info)?;\n        let data_account_info: &AccountInfo = data_account.as_ref();\n        require_keys_eq!(*data_account_info.owner, System::id());\n        Ok(())\n    }",
    "pub fn test_instruction_constraint(\n        _ctx: Context<TestInstructionConstraint>,\n        _nonce: u8,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_pda_init(\n        ctx: Context<TestPdaInit>,\n        _domain: String,\n        _seed: Vec<u8>,\n        _bump: u8,\n    ) -> Result<()> {\n        ctx.accounts.my_pda.data = 6;\n        Ok(())\n    }",
    "pub fn test_pda_init_zero_copy(ctx: Context<TestPdaInitZeroCopy>) -> Result<()> {\n        let mut acc = ctx.accounts.my_pda.load_init()?;\n        acc.data = 9;\n        acc.bump = ctx.bumps.my_pda;\n        Ok(())\n    }",
    "pub fn test_pda_mut_zero_copy(ctx: Context<TestPdaMutZeroCopy>) -> Result<()> {\n        let mut acc = ctx.accounts.my_pda.load_mut()?;\n        acc.data = 1234;\n        Ok(())\n    }",
    "pub fn test_token_seeds_init(_ctx: Context<TestTokenSeedsInit>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_init(ctx: Context<TestInit>) -> Result<()> {\n        ctx.accounts.data.data = 3;\n        Ok(())\n    }",
    "pub fn test_init_zero_copy(ctx: Context<TestInitZeroCopy>) -> Result<()> {\n        let mut data = ctx.accounts.data.load_init()?;\n        data.data = 10;\n        data.bump = 2;\n        Ok(())\n    }",
    "pub fn test_init_mint(ctx: Context<TestInitMint>) -> Result<()> {\n        assert!(ctx.accounts.mint.decimals == 6);\n        Ok(())\n    }",
    "pub fn test_init_mint_with_token_program(\n        _ctx: Context<TestInitMintWithTokenProgram>,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_init_token(ctx: Context<TestInitToken>) -> Result<()> {\n        assert!(ctx.accounts.token.mint == ctx.accounts.mint.key());\n        Ok(())\n    }",
    "pub fn test_init_token_with_token_program(\n        _ctx: Context<TestInitTokenWithTokenProgram>,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_composite_payer(ctx: Context<TestCompositePayer>) -> Result<()> {\n        ctx.accounts.composite.data.data = 1;\n        ctx.accounts.data.udata = 2;\n        ctx.accounts.data.idata = 3;\n        Ok(())\n    }",
    "pub fn test_init_associated_token(ctx: Context<TestInitAssociatedToken>) -> Result<()> {\n        assert!(ctx.accounts.token.mint == ctx.accounts.mint.key());\n        Ok(())\n    }",
    "pub fn test_init_associated_token_with_token_program(\n        _ctx: Context<TestInitAssociatedTokenWithTokenProgram>,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_validate_associated_token(\n        _ctx: Context<TestValidateAssociatedToken>,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_fetch_all(ctx: Context<TestFetchAll>, filterable: Pubkey) -> Result<()> {\n        ctx.accounts.data.authority = ctx.accounts.authority.key();\n        ctx.accounts.data.filterable = filterable;\n        Ok(())\n    }",
    "pub fn test_init_with_empty_seeds(_ctx: Context<TestInitWithEmptySeeds>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_empty_seeds_constraint(_ctx: Context<TestEmptySeedsConstraint>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_init_if_needed(ctx: Context<TestInitIfNeeded>, data: u16) -> Result<()> {\n        ctx.accounts.data.data = data;\n        Ok(())\n    }",
    "pub fn test_init_if_needed_checks_owner(\n        _ctx: Context<TestInitIfNeededChecksOwner>,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_init_if_needed_checks_seeds(\n        _ctx: Context<TestInitIfNeededChecksSeeds>,\n        _seed_data: String,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_init_mint_if_needed(\n        _ctx: Context<TestInitMintIfNeeded>,\n        _decimals: u8,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_init_mint_if_needed_with_token_program(\n        _ctx: Context<TestInitMintIfNeededWithTokenProgram>,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_init_token_if_needed(_ctx: Context<TestInitTokenIfNeeded>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_init_token_if_needed_with_token_program(\n        _ctx: Context<TestInitTokenIfNeededWithTokenProgram>,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_init_associated_token_if_needed(\n        _ctx: Context<TestInitAssociatedTokenIfNeeded>,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_init_associated_token_if_needed_with_token_program(\n        _ctx: Context<TestInitAssociatedTokenIfNeededWithTokenProgram>,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn init_with_space(_ctx: Context<InitWithSpace>, _data: u16) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_multidimensional_array(\n        ctx: Context<TestMultidimensionalArray>,\n        data: [[u8; 10]; 10],\n    ) -> Result<()> {\n        ctx.accounts.data.data = data;\n        Ok(())\n    }",
    "pub fn test_multidimensional_array_const_sizes(\n        ctx: Context<TestMultidimensionalArrayConstSizes>,\n        data: [[u8; 11]; 10],\n    ) -> Result<()> {\n        ctx.accounts.data.data = data;\n        Ok(())\n    }",
    "pub fn test_no_rent_exempt(_ctx: Context<NoRentExempt>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_enforce_rent_exempt(_ctx: Context<EnforceRentExempt>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn init_decrease_lamports(ctx: Context<InitDecreaseLamports>) -> Result<()> {\n        **ctx.accounts.data.try_borrow_mut_lamports()? -= 1;\n        **ctx.accounts.user.try_borrow_mut_lamports()? += 1;\n        Ok(())\n    }",
    "pub fn init_if_needed_checks_rent_exemption(\n        _ctx: Context<InitIfNeededChecksRentExemption>,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_program_id_constraint(\n        _ctx: Context<TestProgramIdConstraint>,\n        _bump: u8,\n        _second_bump: u8,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_program_id_constraint_find_pda(\n        _ctx: Context<TestProgramIdConstraintUsingFindPda>,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_token_constraint(_ctx: Context<TestConstraintToken>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_token_auth_constraint(_ctx: Context<TestAuthorityConstraint>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_only_auth_constraint(_ctx: Context<TestOnlyAuthorityConstraint>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_only_mint_constraint(_ctx: Context<TestOnlyMintConstraint>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_only_token_program_constraint(\n        _ctx: Context<TestOnlyTokenProgramConstraint>,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_mint_constraint(_ctx: Context<TestMintConstraint>, _decimals: u8) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_mint_only_decimals_constraint(\n        _ctx: Context<TestMintOnlyDecimalsConstraint>,\n        _decimals: u8,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_mint_only_auth_constraint(\n        _ctx: Context<TestMintAuthorityConstraint>,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_mint_only_one_auth_constraint(\n        _ctx: Context<TestMintOneAuthorityConstraint>,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_mint_miss_mint_auth_constraint(\n        _ctx: Context<TestMintMissMintAuthConstraint>,\n        _decimals: u8,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_mint_only_token_program_constraint(\n        _ctx: Context<TestMintOnlyTokenProgramConstraint>,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_associated_constraint(_ctx: Context<TestAssociatedToken>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_associated_token_with_token_program_constraint(\n        _ctx: Context<TestAssociatedTokenWithTokenProgramConstraint>,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_used_identifiers(\n        _ctx: Context<TestUsedIdentifiers>,\n        program_id: u8,\n        accounts: u8,\n        ix_data: u8,\n        remaining_accounts: u8,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_init_many_associated_token_accounts(\n        _ctx: Context<InitManyAssociatedTokenAccounts>,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_boxed_owner_constraint(_ctx: Context<TestBoxedOwnerConstraint>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn only_my_feature(_ctx: Context<Empty>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_multiple_zero_constraint(_ctx: Context<TestMultipleZeroConstraint>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_init_and_zero(_ctx: Context<TestInitAndZero>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn initialize(ctx: Context<Initialize>, udata: u128, idata: i128) -> Result<()> {\n        ctx.accounts.data.as_mut().unwrap().udata = udata;\n        ctx.accounts.data.as_mut().unwrap().idata = idata;\n        Ok(())\n    }",
    "pub fn initialize_no_rent_exempt(_ctx: Context<InitializeNoRentExempt>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn initialize_skip_rent_exempt(_ctx: Context<InitializeSkipRentExempt>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_owner(_ctx: Context<TestOwner>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_executable(_ctx: Context<TestExecutable>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_simulate(_ctx: Context<TestSimulate>, data: u32) -> Result<()> {\n        emit!(E1 { data });\n        emit!(E2 { data: 1234 });\n        emit!(E3 { data: 9 });\n        emit!(E5 {\n            data: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n        });\n        emit!(E6 {\n            data: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\n        });\n        Ok(())\n    }",
    "pub fn test_const_array_size(ctx: Context<TestConstArraySize>, data: u8) -> Result<()> {\n        ctx.accounts.data.as_mut().unwrap().data[0] = data;\n        Ok(())\n    }",
    "pub fn test_const_ix_data_size(\n        ctx: Context<TestConstIxDataSize>,\n        data: [u8; MAX_SIZE],\n    ) -> Result<()> {\n        ctx.accounts.data.as_mut().unwrap().data = data;\n        Ok(())\n    }",
    "pub fn test_close(_ctx: Context<TestClose>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_close_twice(ctx: Context<TestCloseTwice>) -> Result<()> {\n        let data_account = &ctx.accounts.data.as_ref().unwrap();\n        let sol_dest_info = ctx.accounts.sol_dest.as_ref().unwrap().to_account_info();\n        data_account.close(sol_dest_info)?;\n        let data_account_info: &AccountInfo = data_account.as_ref();\n        require_keys_eq!(*data_account_info.owner, System::id());\n        Ok(())\n    }",
    "pub fn test_close_mut(ctx: Context<TestCloseMut>) -> Result<()> {\n        let data_account = &ctx.accounts.data.as_ref().unwrap();\n        let sol_dest_info = ctx.accounts.sol_dest.as_ref().unwrap().to_account_info();\n        data_account.close(sol_dest_info)?;\n        let data_account_info: &AccountInfo = data_account.as_ref();\n        require_keys_eq!(*data_account_info.owner, System::id());\n        Ok(())\n    }",
    "pub fn test_instruction_constraint(\n        _ctx: Context<TestInstructionConstraint>,\n        _nonce: u8,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_pda_init(\n        ctx: Context<TestPdaInit>,\n        _domain: String,\n        _seed: Vec<u8>,\n        _bump: u8,\n    ) -> Result<()> {\n        ctx.accounts.my_pda.as_mut().unwrap().data = 6;\n        Ok(())\n    }",
    "pub fn test_pda_init_zero_copy(ctx: Context<TestPdaInitZeroCopy>) -> Result<()> {\n        let mut acc = ctx.accounts.my_pda.as_ref().unwrap().load_init()?;\n        acc.data = 9;\n        acc.bump = ctx.bumps.my_pda.unwrap();\n        Ok(())\n    }",
    "pub fn test_pda_mut_zero_copy(ctx: Context<TestPdaMutZeroCopy>) -> Result<()> {\n        let mut acc = ctx.accounts.my_pda.as_mut().unwrap().load_mut()?;\n        acc.data = 1234;\n        Ok(())\n    }",
    "pub fn test_token_seeds_init(_ctx: Context<TestTokenSeedsInit>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_init(ctx: Context<TestInit>) -> Result<()> {\n        ctx.accounts.data.as_mut().unwrap().data = 3;\n        Ok(())\n    }",
    "pub fn test_init_zero_copy(ctx: Context<TestInitZeroCopy>) -> Result<()> {\n        let mut data = ctx.accounts.data.as_ref().unwrap().load_init()?;\n        data.data = 10;\n        data.bump = 2;\n        Ok(())\n    }",
    "pub fn test_init_mint(ctx: Context<TestInitMint>) -> Result<()> {\n        assert!(ctx.accounts.mint.as_ref().unwrap().decimals == 6);\n        Ok(())\n    }",
    "pub fn test_init_mint_with_token_program(\n        _ctx: Context<TestInitMintWithTokenProgram>,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_init_token(ctx: Context<TestInitToken>) -> Result<()> {\n        assert!(\n            ctx.accounts.token.as_ref().unwrap().mint == ctx.accounts.mint.as_ref().unwrap().key()\n        );\n        Ok(())\n    }",
    "pub fn test_init_token_with_token_program(\n        _ctx: Context<TestInitTokenWithTokenProgram>,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_composite_payer(ctx: Context<TestCompositePayer>) -> Result<()> {\n        ctx.accounts.composite.data.as_mut().unwrap().data = 1;\n        ctx.accounts.data.as_mut().unwrap().udata = 2;\n        ctx.accounts.data.as_mut().unwrap().idata = 3;\n        Ok(())\n    }",
    "pub fn test_init_associated_token(ctx: Context<TestInitAssociatedToken>) -> Result<()> {\n        assert!(\n            ctx.accounts.token.as_ref().unwrap().mint == ctx.accounts.mint.as_ref().unwrap().key()\n        );\n        Ok(())\n    }",
    "pub fn test_init_associated_token_with_token_program(\n        _ctx: Context<TestInitAssociatedTokenWithTokenProgram>,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_validate_associated_token(\n        _ctx: Context<TestValidateAssociatedToken>,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_fetch_all(ctx: Context<TestFetchAll>, filterable: Pubkey) -> Result<()> {\n        ctx.accounts.data.as_mut().unwrap().authority =\n            ctx.accounts.authority.as_ref().unwrap().key();\n        ctx.accounts.data.as_mut().unwrap().filterable = filterable;\n        Ok(())\n    }",
    "pub fn test_init_with_empty_seeds(_ctx: Context<TestInitWithEmptySeeds>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_empty_seeds_constraint(_ctx: Context<TestEmptySeedsConstraint>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_init_if_needed(ctx: Context<TestInitIfNeeded>, data: u16) -> Result<()> {\n        ctx.accounts.data.as_mut().unwrap().data = data;\n        Ok(())\n    }",
    "pub fn test_init_if_needed_checks_owner(\n        _ctx: Context<TestInitIfNeededChecksOwner>,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_init_if_needed_checks_seeds(\n        _ctx: Context<TestInitIfNeededChecksSeeds>,\n        _seed_data: String,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_init_mint_if_needed(\n        _ctx: Context<TestInitMintIfNeeded>,\n        _decimals: u8,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_init_mint_if_needed_with_token_program(\n        _ctx: Context<TestInitMintIfNeededWithTokenProgram>,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_init_token_if_needed(_ctx: Context<TestInitTokenIfNeeded>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_init_token_if_needed_with_token_program(\n        _ctx: Context<TestInitTokenIfNeededWithTokenProgram>,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_init_associated_token_if_needed(\n        _ctx: Context<TestInitAssociatedTokenIfNeeded>,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_init_associated_token_if_needed_with_token_program(\n        _ctx: Context<TestInitAssociatedTokenIfNeededWithTokenProgram>,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn init_with_space(_ctx: Context<InitWithSpace>, _data: u16) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_multidimensional_array(\n        ctx: Context<TestMultidimensionalArray>,\n        data: [[u8; 10]; 10],\n    ) -> Result<()> {\n        ctx.accounts.data.as_mut().unwrap().data = data;\n        Ok(())\n    }",
    "pub fn test_multidimensional_array_const_sizes(\n        ctx: Context<TestMultidimensionalArrayConstSizes>,\n        data: [[u8; 11]; 10],\n    ) -> Result<()> {\n        ctx.accounts.data.as_mut().unwrap().data = data;\n        Ok(())\n    }",
    "pub fn test_no_rent_exempt(_ctx: Context<NoRentExempt>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_enforce_rent_exempt(_ctx: Context<EnforceRentExempt>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn init_decrease_lamports(ctx: Context<InitDecreaseLamports>) -> Result<()> {\n        **ctx\n            .accounts\n            .data\n            .as_mut()\n            .unwrap()\n            .try_borrow_mut_lamports()? -= 1;\n        **ctx\n            .accounts\n            .user\n            .as_mut()\n            .unwrap()\n            .try_borrow_mut_lamports()? += 1;\n        Ok(())\n    }",
    "pub fn init_if_needed_checks_rent_exemption(\n        _ctx: Context<InitIfNeededChecksRentExemption>,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_program_id_constraint(\n        _ctx: Context<TestProgramIdConstraint>,\n        _bump: u8,\n        _second_bump: u8,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_program_id_constraint_find_pda(\n        _ctx: Context<TestProgramIdConstraintUsingFindPda>,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_token_constraint(_ctx: Context<TestConstraintToken>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_token_auth_constraint(_ctx: Context<TestAuthorityConstraint>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_only_auth_constraint(_ctx: Context<TestOnlyAuthorityConstraint>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_only_mint_constraint(_ctx: Context<TestOnlyMintConstraint>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_only_token_program_constraint(\n        _ctx: Context<TestOnlyTokenProgramConstraint>,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_mint_constraint(_ctx: Context<TestMintConstraint>, _decimals: u8) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_mint_only_decimals_constraint(\n        _ctx: Context<TestMintOnlyDecimalsConstraint>,\n        _decimals: u8,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_mint_only_auth_constraint(\n        _ctx: Context<TestMintAuthorityConstraint>,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_mint_only_one_auth_constraint(\n        _ctx: Context<TestMintOneAuthorityConstraint>,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_mint_miss_mint_auth_constraint(\n        _ctx: Context<TestMintMissMintAuthConstraint>,\n        _decimals: u8,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_mint_only_token_program_constraint(\n        _ctx: Context<TestMintOnlyTokenProgramConstraint>,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_associated_constraint(_ctx: Context<TestAssociatedToken>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_associated_token_with_token_program_constraint(\n        _ctx: Context<TestAssociatedTokenWithTokenProgramConstraint>,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_init_many_associated_token_accounts(\n        _ctx: Context<InitManyAssociatedTokenAccounts>,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_multiple_zero_constraint(_ctx: Context<TestMultipleZeroConstraint>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_init_and_zero(_ctx: Context<TestInitAndZero>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn initialize(ctx: Context<Initialize>) -> Result<()> {\n        *ctx.accounts.account = OverflowAccount {\n            i8_left: i8::MIN,\n            i8_right: i8::MAX,\n            i16_left: i16::MIN,\n            i16_right: i16::MAX,\n            i32_left: i32::MIN,\n            i32_right: i32::MAX,\n            i64_left: i64::MIN,\n            i64_right: i64::MAX,\n            i128_left: i128::MIN,\n            i128_right: i128::MAX,\n            u8_left: u8::MIN,\n            u8_right: u8::MAX,\n            u16_left: u16::MIN,\n            u16_right: u16::MAX,\n            u32_left: u32::MIN,\n            u32_right: u32::MAX,\n            u64_left: u64::MIN,\n            u64_right: u64::MAX,\n            u128_left: u128::MIN,\n            u128_right: u128::MAX,\n        };\n\n        Ok(())\n    }",
    "pub fn test_overflow_add(ctx: Context<TestOverflowAdd>) -> Result<()> {\n        let account = &mut ctx.accounts.account;\n        account.i8_right += 1;\n        account.i16_right += 1;\n        account.i32_right += 1;\n        account.i64_right += 1;\n        account.i128_right += 1;\n\n        account.u8_right += 1;\n        account.u16_right += 1;\n        account.u32_right += 1;\n        account.u64_right += 1;\n        account.u128_right += 1;\n\n        Ok(())\n    }",
    "pub fn test_overflow_sub(ctx: Context<TestOverflowSub>) -> Result<()> {\n        let account = &mut ctx.accounts.account;\n        account.i8_left -= 1;\n        account.i16_left -= 1;\n        account.i32_left -= 1;\n        account.i64_left -= 1;\n        account.i128_left -= 1;\n\n        account.u8_left -= 1;\n        account.u16_left -= 1;\n        account.u32_left -= 1;\n        account.u64_left -= 1;\n        account.u128_left -= 1;\n\n        Ok(())\n    }",
    "pub fn test_overflow_mul(ctx: Context<TestOverflowMul>) -> Result<()> {\n        let account = &mut ctx.accounts.account;\n        account.i8_right *= 2;\n        account.i16_right *= 2;\n        account.i32_right *= 2;\n        account.i64_right *= 2;\n        account.i128_right *= 2;\n\n        account.u8_right *= 2;\n        account.u16_right *= 2;\n        account.u32_right *= 2;\n        account.u64_right *= 2;\n        account.u128_right *= 2;\n\n        Ok(())\n    }",
    "pub fn test_init(_ctx: Context<TestInit>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_init_another(_ctx: Context<TestInitAnother>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn initialize(_ctx: Context<Initialize>, _val: u64) -> Result<()> {\n        Ok(())\n    }",
    "pub fn initialize(_ctx: Context<Initialize>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn create_multisig(\n        ctx: Context<CreateMultisig>,\n        owners: Vec<Pubkey>,\n        threshold: u64,\n        nonce: u8,\n    ) -> Result<()> {\n        let multisig = &mut ctx.accounts.multisig;\n        multisig.owners = owners;\n        multisig.threshold = threshold;\n        multisig.nonce = nonce;\n        Ok(())\n    }",
    "pub fn create_transaction(\n        ctx: Context<CreateTransaction>,\n        pid: Pubkey,\n        accs: Vec<TransactionAccount>,\n        data: Vec<u8>,\n    ) -> Result<()> {\n        let owner_index = ctx\n            .accounts\n            .multisig\n            .owners\n            .iter()\n            .position(|a| a == ctx.accounts.proposer.key)\n            .ok_or(error!(ErrorCode::InvalidOwner))?;\n\n        let mut signers = Vec::new();\n        signers.resize(ctx.accounts.multisig.owners.len(), false);\n        signers[owner_index] = true;\n\n        let tx = &mut ctx.accounts.transaction;\n        tx.program_id = pid;\n        tx.accounts = accs;\n        tx.data = data;\n        tx.signers = signers;\n        tx.multisig = *ctx.accounts.multisig.to_account_info().key;\n        tx.did_execute = false;\n\n        Ok(())\n    }",
    "pub fn approve(ctx: Context<Approve>) -> Result<()> {\n        let owner_index = ctx\n            .accounts\n            .multisig\n            .owners\n            .iter()\n            .position(|a| a == ctx.accounts.owner.key)\n            .ok_or(error!(ErrorCode::InvalidOwner))?;\n\n        ctx.accounts.transaction.signers[owner_index] = true;\n\n        Ok(())\n    }",
    "pub fn set_owners(ctx: Context<Auth>, owners: Vec<Pubkey>) -> Result<()> {\n        let multisig = &mut ctx.accounts.multisig;\n\n        if (owners.len() as u64) < multisig.threshold {\n            multisig.threshold = owners.len() as u64;\n        }\n\n        multisig.owners = owners;\n        Ok(())\n    }",
    "pub fn change_threshold(ctx: Context<Auth>, threshold: u64) -> Result<()> {\n        if threshold > ctx.accounts.multisig.owners.len() as u64 {\n            return err!(ErrorCode::InvalidThreshold);\n        }\n        let multisig = &mut ctx.accounts.multisig;\n        multisig.threshold = threshold;\n        Ok(())\n    }",
    "pub fn execute_transaction(ctx: Context<ExecuteTransaction>) -> Result<()> {\n        // Has this been executed already?\n        if ctx.accounts.transaction.did_execute {\n            return err!(ErrorCode::AlreadyExecuted);\n        }\n\n        // Do we have enough signers?\n        let sig_count = ctx\n            .accounts\n            .transaction\n            .signers\n            .iter()\n            .filter_map(|s| match s {\n                false => None,\n                true => Some(true),\n            })\n            .collect::<Vec<_>>()\n            .len() as u64;\n        if sig_count < ctx.accounts.multisig.threshold {\n            return err!(ErrorCode::NotEnoughSigners);\n        }\n\n        // Execute the transaction signed by the multisig.\n        let mut ix: Instruction = (&*ctx.accounts.transaction).into();\n        ix.accounts = ix\n            .accounts\n            .iter()\n            .map(|acc| {\n                if &acc.pubkey == ctx.accounts.multisig_signer.key {\n                    AccountMeta::new_readonly(acc.pubkey, true)\n                }",
    "pub fn do_stuff(ctx: Context<DoStuff>) -> Result<()> {\n        msg!(\"Doing stuff...\");\n        let optional_2 = &mut ctx.accounts.optional_2;\n        if let Some(data_account) = optional_2 {\n            data_account.data = 42;\n        }\n\n        Ok(())\n    }",
    "pub fn initialize(ctx: Context<Initialize>, value: u64, key: Pubkey) -> Result<()> {\n        let optional_pda = &mut ctx.accounts.optional_pda;\n        let optional_account = &mut ctx.accounts.optional_account;\n        let required = &mut ctx.accounts.required;\n\n        required.data = 0;\n\n        if let Some(data_account) = optional_account {\n            if let Some(data_pda) = optional_pda {\n                data_pda.data_account = key;\n                data_account.data = value;\n            } else {\n                data_account.data = value * 2;\n            }\n        }\n\n        Ok(())\n    }",
    "pub fn update(ctx: Context<Update>, value: u64, key: Pubkey, _pda_bump: u8) -> Result<()> {\n        if let Some(data_account) = &mut ctx.accounts.optional_account {\n            data_account.data = value;\n        }\n        if let Some(data_account) = &mut ctx.accounts.optional_pda {\n            data_account.data_account = key;\n        }\n        Ok(())\n    }",
    "pub fn realloc(ctx: Context<Realloc>, new_size: u64) -> Result<()> {\n        let optional_pda = &ctx.accounts.optional_pda;\n        let optional_account = &ctx.accounts.optional_account;\n        if let Some(data_pda) = optional_pda {\n            let len = data_pda.to_account_info().data_len();\n            if len != new_size as usize {\n                return err!(OptionalErrors::ReallocFailed);\n            }\n        }\n        if let Some(data_account) = optional_account {\n            let len = data_account.to_account_info().data_len();\n            if len != new_size as usize {\n                return err!(OptionalErrors::ReallocFailed);\n            }\n        }\n        Ok(())\n    }",
    "pub fn close(_ctx: Context<Close>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn init_base(ctx: Context<InitBase>, data: u64, data_key: Pubkey) -> Result<()> {\n        let base = &mut ctx.accounts.base;\n        base.base_data = data;\n        base.base_data_key = data_key;\n        Ok(())\n    }",
    "pub fn init_another(ctx: Context<InitAnotherBase>, data: u64) -> Result<()> {\n        let base = &mut ctx.accounts.base;\n        base.data = data;\n        Ok(())\n    }",
    "pub fn init_my_account(ctx: Context<InitMyAccount>, _seed_a: u8) -> Result<()> {\n        ctx.accounts.account.data = 1337;\n        Ok(())\n    }",
    "pub fn test_seed_constant(_ctx: Context<TestSeedConstant>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn associated_token_resolution(_ctx: Context<AssociatedTokenResolution>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn seed_math_expr(_ctx: Context<SeedMathExpr>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn resolution_error(_ctx: Context<ResolutionError>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn unsupported_program_seed(_ctx: Context<UnsupportedProgramSeed>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn call_expr_with_no_args(_ctx: Context<CallExprWithNoArgs>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn pubkey_const(_ctx: Context<PubkeyConst>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn seeds_program_account(_ctx: Context<SeedsProgramAccount>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn seeds_program_arg(_ctx: Context<SeedsProgramArg>, _some_program: Pubkey) -> Result<()> {\n        Ok(())\n    }",
    "pub fn initialize(ctx: Context<Initialize>, price: i64, expo: i32, conf: u64) -> Result<()> {\n        let oracle = &ctx.accounts.price;\n\n        let mut price_oracle = Price::load(&oracle).unwrap();\n\n        price_oracle.agg.price = price;\n        price_oracle.agg.conf = conf;\n        price_oracle.expo = expo;\n        price_oracle.ptype = pc::PriceType::Price;\n        Ok(())\n    }",
    "pub fn set_price(ctx: Context<SetPrice>, price: i64) -> Result<()> {\n        let oracle = &ctx.accounts.price;\n        let mut price_oracle = Price::load(&oracle).unwrap();\n        price_oracle.agg.price = price as i64;\n        Ok(())\n    }",
    "pub fn initialize(ctx: Context<Initialize>) -> Result<()> {\n        ctx.accounts.sample.data = vec![0];\n        ctx.accounts.sample.bump = ctx.bumps.sample;\n        Ok(())\n    }",
    "pub fn realloc(ctx: Context<Realloc>, len: u16) -> Result<()> {\n        ctx.accounts\n            .sample\n            .data\n            .resize_with(len as usize, Default::default);\n        Ok(())\n    }",
    "pub fn realloc2(ctx: Context<Realloc2>, len: u16) -> Result<()> {\n        ctx.accounts\n            .sample1\n            .data\n            .resize_with(len as usize, Default::default);\n\n        ctx.accounts\n            .sample2\n            .data\n            .resize_with(len as usize, Default::default);\n        Ok(())\n    }",
    "pub fn init_base(ctx: Context<InitBase>) -> Result<()> {\n        ctx.accounts.account.my_account = ctx.accounts.my_account.key();\n        ctx.accounts.account.bump = ctx.bumps.account;\n        Ok(())\n    }",
    "pub fn test_relation(_ctx: Context<TestRelation>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_address(_ctx: Context<TestAddress>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn initialize(ctx: Context<Initialize>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn initialize(ctx: Context<Initialize>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn initialize(ctx: Context<Initialize>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn handler(ctx: Context<CreateMintAccount>, args: CreateMintAccountArgs) -> Result<()> {\n    ctx.accounts.initialize_token_metadata(\n        args.name.clone(),\n        args.symbol.clone(),\n        args.uri.clone(),\n    )?;\n    ctx.accounts.mint.reload()?;\n    let mint_data = &mut ctx.accounts.mint.to_account_info();\n    let metadata = get_mint_extensible_extension_data::<TokenMetadata>(mint_data)?;\n    assert_eq!(metadata.mint, ctx.accounts.mint.key());\n    assert_eq!(metadata.name, args.name);\n    assert_eq!(metadata.symbol, args.symbol);\n    assert_eq!(metadata.uri, args.uri);\n    let metadata_pointer = get_mint_extension_data::<MetadataPointer>(mint_data)?;\n    let mint_key: Option<Pubkey> = Some(ctx.accounts.mint.key());\n    let authority_key: Option<Pubkey> = Some(ctx.accounts.authority.key());\n    assert_eq!(\n        metadata_pointer.metadata_address,\n        OptionalNonZeroPubkey::try_from(mint_key)?\n    );\n    assert_eq!(\n        metadata_pointer.authority,\n        OptionalNonZeroPubkey::try_from(authority_key)?\n    );\n    let permanent_delegate = get_mint_extension_data::<PermanentDelegate>(mint_data)?;\n    assert_eq!(\n        permanent_delegate.delegate,\n        OptionalNonZeroPubkey::try_from(authority_key)?\n    );\n    let close_authority = get_mint_extension_data::<MintCloseAuthority>(mint_data)?;\n    assert_eq!(\n        close_authority.close_authority,\n        OptionalNonZeroPubkey::try_from(authority_key)?\n    );\n    let transfer_hook = get_mint_extension_data::<TransferHook>(mint_data)?;\n    let program_id: Option<Pubkey> = Some(ctx.program_id.key());\n    assert_eq!(\n        transfer_hook.authority,\n        OptionalNonZeroPubkey::try_from(authority_key)?\n    );\n    assert_eq!(\n        transfer_hook.program_id,\n        OptionalNonZeroPubkey::try_from(program_id)?\n    );\n    let group_member_pointer = get_mint_extension_data::<GroupMemberPointer>(mint_data)?;\n    assert_eq!(\n        group_member_pointer.authority,\n        OptionalNonZeroPubkey::try_from(authority_key)?\n    );\n    assert_eq!(\n        group_member_pointer.member_address,\n        OptionalNonZeroPubkey::try_from(mint_key)?\n    );\n    // transfer minimum rent to mint account\n    update_account_lamports_to_minimum_balance(\n        ctx.accounts.mint.to_account_info(),\n        ctx.accounts.payer.to_account_info(),\n        ctx.accounts.system_program.to_account_info(),\n    )?;\n\n    Ok(())\n}",
    "pub fn create_mint_account(\n        ctx: Context<CreateMintAccount>,\n        args: CreateMintAccountArgs,\n    ) -> Result<()> {\n        instructions::handler(ctx, args)\n    }",
    "pub fn check_mint_extensions_constraints(\n        _ctx: Context<CheckMintExtensionConstraints>,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn get_extra_meta_list_account_pda(mint: Pubkey) -> Pubkey {\n    Pubkey::find_program_address(&[META_LIST_ACCOUNT_SEED, mint.as_ref()], &crate::id()).0\n}\n\npub fn get_approve_account_pda(mint: Pubkey) -> Pubkey {\n    Pubkey::find_program_address(&[APPROVE_ACCOUNT_SEED, mint.as_ref()], &crate::id()).0\n}\n\n/// Determine if we are in CPI\npub fn hook_in_cpi() -> bool {\n    let stack_height = get_stack_height();\n    let tx_height = TRANSACTION_LEVEL_STACK_HEIGHT;\n    let hook_height: usize = tx_height + 1;\n\n    stack_height > hook_height\n}\n\npub fn get_meta_list(approve_account: Option<Pubkey>) -> Vec<ExtraAccountMeta> {\n    if let Some(approve_account) = approve_account {\n        return vec![ExtraAccountMeta {\n            discriminator: 0,\n            address_config: approve_account.to_bytes(),\n            is_signer: false.into(),\n            is_writable: true.into(),\n        }];\n    }\n    vec![]\n}\n\npub fn get_meta_list_size(approve_account: Option<Pubkey>) -> usize {\n    // safe because it's either 0 or 1\n    ExtraAccountMetaList::size_of(get_meta_list(approve_account).len()).unwrap()\n}",
    "pub fn proxy_transfer(ctx: Context<ProxyTransfer>, amount: u64) -> Result<()> {\n        #[allow(deprecated)]\n        token_interface::transfer(ctx.accounts.into(), amount)\n    }",
    "pub fn proxy_optional_transfer(ctx: Context<ProxyOptionalTransfer>, amount: u64) -> Result<()> {\n        if let Some(token_program) = &ctx.accounts.token_program {\n            if let Some(mint) = &ctx.accounts.mint {\n                let cpi_accounts = TransferChecked {\n                    from: ctx.accounts.from.to_account_info(),\n                    mint: mint.to_account_info(),\n                    to: ctx.accounts.to.to_account_info(),\n                    authority: ctx.accounts.authority.clone(),\n                };\n                let cpi_program = token_program.to_account_info();\n                let cpi_context = CpiContext::new(cpi_program, cpi_accounts);\n                token_interface::transfer_checked(cpi_context, amount, mint.decimals)\n            }",
    "pub fn proxy_mint_to(ctx: Context<ProxyMintTo>, amount: u64) -> Result<()> {\n        token_interface::mint_to(ctx.accounts.into(), amount)\n    }",
    "pub fn proxy_burn(ctx: Context<ProxyBurn>, amount: u64) -> Result<()> {\n        token_interface::burn(ctx.accounts.into(), amount)\n    }",
    "pub fn proxy_set_authority(\n        ctx: Context<ProxySetAuthority>,\n        authority_type: AuthorityType,\n        new_authority: Option<Pubkey>,\n    ) -> Result<()> {\n        token_interface::set_authority(ctx.accounts.into(), authority_type.into(), new_authority)\n    }",
    "pub fn proxy_create_token_account(_ctx: Context<ProxyCreateTokenAccount>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn proxy_create_associated_token_account(\n        _ctx: Context<ProxyCreateAssociatedTokenAccount>,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn proxy_create_mint(_ctx: Context<ProxyCreateMint>, _name: String) -> Result<()> {\n        Ok(())\n    }",
    "pub fn initialize(ctx: Context<Initialize>, initializer_amount: u64) -> Result<()> {\n        // deposit into vault\n        token_interface::transfer_checked(\n            CpiContext::new(\n                ctx.accounts.deposit_token_program.to_account_info(),\n                token_interface::TransferChecked {\n                    from: ctx\n                        .accounts\n                        .initializer_deposit_token_account\n                        .to_account_info(),\n                    mint: ctx.accounts.deposit_mint.to_account_info(),\n                    to: ctx.accounts.deposit_token_vault.to_account_info(),\n                    authority: ctx.accounts.initializer.to_account_info(),\n                },\n            ),\n            initializer_amount,\n            ctx.accounts.deposit_mint.decimals,\n        )?;\n\n        // mint wrapped tokens\n        let inner_seeds = [\n            WRAPPER_AUTH_SEED,\n            ctx.accounts.deposit_mint.to_account_info().key.as_ref(),\n            ctx.accounts.wrapped_mint.to_account_info().key.as_ref(),\n            &[ctx.bumps.wrapper_authority],\n        ];\n        let signer_seeds = &[&inner_seeds[..]];\n        token_interface::mint_to(\n            CpiContext::new_with_signer(\n                ctx.accounts.wrapped_token_program.to_account_info(),\n                token_interface::MintTo {\n                    mint: ctx.accounts.wrapped_mint.to_account_info(),\n                    to: ctx\n                        .accounts\n                        .initializer_wrapped_token_account\n                        .to_account_info(),\n                    authority: ctx.accounts.wrapper_authority.to_account_info(),\n                },\n                signer_seeds,\n            ),\n            initializer_amount,\n        )?;\n\n        Ok(())\n    }",
    "pub fn wrap(ctx: Context<Wrap>, wrap_amount: u64) -> Result<()> {\n        // deposit into vault\n        token_interface::transfer_checked(\n            CpiContext::new(\n                ctx.accounts.deposit_token_program.to_account_info(),\n                token_interface::TransferChecked {\n                    from: ctx.accounts.user_deposit_token_account.to_account_info(),\n                    mint: ctx.accounts.deposit_mint.to_account_info(),\n                    to: ctx.accounts.deposit_token_vault.to_account_info(),\n                    authority: ctx.accounts.signer.to_account_info(),\n                },\n            ),\n            wrap_amount,\n            ctx.accounts.deposit_mint.decimals,\n        )?;\n\n        // mint wrapped tokens\n        let inner_seeds = [\n            WRAPPER_AUTH_SEED,\n            ctx.accounts.deposit_mint.to_account_info().key.as_ref(),\n            ctx.accounts.wrapped_mint.to_account_info().key.as_ref(),\n            &[ctx.bumps.wrapper_authority],\n        ];\n        let signer_seeds = &[&inner_seeds[..]];\n        token_interface::mint_to(\n            CpiContext::new_with_signer(\n                ctx.accounts.wrapped_token_program.to_account_info(),\n                token_interface::MintTo {\n                    mint: ctx.accounts.wrapped_mint.to_account_info(),\n                    to: ctx.accounts.user_wrapped_token_account.to_account_info(),\n                    authority: ctx.accounts.wrapper_authority.to_account_info(),\n                },\n                signer_seeds,\n            ),\n            wrap_amount,\n        )?;\n\n        Ok(())\n    }",
    "pub fn unwrap(ctx: Context<Unwrap>, unwrap_amount: u64) -> Result<()> {\n        // burn wrapped tokens\n        token_interface::burn(\n            CpiContext::new(\n                ctx.accounts.wrapped_token_program.to_account_info(),\n                token_interface::Burn {\n                    mint: ctx.accounts.wrapped_mint.to_account_info(),\n                    from: ctx.accounts.user_wrapped_token_account.to_account_info(),\n                    authority: ctx.accounts.signer.to_account_info(),\n                },\n            ),\n            unwrap_amount,\n        )?;\n\n        // withdraw from vault\n        let inner_seeds = [\n            WRAPPER_AUTH_SEED,\n            ctx.accounts.deposit_mint.to_account_info().key.as_ref(),\n            ctx.accounts.wrapped_mint.to_account_info().key.as_ref(),\n            &[ctx.bumps.wrapper_authority],\n        ];\n        let signer_seeds = &[&inner_seeds[..]];\n        token_interface::transfer_checked(\n            CpiContext::new_with_signer(\n                ctx.accounts.deposit_token_program.to_account_info(),\n                token_interface::TransferChecked {\n                    from: ctx.accounts.deposit_token_vault.to_account_info(),\n                    mint: ctx.accounts.deposit_mint.to_account_info(),\n                    to: ctx.accounts.user_deposit_token_account.to_account_info(),\n                    authority: ctx.accounts.wrapper_authority.to_account_info(),\n                },\n                signer_seeds,\n            ),\n            unwrap_amount,\n            ctx.accounts.deposit_mint.decimals,\n        )?;\n\n        Ok(())\n    }",
    "pub fn initialize(ctx: Context<Initialize>, metas: Vec<AnchorExtraAccountMeta>) -> Result<()> {\n        let extra_metas_account = &ctx.accounts.extra_metas_account;\n        let mint = &ctx.accounts.mint;\n        let mint_authority = &ctx.accounts.mint_authority;\n\n        if mint_authority.key()\n            != mint.mint_authority.ok_or(Into::<ProgramError>::into(\n                TransferHookError::MintHasNoMintAuthority,\n            ))?\n        {\n            Err(Into::<ProgramError>::into(\n                TransferHookError::IncorrectMintAuthority,\n            ))?;\n        }\n\n        let metas: Vec<ExtraAccountMeta> = metas.into_iter().map(|meta| meta.into()).collect();\n        let mut data = extra_metas_account.try_borrow_mut_data()?;\n        ExtraAccountMetaList::init::<ExecuteInstruction>(&mut data, &metas)?;\n\n        Ok(())\n    }",
    "pub fn execute(ctx: Context<Execute>, amount: u64) -> Result<()> {\n        let source_account = &ctx.accounts.source_account;\n        let destination_account = &ctx.accounts.destination_account;\n\n        check_token_account_is_transferring(&source_account.to_account_info().try_borrow_data()?)?;\n        check_token_account_is_transferring(\n            &destination_account.to_account_info().try_borrow_data()?,\n        )?;\n\n        let data = ctx.accounts.extra_metas_account.try_borrow_data()?;\n        ExtraAccountMetaList::check_account_infos::<ExecuteInstruction>(\n            &ctx.accounts.to_account_infos(),\n            &TransferHookInstruction::Execute { amount }.pack(),\n            &ctx.program_id,\n            &data,\n        )?;\n\n        Ok(())\n    }",
    "pub fn initialize(_ctx: Context<Initialize>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn sysvars(_ctx: Context<Sysvars>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn initialize_dashboard(ctx: Context<Initializedashboard>) -> Result<()> {\n        let dashboard = &mut ctx.accounts.dashboard;\n        dashboard.game_count = 0;\n        dashboard.address = *dashboard.to_account_info().key;\n        Ok(())\n    }",
    "pub fn initialize(ctx: Context<Initialize>) -> Result<()> {\n        let dashboard = &mut ctx.accounts.dashboard;\n        let game = &mut ctx.accounts.game;\n        dashboard.game_count = dashboard.game_count + 1;\n        dashboard.latest_game = *game.to_account_info().key;\n        game.player_x = *ctx.accounts.player_x.key;\n        Ok(())\n    }",
    "pub fn player_join(ctx: Context<Playerjoin>) -> Result<()> {\n        let game = &mut ctx.accounts.game;\n        game.player_o = *ctx.accounts.player_o.key;\n        game.game_state = 1;\n        Ok(())\n    }",
    "pub fn player_move(ctx: Context<Playermove>, x_or_o: u8, player_move: u8) -> Result<()> {\n        let game = &mut ctx.accounts.game;\n        game.board[player_move as usize] = x_or_o;\n        game.status(x_or_o);\n        Ok(())\n    }",
    "pub fn status(ctx: Context<Status>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn accounts(ctx: &Context<Playermove>, x_or_o: u8, player_move: u8) -> Result<()> {\n        if ctx.accounts.game.board[player_move as usize] != 0 {\n            return Err(ErrorCode::Illegalmove.into());\n        }\n        if x_or_o == BOARD_ITEM_X {\n            return Playermove::player_x_checks(ctx);\n        } else if x_or_o == BOARD_ITEM_O {\n            return Playermove::player_o_checks(ctx);\n        } else {\n            return Err(ErrorCode::UnexpectedValue.into());\n        }\n    }\n\n    pub fn player_x_checks(ctx: &Context<Playermove>) -> Result<()> {\n        if ctx.accounts.game.player_x != *ctx.accounts.player.key {\n            return Err(ErrorCode::Unauthorized.into());\n        }\n        if ctx.accounts.game.game_state != 1 {\n            return Err(ErrorCode::Gamestate.into());\n        }\n        Ok(())\n    }",
    "pub fn player_o_checks(ctx: &Context<Playermove>) -> Result<()> {\n        if ctx.accounts.game.player_o != *ctx.accounts.player.key {\n            return Err(ErrorCode::Unauthorized.into());\n        }\n        if ctx.accounts.game.game_state != 2 {\n            return Err(ErrorCode::Gamestate.into());\n        }\n        Ok(())\n    }",
    "pub fn status(self: &mut Game, x_or_o: u8) {\n        let winner =\n            // Check rows.\n            Game::same(x_or_o, &self.board[0..3])\n            || Game::same(x_or_o, &self.board[3..6])\n            || Game::same(x_or_o, &self.board[6..9])\n            // Check columns.\n            || Game::same(x_or_o, &[self.board[0], self.board[3], self.board[6]])\n            || Game::same(x_or_o, &[self.board[1], self.board[4], self.board[7]])\n            || Game::same(x_or_o, &[self.board[2], self.board[5], self.board[8]])\n            // Check both diagonals.\n            || Game::same(x_or_o, &[self.board[0], self.board[4], self.board[8]])\n            || Game::same(x_or_o, &[self.board[2], self.board[4], self.board[6]]);\n\n        if winner {\n            self.game_state = x_or_o + 2;\n        } else if self.board.iter().all(|&p| p != BOARD_ITEM_FREE) {\n            self.game_state = 5;\n        } else {\n            if x_or_o == BOARD_ITEM_X {\n                self.game_state = 2;\n            } else {\n                self.game_state = 1;\n            }\n        }\n    }\n\n    pub fn same(x_or_o: u8, triple: &[u8]) -> bool {\n        triple.iter().all(|&i| i == x_or_o)\n    }",
    "pub fn initialize(ctx: Context<Initialize>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn initialize(_ctx: Context<Initialize>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn create_foo(ctx: Context<CreateFoo>) -> Result<()> {\n        let foo = &mut ctx.accounts.foo.load_init()?;\n        foo.authority = *ctx.accounts.authority.key;\n        foo.set_second_authority(ctx.accounts.authority.key);\n        Ok(())\n    }",
    "pub fn update_foo(ctx: Context<UpdateFoo>, data: u64) -> Result<()> {\n        let mut foo = ctx.accounts.foo.load_mut()?;\n        foo.data = data;\n        Ok(())\n    }",
    "pub fn update_foo_second(ctx: Context<UpdateFooSecond>, second_data: u64) -> Result<()> {\n        let mut foo = ctx.accounts.foo.load_mut()?;\n        foo.second_data = second_data;\n        Ok(())\n    }",
    "pub fn create_bar(ctx: Context<CreateBar>) -> Result<()> {\n        let bar = &mut ctx.accounts.bar.load_init()?;\n        bar.authority = *ctx.accounts.authority.key;\n        Ok(())\n    }",
    "pub fn update_bar(ctx: Context<UpdateBar>, data: u64) -> Result<()> {\n        let bar = &mut ctx.accounts.bar.load_mut()?;\n        bar.data = data;\n        Ok(())\n    }",
    "pub fn create_large_account(_ctx: Context<CreateLargeAccount>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn update_large_account(\n        ctx: Context<UpdateLargeAccount>,\n        idx: u32,\n        data: u64,\n    ) -> Result<()> {\n        let event_q = &mut ctx.accounts.event_q.load_mut()?;\n        event_q.events[idx as usize] = Event {\n            data,\n            from: *ctx.accounts.from.key,\n        };\n        Ok(())\n    }",
    "pub fn check_cpi(ctx: Context<CheckCpi>, data: u64) -> Result<()> {\n        let cpi_program = ctx.accounts.zero_copy_program.to_account_info();\n        let cpi_accounts = UpdateBar {\n            authority: ctx.accounts.authority.clone(),\n            bar: ctx.accounts.bar.to_account_info(),\n            foo: ctx.accounts.foo.to_account_info(),\n        };\n        let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);\n        zero_copy::cpi::update_bar(cpi_ctx, data)?;\n        Ok(())\n    }",
    "pub fn create(ctx: Context<Create>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn create_idempotent(ctx: Context<CreateIdempotent>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn recover_nested(ctx: Context<RecoverNested>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn initialize_binary_option(\n        ctx: Context<InitializeBinaryOption>,\n        decimals: u8,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn trade(ctx: Context<Trade>, size: u64, buy_price: u64, sell_price: u64) -> Result<()> {\n        Ok(())\n    }",
    "pub fn settle(ctx: Context<Settle>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn collect(ctx: Context<Collect>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn init_pool(\n        ctx: Context<InitPool>,\n        mint_end_slot: u64,\n        decide_end_slot: u64,\n        bump_seed: u8,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn deposit(ctx: Context<Deposit>, arg: u64) -> Result<()> {\n        Ok(())\n    }",
    "pub fn withdraw(ctx: Context<Withdraw>, arg: u64) -> Result<()> {\n        Ok(())\n    }",
    "pub fn decide(ctx: Context<Decide>, arg: bool) -> Result<()> {\n        Ok(())\n    }",
    "pub fn propose(\n        ctx: Context<Propose>,\n        tokens_to_mint: u64,\n        acceptance_criteria: AcceptanceCriteria,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn tally(ctx: Context<Tally>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn create_realm(\n        ctx: Context<CreateRealm>,\n        name: String,\n        config_args: RealmConfigArgs,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn deposit_governing_tokens(\n        ctx: Context<DepositGoverningTokens>,\n        amount: u64,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn withdraw_governing_tokens(ctx: Context<WithdrawGoverningTokens>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn set_governance_delegate(\n        ctx: Context<SetGovernanceDelegate>,\n        new_governance_delegate: Option<Pubkey>,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn create_governance(\n        ctx: Context<CreateGovernance>,\n        config: GovernanceConfig,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn create_program_governance(\n        ctx: Context<CreateProgramGovernance>,\n        config: GovernanceConfig,\n        transfer_upgrade_authority: bool,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn create_proposal(\n        ctx: Context<CreateProposal>,\n        name: String,\n        description_link: String,\n        vote_type: VoteType,\n        options: Vec<String>,\n        use_deny_option: bool,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn add_signatory(ctx: Context<AddSignatory>, signatory: Pubkey) -> Result<()> {\n        Ok(())\n    }",
    "pub fn remove_signatory(ctx: Context<RemoveSignatory>, signatory: Pubkey) -> Result<()> {\n        Ok(())\n    }",
    "pub fn insert_transaction(\n        ctx: Context<InsertTransaction>,\n        option_index: u8,\n        index: u16,\n        hold_up_time: u32,\n        instructions: Vec<InstructionData>,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn remove_transaction(ctx: Context<RemoveTransaction>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn cancel_proposal(ctx: Context<CancelProposal>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn sign_off_proposal(ctx: Context<SignOffProposal>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn cast_vote(ctx: Context<CastVote>, vote: Vote) -> Result<()> {\n        Ok(())\n    }",
    "pub fn finalize_vote(ctx: Context<FinalizeVote>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn relinquish_vote(ctx: Context<RelinquishVote>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn execute_transaction(ctx: Context<ExecuteTransaction>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn create_mint_governance(\n        ctx: Context<CreateMintGovernance>,\n        config: GovernanceConfig,\n        transfer_mint_authorities: bool,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn create_token_governance(\n        ctx: Context<CreateTokenGovernance>,\n        config: GovernanceConfig,\n        transfer_account_authorities: bool,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn set_governance_config(\n        ctx: Context<SetGovernanceConfig>,\n        config: GovernanceConfig,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn flag_transaction_error(ctx: Context<FlagTransactionError>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn set_realm_authority(\n        ctx: Context<SetRealmAuthority>,\n        action: SetRealmAuthorityAction,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn set_realm_config(\n        ctx: Context<SetRealmConfig>,\n        config_args: RealmConfigArgs,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn create_token_owner_record(ctx: Context<CreateTokenOwnerRecord>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn update_program_metadata(ctx: Context<UpdateProgramMetadata>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn create_native_treasury(ctx: Context<CreateNativeTreasury>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn add_memo(ctx: Context<AddMemo>, memo: String) -> Result<()> {\n        Ok(())\n    }",
    "pub fn create(\n        ctx: Context<Create>,\n        hashed_name: Vec<u8>,\n        lamports: u64,\n        space: u32,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn update(ctx: Context<Update>, offset: u32, data: Vec<u8>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn transfer(ctx: Context<Transfer>, new_owner: Pubkey) -> Result<()> {\n        Ok(())\n    }",
    "pub fn delete(ctx: Context<Delete>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn initialize(ctx: Context<Initialize>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn write(ctx: Context<Write>, offset: u64, data: Vec<u8>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn set_authority(ctx: Context<SetAuthority>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn close_account(ctx: Context<CloseAccount>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn initialize(\n        ctx: Context<Initialize>,\n        fee: Fee,\n        withdrawal_fee: Fee,\n        deposit_fee: Fee,\n        referral_fee: u8,\n        max_validators: u32,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn add_validator_to_pool(ctx: Context<AddValidatorToPool>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn remove_validator_from_pool(ctx: Context<RemoveValidatorFromPool>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn decrease_validator_stake(\n        ctx: Context<DecreaseValidatorStake>,\n        lamports: u64,\n        transient_stake_seed: u64,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn increase_validator_stake(\n        ctx: Context<IncreaseValidatorStake>,\n        lamports: u64,\n        transient_stake_seed: u64,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn set_preferred_validator(\n        ctx: Context<SetPreferredValidator>,\n        validator_type: PreferredValidatorType,\n        validator_vote_address: Option<Pubkey>,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn update_validator_list_balance(\n        ctx: Context<UpdateValidatorListBalance>,\n        start_index: u32,\n        no_merge: bool,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn update_stake_pool_balance(ctx: Context<UpdateStakePoolBalance>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn cleanup_removed_validator_entries(\n        ctx: Context<CleanupRemovedValidatorEntries>,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn deposit_stake(ctx: Context<DepositStake>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn withdraw_stake(ctx: Context<WithdrawStake>, arg: u64) -> Result<()> {\n        Ok(())\n    }",
    "pub fn set_manager(ctx: Context<SetManager>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn set_fee(ctx: Context<SetFee>, fee: FeeType) -> Result<()> {\n        Ok(())\n    }",
    "pub fn set_staker(ctx: Context<SetStaker>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn deposit_sol(ctx: Context<DepositSol>, arg: u64) -> Result<()> {\n        Ok(())\n    }",
    "pub fn set_funding_authority(\n        ctx: Context<SetFundingAuthority>,\n        arg: FundingType,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn withdraw_sol(ctx: Context<WithdrawSol>, arg: u64) -> Result<()> {\n        Ok(())\n    }",
    "pub fn create_token_metadata(\n        ctx: Context<CreateTokenMetadata>,\n        name: String,\n        symbol: String,\n        uri: String,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn update_token_metadata(\n        ctx: Context<UpdateTokenMetadata>,\n        name: String,\n        symbol: String,\n        uri: String,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn accept_offer(\n        ctx: Context<AcceptOffer>,\n        has_metadata: bool,\n        maker_size: u64,\n        taker_size: u64,\n        bump_seed: u8,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn initialize_mint(\n        ctx: Context<InitializeMint>,\n        decimals: u8,\n        mint_authority: Pubkey,\n        freeze_authority: COption<Pubkey>,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn initialize_account(ctx: Context<InitializeAccount>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn initialize_multisig(ctx: Context<InitializeMultisig>, m: u8) -> Result<()> {\n        Ok(())\n    }",
    "pub fn transfer(ctx: Context<Transfer>, amount: u64) -> Result<()> {\n        Ok(())\n    }",
    "pub fn approve(ctx: Context<Approve>, amount: u64) -> Result<()> {\n        Ok(())\n    }",
    "pub fn revoke(ctx: Context<Revoke>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn set_authority(\n        ctx: Context<SetAuthority>,\n        authority_type: AuthorityType,\n        new_authority: COption<Pubkey>,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn mint_to(ctx: Context<MintTo>, amount: u64) -> Result<()> {\n        Ok(())\n    }",
    "pub fn burn(ctx: Context<Burn>, amount: u64) -> Result<()> {\n        Ok(())\n    }",
    "pub fn close_account(ctx: Context<CloseAccount>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn freeze_account(ctx: Context<FreezeAccount>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn thaw_account(ctx: Context<ThawAccount>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn transfer_checked(\n        ctx: Context<TransferChecked>,\n        amount: u64,\n        decimals: u8,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn approve_checked(ctx: Context<ApproveChecked>, amount: u64, decimals: u8) -> Result<()> {\n        Ok(())\n    }",
    "pub fn mint_to_checked(ctx: Context<MintToChecked>, amount: u64, decimals: u8) -> Result<()> {\n        Ok(())\n    }",
    "pub fn burn_checked(ctx: Context<BurnChecked>, amount: u64, decimals: u8) -> Result<()> {\n        Ok(())\n    }",
    "pub fn initialize_account2(ctx: Context<InitializeAccount2>, owner: Pubkey) -> Result<()> {\n        Ok(())\n    }",
    "pub fn sync_native(ctx: Context<SyncNative>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn initialize_account3(ctx: Context<InitializeAccount3>, owner: Pubkey) -> Result<()> {\n        Ok(())\n    }",
    "pub fn initialize_multisig2(ctx: Context<InitializeMultisig2>, m: u8) -> Result<()> {\n        Ok(())\n    }",
    "pub fn initialize_mint2(\n        ctx: Context<InitializeMint2>,\n        decimals: u8,\n        mint_authority: Pubkey,\n        freeze_authority: COption<Pubkey>,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn get_account_data_size(ctx: Context<GetAccountDataSize>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn initialize_immutable_owner(ctx: Context<InitializeImmutableOwner>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn amount_to_ui_amount(ctx: Context<AmountToUiAmount>, amount: u64) -> Result<()> {\n        Ok(())\n    }",
    "pub fn ui_amount_to_amount(ctx: Context<UiAmountToAmount>, ui_amount: &'a str) -> Result<()> {\n        Ok(())\n    }",
    "pub fn init_lending_market(\n        ctx: Context<InitLendingMarket>,\n        owner: Pubkey,\n        quote_currency: [u8; 32],\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn set_lending_market_owner(\n        ctx: Context<SetLendingMarketOwner>,\n        new_owner: Pubkey,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn init_reserve(\n        ctx: Context<InitReserve>,\n        liquidity_amount: u64,\n        config: ReserveConfig,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn refresh_reserve(ctx: Context<RefreshReserve>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn deposit_reserve_liquidity(\n        ctx: Context<DepositReserveLiquidity>,\n        liquidity_amount: u64,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn redeem_reserve_collateral(\n        ctx: Context<RedeemReserveCollateral>,\n        collateral_amount: u64,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn init_obligation(ctx: Context<InitObligation>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn refresh_obligation(ctx: Context<RefreshObligation>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn deposit_obligation_collateral(\n        ctx: Context<DepositObligationCollateral>,\n        collateral_amount: u64,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn withdraw_obligation_collateral(\n        ctx: Context<WithdrawObligationCollateral>,\n        collateral_amount: u64,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn borrow_obligation_liquidity(\n        ctx: Context<BorrowObligationLiquidity>,\n        liquidity_amount: u64,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn repay_obligation_liquidity(\n        ctx: Context<RepayObligationLiquidity>,\n        liquidity_amount: u64,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn liquidate_obligation(\n        ctx: Context<LiquidateObligation>,\n        liquidity_amount: u64,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn flash_loan(ctx: Context<FlashLoan>, amount: u64) -> Result<()> {\n        Ok(())\n    }",
    "pub fn initialize(ctx: Context<Initialize>, fees: Fees, swap_curve: SwapCurve) -> Result<()> {\n        Ok(())\n    }",
    "pub fn swap(ctx: Context<Swap>, amount_in: u64, minimum_amount_out: u64) -> Result<()> {\n        Ok(())\n    }",
    "pub fn deposit_all_token_types(\n        ctx: Context<DepositAllTokenTypes>,\n        pool_token_amount: u64,\n        maximum_token_a_amount: u64,\n        maximum_token_b_amount: u64,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn withdraw_all_token_types(\n        ctx: Context<WithdrawAllTokenTypes>,\n        pool_token_amount: u64,\n        minimum_token_a_amount: u64,\n        minimum_token_b_amount: u64,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn deposit_single_token_type_exact_amount_in(\n        ctx: Context<DepositSingleTokenTypeExactAmountIn>,\n        source_token_amount: u64,\n        minimum_pool_token_amount: u64,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn withdraw_single_token_type_exact_amount_out(\n        ctx: Context<WithdrawSingleTokenTypeExactAmountOut>,\n        destination_token_amount: u64,\n        maximum_pool_token_amount: u64,\n    ) -> Result<()> {\n        Ok(())\n    }"
  ],
  "solana": [
    "pub fn check_canopy_bytes(canopy_bytes: &[u8]) -> Result<()> {\n    if canopy_bytes.len() % size_of::<Node>() != 0 {\n        msg!(\n            \"Canopy byte length {} is not a multiple of {}\",\n            canopy_bytes.len(),\n            size_of::<Node>()\n        );\n        err!(AccountCompressionError::CanopyLengthMismatch)\n    }",
    "pub fn update_canopy(\n    canopy_bytes: &mut [u8],\n    max_depth: u32,\n    change_log: Option<&ChangeLogEvent>,\n) -> Result<()> {\n    check_canopy_bytes(canopy_bytes)?;\n    let canopy = cast_slice_mut::<u8, Node>(canopy_bytes);\n    let path_len = get_cached_path_length(canopy, max_depth)?;\n    if let Some(cl_event) = change_log {\n        match &*cl_event {\n            ChangeLogEvent::V1(cl) => {\n                // Update the canopy from the newest change log\n                for path_node in cl.path.iter().rev().skip(1).take(path_len as usize) {\n                    // node_idx - 2 maps to the canopy index\n                    canopy[(path_node.index - 2) as usize] = path_node.node;\n                }\n            }\n        }\n    }\n    Ok(())\n}",
    "pub fn fill_in_proof_from_canopy(\n    canopy_bytes: &[u8],\n    max_depth: u32,\n    index: u32,\n    proof: &mut Vec<Node>,\n) -> Result<()> {\n    let mut empty_node_cache = Box::new([EMPTY; MAX_SUPPORTED_DEPTH]);\n    check_canopy_bytes(canopy_bytes)?;\n    let canopy = cast_slice::<u8, Node>(canopy_bytes);\n    let path_len = get_cached_path_length(canopy, max_depth)?;\n\n    // We want to compute the node index (w.r.t. the canopy) where the current path\n    // intersects the leaves of the canopy\n    let mut node_idx = ((1 << max_depth) + index) >> (max_depth - path_len);\n    let mut inferred_nodes = vec![];\n    while node_idx > 1 {\n        // node_idx - 2 maps to the canopy index\n        let shifted_index = node_idx as usize - 2;\n        let cached_idx = if shifted_index % 2 == 0 {\n            shifted_index + 1\n        } else {\n            shifted_index - 1\n        };\n        if canopy[cached_idx] == EMPTY {\n            let level = max_depth - (31 - node_idx.leading_zeros());\n            let empty_node = empty_node_cached::<MAX_SUPPORTED_DEPTH>(level, &mut empty_node_cache);\n            inferred_nodes.push(empty_node);\n        } else {\n            inferred_nodes.push(canopy[cached_idx]);\n        }\n        node_idx >>= 1;\n    }\n    // We only want to add inferred canopy nodes such that the proof length\n    // is equal to the tree depth. If the length of proof + length of canopy nodes is\n    // less than the tree depth, the instruction will fail.\n    let overlap = (proof.len() + inferred_nodes.len()).saturating_sub(max_depth as usize);\n    proof.extend(inferred_nodes.iter().skip(overlap));\n    Ok(())\n}",
    "pub fn set_canopy_leaf_nodes(\n    canopy_bytes: &mut [u8],\n    max_depth: u32,\n    start_index: u32,\n    nodes: &[Node],\n) -> Result<()> {\n    check_canopy_bytes(canopy_bytes)?;\n    let canopy = cast_slice_mut::<u8, Node>(canopy_bytes);\n    let path_len = get_cached_path_length(canopy, max_depth)?;\n    if path_len == 0 {\n        return err!(AccountCompressionError::CanopyNotAllocated);\n    }\n    let start_canopy_node = leaf_node_index_to_canopy_index(path_len, start_index)?;\n    let start_canopy_idx = start_canopy_node - 2;\n    // set the \"leaf\" nodes of the canopy first - that's the lowest level of the canopy\n    for (i, node) in nodes.iter().enumerate() {\n        canopy[start_canopy_idx + i] = *node;\n    }\n    let mut start_canopy_node = start_canopy_node;\n    let mut end_canopy_node = start_canopy_node + nodes.len() - 1;\n    let mut empty_node_cache = Box::new([EMPTY; MAX_SUPPORTED_DEPTH]);\n    let leaf_node_level = max_depth - path_len;\n    // traverse up the tree and update the parent nodes in the modified subtree\n    for level in leaf_node_level + 1..max_depth {\n        start_canopy_node >>= 1;\n        end_canopy_node >>= 1;\n        for node in start_canopy_node..end_canopy_node + 1 {\n            let left_child = get_value_for_node::<MAX_SUPPORTED_DEPTH>(\n                node << 1,\n                level - 1,\n                canopy,\n                &mut empty_node_cache,\n            );\n            let right_child = get_value_for_node::<MAX_SUPPORTED_DEPTH>(\n                (node << 1) + 1,\n                level - 1,\n                canopy,\n                &mut empty_node_cache,\n            );\n            canopy[node - 2].copy_from_slice(hashv(&[&left_child, &right_child]).as_ref());\n        }\n    }\n    Ok(())\n}",
    "pub fn check_canopy_root(canopy_bytes: &[u8], expected_root: &Node, max_depth: u32) -> Result<()> {\n    check_canopy_bytes(canopy_bytes)?;\n    let canopy = cast_slice::<u8, Node>(canopy_bytes);\n    if canopy.is_empty() {\n        return Ok(()); // Canopy is empty\n    }\n    let mut empty_node_cache = Box::new([EMPTY; MAX_SUPPORTED_DEPTH]);\n    // first two nodes are the children of the root, they have index 2 and 3 respectively\n    let left_root_child =\n        get_value_for_node::<MAX_SUPPORTED_DEPTH>(2, max_depth - 1, canopy, &mut empty_node_cache);\n    let right_root_child =\n        get_value_for_node::<MAX_SUPPORTED_DEPTH>(3, max_depth - 1, canopy, &mut empty_node_cache);\n    let actual_root = hashv(&[&left_root_child, &right_root_child]).to_bytes();\n    if actual_root != *expected_root {\n        msg!(\n            \"Canopy root mismatch. Expected: {:?}, Actual: {:?}\",\n            expected_root,\n            actual_root\n        );\n        err!(AccountCompressionError::CanopyRootMismatch)\n    }",
    "pub fn check_canopy_no_nodes_to_right_of_index(\n    canopy_bytes: &[u8],\n    max_depth: u32,\n    index: u32,\n) -> Result<()> {\n    check_canopy_bytes(canopy_bytes)?;\n    check_index(index, max_depth)?;\n    let canopy = cast_slice::<u8, Node>(canopy_bytes);\n    let path_len = get_cached_path_length(canopy, max_depth)?;\n\n    let mut node_idx = ((1 << max_depth) + index) >> (max_depth - path_len);\n    // no need to check the node_idx as it's the leaf continaing the index underneath it\n    while node_idx & (node_idx + 1) != 0 {\n        // check the next node to the right\n        node_idx += 1;\n        // find the top-most node that has the node as its left-most child\n        node_idx >>= node_idx.trailing_zeros();\n\n        let shifted_index = node_idx as usize - 2;\n        if canopy[shifted_index] != EMPTY {\n            msg!(\"Canopy node at index {} is not empty\", shifted_index);\n            return err!(AccountCompressionError::CanopyRightmostLeafMismatch);\n        }\n    }\n    Ok(())\n}",
    "pub fn merkle_tree_initialize_empty(\n    header: &ConcurrentMerkleTreeHeader,\n    tree_id: Pubkey,\n    tree_bytes: &mut [u8],\n) -> Result<Box<ChangeLogEvent>> {\n    merkle_tree_apply_fn_mut!(header, tree_id, tree_bytes, initialize,)\n}",
    "pub fn merkle_tree_initialize_with_root(\n    header: &ConcurrentMerkleTreeHeader,\n    tree_id: Pubkey,\n    tree_bytes: &mut [u8],\n    args: &InitializeWithRootArgs,\n) -> Result<Box<ChangeLogEvent>> {\n    merkle_tree_apply_fn_mut!(header, tree_id, tree_bytes, initialize_with_root, args)\n}",
    "pub fn merkle_tree_set_leaf(\n    header: &ConcurrentMerkleTreeHeader,\n    tree_id: Pubkey,\n    tree_bytes: &mut [u8],\n    args: &SetLeafArgs,\n) -> Result<Box<ChangeLogEvent>> {\n    merkle_tree_apply_fn_mut!(header, tree_id, tree_bytes, set_leaf, args)\n}",
    "pub fn merkle_tree_fill_empty_or_append(\n    header: &ConcurrentMerkleTreeHeader,\n    tree_id: Pubkey,\n    tree_bytes: &mut [u8],\n    args: &FillEmptyOrAppendArgs,\n) -> Result<Box<ChangeLogEvent>> {\n    merkle_tree_apply_fn_mut!(header, tree_id, tree_bytes, fill_empty_or_append, args)\n}",
    "pub fn merkle_tree_prove_leaf(\n    header: &ConcurrentMerkleTreeHeader,\n    tree_id: Pubkey,\n    tree_bytes: &[u8],\n    args: &ProveLeafArgs,\n) -> Result<Box<ChangeLogEvent>> {\n    merkle_tree_apply_fn!(header, tree_id, tree_bytes, prove_leaf, args)\n}",
    "pub fn merkle_tree_append_leaf(\n    header: &ConcurrentMerkleTreeHeader,\n    tree_id: Pubkey,\n    tree_bytes: &mut [u8],\n    args: &[u8; 32],\n) -> Result<Box<ChangeLogEvent>> {\n    merkle_tree_apply_fn_mut!(header, tree_id, tree_bytes, append, *args)\n}",
    "pub fn tree_bytes_uninitialized(tree_bytes: &[u8]) -> bool {\n    tree_bytes.iter().all(|&x| x == 0)\n}",
    "pub fn assert_tree_is_empty(\n    header: &ConcurrentMerkleTreeHeader,\n    tree_id: Pubkey,\n    tree_bytes: &mut [u8],\n) -> Result<()> {\n    // If the tree is batch initialized and not finalized yet, we can treat it as empty.\n    // Before the tree is finalized, the tree_bytes will be all 0 as only the header will be\n    // initialized at that point, so we may skip the deserialization.\n    if header.get_is_batch_initialized() && tree_bytes_uninitialized(tree_bytes) {\n        return Ok(());\n    }\n    // check the tree is empty\n    merkle_tree_apply_fn_mut!(header, tree_id, tree_bytes, prove_tree_is_empty,)?;\n    Ok(())\n}",
    "pub fn init_empty_merkle_tree(\n        ctx: Context<Initialize>,\n        max_depth: u32,\n        max_buffer_size: u32,\n    ) -> Result<()> {\n        require_eq!(\n            *ctx.accounts.merkle_tree.owner,\n            crate::id(),\n            AccountCompressionError::IncorrectAccountOwner\n        );\n        let mut merkle_tree_bytes = ctx.accounts.merkle_tree.try_borrow_mut_data()?;\n\n        let (mut header_bytes, rest) =\n            merkle_tree_bytes.split_at_mut(CONCURRENT_MERKLE_TREE_HEADER_SIZE_V1);\n\n        let mut header = ConcurrentMerkleTreeHeader::try_from_slice(header_bytes)?;\n        header.initialize(\n            max_depth,\n            max_buffer_size,\n            &ctx.accounts.authority.key(),\n            Clock::get()?.slot,\n        );\n        header.serialize(&mut header_bytes)?;\n\n        let merkle_tree_size = merkle_tree_get_size(&header)?;\n        let (tree_bytes, canopy_bytes) = rest.split_at_mut(merkle_tree_size);\n        let id = ctx.accounts.merkle_tree.key();\n\n        let change_log_event = merkle_tree_initialize_empty(&header, id, tree_bytes)?;\n\n        wrap_event(\n            &AccountCompressionEvent::ChangeLog(*change_log_event),\n            &ctx.accounts.noop,\n        )?;\n        update_canopy(canopy_bytes, header.get_max_depth(), None)\n    }",
    "pub fn prepare_batch_merkle_tree(\n        ctx: Context<Initialize>,\n        max_depth: u32,\n        max_buffer_size: u32,\n    ) -> Result<()> {\n        require_eq!(\n            *ctx.accounts.merkle_tree.owner,\n            crate::id(),\n            AccountCompressionError::IncorrectAccountOwner\n        );\n        let mut merkle_tree_bytes = ctx.accounts.merkle_tree.try_borrow_mut_data()?;\n\n        let (mut header_bytes, rest) =\n            merkle_tree_bytes.split_at_mut(CONCURRENT_MERKLE_TREE_HEADER_SIZE_V1);\n\n        let mut header = ConcurrentMerkleTreeHeader::try_from_slice(header_bytes)?;\n        header.initialize_batched(\n            max_depth,\n            max_buffer_size,\n            &ctx.accounts.authority.key(),\n            Clock::get()?.slot,\n        );\n        header.serialize(&mut header_bytes)?;\n        let merkle_tree_size = merkle_tree_get_size(&header)?;\n        let (_tree_bytes, canopy_bytes) = rest.split_at_mut(merkle_tree_size);\n        check_canopy_bytes(canopy_bytes)\n    }",
    "pub fn append_canopy_nodes(\n        ctx: Context<Modify>,\n        start_index: u32,\n        canopy_nodes: Vec<[u8; 32]>,\n    ) -> Result<()> {\n        require_eq!(\n            *ctx.accounts.merkle_tree.owner,\n            crate::id(),\n            AccountCompressionError::IncorrectAccountOwner\n        );\n        let mut merkle_tree_bytes = ctx.accounts.merkle_tree.try_borrow_mut_data()?;\n\n        let (header_bytes, rest) =\n            merkle_tree_bytes.split_at_mut(CONCURRENT_MERKLE_TREE_HEADER_SIZE_V1);\n\n        let header = ConcurrentMerkleTreeHeader::try_from_slice(header_bytes)?;\n        header.assert_valid_authority(&ctx.accounts.authority.key())?;\n        header.assert_is_batch_initialized()?;\n        // assert the tree is not initialized yet, we don't want to overwrite the canopy of an\n        // initialized tree\n        let merkle_tree_size = merkle_tree_get_size(&header)?;\n        let (tree_bytes, canopy_bytes) = rest.split_at_mut(merkle_tree_size);\n        // ensure the tree is not initialized, the hacky way\n        require!(\n            tree_bytes_uninitialized(tree_bytes),\n            AccountCompressionError::TreeAlreadyInitialized\n        );\n        set_canopy_leaf_nodes(\n            canopy_bytes,\n            header.get_max_depth(),\n            start_index,\n            &canopy_nodes,\n        )\n    }",
    "pub fn init_prepared_tree_with_root(\n        ctx: Context<Modify>,\n        root: [u8; 32],\n        rightmost_leaf: [u8; 32],\n        rightmost_index: u32,\n    ) -> Result<()> {\n        require_eq!(\n            *ctx.accounts.merkle_tree.owner,\n            crate::id(),\n            AccountCompressionError::IncorrectAccountOwner\n        );\n        let mut merkle_tree_bytes = ctx.accounts.merkle_tree.try_borrow_mut_data()?;\n\n        let (header_bytes, rest) =\n            merkle_tree_bytes.split_at_mut(CONCURRENT_MERKLE_TREE_HEADER_SIZE_V1);\n        // the header should already be initialized with prepare_batch_merkle_tree\n        let header = ConcurrentMerkleTreeHeader::try_from_slice(header_bytes)?;\n        header.assert_valid_authority(&ctx.accounts.authority.key())?;\n        header.assert_is_batch_initialized()?;\n        let merkle_tree_size = merkle_tree_get_size(&header)?;\n        let (tree_bytes, canopy_bytes) = rest.split_at_mut(merkle_tree_size);\n        // check the canopy root matches the tree root\n        check_canopy_root(canopy_bytes, &root, header.get_max_depth())?;\n        // verify the canopy does not conain any nodes to the right of the rightmost leaf\n        check_canopy_no_nodes_to_right_of_index(\n            canopy_bytes,\n            header.get_max_depth(),\n            rightmost_index,\n        )?;\n\n        // Get rightmost proof from accounts\n        let mut proof = vec![];\n        for node in ctx.remaining_accounts.iter() {\n            proof.push(node.key().to_bytes());\n        }\n        fill_in_proof_from_canopy(\n            canopy_bytes,\n            header.get_max_depth(),\n            rightmost_index,\n            &mut proof,\n        )?;\n        assert_eq!(proof.len(), header.get_max_depth() as usize);\n\n        let id = ctx.accounts.merkle_tree.key();\n        // A call is made to ConcurrentMerkleTree::initialize_with_root\n        let args = &InitializeWithRootArgs {\n            root,\n            rightmost_leaf,\n            proof_vec: proof,\n            index: rightmost_index,\n        };\n        let change_log = merkle_tree_initialize_with_root(&header, id, tree_bytes, args)?;\n        update_canopy(canopy_bytes, header.get_max_depth(), Some(&change_log))?;\n        wrap_event(\n            &AccountCompressionEvent::ChangeLog(*change_log),\n            &ctx.accounts.noop,\n        )\n    }",
    "pub fn replace_leaf(\n        ctx: Context<Modify>,\n        root: [u8; 32],\n        previous_leaf: [u8; 32],\n        new_leaf: [u8; 32],\n        index: u32,\n    ) -> Result<()> {\n        require_eq!(\n            *ctx.accounts.merkle_tree.owner,\n            crate::id(),\n            AccountCompressionError::IncorrectAccountOwner\n        );\n        let mut merkle_tree_bytes = ctx.accounts.merkle_tree.try_borrow_mut_data()?;\n        let (header_bytes, rest) =\n            merkle_tree_bytes.split_at_mut(CONCURRENT_MERKLE_TREE_HEADER_SIZE_V1);\n\n        let header = ConcurrentMerkleTreeHeader::try_from_slice(header_bytes)?;\n        header.assert_valid_authority(&ctx.accounts.authority.key())?;\n        header.assert_valid_leaf_index(index)?;\n\n        let merkle_tree_size = merkle_tree_get_size(&header)?;\n        let (tree_bytes, canopy_bytes) = rest.split_at_mut(merkle_tree_size);\n\n        let mut proof = vec![];\n        for node in ctx.remaining_accounts.iter() {\n            proof.push(node.key().to_bytes());\n        }\n        fill_in_proof_from_canopy(canopy_bytes, header.get_max_depth(), index, &mut proof)?;\n        let id = ctx.accounts.merkle_tree.key();\n        // A call is made to ConcurrentMerkleTree::set_leaf(root, previous_leaf, new_leaf, proof, index)\n        let args = &SetLeafArgs {\n            current_root: root,\n            previous_leaf,\n            new_leaf,\n            proof_vec: proof,\n            index,\n        };\n        let change_log_event = merkle_tree_set_leaf(&header, id, tree_bytes, args)?;\n\n        update_canopy(\n            canopy_bytes,\n            header.get_max_depth(),\n            Some(&change_log_event),\n        )?;\n        wrap_event(\n            &AccountCompressionEvent::ChangeLog(*change_log_event),\n            &ctx.accounts.noop,\n        )\n    }",
    "pub fn transfer_authority(\n        ctx: Context<TransferAuthority>,\n        new_authority: Pubkey,\n    ) -> Result<()> {\n        require_eq!(\n            *ctx.accounts.merkle_tree.owner,\n            crate::id(),\n            AccountCompressionError::IncorrectAccountOwner\n        );\n        let mut merkle_tree_bytes = ctx.accounts.merkle_tree.try_borrow_mut_data()?;\n        let (mut header_bytes, _) =\n            merkle_tree_bytes.split_at_mut(CONCURRENT_MERKLE_TREE_HEADER_SIZE_V1);\n\n        let mut header = ConcurrentMerkleTreeHeader::try_from_slice(header_bytes)?;\n        header.assert_valid_authority(&ctx.accounts.authority.key())?;\n\n        header.set_new_authority(&new_authority);\n        header.serialize(&mut header_bytes)?;\n\n        Ok(())\n    }",
    "pub fn verify_leaf(\n        ctx: Context<VerifyLeaf>,\n        root: [u8; 32],\n        leaf: [u8; 32],\n        index: u32,\n    ) -> Result<()> {\n        require_eq!(\n            *ctx.accounts.merkle_tree.owner,\n            crate::id(),\n            AccountCompressionError::IncorrectAccountOwner\n        );\n        let merkle_tree_bytes = ctx.accounts.merkle_tree.try_borrow_data()?;\n        let (header_bytes, rest) =\n            merkle_tree_bytes.split_at(CONCURRENT_MERKLE_TREE_HEADER_SIZE_V1);\n\n        let header = ConcurrentMerkleTreeHeader::try_from_slice(header_bytes)?;\n        header.assert_valid()?;\n        header.assert_valid_leaf_index(index)?;\n\n        let merkle_tree_size = merkle_tree_get_size(&header)?;\n        let (tree_bytes, canopy_bytes) = rest.split_at(merkle_tree_size);\n\n        let mut proof = vec![];\n        for node in ctx.remaining_accounts.iter() {\n            proof.push(node.key().to_bytes());\n        }\n        fill_in_proof_from_canopy(canopy_bytes, header.get_max_depth(), index, &mut proof)?;\n        let id = ctx.accounts.merkle_tree.key();\n\n        let args = &ProveLeafArgs {\n            current_root: root,\n            leaf,\n            proof_vec: proof,\n            index,\n        };\n        merkle_tree_prove_leaf(&header, id, tree_bytes, args)?;\n\n        Ok(())\n    }",
    "pub fn append(ctx: Context<Modify>, leaf: [u8; 32]) -> Result<()> {\n        require_eq!(\n            *ctx.accounts.merkle_tree.owner,\n            crate::id(),\n            AccountCompressionError::IncorrectAccountOwner\n        );\n        let mut merkle_tree_bytes = ctx.accounts.merkle_tree.try_borrow_mut_data()?;\n        let (header_bytes, rest) =\n            merkle_tree_bytes.split_at_mut(CONCURRENT_MERKLE_TREE_HEADER_SIZE_V1);\n\n        let header = ConcurrentMerkleTreeHeader::try_from_slice(header_bytes)?;\n        header.assert_valid_authority(&ctx.accounts.authority.key())?;\n\n        let id = ctx.accounts.merkle_tree.key();\n        let merkle_tree_size = merkle_tree_get_size(&header)?;\n        let (tree_bytes, canopy_bytes) = rest.split_at_mut(merkle_tree_size);\n        let change_log_event = merkle_tree_append_leaf(&header, id, tree_bytes, &leaf)?;\n        update_canopy(\n            canopy_bytes,\n            header.get_max_depth(),\n            Some(&change_log_event),\n        )?;\n        wrap_event(\n            &AccountCompressionEvent::ChangeLog(*change_log_event),\n            &ctx.accounts.noop,\n        )\n    }",
    "pub fn insert_or_append(\n        ctx: Context<Modify>,\n        root: [u8; 32],\n        leaf: [u8; 32],\n        index: u32,\n    ) -> Result<()> {\n        require_eq!(\n            *ctx.accounts.merkle_tree.owner,\n            crate::id(),\n            AccountCompressionError::IncorrectAccountOwner\n        );\n        let mut merkle_tree_bytes = ctx.accounts.merkle_tree.try_borrow_mut_data()?;\n        let (header_bytes, rest) =\n            merkle_tree_bytes.split_at_mut(CONCURRENT_MERKLE_TREE_HEADER_SIZE_V1);\n\n        let header = ConcurrentMerkleTreeHeader::try_from_slice(header_bytes)?;\n        header.assert_valid_authority(&ctx.accounts.authority.key())?;\n        header.assert_valid_leaf_index(index)?;\n\n        let merkle_tree_size = merkle_tree_get_size(&header)?;\n        let (tree_bytes, canopy_bytes) = rest.split_at_mut(merkle_tree_size);\n\n        let mut proof = vec![];\n        for node in ctx.remaining_accounts.iter() {\n            proof.push(node.key().to_bytes());\n        }\n        fill_in_proof_from_canopy(canopy_bytes, header.get_max_depth(), index, &mut proof)?;\n        // A call is made to ConcurrentMerkleTree::fill_empty_or_append\n        let id = ctx.accounts.merkle_tree.key();\n        let args = &FillEmptyOrAppendArgs {\n            current_root: root,\n            leaf,\n            proof_vec: proof,\n            index,\n        };\n        let change_log_event = merkle_tree_fill_empty_or_append(&header, id, tree_bytes, args)?;\n\n        update_canopy(\n            canopy_bytes,\n            header.get_max_depth(),\n            Some(&change_log_event),\n        )?;\n        wrap_event(\n            &AccountCompressionEvent::ChangeLog(*change_log_event),\n            &ctx.accounts.noop,\n        )\n    }",
    "pub fn close_empty_tree(ctx: Context<CloseTree>) -> Result<()> {\n        require_eq!(\n            *ctx.accounts.merkle_tree.owner,\n            crate::id(),\n            AccountCompressionError::IncorrectAccountOwner\n        );\n        let mut merkle_tree_bytes = ctx.accounts.merkle_tree.try_borrow_mut_data()?;\n        let (header_bytes, rest) =\n            merkle_tree_bytes.split_at_mut(CONCURRENT_MERKLE_TREE_HEADER_SIZE_V1);\n\n        let header = ConcurrentMerkleTreeHeader::try_from_slice(header_bytes)?;\n        header.assert_valid_authority(&ctx.accounts.authority.key())?;\n\n        let merkle_tree_size = merkle_tree_get_size(&header)?;\n        let (tree_bytes, canopy_bytes) = rest.split_at_mut(merkle_tree_size);\n\n        let id = ctx.accounts.merkle_tree.key();\n        assert_tree_is_empty(&header, id, tree_bytes)?;\n\n        // Close merkle tree account\n        // 1. Move lamports\n        let dest_starting_lamports = ctx.accounts.recipient.lamports();\n        **ctx.accounts.recipient.lamports.borrow_mut() = dest_starting_lamports\n            .checked_add(ctx.accounts.merkle_tree.lamports())\n            .unwrap();\n        **ctx.accounts.merkle_tree.lamports.borrow_mut() = 0;\n\n        // 2. Set all CMT account bytes to 0\n        header_bytes.fill(0);\n        tree_bytes.fill(0);\n        canopy_bytes.fill(0);\n\n        Ok(())\n    }",
    "pub fn new(id: Pubkey, path: Vec<PathNode>, seq: u64, index: u32) -> Self {\n        Self::V1(ChangeLogEventV1 {\n            id,\n            path,\n            seq,\n            index,\n        })\n    }",
    "pub fn initialize(\n        &mut self,\n        max_depth: u32,\n        max_buffer_size: u32,\n        authority: &Pubkey,\n        creation_slot: u64,\n    ) {\n        self.account_type = CompressionAccountType::ConcurrentMerkleTree;\n\n        match self.header {\n            ConcurrentMerkleTreeHeaderData::V1(ref mut header) => {\n                // Double check header is empty after deserialization from zero'd bytes\n                assert_eq!(header.max_buffer_size, 0);\n                assert_eq!(header.max_depth, 0);\n                header.max_buffer_size = max_buffer_size;\n                header.max_depth = max_depth;\n                header.authority = *authority;\n                header.creation_slot = creation_slot;\n                // is_batch_initialized is left false by default\n            }\n        }\n    }\n\n    /// Initializes the header with the given parameters and sets the `is_batch_initialized` flag to\n    /// true.\n    pub fn initialize_batched(\n        &mut self,\n        max_depth: u32,\n        max_buffer_size: u32,\n        authority: &Pubkey,\n        creation_slot: u64,\n    ) {\n        self.initialize(max_depth, max_buffer_size, authority, creation_slot);\n        match self.header {\n            ConcurrentMerkleTreeHeaderData::V1(ref mut header) => {\n                header.is_batch_initialized = true;\n            }\n        }\n    }\n\n    pub fn get_max_depth(&self) -> u32 {\n        match &self.header {\n            ConcurrentMerkleTreeHeaderData::V1(header) => header.max_depth,\n        }\n    }\n\n    pub fn get_max_buffer_size(&self) -> u32 {\n        match &self.header {\n            ConcurrentMerkleTreeHeaderData::V1(header) => header.max_buffer_size,\n        }\n    }\n\n    pub fn get_creation_slot(&self) -> u64 {\n        match &self.header {\n            ConcurrentMerkleTreeHeaderData::V1(header) => header.creation_slot,\n        }\n    }\n\n    pub fn get_is_batch_initialized(&self) -> bool {\n        match &self.header {\n            ConcurrentMerkleTreeHeaderData::V1(header) => header.is_batch_initialized,\n        }\n    }\n\n    pub fn set_new_authority(&mut self, new_authority: &Pubkey) {\n        match self.header {\n            ConcurrentMerkleTreeHeaderData::V1(ref mut header) => {\n                header.authority = new_authority.clone();\n                msg!(\"Authority transferred to: {:?}\", header.authority);\n            }\n        }\n    }\n\n    pub fn assert_valid(&self) -> Result<()> {\n        require_eq!(\n            self.account_type,\n            CompressionAccountType::ConcurrentMerkleTree,\n            AccountCompressionError::IncorrectAccountType,\n        );\n        Ok(())\n    }",
    "pub fn assert_valid_authority(&self, expected_authority: &Pubkey) -> Result<()> {\n        self.assert_valid()?;\n        match &self.header {\n            ConcurrentMerkleTreeHeaderData::V1(header) => {\n                require_eq!(\n                    header.authority,\n                    *expected_authority,\n                    AccountCompressionError::IncorrectAuthority,\n                );\n            }\n        }\n        Ok(())\n    }",
    "pub fn assert_valid_leaf_index(&self, leaf_index: u32) -> Result<()> {\n        if leaf_index >= (1 << self.get_max_depth()) {\n            return Err(AccountCompressionError::LeafIndexOutOfBounds.into());\n        }\n        Ok(())\n    }",
    "pub fn assert_is_batch_initialized(&self) -> Result<()> {\n        match &self.header {\n            ConcurrentMerkleTreeHeaderData::V1(header) => {\n                require!(\n                    header.is_batch_initialized,\n                    AccountCompressionError::BatchNotInitialized\n                );\n            }\n        }\n        Ok(())\n    }",
    "pub fn merkle_tree_get_size(header: &ConcurrentMerkleTreeHeader) -> Result<usize> {\n    // Note: max_buffer_size MUST be a power of 2\n    match (header.get_max_depth(), header.get_max_buffer_size()) {\n        (3, 8) => Ok(size_of::<ConcurrentMerkleTree<3, 8>>()),\n        (5, 8) => Ok(size_of::<ConcurrentMerkleTree<5, 8>>()),\n        (6, 16) => Ok(size_of::<ConcurrentMerkleTree<6, 16>>()),\n        (7, 16) => Ok(size_of::<ConcurrentMerkleTree<7, 16>>()),\n        (8, 16) => Ok(size_of::<ConcurrentMerkleTree<8, 16>>()),\n        (9, 16) => Ok(size_of::<ConcurrentMerkleTree<9, 16>>()),\n        (10, 32) => Ok(size_of::<ConcurrentMerkleTree<10, 32>>()),\n        (11, 32) => Ok(size_of::<ConcurrentMerkleTree<11, 32>>()),\n        (12, 32) => Ok(size_of::<ConcurrentMerkleTree<12, 32>>()),\n        (13, 32) => Ok(size_of::<ConcurrentMerkleTree<13, 32>>()),\n        (14, 64) => Ok(size_of::<ConcurrentMerkleTree<14, 64>>()),\n        (14, 256) => Ok(size_of::<ConcurrentMerkleTree<14, 256>>()),\n        (14, 1024) => Ok(size_of::<ConcurrentMerkleTree<14, 1024>>()),\n        (14, 2048) => Ok(size_of::<ConcurrentMerkleTree<14, 2048>>()),\n        (15, 64) => Ok(size_of::<ConcurrentMerkleTree<15, 64>>()),\n        (16, 64) => Ok(size_of::<ConcurrentMerkleTree<16, 64>>()),\n        (17, 64) => Ok(size_of::<ConcurrentMerkleTree<17, 64>>()),\n        (18, 64) => Ok(size_of::<ConcurrentMerkleTree<18, 64>>()),\n        (19, 64) => Ok(size_of::<ConcurrentMerkleTree<19, 64>>()),\n        (20, 64) => Ok(size_of::<ConcurrentMerkleTree<20, 64>>()),\n        (20, 256) => Ok(size_of::<ConcurrentMerkleTree<20, 256>>()),\n        (20, 1024) => Ok(size_of::<ConcurrentMerkleTree<20, 1024>>()),\n        (20, 2048) => Ok(size_of::<ConcurrentMerkleTree<20, 2048>>()),\n        (24, 64) => Ok(size_of::<ConcurrentMerkleTree<24, 64>>()),\n        (24, 256) => Ok(size_of::<ConcurrentMerkleTree<24, 256>>()),\n        (24, 512) => Ok(size_of::<ConcurrentMerkleTree<24, 512>>()),\n        (24, 1024) => Ok(size_of::<ConcurrentMerkleTree<24, 1024>>()),\n        (24, 2048) => Ok(size_of::<ConcurrentMerkleTree<24, 2048>>()),\n        (26, 512) => Ok(size_of::<ConcurrentMerkleTree<26, 512>>()),\n        (26, 1024) => Ok(size_of::<ConcurrentMerkleTree<26, 1024>>()),\n        (26, 2048) => Ok(size_of::<ConcurrentMerkleTree<26, 2048>>()),\n        (30, 512) => Ok(size_of::<ConcurrentMerkleTree<30, 512>>()),\n        (30, 1024) => Ok(size_of::<ConcurrentMerkleTree<30, 1024>>()),\n        (30, 2048) => Ok(size_of::<ConcurrentMerkleTree<30, 2048>>()),\n        _ => {\n            msg!(\n                \"Failed to get size of max depth {} and max buffer size {}\",\n                header.get_max_depth(),\n                header.get_max_buffer_size()\n            );\n            err!(AccountCompressionError::ConcurrentMerkleTreeConstantsError)\n        }",
    "pub fn noop(\n    _program_id: &Pubkey,\n    _accounts: &[AccountInfo],\n    _instruction_data: &[u8],\n) -> ProgramResult {\n    Ok(())\n}",
    "pub fn process(\n        program_id: &Pubkey,\n        accounts: &[AccountInfo],\n        instruction_data: &[u8],\n    ) -> ProgramResult {\n        let instruction = BinaryOptionInstruction::try_from_slice(instruction_data)?;\n        match instruction {\n            BinaryOptionInstruction::InitializeBinaryOption(args) => {\n                msg!(\"Instruction: InitializeBinaryOption\");\n                process_initialize_binary_option(program_id, accounts, args.decimals)\n            }",
    "pub fn process_initialize_binary_option(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    decimals: u8,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let binary_option_account_info = next_account_info(account_info_iter)?;\n    let escrow_mint_info = next_account_info(account_info_iter)?;\n    let escrow_account_info = next_account_info(account_info_iter)?;\n    let long_token_mint_info = next_account_info(account_info_iter)?;\n    let short_token_mint_info = next_account_info(account_info_iter)?;\n    let mint_authority_info = next_account_info(account_info_iter)?;\n    let update_authority_info = next_account_info(account_info_iter)?;\n    let token_program_info = next_account_info(account_info_iter)?;\n    let system_account_info = next_account_info(account_info_iter)?;\n    let rent_info = next_account_info(account_info_iter)?;\n\n    create_new_account(\n        mint_authority_info,\n        long_token_mint_info,\n        Mint::LEN,\n        token_program_info,\n        rent_info,\n    )?;\n    create_new_account(\n        mint_authority_info,\n        short_token_mint_info,\n        Mint::LEN,\n        token_program_info,\n        rent_info,\n    )?;\n    create_new_account(\n        update_authority_info,\n        escrow_account_info,\n        Account::LEN,\n        token_program_info,\n        rent_info,\n    )?;\n    spl_mint_initialize(\n        token_program_info,\n        long_token_mint_info,\n        mint_authority_info,\n        mint_authority_info,\n        rent_info,\n        0,\n    )?;\n    spl_mint_initialize(\n        token_program_info,\n        short_token_mint_info,\n        mint_authority_info,\n        mint_authority_info,\n        rent_info,\n        0,\n    )?;\n    spl_initialize(\n        token_program_info,\n        escrow_account_info,\n        escrow_mint_info,\n        update_authority_info,\n        rent_info,\n    )?;\n\n    assert_keys_equal(*token_program_info.key, spl_token::id())?;\n\n    // Transfer ownership of the escrow accounts to a PDA\n    let (authority_key, _) = Pubkey::find_program_address(\n        &[\n            long_token_mint_info.key.as_ref(),\n            short_token_mint_info.key.as_ref(),\n            token_program_info.key.as_ref(),\n            program_id.as_ref(),\n        ],\n        program_id,\n    );\n    spl_set_authority(\n        token_program_info,\n        escrow_account_info,\n        Some(authority_key),\n        AuthorityType::AccountOwner,\n        update_authority_info,\n    )?;\n    spl_set_authority(\n        token_program_info,\n        long_token_mint_info,\n        Some(authority_key),\n        AuthorityType::MintTokens,\n        update_authority_info,\n    )?;\n    spl_set_authority(\n        token_program_info,\n        short_token_mint_info,\n        Some(authority_key),\n        AuthorityType::MintTokens,\n        update_authority_info,\n    )?;\n\n    create_or_allocate_account_raw(\n        *program_id,\n        binary_option_account_info,\n        rent_info,\n        system_account_info,\n        update_authority_info,\n        BinaryOption::LEN,\n    )?;\n\n    let mut binary_option =\n        BinaryOption::try_from_slice(&binary_option_account_info.data.borrow_mut())?;\n    binary_option.decimals = decimals;\n    binary_option.circulation = 0;\n    binary_option.settled = false;\n    binary_option.long_mint_account_pubkey = *long_token_mint_info.key;\n    binary_option.short_mint_account_pubkey = *short_token_mint_info.key;\n    binary_option.escrow_mint_account_pubkey = *escrow_mint_info.key;\n    binary_option.escrow_account_pubkey = *escrow_account_info.key;\n    binary_option.owner = *update_authority_info.key;\n    borsh::to_writer(\n        &mut binary_option_account_info.data.borrow_mut()[..],\n        &binary_option,\n    )?;\n    Ok(())\n}",
    "pub fn process_trade(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    size: u64,\n    buy_price: u64,\n    sell_price: u64,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let binary_option_account_info = next_account_info(account_info_iter)?;\n    let escrow_account_info = next_account_info(account_info_iter)?;\n    let long_token_mint_info = next_account_info(account_info_iter)?;\n    let short_token_mint_info = next_account_info(account_info_iter)?;\n    let buyer_info = next_account_info(account_info_iter)?;\n    let seller_info = next_account_info(account_info_iter)?;\n    let buyer_account_info = next_account_info(account_info_iter)?;\n    let seller_account_info = next_account_info(account_info_iter)?;\n    let buyer_long_token_account_info = next_account_info(account_info_iter)?;\n    let buyer_short_token_account_info = next_account_info(account_info_iter)?;\n    let seller_long_token_account_info = next_account_info(account_info_iter)?;\n    let seller_short_token_account_info = next_account_info(account_info_iter)?;\n    let authority_info = next_account_info(account_info_iter)?;\n    let token_program_info = next_account_info(account_info_iter)?;\n\n    // Unpack accounts\n    let long_token_mint: Mint = assert_initialized(long_token_mint_info)?;\n    let short_token_mint: Mint = assert_initialized(short_token_mint_info)?;\n    let buyer_long_token_account: Account = assert_initialized(buyer_long_token_account_info)?;\n    let buyer_short_token_account: Account = assert_initialized(buyer_short_token_account_info)?;\n    let seller_long_token_account: Account = assert_initialized(seller_long_token_account_info)?;\n    let seller_short_token_account: Account = assert_initialized(seller_short_token_account_info)?;\n    let buyer_account: Account = assert_initialized(buyer_account_info)?;\n    let seller_account: Account = assert_initialized(seller_account_info)?;\n    let mut binary_option =\n        BinaryOption::try_from_slice(&binary_option_account_info.data.borrow_mut())?;\n\n    // Get program derived address for escrow\n    let (authority_key, bump_seed) = Pubkey::find_program_address(\n        &[\n            long_token_mint_info.key.as_ref(),\n            short_token_mint_info.key.as_ref(),\n            token_program_info.key.as_ref(),\n            program_id.as_ref(),\n        ],\n        program_id,\n    );\n    let seeds = &[\n        long_token_mint_info.key.as_ref(),\n        short_token_mint_info.key.as_ref(),\n        token_program_info.key.as_ref(),\n        program_id.as_ref(),\n        &[bump_seed],\n    ];\n\n    // Validate data\n    let total_price = buy_price\n        .checked_add(sell_price)\n        .ok_or(BinaryOptionError::TradePricesIncorrect)?;\n    if total_price != u64::pow(10, binary_option.decimals as u32) {\n        return Err(BinaryOptionError::TradePricesIncorrect.into());\n    }\n    if binary_option.settled {\n        return Err(BinaryOptionError::AlreadySettled.into());\n    }\n    assert_keys_equal(*token_program_info.key, spl_token::id())?;\n    assert_keys_unequal(*buyer_info.key, *seller_info.key)?;\n    assert_keys_equal(*long_token_mint_info.owner, spl_token::id())?;\n    assert_keys_equal(*short_token_mint_info.owner, spl_token::id())?;\n    assert_keys_equal(buyer_long_token_account.owner, *buyer_info.key)?;\n    assert_keys_equal(buyer_short_token_account.owner, *buyer_info.key)?;\n    assert_keys_equal(seller_long_token_account.owner, *seller_info.key)?;\n    assert_keys_equal(seller_short_token_account.owner, *seller_info.key)?;\n    assert_keys_equal(buyer_account.owner, *buyer_info.key)?;\n    assert_keys_equal(seller_account.owner, *seller_info.key)?;\n    assert_keys_equal(authority_key, *authority_info.key)?;\n    assert_keys_equal(\n        *long_token_mint_info.key,\n        binary_option.long_mint_account_pubkey,\n    )?;\n    assert_keys_equal(\n        *short_token_mint_info.key,\n        binary_option.short_mint_account_pubkey,\n    )?;\n    assert_keys_equal(\n        *escrow_account_info.key,\n        binary_option.escrow_account_pubkey,\n    )?;\n    assert_keys_equal(\n        buyer_long_token_account.mint,\n        binary_option.long_mint_account_pubkey,\n    )?;\n    assert_keys_equal(\n        buyer_short_token_account.mint,\n        binary_option.short_mint_account_pubkey,\n    )?;\n    assert_keys_equal(\n        seller_long_token_account.mint,\n        binary_option.long_mint_account_pubkey,\n    )?;\n    assert_keys_equal(\n        seller_short_token_account.mint,\n        binary_option.short_mint_account_pubkey,\n    )?;\n    assert_keys_equal(buyer_account.mint, binary_option.escrow_mint_account_pubkey)?;\n    assert_keys_equal(\n        seller_account.mint,\n        binary_option.escrow_mint_account_pubkey,\n    )?;\n\n    let n = size;\n    let n_b = buyer_short_token_account.amount;\n    let n_s = seller_long_token_account.amount;\n\n    let mut b_l = buyer_long_token_account.amount;\n    let mut b_s = n_b;\n    let mut s_l = n_s;\n    let mut s_s = seller_short_token_account.amount;\n\n    match [n_b >= n, n_s >= n] {\n        /*\n        When n is less than both n_b and n_s, this means that both buyer and seller are simply reducing their existing inventory.\n        Therefore, we can just remove n long tokens and n short tokens from circulation. Both parties are also entitled to the locked up\n        funds for their positions that were closed. This always results in a decrease in total circulation.\n        */\n        [true, true] => {\n            msg!(\"Case 1\");\n            spl_burn(\n                token_program_info,\n                buyer_short_token_account_info,\n                short_token_mint_info,\n                buyer_info,\n                n,\n            )?;\n            spl_burn(\n                token_program_info,\n                seller_long_token_account_info,\n                long_token_mint_info,\n                seller_info,\n                n,\n            )?;\n            spl_token_transfer_signed(\n                token_program_info,\n                escrow_account_info,\n                buyer_account_info,\n                authority_info,\n                n * sell_price,\n                seeds,\n            )?;\n            spl_token_transfer_signed(\n                token_program_info,\n                escrow_account_info,\n                seller_account_info,\n                authority_info,\n                n * buy_price,\n                seeds,\n            )?;\n            b_s -= n;\n            s_l -= n;\n            binary_option.decrement_supply(n)?;\n        }\n        /*\n        When n is greater than both n_b and n_s, this means that both buyer and seller have put on a position that is different from their\n        existing position. We will first burn the tokens of representing the opposite position and then mint new tokens to ensure the buyer's\n        change is +n and the seller's change is -n. Both parties are also entitled to the locked up funds for their positions that were closed.\n        The net change in tokens can be calculated as follows: (-n_b - n_s + 2n - n_b - n_s) / 2 = n - n_b - n_s. If this quantity is positive, this\n        means that the trade causes a net increase in the total supply of contracts in the betting pool. Otherwise, it results in a net decrease\n        in total circulation.\n        */\n        [false, false] => {\n            msg!(\"Case 2\");\n            spl_burn(\n                token_program_info,\n                buyer_short_token_account_info,\n                short_token_mint_info,\n                buyer_info,\n                n_b,\n            )?;\n            spl_burn(\n                token_program_info,\n                seller_long_token_account_info,\n                long_token_mint_info,\n                seller_info,\n                n_s,\n            )?;\n            b_s -= n_b;\n            s_l -= n_s;\n            spl_mint_to(\n                token_program_info,\n                buyer_long_token_account_info,\n                long_token_mint_info,\n                authority_info,\n                n - n_b,\n                seeds,\n            )?;\n            spl_mint_to(\n                token_program_info,\n                seller_short_token_account_info,\n                short_token_mint_info,\n                authority_info,\n                n - n_s,\n                seeds,\n            )?;\n            b_l += n - n_b;\n            s_s += n - n_s;\n            spl_token_transfer(\n                token_program_info,\n                buyer_account_info,\n                escrow_account_info,\n                buyer_info,\n                (n - n_b) * buy_price,\n            )?;\n            spl_token_transfer(\n                token_program_info,\n                seller_account_info,\n                escrow_account_info,\n                seller_info,\n                (n - n_s) * sell_price,\n            )?;\n            spl_token_transfer_signed(\n                token_program_info,\n                escrow_account_info,\n                buyer_account_info,\n                authority_info,\n                n_b * sell_price,\n                seeds,\n            )?;\n            spl_token_transfer_signed(\n                token_program_info,\n                escrow_account_info,\n                seller_account_info,\n                authority_info,\n                n_s * buy_price,\n                seeds,\n            )?;\n            if n > n_b + n_s {\n                binary_option.increment_supply(n - n_b - n_s)?;\n            } else {\n                binary_option.decrement_supply(n - n_b - n_s)?;\n            }\n        }\n        /*\n        When n is greater than n_b but less than n_s, this means that the buyer has put on a position that is different from their\n        existing position, and the seller has reduced their inventory. We will burn and mint tokens such the buyer's net change in\n        position is +n and the seller's net change is -n. Both parties are also entitled to the locked up funds for their positions that were closed.\n        The net change in tokens can be calculated as follows: (-n - n_s + n - n_s) / 2 = -n_s. This always results in a decrease in total\n        circulation.\n        */\n        [true, false] => {\n            msg!(\"Case 3\");\n            spl_burn(\n                token_program_info,\n                buyer_short_token_account_info,\n                short_token_mint_info,\n                buyer_info,\n                n,\n            )?;\n            spl_burn(\n                token_program_info,\n                seller_long_token_account_info,\n                long_token_mint_info,\n                seller_info,\n                n_s,\n            )?;\n            b_s -= n;\n            s_l -= n_s;\n            spl_mint_to(\n                token_program_info,\n                seller_short_token_account_info,\n                short_token_mint_info,\n                authority_info,\n                n - n_s,\n                seeds,\n            )?;\n            s_s += n - n_s;\n            spl_token_transfer(\n                token_program_info,\n                seller_account_info,\n                escrow_account_info,\n                seller_info,\n                (n - n_s) * sell_price,\n            )?;\n            spl_token_transfer_signed(\n                token_program_info,\n                escrow_account_info,\n                seller_account_info,\n                authority_info,\n                n_s * buy_price,\n                seeds,\n            )?;\n            spl_token_transfer_signed(\n                token_program_info,\n                escrow_account_info,\n                buyer_account_info,\n                authority_info,\n                n * sell_price,\n                seeds,\n            )?;\n            binary_option.decrement_supply(n_s)?;\n        }\n        /*\n        When n is greater than n_s bust less than n_b, this means that the seller has put on a position that is different from their\n        existing position, and the buyer has reduced their inventory. We will burn and mint tokens such the buyer's net change in\n        position is +n and the seller's net change is -n. Both parties are also entitled to the locked up funds for their positions that were closed.\n        The net change in tokens can be calculated as follows: (-n - n_b + n - n_b) / 2 = -n_b. This always results in a decrease in total\n        circulation.\n        */\n        [false, true] => {\n            msg!(\"Case 4\");\n            spl_burn(\n                token_program_info,\n                seller_long_token_account_info,\n                long_token_mint_info,\n                seller_info,\n                n,\n            )?;\n            spl_burn(\n                token_program_info,\n                buyer_short_token_account_info,\n                short_token_mint_info,\n                buyer_info,\n                n_b,\n            )?;\n            b_s -= n_b;\n            s_l -= n;\n            spl_mint_to(\n                token_program_info,\n                buyer_long_token_account_info,\n                long_token_mint_info,\n                authority_info,\n                n - n_b,\n                seeds,\n            )?;\n            b_l += n - n_b;\n            spl_token_transfer(\n                token_program_info,\n                buyer_account_info,\n                escrow_account_info,\n                buyer_info,\n                (n - n_b) * buy_price,\n            )?;\n            spl_token_transfer_signed(\n                token_program_info,\n                escrow_account_info,\n                buyer_account_info,\n                authority_info,\n                n_b * sell_price,\n                seeds,\n            )?;\n            spl_token_transfer_signed(\n                token_program_info,\n                escrow_account_info,\n                seller_account_info,\n                authority_info,\n                n * buy_price,\n                seeds,\n            )?;\n            binary_option.decrement_supply(n_b)?;\n        }\n    }\n    // Delegate the burn authority to the PDA, so a private key is unnecessary on\n    // collection This can probably be optimized to reduce the number of\n    // instructions needed at some point\n    spl_approve(\n        token_program_info,\n        buyer_long_token_account_info,\n        long_token_mint_info,\n        authority_info,\n        buyer_info,\n        b_l,\n        long_token_mint.decimals,\n    )?;\n    spl_approve(\n        token_program_info,\n        seller_short_token_account_info,\n        short_token_mint_info,\n        authority_info,\n        seller_info,\n        s_s,\n        short_token_mint.decimals,\n    )?;\n    spl_approve(\n        token_program_info,\n        buyer_short_token_account_info,\n        short_token_mint_info,\n        authority_info,\n        buyer_info,\n        b_s,\n        short_token_mint.decimals,\n    )?;\n    spl_approve(\n        token_program_info,\n        seller_long_token_account_info,\n        long_token_mint_info,\n        authority_info,\n        seller_info,\n        s_l,\n        long_token_mint.decimals,\n    )?;\n    borsh::to_writer(\n        &mut binary_option_account_info.data.borrow_mut()[..],\n        &binary_option,\n    )?;\n    Ok(())\n}",
    "pub fn process_settle(_program_id: &Pubkey, accounts: &[AccountInfo]) -> ProgramResult {\n    // This should NEVER be called directly (otherwise this is literally a rug)\n    // The `pool_owner_info` needs to approve this action, so the recommended use\n    // case is to have a higher level program own the pool and use an oracle to\n    // resolve settlements\n    let account_info_iter = &mut accounts.iter();\n    let binary_option_account_info = next_account_info(account_info_iter)?;\n    let winning_mint_account_info = next_account_info(account_info_iter)?;\n    let pool_owner_info = next_account_info(account_info_iter)?;\n\n    let mut binary_option =\n        BinaryOption::try_from_slice(&binary_option_account_info.data.borrow_mut())?;\n    if !pool_owner_info.is_signer {\n        return Err(ProgramError::MissingRequiredSignature);\n    }\n    if binary_option.settled {\n        return Err(BinaryOptionError::AlreadySettled.into());\n    }\n\n    assert_keys_equal(*pool_owner_info.key, binary_option.owner)?;\n    if *winning_mint_account_info.key == binary_option.long_mint_account_pubkey\n        || *winning_mint_account_info.key == binary_option.short_mint_account_pubkey\n    {\n        binary_option.winning_side_pubkey = *winning_mint_account_info.key;\n    } else {\n        return Err(BinaryOptionError::InvalidWinner.into());\n    }\n    binary_option.settled = true;\n    borsh::to_writer(\n        &mut binary_option_account_info.data.borrow_mut()[..],\n        &binary_option,\n    )?;\n    Ok(())\n}",
    "pub fn process_collect(program_id: &Pubkey, accounts: &[AccountInfo]) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let binary_option_account_info = next_account_info(account_info_iter)?;\n    let collector_info = next_account_info(account_info_iter)?;\n    let collector_long_token_account_info = next_account_info(account_info_iter)?;\n    let collector_short_token_account_info = next_account_info(account_info_iter)?;\n    let collector_account_info = next_account_info(account_info_iter)?;\n    let long_token_mint_info = next_account_info(account_info_iter)?;\n    let short_token_mint_info = next_account_info(account_info_iter)?;\n    let escrow_account_info = next_account_info(account_info_iter)?;\n    let escrow_authority_info = next_account_info(account_info_iter)?;\n    let token_program_info = next_account_info(account_info_iter)?;\n\n    let collector_long_token_account: Account =\n        assert_initialized(collector_long_token_account_info)?;\n    let collector_short_token_account: Account =\n        assert_initialized(collector_short_token_account_info)?;\n    let collector_account: Account = assert_initialized(collector_account_info)?;\n    let escrow_account: Account = assert_initialized(escrow_account_info)?;\n    let mut binary_option =\n        BinaryOption::try_from_slice(&binary_option_account_info.data.borrow_mut())?;\n\n    // Get program derived address for escrow\n    let (escrow_owner_key, bump_seed) = Pubkey::find_program_address(\n        &[\n            long_token_mint_info.key.as_ref(),\n            short_token_mint_info.key.as_ref(),\n            token_program_info.key.as_ref(),\n            program_id.as_ref(),\n        ],\n        program_id,\n    );\n    let seeds = &[\n        long_token_mint_info.key.as_ref(),\n        short_token_mint_info.key.as_ref(),\n        token_program_info.key.as_ref(),\n        program_id.as_ref(),\n        &[bump_seed],\n    ];\n\n    if !binary_option.settled {\n        return Err(BinaryOptionError::BetNotSettled.into());\n    }\n    assert_owned_by(long_token_mint_info, &spl_token::id())?;\n    assert_owned_by(short_token_mint_info, &spl_token::id())?;\n    assert_keys_equal(collector_long_token_account.owner, *collector_info.key)?;\n    assert_keys_equal(collector_short_token_account.owner, *collector_info.key)?;\n    assert_keys_equal(collector_account.owner, *collector_info.key)?;\n    assert_keys_equal(escrow_owner_key, *escrow_authority_info.key)?;\n    assert_keys_equal(\n        *long_token_mint_info.key,\n        binary_option.long_mint_account_pubkey,\n    )?;\n    assert_keys_equal(\n        *short_token_mint_info.key,\n        binary_option.short_mint_account_pubkey,\n    )?;\n    assert_keys_equal(\n        *escrow_account_info.key,\n        binary_option.escrow_account_pubkey,\n    )?;\n    assert_keys_equal(\n        collector_long_token_account.mint,\n        binary_option.long_mint_account_pubkey,\n    )?;\n    assert_keys_equal(\n        collector_short_token_account.mint,\n        binary_option.short_mint_account_pubkey,\n    )?;\n    assert_keys_equal(\n        collector_account.mint,\n        binary_option.escrow_mint_account_pubkey,\n    )?;\n\n    let reward = if collector_long_token_account.mint == binary_option.winning_side_pubkey {\n        collector_long_token_account.amount\n    } else if collector_short_token_account.mint == binary_option.winning_side_pubkey {\n        collector_short_token_account.amount\n    } else {\n        return Err(BinaryOptionError::TokenNotFoundInPool.into());\n    };\n\n    spl_burn_signed(\n        token_program_info,\n        collector_long_token_account_info,\n        long_token_mint_info,\n        escrow_authority_info,\n        collector_long_token_account.amount,\n        seeds,\n    )?;\n    spl_burn_signed(\n        token_program_info,\n        collector_short_token_account_info,\n        short_token_mint_info,\n        escrow_authority_info,\n        collector_short_token_account.amount,\n        seeds,\n    )?;\n    if reward > 0 {\n        let amount = reward\n            .checked_mul(escrow_account.amount)\n            .ok_or(BinaryOptionError::AmountOverflow)?;\n        let amount = amount / binary_option.circulation;\n        spl_token_transfer_signed(\n            token_program_info,\n            escrow_account_info,\n            collector_account_info,\n            escrow_authority_info,\n            amount,\n            seeds,\n        )?;\n        binary_option.decrement_supply(reward)?;\n    }\n    borsh::to_writer(\n        &mut binary_option_account_info.data.borrow_mut()[..],\n        &binary_option,\n    )?;\n    Ok(())\n}",
    "pub fn from_account_info(a: &AccountInfo) -> Result<BinaryOption, ProgramError> {\n        let binary_option = BinaryOption::try_from_slice(&a.data.borrow_mut())?;\n        Ok(binary_option)\n    }",
    "pub fn increment_supply(&mut self, n: u64) -> ProgramResult {\n        self.circulation = self\n            .circulation\n            .checked_add(n)\n            .ok_or(BinaryOptionError::AmountOverflow)?;\n        Ok(())\n    }",
    "pub fn decrement_supply(&mut self, n: u64) -> ProgramResult {\n        if self.circulation < n {\n            return Err(BinaryOptionError::InvalidSupply.into());\n        }\n        self.circulation -= n;\n        Ok(())\n    }",
    "pub fn assert_keys_equal(key1: Pubkey, key2: Pubkey) -> ProgramResult {\n    if key1 != key2 {\n        Err(BinaryOptionError::PublicKeyMismatch.into())\n    }",
    "pub fn assert_keys_unequal(key1: Pubkey, key2: Pubkey) -> ProgramResult {\n    if key1 == key2 {\n        Err(BinaryOptionError::PublicKeysShouldBeUnique.into())\n    }",
    "pub fn assert_owned_by(account: &AccountInfo, owner: &Pubkey) -> ProgramResult {\n    if account.owner != owner {\n        Err(BinaryOptionError::IncorrectOwner.into())\n    }",
    "pub fn init_pool(\n    program_id: &Pubkey,\n    pool: &Pubkey,\n    authority: &Pubkey,\n    decider: &Pubkey,\n    deposit_token_mint: &Pubkey,\n    deposit_account: &Pubkey,\n    token_pass_mint: &Pubkey,\n    token_fail_mint: &Pubkey,\n    token_program_id: &Pubkey,\n    init_args: InitArgs,\n) -> Result<Instruction, ProgramError> {\n    let init_data = PoolInstruction::InitPool(init_args);\n    let data = borsh::to_vec(&init_data)?;\n    let accounts = vec![\n        AccountMeta::new(*pool, false),\n        AccountMeta::new_readonly(*authority, false),\n        AccountMeta::new_readonly(*decider, false),\n        AccountMeta::new_readonly(*deposit_token_mint, false),\n        AccountMeta::new(*deposit_account, false),\n        AccountMeta::new(*token_pass_mint, false),\n        AccountMeta::new(*token_fail_mint, false),\n        AccountMeta::new_readonly(sysvar::rent::id(), false),\n        AccountMeta::new_readonly(*token_program_id, false),\n    ];\n    Ok(Instruction {\n        program_id: *program_id,\n        accounts,\n        data,\n    })\n}",
    "pub fn deposit(\n    program_id: &Pubkey,\n    pool: &Pubkey,\n    authority: &Pubkey,\n    user_transfer_authority: &Pubkey,\n    user_token_account: &Pubkey,\n    pool_deposit_token_account: &Pubkey,\n    token_pass_mint: &Pubkey,\n    token_fail_mint: &Pubkey,\n    token_pass_destination_account: &Pubkey,\n    token_fail_destination_account: &Pubkey,\n    token_program_id: &Pubkey,\n    amount: u64,\n) -> Result<Instruction, ProgramError> {\n    let init_data = PoolInstruction::Deposit(amount);\n    let data = borsh::to_vec(&init_data)?;\n\n    let accounts = vec![\n        AccountMeta::new_readonly(*pool, false),\n        AccountMeta::new_readonly(*authority, false),\n        AccountMeta::new_readonly(\n            *user_transfer_authority,\n            authority != user_transfer_authority,\n        ),\n        AccountMeta::new(*user_token_account, false),\n        AccountMeta::new(*pool_deposit_token_account, false),\n        AccountMeta::new(*token_pass_mint, false),\n        AccountMeta::new(*token_fail_mint, false),\n        AccountMeta::new(*token_pass_destination_account, false),\n        AccountMeta::new(*token_fail_destination_account, false),\n        AccountMeta::new_readonly(sysvar::clock::id(), false),\n        AccountMeta::new_readonly(*token_program_id, false),\n    ];\n    Ok(Instruction {\n        program_id: *program_id,\n        accounts,\n        data,\n    })\n}",
    "pub fn withdraw(\n    program_id: &Pubkey,\n    pool: &Pubkey,\n    authority: &Pubkey,\n    user_transfer_authority: &Pubkey,\n    pool_deposit_token_account: &Pubkey,\n    token_pass_user_account: &Pubkey,\n    token_fail_user_account: &Pubkey,\n    token_pass_mint: &Pubkey,\n    token_fail_mint: &Pubkey,\n    user_token_destination_account: &Pubkey,\n    token_program_id: &Pubkey,\n    amount: u64,\n) -> Result<Instruction, ProgramError> {\n    let init_data = PoolInstruction::Withdraw(amount);\n    let data = borsh::to_vec(&init_data)?;\n    let accounts = vec![\n        AccountMeta::new_readonly(*pool, false),\n        AccountMeta::new_readonly(*authority, false),\n        AccountMeta::new_readonly(\n            *user_transfer_authority,\n            authority != user_transfer_authority,\n        ),\n        AccountMeta::new(*pool_deposit_token_account, false),\n        AccountMeta::new(*token_pass_user_account, false),\n        AccountMeta::new(*token_fail_user_account, false),\n        AccountMeta::new(*token_pass_mint, false),\n        AccountMeta::new(*token_fail_mint, false),\n        AccountMeta::new(*user_token_destination_account, false),\n        AccountMeta::new_readonly(sysvar::clock::id(), false),\n        AccountMeta::new_readonly(*token_program_id, false),\n    ];\n    Ok(Instruction {\n        program_id: *program_id,\n        accounts,\n        data,\n    })\n}",
    "pub fn decide(\n    program_id: &Pubkey,\n    pool: &Pubkey,\n    decider: &Pubkey,\n    decision: bool,\n) -> Result<Instruction, ProgramError> {\n    let init_data = PoolInstruction::Decide(decision);\n    let data = borsh::to_vec(&init_data)?;\n    let accounts = vec![\n        AccountMeta::new(*pool, false),\n        AccountMeta::new_readonly(*decider, true),\n        AccountMeta::new_readonly(sysvar::clock::id(), false),\n    ];\n    Ok(Instruction {\n        program_id: *program_id,\n        accounts,\n        data,\n    })\n}",
    "pub fn authority_id(\n        program_id: &Pubkey,\n        my_info: &Pubkey,\n        bump_seed: u8,\n    ) -> Result<Pubkey, ProgramError> {\n        Pubkey::create_program_address(&[&my_info.to_bytes()[..32], &[bump_seed]], program_id)\n            .map_err(|_| PoolError::InvalidAuthorityData.into())\n    }",
    "pub fn process_init_pool(\n        program_id: &Pubkey,\n        accounts: &[AccountInfo],\n        mint_end_slot: Slot,\n        decide_end_slot: Slot,\n        bump_seed: u8,\n    ) -> ProgramResult {\n        let account_info_iter = &mut accounts.iter();\n        let pool_account_info = next_account_info(account_info_iter)?;\n        let authority_info = next_account_info(account_info_iter)?;\n        let decider_info = next_account_info(account_info_iter)?;\n        let deposit_token_mint_info = next_account_info(account_info_iter)?;\n        let deposit_account_info = next_account_info(account_info_iter)?;\n        let token_pass_mint_info = next_account_info(account_info_iter)?;\n        let token_fail_mint_info = next_account_info(account_info_iter)?;\n        let rent_info = next_account_info(account_info_iter)?;\n        let rent = &Rent::from_account_info(rent_info)?;\n        let token_program_info = next_account_info(account_info_iter)?;\n\n        let mut pool = Pool::try_from_slice(&pool_account_info.data.borrow())?;\n        // Pool account should not be already initialized\n        if pool.is_initialized() {\n            return Err(PoolError::AlreadyInUse.into());\n        }\n\n        // Check if pool account is rent-exempt\n        if !rent.is_exempt(pool_account_info.lamports(), pool_account_info.data_len()) {\n            return Err(PoolError::NotRentExempt.into());\n        }\n\n        // Check if deposit token's mint owner is token program\n        if deposit_token_mint_info.owner != token_program_info.key {\n            return Err(PoolError::InvalidTokenMint.into());\n        }\n\n        // Check if deposit token mint is initialized\n        let deposit_token_mint = Mint::unpack(&deposit_token_mint_info.data.borrow())?;\n\n        // Check if bump seed is correct\n        let authority = Self::authority_id(program_id, pool_account_info.key, bump_seed)?;\n        if &authority != authority_info.key {\n            return Err(PoolError::InvalidAuthorityAccount.into());\n        }\n\n        let deposit_account = Account::unpack_unchecked(&deposit_account_info.data.borrow())?;\n        if deposit_account.is_initialized() {\n            return Err(PoolError::DepositAccountInUse.into());\n        }\n\n        let token_pass = Mint::unpack_unchecked(&token_pass_mint_info.data.borrow())?;\n        if token_pass.is_initialized() {\n            return Err(PoolError::TokenMintInUse.into());\n        }\n\n        let token_fail = Mint::unpack_unchecked(&token_fail_mint_info.data.borrow())?;\n        if token_fail.is_initialized() {\n            return Err(PoolError::TokenMintInUse.into());\n        }\n\n        invoke(\n            &spl_token::instruction::initialize_account(\n                token_program_info.key,\n                deposit_account_info.key,\n                deposit_token_mint_info.key,\n                authority_info.key,\n            )\n            .unwrap(),\n            &[\n                token_program_info.clone(),\n                deposit_account_info.clone(),\n                deposit_token_mint_info.clone(),\n                authority_info.clone(),\n                rent_info.clone(),\n            ],\n        )?;\n\n        invoke(\n            &spl_token::instruction::initialize_mint(\n                &spl_token::id(),\n                token_pass_mint_info.key,\n                authority_info.key,\n                None,\n                deposit_token_mint.decimals,\n            )\n            .unwrap(),\n            &[\n                token_program_info.clone(),\n                token_pass_mint_info.clone(),\n                rent_info.clone(),\n            ],\n        )?;\n\n        invoke(\n            &spl_token::instruction::initialize_mint(\n                &spl_token::id(),\n                token_fail_mint_info.key,\n                authority_info.key,\n                None,\n                deposit_token_mint.decimals,\n            )\n            .unwrap(),\n            &[\n                token_program_info.clone(),\n                token_fail_mint_info.clone(),\n                rent_info.clone(),\n            ],\n        )?;\n\n        pool.version = POOL_VERSION;\n        pool.bump_seed = bump_seed;\n        pool.token_program_id = *token_program_info.key;\n        pool.deposit_account = *deposit_account_info.key;\n        pool.token_pass_mint = *token_pass_mint_info.key;\n        pool.token_fail_mint = *token_fail_mint_info.key;\n        pool.decider = *decider_info.key;\n        pool.mint_end_slot = mint_end_slot;\n        pool.decide_end_slot = decide_end_slot;\n        pool.decision = Decision::Undecided;\n\n        borsh::to_writer(&mut pool_account_info.data.borrow_mut()[..], &pool).map_err(|e| e.into())\n    }",
    "pub fn process_deposit(\n        program_id: &Pubkey,\n        accounts: &[AccountInfo],\n        amount: u64,\n    ) -> ProgramResult {\n        let account_info_iter = &mut accounts.iter();\n        let pool_account_info = next_account_info(account_info_iter)?;\n        let authority_account_info = next_account_info(account_info_iter)?;\n        let user_transfer_authority_info = next_account_info(account_info_iter)?;\n        let user_token_account_info = next_account_info(account_info_iter)?;\n        let pool_deposit_token_account_info = next_account_info(account_info_iter)?;\n        let token_pass_mint_info = next_account_info(account_info_iter)?;\n        let token_fail_mint_info = next_account_info(account_info_iter)?;\n        let token_pass_destination_account_info = next_account_info(account_info_iter)?;\n        let token_fail_destination_account_info = next_account_info(account_info_iter)?;\n        let clock_info = next_account_info(account_info_iter)?;\n        let clock = &Clock::from_account_info(clock_info)?;\n        let token_program_id_info = next_account_info(account_info_iter)?;\n\n        if amount == 0 {\n            return Err(PoolError::InvalidAmount.into());\n        }\n\n        let pool = Pool::try_from_slice(&pool_account_info.data.borrow())?;\n\n        if clock.slot > pool.mint_end_slot {\n            return Err(PoolError::InvalidSlotForDeposit.into());\n        }\n\n        let authority_pub_key =\n            Self::authority_id(program_id, pool_account_info.key, pool.bump_seed)?;\n        if *authority_account_info.key != authority_pub_key {\n            return Err(PoolError::InvalidAuthorityAccount.into());\n        }\n\n        // Transfer deposit tokens from user's account to our deposit account\n        Self::transfer(\n            token_program_id_info.clone(),\n            user_token_account_info.clone(),\n            pool_deposit_token_account_info.clone(),\n            authority_account_info.clone(),\n            user_transfer_authority_info.clone(),\n            amount,\n            pool_account_info.key,\n            pool.bump_seed,\n        )?;\n\n        // Mint PASS tokens to user account\n        Self::mint(\n            token_program_id_info.clone(),\n            token_pass_mint_info.clone(),\n            token_pass_destination_account_info.clone(),\n            authority_account_info.clone(),\n            amount,\n            pool_account_info.key,\n            pool.bump_seed,\n        )?;\n        // Mint FAIL tokens to user account\n        Self::mint(\n            token_program_id_info.clone(),\n            token_fail_mint_info.clone(),\n            token_fail_destination_account_info.clone(),\n            authority_account_info.clone(),\n            amount,\n            pool_account_info.key,\n            pool.bump_seed,\n        )?;\n\n        Ok(())\n    }",
    "pub fn process_withdraw(\n        program_id: &Pubkey,\n        accounts: &[AccountInfo],\n        amount: u64,\n    ) -> ProgramResult {\n        let account_info_iter = &mut accounts.iter();\n        let pool_account_info = next_account_info(account_info_iter)?;\n        let authority_account_info = next_account_info(account_info_iter)?;\n        let user_transfer_authority_info = next_account_info(account_info_iter)?;\n        let pool_deposit_token_account_info = next_account_info(account_info_iter)?;\n        let token_pass_user_account_info = next_account_info(account_info_iter)?;\n        let token_fail_user_account_info = next_account_info(account_info_iter)?;\n        let token_pass_mint_info = next_account_info(account_info_iter)?;\n        let token_fail_mint_info = next_account_info(account_info_iter)?;\n        let user_token_destination_account_info = next_account_info(account_info_iter)?;\n        let clock_info = next_account_info(account_info_iter)?;\n        let clock = &Clock::from_account_info(clock_info)?;\n        let token_program_id_info = next_account_info(account_info_iter)?;\n\n        if amount == 0 {\n            return Err(PoolError::InvalidAmount.into());\n        }\n\n        let user_pass_token_account = Account::unpack(&token_pass_user_account_info.data.borrow())?;\n        let user_fail_token_account = Account::unpack(&token_fail_user_account_info.data.borrow())?;\n\n        let pool = Pool::try_from_slice(&pool_account_info.data.borrow())?;\n\n        if pool.token_pass_mint != *token_pass_mint_info.key {\n            return Err(PoolError::InvalidTokenMint.into());\n        }\n        if pool.token_fail_mint != *token_fail_mint_info.key {\n            return Err(PoolError::InvalidTokenMint.into());\n        }\n        let authority_pub_key =\n            Self::authority_id(program_id, pool_account_info.key, pool.bump_seed)?;\n        if *authority_account_info.key != authority_pub_key {\n            return Err(PoolError::InvalidAuthorityAccount.into());\n        }\n\n        match pool.decision {\n            Decision::Pass => {\n                // Burn PASS tokens\n                Self::burn(\n                    token_program_id_info.clone(),\n                    token_pass_user_account_info.clone(),\n                    token_pass_mint_info.clone(),\n                    authority_account_info.clone(),\n                    user_transfer_authority_info.clone(),\n                    amount,\n                    pool_account_info.key,\n                    pool.bump_seed,\n                )?;\n\n                // Transfer deposit tokens from pool deposit account to user destination account\n                Self::transfer(\n                    token_program_id_info.clone(),\n                    pool_deposit_token_account_info.clone(),\n                    user_token_destination_account_info.clone(),\n                    authority_account_info.clone(),\n                    authority_account_info.clone(),\n                    amount,\n                    pool_account_info.key,\n                    pool.bump_seed,\n                )?;\n            }\n            Decision::Fail => {\n                // Burn FAIL tokens\n                Self::burn(\n                    token_program_id_info.clone(),\n                    token_fail_user_account_info.clone(),\n                    token_fail_mint_info.clone(),\n                    authority_account_info.clone(),\n                    user_transfer_authority_info.clone(),\n                    amount,\n                    pool_account_info.key,\n                    pool.bump_seed,\n                )?;\n\n                // Transfer deposit tokens from pool deposit account to user destination account\n                Self::transfer(\n                    token_program_id_info.clone(),\n                    pool_deposit_token_account_info.clone(),\n                    user_token_destination_account_info.clone(),\n                    authority_account_info.clone(),\n                    authority_account_info.clone(),\n                    amount,\n                    pool_account_info.key,\n                    pool.bump_seed,\n                )?;\n            }\n            Decision::Undecided => {\n                let current_slot = clock.slot;\n                if current_slot < pool.mint_end_slot || current_slot > pool.decide_end_slot {\n                    let possible_withdraw_amount = amount\n                        .min(user_pass_token_account.amount)\n                        .min(user_fail_token_account.amount);\n\n                    // Burn PASS tokens\n                    Self::burn(\n                        token_program_id_info.clone(),\n                        token_pass_user_account_info.clone(),\n                        token_pass_mint_info.clone(),\n                        authority_account_info.clone(),\n                        user_transfer_authority_info.clone(),\n                        possible_withdraw_amount,\n                        pool_account_info.key,\n                        pool.bump_seed,\n                    )?;\n\n                    // Burn FAIL tokens\n                    Self::burn(\n                        token_program_id_info.clone(),\n                        token_fail_user_account_info.clone(),\n                        token_fail_mint_info.clone(),\n                        authority_account_info.clone(),\n                        user_transfer_authority_info.clone(),\n                        amount,\n                        pool_account_info.key,\n                        pool.bump_seed,\n                    )?;\n\n                    // Transfer deposit tokens from pool deposit account to user destination account\n                    Self::transfer(\n                        token_program_id_info.clone(),\n                        pool_deposit_token_account_info.clone(),\n                        user_token_destination_account_info.clone(),\n                        authority_account_info.clone(),\n                        authority_account_info.clone(),\n                        amount,\n                        pool_account_info.key,\n                        pool.bump_seed,\n                    )?;\n                } else {\n                    return Err(PoolError::NoDecisionMadeYet.into());\n                }\n            }\n        }\n\n        Ok(())\n    }",
    "pub fn process_decide(\n        _program_id: &Pubkey,\n        accounts: &[AccountInfo],\n        decision: bool,\n    ) -> ProgramResult {\n        let account_info_iter = &mut accounts.iter();\n        let pool_account_info = next_account_info(account_info_iter)?;\n        let decider_account_info = next_account_info(account_info_iter)?;\n        let clock_info = next_account_info(account_info_iter)?;\n        let clock = &Clock::from_account_info(clock_info)?;\n\n        let mut pool = Pool::try_from_slice(&pool_account_info.data.borrow())?;\n\n        if *decider_account_info.key != pool.decider {\n            return Err(PoolError::WrongDeciderAccount.into());\n        }\n\n        if !decider_account_info.is_signer {\n            return Err(PoolError::SignatureMissing.into());\n        }\n\n        if pool.decision != Decision::Undecided {\n            return Err(PoolError::DecisionAlreadyMade.into());\n        }\n\n        let current_slot = clock.slot;\n        if current_slot < pool.mint_end_slot || current_slot > pool.decide_end_slot {\n            return Err(PoolError::InvalidSlotForDecision.into());\n        }\n\n        pool.decision = if decision {\n            Decision::Pass\n        } else {\n            Decision::Fail\n        };\n\n        borsh::to_writer(&mut pool_account_info.data.borrow_mut()[..], &pool).map_err(|e| e.into())\n    }",
    "pub fn process_instruction(\n        program_id: &Pubkey,\n        accounts: &[AccountInfo],\n        input: &[u8],\n    ) -> ProgramResult {\n        let instruction = PoolInstruction::try_from_slice(input)?;\n        match instruction {\n            PoolInstruction::InitPool(init_args) => {\n                msg!(\"Instruction: InitPool\");\n                Self::process_init_pool(\n                    program_id,\n                    accounts,\n                    init_args.mint_end_slot,\n                    init_args.decide_end_slot,\n                    init_args.bump_seed,\n                )\n            }",
    "pub fn program_test() -> ProgramTest {\n    ProgramTest::new(\n        \"spl_binary_oracle_pair\",\n        id(),\n        processor!(processor::Processor::process_instruction),\n    )\n}",
    "pub fn new() -> Self {\n        let pool_account = Keypair::new();\n        let (authority, bump_seed) =\n            Pubkey::find_program_address(&[&pool_account.pubkey().to_bytes()[..32]], &id());\n        Self {\n            pool_account,\n            authority,\n            bump_seed,\n            deposit_token_mint: Keypair::new(),\n            deposit_token_mint_owner: Keypair::new(),\n            pool_deposit_account: Keypair::new(),\n            token_pass_mint: Keypair::new(),\n            token_fail_mint: Keypair::new(),\n            decider: Keypair::new(),\n            mint_end_slot: 2,\n            decide_end_slot: 2000,\n        }\n    }\n\n    pub async fn init_pool(\n        &self,\n        banks_client: &mut BanksClient,\n        payer: &Keypair,\n        recent_blockhash: &Hash,\n    ) {\n        let rent = banks_client.get_rent().await.unwrap();\n        let pool_rent = rent.minimum_balance(state::Pool::LEN);\n        let mint_rent = rent.minimum_balance(spl_token::state::Mint::LEN);\n        let account_rent = rent.minimum_balance(spl_token::state::Account::LEN);\n\n        // create pool account\n        create_account(\n            banks_client,\n            payer,\n            recent_blockhash,\n            &self.pool_account,\n            pool_rent,\n            state::Pool::LEN as u64,\n            &id(),\n        )\n        .await\n        .unwrap();\n\n        // create mint of deposit token\n        create_mint(\n            banks_client,\n            payer,\n            recent_blockhash,\n            &self.deposit_token_mint,\n            mint_rent,\n            &self.deposit_token_mint_owner.pubkey(),\n        )\n        .await\n        .unwrap();\n\n        let init_args = instruction::InitArgs {\n            mint_end_slot: self.mint_end_slot,\n            decide_end_slot: self.decide_end_slot,\n            bump_seed: self.bump_seed,\n        };\n\n        let mut transaction = Transaction::new_with_payer(\n            &[\n                system_instruction::create_account(\n                    &payer.pubkey(),\n                    &self.pool_deposit_account.pubkey(),\n                    account_rent,\n                    spl_token::state::Account::LEN as u64,\n                    &spl_token::id(),\n                ),\n                system_instruction::create_account(\n                    &payer.pubkey(),\n                    &self.token_pass_mint.pubkey(),\n                    mint_rent,\n                    spl_token::state::Mint::LEN as u64,\n                    &spl_token::id(),\n                ),\n                system_instruction::create_account(\n                    &payer.pubkey(),\n                    &self.token_fail_mint.pubkey(),\n                    mint_rent,\n                    spl_token::state::Mint::LEN as u64,\n                    &spl_token::id(),\n                ),\n                instruction::init_pool(\n                    &id(),\n                    &self.pool_account.pubkey(),\n                    &self.authority,\n                    &self.decider.pubkey(),\n                    &self.deposit_token_mint.pubkey(),\n                    &self.pool_deposit_account.pubkey(),\n                    &self.token_pass_mint.pubkey(),\n                    &self.token_fail_mint.pubkey(),\n                    &spl_token::id(),\n                    init_args,\n                )\n                .unwrap(),\n            ],\n            Some(&payer.pubkey()),\n        );\n\n        transaction.sign(\n            &[\n                payer,\n                &self.pool_deposit_account,\n                &self.token_pass_mint,\n                &self.token_fail_mint,\n            ],\n            *recent_blockhash,\n        );\n        banks_client.process_transaction(transaction).await.unwrap();\n    }\n\n    #[allow(clippy::too_many_arguments)]\n    pub async fn prepare_accounts_for_deposit(\n        &self,\n        banks_client: &mut BanksClient,\n        payer: &Keypair,\n        recent_blockhash: &Hash,\n        deposit_tokens_to_mint: u64,\n        deposit_tokens_for_allowance: u64,\n        user_account: &Keypair,\n        authority: &Pubkey,\n        user_account_owner: &Keypair,\n        user_pass_account: &Keypair,\n        user_fail_account: &Keypair,\n    ) {\n        // Create user account\n        create_token_account(\n            banks_client,\n            payer,\n            recent_blockhash,\n            user_account,\n            &self.deposit_token_mint.pubkey(),\n            &user_account_owner.pubkey(),\n        )\n        .await\n        .unwrap();\n\n        // Mint to him some deposit tokens\n        mint_tokens_to(\n            banks_client,\n            payer,\n            recent_blockhash,\n            &self.deposit_token_mint.pubkey(),\n            &user_account.pubkey(),\n            &self.deposit_token_mint_owner,\n            deposit_tokens_to_mint,\n        )\n        .await\n        .unwrap();\n\n        // Give allowance to pool authority\n        approve_delegate(\n            banks_client,\n            payer,\n            recent_blockhash,\n            &user_account.pubkey(),\n            authority,\n            user_account_owner,\n            deposit_tokens_for_allowance,\n        )\n        .await\n        .unwrap();\n\n        // Create token accounts for PASS and FAIL tokens\n        create_token_account(\n            banks_client,\n            payer,\n            recent_blockhash,\n            user_pass_account,\n            &self.token_pass_mint.pubkey(),\n            &user_account_owner.pubkey(),\n        )\n        .await\n        .unwrap();\n\n        create_token_account(\n            banks_client,\n            payer,\n            recent_blockhash,\n            user_fail_account,\n            &self.token_fail_mint.pubkey(),\n            &user_account_owner.pubkey(),\n        )\n        .await\n        .unwrap();\n    }\n\n    #[allow(clippy::too_many_arguments)]\n    pub async fn make_deposit(\n        &self,\n        banks_client: &mut BanksClient,\n        payer: &Keypair,\n        recent_blockhash: &Hash,\n        user_account: &Keypair,\n        user_pass_account: &Keypair,\n        user_fail_account: &Keypair,\n        deposit_amount: u64,\n    ) {\n        let mut transaction = Transaction::new_with_payer(\n            &[instruction::deposit(\n                &id(),\n                &self.pool_account.pubkey(),\n                &self.authority,\n                &self.authority,\n                &user_account.pubkey(),\n                &self.pool_deposit_account.pubkey(),\n                &self.token_pass_mint.pubkey(),\n                &self.token_fail_mint.pubkey(),\n                &user_pass_account.pubkey(),\n                &user_fail_account.pubkey(),\n                &spl_token::id(),\n                deposit_amount,\n            )\n            .unwrap()],\n            Some(&payer.pubkey()),\n        );\n        transaction.sign(&[payer], *recent_blockhash);\n        banks_client.process_transaction(transaction).await.unwrap();\n    }\n\n    #[allow(clippy::too_many_arguments)]\n    pub async fn make_deposit_with_user_transfer_authority(\n        &self,\n        banks_client: &mut BanksClient,\n        payer: &Keypair,\n        recent_blockhash: &Hash,\n        user_account: &Keypair,\n        user_authority: &Keypair,\n        user_pass_account: &Keypair,\n        user_fail_account: &Keypair,\n        deposit_amount: u64,\n    ) {\n        let mut transaction = Transaction::new_with_payer(\n            &[instruction::deposit(\n                &id(),\n                &self.pool_account.pubkey(),\n                &self.authority,\n                &user_authority.pubkey(),\n                &user_account.pubkey(),\n                &self.pool_deposit_account.pubkey(),\n                &self.token_pass_mint.pubkey(),\n                &self.token_fail_mint.pubkey(),\n                &user_pass_account.pubkey(),\n                &user_fail_account.pubkey(),\n                &spl_token::id(),\n                deposit_amount,\n            )\n            .unwrap()],\n            Some(&payer.pubkey()),\n        );\n        transaction.sign(&[payer, user_authority], *recent_blockhash);\n        banks_client.process_transaction(transaction).await.unwrap();\n    }\n}\nimpl Default for TestPool {\n    fn default() -> Self {\n        Self::new()\n    }",
    "pub fn process_instruction(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    instruction_data: &[u8],\n) -> ProgramResult {\n    // Create in iterator to safety reference accounts in the slice\n    let account_info_iter = &mut accounts.iter();\n\n    // Account info for the program being invoked\n    let system_program_info = next_account_info(account_info_iter)?;\n    // Account info to allocate\n    let allocated_info = next_account_info(account_info_iter)?;\n\n    let expected_allocated_key =\n        Pubkey::create_program_address(&[b\"You pass butter\", &[instruction_data[0]]], program_id)?;\n    if *allocated_info.key != expected_allocated_key {\n        // allocated key does not match the derived address\n        return Err(ProgramError::InvalidArgument);\n    }\n\n    // Invoke the system program to allocate account data\n    invoke_signed(\n        &system_instruction::allocate(allocated_info.key, SIZE as u64),\n        // Order doesn't matter and this slice could include all the accounts and be:\n        // `&accounts`\n        &[\n            system_program_info.clone(), // program being invoked also needs to be included\n            allocated_info.clone(),\n        ],\n        &[&[b\"You pass butter\", &[instruction_data[0]]]],\n    )?;\n\n    Ok(())\n}",
    "pub fn process_instruction(\n    _program_id: &Pubkey,\n    _accounts: &[AccountInfo],\n    _instruction_data: &[u8],\n) -> ProgramResult {\n    let vec = vec![42_u8; 5];\n    sol_log_slice(&vec);\n    Ok(())\n}",
    "pub fn process_instruction(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    instruction_data: &[u8],\n) -> ProgramResult {\n    // Log a string\n    msg!(\"static string\");\n\n    // Log a slice\n    sol_log_slice(instruction_data);\n\n    // Log a formatted message, use with caution can be expensive\n    msg!(\"formatted {}: {:?}\", \"message\", instruction_data);\n\n    // Log a public key\n    program_id.log();\n\n    // Log all the program's input parameters\n    sol_log_params(accounts, instruction_data);\n\n    // Log the number of compute units remaining that the program can consume.\n    sol_log_compute_units();\n\n    Ok(())\n}",
    "pub fn process_instruction(\n    _program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    _instruction_data: &[u8],\n) -> ProgramResult {\n    // Create in iterator to safety reference accounts in the slice\n    let account_info_iter = &mut accounts.iter();\n\n    // Get the clock sysvar via syscall\n    let clock_via_sysvar = Clock::get()?;\n    // Or deserialize the account into a clock struct\n    let clock_sysvar_info = next_account_info(account_info_iter)?;\n    let clock_via_account = Clock::from_account_info(clock_sysvar_info)?;\n    // Both produce the same sysvar\n    assert_eq!(clock_via_sysvar, clock_via_account);\n    // Note: `format!` can be very expensive, use cautiously\n    msg!(\"{:?}\", clock_via_sysvar);\n\n    // Get the rent sysvar via syscall\n    let rent_via_sysvar = Rent::get()?;\n    // Or deserialize the account into a rent struct\n    let rent_sysvar_info = next_account_info(account_info_iter)?;\n    let rent_via_account = Rent::from_account_info(rent_sysvar_info)?;\n    // Both produce the same sysvar\n    assert_eq!(rent_via_sysvar, rent_via_account);\n    // Can't print `exemption_threshold` because BPF does not support printing\n    // floats\n    msg!(\n        \"Rent: lamports_per_byte_year: {:?}, burn_percent: {:?}\",\n        rent_via_sysvar.lamports_per_byte_year,\n        rent_via_sysvar.burn_percent\n    );\n\n    Ok(())\n}",
    "pub fn process_instruction(\n    _program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    _instruction_data: &[u8],\n) -> ProgramResult {\n    // Create an iterator to safely reference accounts in the slice\n    let account_info_iter = &mut accounts.iter();\n\n    // As part of the program specification the first account is the source\n    // account and the second is the destination account\n    let source_info = next_account_info(account_info_iter)?;\n    let destination_info = next_account_info(account_info_iter)?;\n\n    // Withdraw five lamports from the source\n    **source_info.try_borrow_mut_lamports()? -= 5;\n    // Deposit five lamports into the destination\n    **destination_info.try_borrow_mut_lamports()? += 5;\n\n    Ok(())\n}",
    "pub fn process_instruction(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    _instruction_data: &[u8],\n) -> ProgramResult {\n    // Create an iterator to safely reference accounts in the slice\n    let account_info_iter = &mut accounts.iter();\n\n    // As part of the program specification the instruction gives:\n    let source_info = next_account_info(account_info_iter)?; // 1.\n    let mint_info = next_account_info(account_info_iter)?; // 2.\n    let destination_info = next_account_info(account_info_iter)?; // 3.\n    let authority_info = next_account_info(account_info_iter)?; // 4.\n    let token_program_info = next_account_info(account_info_iter)?; // 5.\n\n    // In order to transfer from the source account, owned by the program-derived\n    // address, we must have the correct address and seeds.\n    let (expected_authority, bump_seed) = Pubkey::find_program_address(&[b\"authority\"], program_id);\n    if expected_authority != *authority_info.key {\n        return Err(ProgramError::InvalidSeeds);\n    }\n\n    // The program transfers everything out of its account, so extract that from\n    // the account data.\n    let source_account = Account::unpack(&source_info.try_borrow_data()?)?;\n    let amount = source_account.amount;\n\n    // The program uses `transfer_checked`, which requires the number of decimals\n    // in the mint, so extract that from the account data too.\n    let mint = Mint::unpack(&mint_info.try_borrow_data()?)?;\n    let decimals = mint.decimals;\n\n    // Invoke the transfer\n    msg!(\"Attempting to transfer {} tokens\", amount);\n    invoke_signed(\n        &transfer_checked(\n            token_program_info.key,\n            source_info.key,\n            mint_info.key,\n            destination_info.key,\n            authority_info.key,\n            &[], // no multisig allowed\n            amount,\n            decimals,\n        )\n        .unwrap(),\n        &[\n            source_info.clone(),\n            mint_info.clone(),\n            destination_info.clone(),\n            authority_info.clone(),\n            token_program_info.clone(), // not required, but better for clarity\n        ],\n        &[&[b\"authority\", &[bump_seed]]],\n    )\n}",
    "pub fn process_instruction(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    input: &[u8],\n) -> ProgramResult {\n    let instruction = VoterWeightAddinInstruction::try_from_slice(input)\n        .map_err(|_| ProgramError::InvalidInstructionData)?;\n\n    msg!(\"GOVERNANCE-VOTER-WEIGHT-INSTRUCTION: {:?}\", instruction);\n\n    match instruction {\n        VoterWeightAddinInstruction::SetupVoterWeightRecord {\n            voter_weight,\n            voter_weight_expiry,\n            weight_action,\n            weight_action_target,\n        } => process_setup_voter_weight_record(\n            program_id,\n            accounts,\n            voter_weight,\n            voter_weight_expiry,\n            weight_action,\n            weight_action_target,\n        ),\n        VoterWeightAddinInstruction::SetupMaxVoterWeightRecord {\n            max_voter_weight,\n            max_voter_weight_expiry,\n        } => process_setup_max_voter_weight_record(\n            program_id,\n            accounts,\n            max_voter_weight,\n            max_voter_weight_expiry,\n        ),\n    }\n}\n\n/// Processes SetupVoterWeightRecord instruction\npub fn process_setup_voter_weight_record(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    voter_weight: u64,\n    voter_weight_expiry: Option<Slot>,\n    weight_action: Option<VoterWeightAction>,\n    weight_action_target: Option<Pubkey>,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n\n    let realm_info = next_account_info(account_info_iter)?; // 0\n    let governing_token_mint_info = next_account_info(account_info_iter)?; // 1\n    let governing_token_owner_info = next_account_info(account_info_iter)?; // 2\n    let voter_weight_record_info = next_account_info(account_info_iter)?; // 3\n    let payer_info = next_account_info(account_info_iter)?; // 4\n    let system_info = next_account_info(account_info_iter)?; // 5\n\n    let voter_weight_record_data = VoterWeightRecord {\n        account_discriminator: VoterWeightRecord::ACCOUNT_DISCRIMINATOR,\n        realm: *realm_info.key,\n        governing_token_mint: *governing_token_mint_info.key,\n        governing_token_owner: *governing_token_owner_info.key,\n        voter_weight,\n        voter_weight_expiry,\n        weight_action,\n        weight_action_target,\n        reserved: [0; 8],\n    };\n\n    create_and_serialize_account(\n        payer_info,\n        voter_weight_record_info,\n        &voter_weight_record_data,\n        program_id,\n        system_info,\n    )?;\n\n    Ok(())\n}",
    "pub fn process_setup_max_voter_weight_record(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    max_voter_weight: u64,\n    max_voter_weight_expiry: Option<Slot>,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n\n    let realm_info = next_account_info(account_info_iter)?; // 0\n    let governing_token_mint_info = next_account_info(account_info_iter)?; // 1\n    let max_voter_weight_record_info = next_account_info(account_info_iter)?; // 2\n    let payer_info = next_account_info(account_info_iter)?; // 3\n    let system_info = next_account_info(account_info_iter)?; // 4\n\n    let max_voter_weight_record_data = MaxVoterWeightRecord {\n        account_discriminator: MaxVoterWeightRecord::ACCOUNT_DISCRIMINATOR,\n        realm: *realm_info.key,\n        governing_token_mint: *governing_token_mint_info.key,\n        max_voter_weight,\n        max_voter_weight_expiry,\n        reserved: [0; 8],\n    };\n\n    create_and_serialize_account(\n        payer_info,\n        max_voter_weight_record_info,\n        &max_voter_weight_record_data,\n        program_id,\n        system_info,\n    )?;\n\n    Ok(())\n}",
    "pub fn process_instruction(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    input: &[u8],\n) -> ProgramResult {\n    msg!(\"VERSION:{:?}\", env!(\"CARGO_PKG_VERSION\"));\n\n    let instruction = GovernanceChatInstruction::try_from_slice(input)\n        .map_err(|_| ProgramError::InvalidInstructionData)?;\n\n    match instruction {\n        GovernanceChatInstruction::PostMessage { body, is_reply } => {\n            msg!(\"GOVERNANCE-CHAT-INSTRUCTION: PostMessage\");\n            process_post_message(program_id, accounts, body, is_reply)\n        }",
    "pub fn process_post_message(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    body: MessageBody,\n    is_reply: bool,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n\n    let governance_program_info = next_account_info(account_info_iter)?; // 0\n    let realm_info = next_account_info(account_info_iter)?; // 1\n    let governance_info = next_account_info(account_info_iter)?; // 2\n    let proposal_info = next_account_info(account_info_iter)?; // 3\n    let token_owner_record_info = next_account_info(account_info_iter)?; // 4\n    let governance_authority_info = next_account_info(account_info_iter)?; // 5\n\n    let chat_message_info = next_account_info(account_info_iter)?; // 6\n\n    let payer_info = next_account_info(account_info_iter)?; // 7\n    let system_info = next_account_info(account_info_iter)?; // 8\n\n    let reply_to_address = if is_reply {\n        let reply_to_info = next_account_info(account_info_iter)?; // 9\n        assert_is_valid_chat_message(program_id, reply_to_info)?;\n        Some(*reply_to_info.key)\n    }",
    "pub fn assert_is_valid_chat_message(\n    program_id: &Pubkey,\n    chat_message_info: &AccountInfo,\n) -> Result<(), ProgramError> {\n    assert_is_valid_account_of_type(\n        program_id,\n        chat_message_info,\n        GovernanceChatAccountType::ChatMessage,\n    )\n}",
    "pub fn create_realm(\n    program_id: &Pubkey,\n    // Accounts\n    realm_authority: &Pubkey,\n    community_token_mint: &Pubkey,\n    payer: &Pubkey,\n    council_token_mint: Option<Pubkey>,\n    // Accounts Args\n    community_token_config_args: Option<GoverningTokenConfigAccountArgs>,\n    council_token_config_args: Option<GoverningTokenConfigAccountArgs>,\n    // Args\n    name: String,\n    min_community_weight_to_create_governance: u64,\n    community_mint_max_voter_weight_source: MintMaxVoterWeightSource,\n) -> Instruction {\n    let realm_address = get_realm_address(program_id, &name);\n    let community_token_holding_address =\n        get_governing_token_holding_address(program_id, &realm_address, community_token_mint);\n\n    let mut accounts = vec![\n        AccountMeta::new(realm_address, false),\n        AccountMeta::new_readonly(*realm_authority, false),\n        AccountMeta::new_readonly(*community_token_mint, false),\n        AccountMeta::new(community_token_holding_address, false),\n        AccountMeta::new(*payer, true),\n        AccountMeta::new_readonly(system_program::id(), false),\n        AccountMeta::new_readonly(spl_token::id(), false),\n        AccountMeta::new_readonly(sysvar::rent::id(), false),\n    ];\n\n    let use_council_mint = if let Some(council_token_mint) = council_token_mint {\n        let council_token_holding_address =\n            get_governing_token_holding_address(program_id, &realm_address, &council_token_mint);\n\n        accounts.push(AccountMeta::new_readonly(council_token_mint, false));\n        accounts.push(AccountMeta::new(council_token_holding_address, false));\n        true\n    } else {\n        false\n    };\n\n    let realm_config_address = get_realm_config_address(program_id, &realm_address);\n    accounts.push(AccountMeta::new(realm_config_address, false));\n\n    let community_token_config_args =\n        with_governing_token_config_args(&mut accounts, community_token_config_args);\n\n    let council_token_config_args =\n        with_governing_token_config_args(&mut accounts, council_token_config_args);\n\n    let instruction = GovernanceInstruction::CreateRealm {\n        config_args: RealmConfigArgs {\n            use_council_mint,\n            min_community_weight_to_create_governance,\n            community_mint_max_voter_weight_source,\n            community_token_config_args,\n            council_token_config_args,\n        },\n        name,\n    };\n\n    Instruction {\n        program_id: *program_id,\n        accounts,\n        data: borsh::to_vec(&instruction).unwrap(),\n    }\n}\n\n/// Creates DepositGoverningTokens instruction\n#[allow(clippy::too_many_arguments)]\npub fn deposit_governing_tokens(\n    program_id: &Pubkey,\n    // Accounts\n    realm: &Pubkey,\n    governing_token_source: &Pubkey,\n    governing_token_owner: &Pubkey,\n    governing_token_source_authority: &Pubkey,\n    payer: &Pubkey,\n    // Args\n    amount: u64,\n    governing_token_mint: &Pubkey,\n) -> Instruction {\n    let token_owner_record_address = get_token_owner_record_address(\n        program_id,\n        realm,\n        governing_token_mint,\n        governing_token_owner,\n    );\n\n    let governing_token_holding_address =\n        get_governing_token_holding_address(program_id, realm, governing_token_mint);\n\n    let realm_config_address = get_realm_config_address(program_id, realm);\n\n    let accounts = vec![\n        AccountMeta::new_readonly(*realm, false),\n        AccountMeta::new(governing_token_holding_address, false),\n        AccountMeta::new(*governing_token_source, false),\n        AccountMeta::new_readonly(*governing_token_owner, true),\n        AccountMeta::new_readonly(*governing_token_source_authority, true),\n        AccountMeta::new(token_owner_record_address, false),\n        AccountMeta::new(*payer, true),\n        AccountMeta::new_readonly(system_program::id(), false),\n        AccountMeta::new_readonly(spl_token::id(), false),\n        AccountMeta::new_readonly(realm_config_address, false),\n    ];\n\n    let instruction = GovernanceInstruction::DepositGoverningTokens { amount };\n\n    Instruction {\n        program_id: *program_id,\n        accounts,\n        data: borsh::to_vec(&instruction).unwrap(),\n    }\n}\n\n/// Creates WithdrawGoverningTokens instruction\npub fn withdraw_governing_tokens(\n    program_id: &Pubkey,\n    // Accounts\n    realm: &Pubkey,\n    governing_token_destination: &Pubkey,\n    governing_token_owner: &Pubkey,\n    // Args\n    governing_token_mint: &Pubkey,\n) -> Instruction {\n    let token_owner_record_address = get_token_owner_record_address(\n        program_id,\n        realm,\n        governing_token_mint,\n        governing_token_owner,\n    );\n\n    let governing_token_holding_address =\n        get_governing_token_holding_address(program_id, realm, governing_token_mint);\n\n    let realm_config_address = get_realm_config_address(program_id, realm);\n\n    let accounts = vec![\n        AccountMeta::new_readonly(*realm, false),\n        AccountMeta::new(governing_token_holding_address, false),\n        AccountMeta::new(*governing_token_destination, false),\n        AccountMeta::new_readonly(*governing_token_owner, true),\n        AccountMeta::new(token_owner_record_address, false),\n        AccountMeta::new_readonly(spl_token::id(), false),\n        AccountMeta::new_readonly(realm_config_address, false),\n    ];\n\n    let instruction = GovernanceInstruction::WithdrawGoverningTokens {};\n\n    Instruction {\n        program_id: *program_id,\n        accounts,\n        data: borsh::to_vec(&instruction).unwrap(),\n    }\n}\n\n/// Creates SetGovernanceDelegate instruction\npub fn set_governance_delegate(\n    program_id: &Pubkey,\n    // Accounts\n    governance_authority: &Pubkey,\n    // Args\n    realm: &Pubkey,\n    governing_token_mint: &Pubkey,\n    governing_token_owner: &Pubkey,\n    new_governance_delegate: &Option<Pubkey>,\n) -> Instruction {\n    let vote_record_address = get_token_owner_record_address(\n        program_id,\n        realm,\n        governing_token_mint,\n        governing_token_owner,\n    );\n\n    let accounts = vec![\n        AccountMeta::new_readonly(*governance_authority, true),\n        AccountMeta::new(vote_record_address, false),\n    ];\n\n    let instruction = GovernanceInstruction::SetGovernanceDelegate {\n        new_governance_delegate: *new_governance_delegate,\n    };\n\n    Instruction {\n        program_id: *program_id,\n        accounts,\n        data: borsh::to_vec(&instruction).unwrap(),\n    }\n}\n\n/// Creates CreateGovernance instruction using optional voter weight addin\n#[allow(clippy::too_many_arguments)]\npub fn create_governance(\n    program_id: &Pubkey,\n    // Accounts\n    realm: &Pubkey,\n    governance_seed: &Pubkey,\n    token_owner_record: &Pubkey,\n    payer: &Pubkey,\n    create_authority: &Pubkey,\n    voter_weight_record: Option<Pubkey>,\n    // Args\n    config: GovernanceConfig,\n) -> Instruction {\n    let governance_address = get_governance_address(program_id, realm, governance_seed);\n\n    let mut accounts = vec![\n        AccountMeta::new_readonly(*realm, false),\n        AccountMeta::new(governance_address, false),\n        AccountMeta::new_readonly(*governance_seed, false),\n        AccountMeta::new_readonly(*token_owner_record, false),\n        AccountMeta::new(*payer, true),\n        AccountMeta::new_readonly(system_program::id(), false),\n        AccountMeta::new_readonly(*create_authority, true),\n    ];\n\n    with_realm_config_accounts(program_id, &mut accounts, realm, voter_weight_record, None);\n\n    let instruction = GovernanceInstruction::CreateGovernance { config };\n\n    Instruction {\n        program_id: *program_id,\n        accounts,\n        data: borsh::to_vec(&instruction).unwrap(),\n    }\n}\n\n/// Creates CreateProposal instruction\n#[allow(clippy::too_many_arguments)]\npub fn create_proposal(\n    program_id: &Pubkey,\n    // Accounts\n    governance: &Pubkey,\n    proposal_owner_record: &Pubkey,\n    governance_authority: &Pubkey,\n    payer: &Pubkey,\n    voter_weight_record: Option<Pubkey>,\n    // Args\n    realm: &Pubkey,\n    name: String,\n    description_link: String,\n    governing_token_mint: &Pubkey,\n    vote_type: VoteType,\n    options: Vec<String>,\n    use_deny_option: bool,\n    proposal_seed: &Pubkey,\n) -> Instruction {\n    let proposal_address =\n        get_proposal_address(program_id, governance, governing_token_mint, proposal_seed);\n\n    let mut accounts = vec![\n        AccountMeta::new_readonly(*realm, false),\n        AccountMeta::new(proposal_address, false),\n        AccountMeta::new(*governance, false),\n        AccountMeta::new(*proposal_owner_record, false),\n        AccountMeta::new_readonly(*governing_token_mint, false),\n        AccountMeta::new_readonly(*governance_authority, true),\n        AccountMeta::new(*payer, true),\n        AccountMeta::new_readonly(system_program::id(), false),\n    ];\n\n    with_realm_config_accounts(program_id, &mut accounts, realm, voter_weight_record, None);\n\n    // Deposit is only required when there are more active proposal then the\n    // configured exempt amount Note: We always pass the account because the\n    // actual value is not known here without passing Governance account data\n    let proposal_deposit_address =\n        get_proposal_deposit_address(program_id, &proposal_address, payer);\n    accounts.push(AccountMeta::new(proposal_deposit_address, false));\n\n    let instruction = GovernanceInstruction::CreateProposal {\n        name,\n        description_link,\n        vote_type,\n        options,\n        use_deny_option,\n        proposal_seed: *proposal_seed,\n    };\n\n    Instruction {\n        program_id: *program_id,\n        accounts,\n        data: borsh::to_vec(&instruction).unwrap(),\n    }\n}\n\n/// Creates AddSignatory instruction\npub fn add_signatory(\n    program_id: &Pubkey,\n    // Accounts\n    governance: &Pubkey,\n    proposal: &Pubkey,\n    add_signatory_authority: &AddSignatoryAuthority,\n    payer: &Pubkey,\n    // Args\n    signatory: &Pubkey,\n) -> Instruction {\n    let signatory_record_address = get_signatory_record_address(program_id, proposal, signatory);\n\n    let mut accounts = vec![\n        AccountMeta::new_readonly(*governance, false),\n        AccountMeta::new(*proposal, false),\n        AccountMeta::new(signatory_record_address, false),\n        AccountMeta::new(*payer, true),\n        AccountMeta::new_readonly(system_program::id(), false),\n    ];\n\n    match add_signatory_authority {\n        AddSignatoryAuthority::ProposalOwner {\n            governance_authority,\n            token_owner_record,\n        } => {\n            accounts.push(AccountMeta::new_readonly(*token_owner_record, false));\n            accounts.push(AccountMeta::new_readonly(*governance_authority, true));\n        }\n        AddSignatoryAuthority::None => {\n            accounts.push(AccountMeta::new_readonly(\n                get_required_signatory_address(program_id, governance, signatory),\n                false,\n            ));\n        }\n    };\n\n    let instruction = GovernanceInstruction::AddSignatory {\n        signatory: *signatory,\n    };\n\n    Instruction {\n        program_id: *program_id,\n        accounts,\n        data: borsh::to_vec(&instruction).unwrap(),\n    }\n}\n\n#[derive(Debug, Copy, Clone)]\n/// Enum to specify the authority by which the instruction should add a\n/// signatory\npub enum AddSignatoryAuthority {\n    /// Proposal owners can add optional signatories to a proposal\n    ProposalOwner {\n        /// Token owner or its delegate\n        governance_authority: Pubkey,\n        /// Token owner record of the Proposal owner\n        token_owner_record: Pubkey,\n    },\n    /// Anyone can add signatories that are required by the governance to a\n    /// proposal\n    None,\n}\n\n/// Creates SignOffProposal instruction\npub fn sign_off_proposal(\n    program_id: &Pubkey,\n    // Accounts\n    realm: &Pubkey,\n    governance: &Pubkey,\n    proposal: &Pubkey,\n    signatory: &Pubkey,\n    proposal_owner_record: Option<&Pubkey>,\n) -> Instruction {\n    let mut accounts = vec![\n        AccountMeta::new_readonly(*realm, false),\n        AccountMeta::new_readonly(*governance, false),\n        AccountMeta::new(*proposal, false),\n        AccountMeta::new_readonly(*signatory, true),\n    ];\n\n    if let Some(proposal_owner_record) = proposal_owner_record {\n        accounts.push(AccountMeta::new_readonly(*proposal_owner_record, false))\n    }",
    "pub fn assert_is_valid_max_voter_weight(\n    max_voter_weight_record: &MaxVoterWeightRecord,\n) -> Result<(), ProgramError> {\n    // Assert max voter weight is not stale\n    if let Some(max_voter_weight_expiry) = max_voter_weight_record.max_voter_weight_expiry {\n        let slot = Clock::get()?.slot;\n\n        if slot > max_voter_weight_expiry {\n            return Err(GovernanceError::MaxVoterWeightRecordExpired.into());\n        }\n    }\n\n    Ok(())\n}",
    "pub fn get_max_voter_weight_record_data(\n    program_id: &Pubkey,\n    max_voter_weight_record_info: &AccountInfo,\n) -> Result<MaxVoterWeightRecord, ProgramError> {\n    get_account_data::<MaxVoterWeightRecord>(program_id, max_voter_weight_record_info)\n}",
    "pub fn get_max_voter_weight_record_data_for_realm_and_governing_token_mint(\n    program_id: &Pubkey,\n    max_voter_weight_record_info: &AccountInfo,\n    realm: &Pubkey,\n    governing_token_mint: &Pubkey,\n) -> Result<MaxVoterWeightRecord, ProgramError> {\n    let max_voter_weight_record_data =\n        get_max_voter_weight_record_data(program_id, max_voter_weight_record_info)?;\n\n    if max_voter_weight_record_data.realm != *realm {\n        return Err(GovernanceError::InvalidMaxVoterWeightRecordForRealm.into());\n    }\n\n    if max_voter_weight_record_data.governing_token_mint != *governing_token_mint {\n        return Err(GovernanceError::InvalidMaxVoterWeightRecordForGoverningTokenMint.into());\n    }\n\n    Ok(max_voter_weight_record_data)\n}",
    "pub fn assert_is_valid_voter_weight(\n    voter_weight_record: &VoterWeightRecord,\n    weight_action: VoterWeightAction,\n    weight_action_target: &Pubkey,\n) -> Result<(), ProgramError> {\n    // Assert the weight is not stale\n    if let Some(voter_weight_expiry) = voter_weight_record.voter_weight_expiry {\n        let slot = Clock::get()?.slot;\n\n        if slot > voter_weight_expiry {\n            return Err(GovernanceError::VoterWeightRecordExpired.into());\n        }\n    }\n\n    // Assert the weight is for the action specified by the addin\n    if let Some(voter_weight_action) = &voter_weight_record.weight_action {\n        if voter_weight_action != &weight_action {\n            return Err(GovernanceError::VoterWeightRecordInvalidAction.into());\n        }\n    }\n\n    // Assert the weight is for the action target specified by the addin\n    if let Some(voter_weight_action_target) = &voter_weight_record.weight_action_target {\n        if voter_weight_action_target != weight_action_target {\n            return Err(GovernanceError::VoterWeightRecordInvalidActionTarget.into());\n        }\n    }\n\n    Ok(())\n}",
    "pub fn get_voter_weight_record_data(\n    program_id: &Pubkey,\n    voter_weight_record_info: &AccountInfo,\n) -> Result<VoterWeightRecord, ProgramError> {\n    get_account_data::<VoterWeightRecord>(program_id, voter_weight_record_info)\n}",
    "pub fn get_voter_weight_record_data_for_token_owner_record(\n    program_id: &Pubkey,\n    voter_weight_record_info: &AccountInfo,\n    token_owner_record: &TokenOwnerRecordV2,\n) -> Result<VoterWeightRecord, ProgramError> {\n    let voter_weight_record_data =\n        get_voter_weight_record_data(program_id, voter_weight_record_info)?;\n\n    if voter_weight_record_data.realm != token_owner_record.realm {\n        return Err(GovernanceError::InvalidVoterWeightRecordForRealm.into());\n    }\n\n    if voter_weight_record_data.governing_token_mint != token_owner_record.governing_token_mint {\n        return Err(GovernanceError::InvalidVoterWeightRecordForGoverningTokenMint.into());\n    }\n\n    if voter_weight_record_data.governing_token_owner != token_owner_record.governing_token_owner {\n        return Err(GovernanceError::InvalidVoterWeightRecordForTokenOwner.into());\n    }\n\n    Ok(voter_weight_record_data)\n}",
    "pub fn process_instruction(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    input: &[u8],\n) -> ProgramResult {\n    msg!(\"VERSION:{:?}\", env!(\"CARGO_PKG_VERSION\"));\n    // Use try_from_slice_unchecked to support forward compatibility of newer UI\n    // with older program\n    let instruction: GovernanceInstruction =\n        try_from_slice_unchecked(input).map_err(|_| ProgramError::InvalidInstructionData)?;\n\n    if let GovernanceInstruction::InsertTransaction {\n        option_index,\n        index,\n        legacy: _,\n        instructions: _,\n    } = instruction\n    {\n        // Do not dump instruction data into logs\n        msg!(\n            \"GOVERNANCE-INSTRUCTION: InsertInstruction {{option_index: {:?}, index: {:?}}}\",\n            option_index,\n            index,\n        );\n    } else {\n        msg!(\"GOVERNANCE-INSTRUCTION: {:?}\", instruction);\n    }\n\n    match instruction {\n        GovernanceInstruction::CreateRealm { name, config_args } => {\n            process_create_realm(program_id, accounts, name, config_args)\n        }",
    "pub fn process_add_required_signatory(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    signatory: Pubkey,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n\n    let governance_info = next_account_info(account_info_iter)?; // 0\n\n    let required_signatory_info = next_account_info(account_info_iter)?; // 1\n\n    let payer_info = next_account_info(account_info_iter)?; // 2\n    let system_info = next_account_info(account_info_iter)?; // 3\n\n    let rent = Rent::get()?;\n\n    // Only governance PDA via a proposal can authorize change to its own config\n    if !governance_info.is_signer {\n        return Err(GovernanceError::GovernancePdaMustSign.into());\n    };\n\n    let mut governance_data = get_governance_data(program_id, governance_info)?;\n    governance_data.required_signatories_count = governance_data\n        .required_signatories_count\n        .checked_add(1)\n        .unwrap();\n    governance_data.serialize(&mut governance_info.data.borrow_mut()[..])?;\n\n    let signatory_record_data = RequiredSignatory {\n        signatory,\n        account_type: GovernanceAccountType::RequiredSignatory,\n        governance: *governance_info.key,\n        account_version: 0,\n    };\n\n    create_and_serialize_account_signed::<RequiredSignatory>(\n        payer_info,\n        required_signatory_info,\n        &signatory_record_data,\n        &get_required_signatory_address_seeds(governance_info.key, &signatory),\n        program_id,\n        system_info,\n        &rent,\n        0,\n    )?;\n\n    Ok(())\n}",
    "pub fn process_add_signatory(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    signatory: Pubkey,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n\n    let governance_info = next_account_info(account_info_iter)?; // 0\n    let proposal_info = next_account_info(account_info_iter)?; // 1\n    let signatory_record_info = next_account_info(account_info_iter)?; // 2\n\n    let payer_info = next_account_info(account_info_iter)?; // 3\n    let system_info = next_account_info(account_info_iter)?; // 4\n\n    let governance_data = get_governance_data(program_id, governance_info)?;\n\n    let mut proposal_data =\n        get_proposal_data_for_governance(program_id, proposal_info, governance_info.key)?;\n    proposal_data.assert_can_edit_signatories()?;\n\n    if !signatory_record_info.data_is_empty() {\n        return Err(GovernanceError::SignatoryRecordAlreadyExists.into());\n    }\n\n    // All required signatories must be added before additional signatories can be\n    // added\n    if proposal_data.signatories_count < governance_data.required_signatories_count {\n        let required_signatory_info = next_account_info(account_info_iter)?; // 5\n        let required_signatory_data = get_required_signatory_data_for_governance(\n            program_id,\n            required_signatory_info,\n            governance_info.key,\n        )?;\n\n        if required_signatory_data.signatory != signatory {\n            return Err(GovernanceError::InvalidSignatoryAddress.into());\n        }\n    } else {\n        let token_owner_record_info = next_account_info(account_info_iter)?; // 5\n        let governance_authority_info = next_account_info(account_info_iter)?; // 6\n\n        let token_owner_record_data = get_token_owner_record_data_for_proposal_owner(\n            program_id,\n            token_owner_record_info,\n            &proposal_data.token_owner_record,\n        )?;\n\n        token_owner_record_data\n            .assert_token_owner_or_delegate_is_signer(governance_authority_info)?;\n    }\n\n    let rent = Rent::get()?;\n\n    let signatory_record_data = SignatoryRecordV2 {\n        account_type: GovernanceAccountType::SignatoryRecordV2,\n        proposal: *proposal_info.key,\n        signatory,\n        signed_off: false,\n        reserved_v2: [0; 8],\n    };\n\n    create_and_serialize_account_signed::<SignatoryRecordV2>(\n        payer_info,\n        signatory_record_info,\n        &signatory_record_data,\n        &get_signatory_record_address_seeds(proposal_info.key, &signatory),\n        program_id,\n        system_info,\n        &rent,\n        0,\n    )?;\n\n    proposal_data.signatories_count = proposal_data.signatories_count.checked_add(1).unwrap();\n    proposal_data.serialize(&mut proposal_info.data.borrow_mut()[..])?;\n\n    Ok(())\n}",
    "pub fn process_cancel_proposal(program_id: &Pubkey, accounts: &[AccountInfo]) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n\n    let realm_info = next_account_info(account_info_iter)?; // 0\n    let governance_info = next_account_info(account_info_iter)?; // 1\n    let proposal_info = next_account_info(account_info_iter)?; // 2\n    let proposal_owner_record_info = next_account_info(account_info_iter)?; // 3\n    let governance_authority_info = next_account_info(account_info_iter)?; // 4\n\n    let clock = Clock::get()?;\n\n    assert_is_valid_realm(program_id, realm_info)?;\n\n    let mut governance_data =\n        get_governance_data_for_realm(program_id, governance_info, realm_info.key)?;\n\n    let mut proposal_data =\n        get_proposal_data_for_governance(program_id, proposal_info, governance_info.key)?;\n    proposal_data.assert_can_cancel(&governance_data.config, clock.unix_timestamp)?;\n\n    let mut proposal_owner_record_data = get_token_owner_record_data_for_proposal_owner(\n        program_id,\n        proposal_owner_record_info,\n        &proposal_data.token_owner_record,\n    )?;\n\n    proposal_owner_record_data\n        .assert_token_owner_or_delegate_is_signer(governance_authority_info)?;\n\n    proposal_owner_record_data.decrease_outstanding_proposal_count();\n    proposal_owner_record_data.serialize(&mut proposal_owner_record_info.data.borrow_mut()[..])?;\n\n    proposal_data.state = ProposalState::Cancelled;\n    proposal_data.closed_at = Some(clock.unix_timestamp);\n\n    proposal_data.serialize(&mut proposal_info.data.borrow_mut()[..])?;\n\n    // Update  Governance active_proposal_count\n    governance_data.active_proposal_count = governance_data.active_proposal_count.saturating_sub(1);\n    governance_data.serialize(&mut governance_info.data.borrow_mut()[..])?;\n\n    Ok(())\n}",
    "pub fn process_cast_vote(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    vote: Vote,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n\n    let realm_info = next_account_info(account_info_iter)?; // 0\n    let governance_info = next_account_info(account_info_iter)?; // 1\n\n    let proposal_info = next_account_info(account_info_iter)?; // 2\n    let proposal_owner_record_info = next_account_info(account_info_iter)?; // 3\n\n    let voter_token_owner_record_info = next_account_info(account_info_iter)?; // 4\n    let governance_authority_info = next_account_info(account_info_iter)?; // 5\n\n    let vote_record_info = next_account_info(account_info_iter)?; // 6\n    let vote_governing_token_mint_info = next_account_info(account_info_iter)?; // 7\n\n    let payer_info = next_account_info(account_info_iter)?; // 8\n    let system_info = next_account_info(account_info_iter)?; // 9\n\n    let rent = Rent::get()?;\n    let clock = Clock::get()?;\n\n    if !vote_record_info.data_is_empty() {\n        return Err(GovernanceError::VoteAlreadyExists.into());\n    }\n\n    let realm_data = get_realm_data_for_governing_token_mint(\n        program_id,\n        realm_info,\n        vote_governing_token_mint_info.key,\n    )?;\n\n    let mut governance_data =\n        get_governance_data_for_realm(program_id, governance_info, realm_info.key)?;\n\n    let vote_kind = get_vote_kind(&vote);\n\n    // Get the governing_token_mint which the Proposal should be configured with as\n    // the voting population for the given vote For Approve, Deny and Abstain\n    // votes it's the same as vote_governing_token_mint For Veto it's the\n    // governing token mint of the opposite voting population\n    let proposal_governing_token_mint = realm_data.get_proposal_governing_token_mint_for_vote(\n        vote_governing_token_mint_info.key,\n        &vote_kind,\n    )?;\n\n    let mut proposal_data = get_proposal_data_for_governance_and_governing_mint(\n        program_id,\n        proposal_info,\n        governance_info.key,\n        &proposal_governing_token_mint,\n    )?;\n    proposal_data.assert_can_cast_vote(&governance_data.config, &vote, clock.unix_timestamp)?;\n\n    let mut voter_token_owner_record_data =\n        get_token_owner_record_data_for_realm_and_governing_mint(\n            program_id,\n            voter_token_owner_record_info,\n            &governance_data.realm,\n            vote_governing_token_mint_info.key,\n        )?;\n    voter_token_owner_record_data\n        .assert_token_owner_or_delegate_is_signer(governance_authority_info)?;\n\n    // Update TokenOwnerRecord vote counts\n    voter_token_owner_record_data.unrelinquished_votes_count = voter_token_owner_record_data\n        .unrelinquished_votes_count\n        .checked_add(1)\n        .unwrap();\n\n    let realm_config_info = next_account_info(account_info_iter)?; // 9\n    let realm_config_data =\n        get_realm_config_data_for_realm(program_id, realm_config_info, realm_info.key)?;\n\n    let voter_weight = voter_token_owner_record_data.resolve_voter_weight(\n        account_info_iter, // voter_weight_record  *10\n        &realm_data,\n        &realm_config_data,\n        VoterWeightAction::CastVote,\n        proposal_info.key,\n    )?;\n\n    proposal_data.assert_valid_vote(&vote)?;\n\n    // Calculate Proposal voting weights\n    match &vote {\n        Vote::Approve(choices) => {\n            for (option, choice) in proposal_data.options.iter_mut().zip(choices) {\n                option.vote_weight = option\n                    .vote_weight\n                    .checked_add(choice.get_choice_weight(voter_weight)?)\n                    .unwrap();\n            }\n        }\n        Vote::Deny => {\n            proposal_data.deny_vote_weight = Some(\n                proposal_data\n                    .deny_vote_weight\n                    .unwrap()\n                    .checked_add(voter_weight)\n                    .unwrap(),\n            )\n        }",
    "pub fn process_complete_proposal(program_id: &Pubkey, accounts: &[AccountInfo]) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n\n    let proposal_info = next_account_info(account_info_iter)?; // 0\n    let token_owner_record_info = next_account_info(account_info_iter)?; // 1\n    let complete_proposal_authority_info = next_account_info(account_info_iter)?; // 2\n\n    let mut proposal_data = get_proposal_data(program_id, proposal_info)?;\n    proposal_data.assert_can_complete()?;\n\n    let token_owner_record_data = get_token_owner_record_data_for_proposal_owner(\n        program_id,\n        token_owner_record_info,\n        &proposal_data.token_owner_record,\n    )?;\n    token_owner_record_data\n        .assert_token_owner_or_delegate_is_signer(complete_proposal_authority_info)?;\n\n    let clock = Clock::get()?;\n    proposal_data.closed_at = Some(clock.unix_timestamp);\n    proposal_data.state = ProposalState::Completed;\n\n    proposal_data.serialize(&mut proposal_info.data.borrow_mut()[..])?;\n    Ok(())\n}",
    "pub fn process_create_governance(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    config: GovernanceConfig,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n\n    let realm_info = next_account_info(account_info_iter)?; // 0\n    let governance_info = next_account_info(account_info_iter)?; // 1\n    let governance_seed_info = next_account_info(account_info_iter)?; // 2\n\n    let token_owner_record_info = next_account_info(account_info_iter)?; // 3\n\n    let payer_info = next_account_info(account_info_iter)?; // 4\n    let system_info = next_account_info(account_info_iter)?; // 5\n\n    let rent = Rent::get()?;\n\n    let create_authority_info = next_account_info(account_info_iter)?; // 6\n\n    assert_valid_create_governance_args(program_id, &config, realm_info)?;\n\n    let realm_data = get_realm_data(program_id, realm_info)?;\n\n    realm_data.assert_create_authority_can_create_governance(\n        program_id,\n        realm_info.key,\n        token_owner_record_info,\n        create_authority_info,\n        account_info_iter, // realm_config_info 7, voter_weight_record_info 8\n    )?;\n\n    let governance_data = GovernanceV2 {\n        account_type: GovernanceAccountType::GovernanceV2,\n        realm: *realm_info.key,\n        governance_seed: *governance_seed_info.key,\n        config,\n        reserved1: 0,\n        reserved_v2: Reserved119::default(),\n        required_signatories_count: 0,\n        active_proposal_count: 0,\n    };\n\n    create_and_serialize_account_signed::<GovernanceV2>(\n        payer_info,\n        governance_info,\n        &governance_data,\n        &get_governance_address_seeds(realm_info.key, governance_seed_info.key),\n        program_id,\n        system_info,\n        &rent,\n        0,\n    )?;\n\n    Ok(())\n}",
    "pub fn process_create_native_treasury(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n\n    let governance_info = next_account_info(account_info_iter)?; // 0\n    let native_treasury_info = next_account_info(account_info_iter)?; // 1\n    let payer_info = next_account_info(account_info_iter)?; // 2\n    let system_info = next_account_info(account_info_iter)?; // 3\n\n    let rent = Rent::get()?;\n\n    assert_is_valid_governance(program_id, governance_info)?;\n\n    let native_treasury_data = NativeTreasury {};\n\n    create_and_serialize_account_with_owner_signed(\n        payer_info,\n        native_treasury_info,\n        &native_treasury_data,\n        &get_native_treasury_address_seeds(governance_info.key),\n        program_id,\n        &system_program::id(), // System program as the PDA owner\n        system_info,\n        &rent,\n        0,\n    )?;\n\n    Ok(())\n}",
    "pub fn process_create_proposal(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    name: String,\n    description_link: String,\n    vote_type: VoteType,\n    options: Vec<String>,\n    use_deny_option: bool,\n    proposal_seed: Pubkey,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n\n    let realm_info = next_account_info(account_info_iter)?; // 0\n    let proposal_info = next_account_info(account_info_iter)?; // 1\n    let governance_info = next_account_info(account_info_iter)?; // 2\n\n    let proposal_owner_record_info = next_account_info(account_info_iter)?; // 3\n    let governing_token_mint_info = next_account_info(account_info_iter)?; // 4\n    let governance_authority_info = next_account_info(account_info_iter)?; // 5\n\n    let payer_info = next_account_info(account_info_iter)?; // 6\n    let system_info = next_account_info(account_info_iter)?; // 7\n\n    let rent = Rent::get()?;\n    let clock = Clock::get()?;\n\n    if !proposal_info.data_is_empty() {\n        return Err(GovernanceError::ProposalAlreadyExists.into());\n    }\n\n    let realm_data = get_realm_data_for_governing_token_mint(\n        program_id,\n        realm_info,\n        governing_token_mint_info.key,\n    )?;\n\n    let mut governance_data =\n        get_governance_data_for_realm(program_id, governance_info, realm_info.key)?;\n\n    governance_data.assert_governing_token_mint_can_vote(\n        &realm_data,\n        governing_token_mint_info.key,\n        &VoteKind::Electorate,\n    )?;\n\n    let mut proposal_owner_record_data = get_token_owner_record_data_for_realm(\n        program_id,\n        proposal_owner_record_info,\n        realm_info.key,\n    )?;\n\n    // Proposal owner (TokenOwner) or its governance_delegate must sign this\n    // transaction\n    proposal_owner_record_data\n        .assert_token_owner_or_delegate_is_signer(governance_authority_info)?;\n\n    let realm_config_info = next_account_info(account_info_iter)?; // 8\n    let realm_config_data =\n        get_realm_config_data_for_realm(program_id, realm_config_info, realm_info.key)?;\n\n    let voter_weight = proposal_owner_record_data.resolve_voter_weight(\n        account_info_iter, // voter_weight_record  *9\n        &realm_data,\n        &realm_config_data,\n        VoterWeightAction::CreateProposal,\n        governance_info.key,\n    )?;\n\n    // Ensure proposal owner (TokenOwner) has enough tokens to create proposal and\n    // no outstanding proposals\n    proposal_owner_record_data.assert_can_create_proposal(\n        &realm_data,\n        &governance_data.config,\n        voter_weight,\n    )?;\n\n    proposal_owner_record_data.outstanding_proposal_count = proposal_owner_record_data\n        .outstanding_proposal_count\n        .checked_add(1)\n        .unwrap();\n    proposal_owner_record_data.serialize(&mut proposal_owner_record_info.data.borrow_mut()[..])?;\n\n    assert_valid_proposal_options(&options, &vote_type)?;\n\n    let proposal_options: Vec<ProposalOption> = options\n        .iter()\n        .map(|o| ProposalOption {\n            label: o.to_string(),\n            vote_weight: 0,\n            vote_result: OptionVoteResult::None,\n            transactions_executed_count: 0,\n            transactions_count: 0,\n            transactions_next_index: 0,\n        })\n        .collect();\n\n    let deny_vote_weight = if use_deny_option { Some(0) }",
    "pub fn process_create_realm(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    name: String,\n    realm_config_args: RealmConfigArgs,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n\n    let realm_info = next_account_info(account_info_iter)?; // 0\n    let realm_authority_info = next_account_info(account_info_iter)?; // 1\n    let governance_token_mint_info = next_account_info(account_info_iter)?; // 2\n    let governance_token_holding_info = next_account_info(account_info_iter)?; // 3\n    let payer_info = next_account_info(account_info_iter)?; // 4\n    let system_info = next_account_info(account_info_iter)?; // 5\n    let spl_token_info = next_account_info(account_info_iter)?; // 6\n\n    let rent_sysvar_info = next_account_info(account_info_iter)?; // 7\n    let rent = &Rent::from_account_info(rent_sysvar_info)?;\n\n    if !realm_info.data_is_empty() {\n        return Err(GovernanceError::RealmAlreadyExists.into());\n    }\n\n    assert_valid_realm_config_args(&realm_config_args)?;\n\n    // Create Community token holding account\n    create_spl_token_account_signed(\n        payer_info,\n        governance_token_holding_info,\n        &get_governing_token_holding_address_seeds(realm_info.key, governance_token_mint_info.key),\n        governance_token_mint_info,\n        realm_info,\n        program_id,\n        system_info,\n        spl_token_info,\n        rent_sysvar_info,\n        rent,\n    )?;\n\n    // Create Council token holding account\n    let council_token_mint_address = if realm_config_args.use_council_mint {\n        let council_token_mint_info = next_account_info(account_info_iter)?; // 8\n        let council_token_holding_info = next_account_info(account_info_iter)?; // 9\n\n        create_spl_token_account_signed(\n            payer_info,\n            council_token_holding_info,\n            &get_governing_token_holding_address_seeds(realm_info.key, council_token_mint_info.key),\n            council_token_mint_info,\n            realm_info,\n            program_id,\n            system_info,\n            spl_token_info,\n            rent_sysvar_info,\n            rent,\n        )?;\n\n        Some(*council_token_mint_info.key)\n    }",
    "pub fn process_create_token_owner_record(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n\n    let realm_info = next_account_info(account_info_iter)?; // 0\n    let governing_token_owner_info = next_account_info(account_info_iter)?; // 1\n    let token_owner_record_info = next_account_info(account_info_iter)?; // 2\n    let governing_token_mint_info = next_account_info(account_info_iter)?; // 3\n    let payer_info = next_account_info(account_info_iter)?; // 4\n    let system_info = next_account_info(account_info_iter)?; // 5\n    let rent = Rent::get()?;\n\n    let realm_data = get_realm_data(program_id, realm_info)?;\n    realm_data.assert_is_valid_governing_token_mint(governing_token_mint_info.key)?;\n\n    if !token_owner_record_info.data_is_empty() {\n        return Err(GovernanceError::TokenOwnerRecordAlreadyExists.into());\n    }\n\n    let token_owner_record_data = TokenOwnerRecordV2 {\n        account_type: GovernanceAccountType::TokenOwnerRecordV2,\n        realm: *realm_info.key,\n        governing_token_owner: *governing_token_owner_info.key,\n        governing_token_deposit_amount: 0,\n        governing_token_mint: *governing_token_mint_info.key,\n        governance_delegate: None,\n        unrelinquished_votes_count: 0,\n        outstanding_proposal_count: 0,\n        version: TOKEN_OWNER_RECORD_LAYOUT_VERSION,\n        reserved: [0; 6],\n        reserved_v2: [0; 124],\n        locks: vec![],\n    };\n\n    create_and_serialize_account_signed(\n        payer_info,\n        token_owner_record_info,\n        &token_owner_record_data,\n        &get_token_owner_record_address_seeds(\n            realm_info.key,\n            governing_token_mint_info.key,\n            governing_token_owner_info.key,\n        ),\n        program_id,\n        system_info,\n        &rent,\n        0,\n    )\n}",
    "pub fn process_deposit_governing_tokens(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    amount: u64,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n\n    let realm_info = next_account_info(account_info_iter)?; // 0\n    let governing_token_holding_info = next_account_info(account_info_iter)?; // 1\n    let governing_token_source_info = next_account_info(account_info_iter)?; // 2\n    let governing_token_owner_info = next_account_info(account_info_iter)?; // 3\n    let governing_token_source_authority_info = next_account_info(account_info_iter)?; // 4\n    let token_owner_record_info = next_account_info(account_info_iter)?; // 5\n    let payer_info = next_account_info(account_info_iter)?; // 6\n    let system_info = next_account_info(account_info_iter)?; // 7\n    let spl_token_info = next_account_info(account_info_iter)?; // 8\n    let realm_config_info = next_account_info(account_info_iter)?; // 9\n\n    let rent = Rent::get()?;\n\n    let realm_data = get_realm_data(program_id, realm_info)?;\n    let governing_token_mint = get_spl_token_mint(governing_token_holding_info)?;\n\n    realm_data.assert_is_valid_governing_token_mint_and_holding(\n        program_id,\n        realm_info.key,\n        &governing_token_mint,\n        governing_token_holding_info.key,\n    )?;\n\n    let realm_config_data =\n        get_realm_config_data_for_realm(program_id, realm_config_info, realm_info.key)?;\n\n    realm_config_data.assert_can_deposit_governing_token(&realm_data, &governing_token_mint)?;\n\n    if is_spl_token_account(governing_token_source_info) {\n        // If the source is spl-token token account then transfer tokens from it\n        transfer_spl_tokens(\n            governing_token_source_info,\n            governing_token_holding_info,\n            governing_token_source_authority_info,\n            amount,\n            spl_token_info,\n        )?;\n    } else if is_spl_token_mint(governing_token_source_info) {\n        // If it's a mint then mint the tokens\n        mint_spl_tokens_to(\n            governing_token_source_info,\n            governing_token_holding_info,\n            governing_token_source_authority_info,\n            amount,\n            spl_token_info,\n        )?;\n    } else {\n        return Err(GovernanceError::InvalidGoverningTokenSource.into());\n    }\n\n    let token_owner_record_address_seeds = get_token_owner_record_address_seeds(\n        realm_info.key,\n        &governing_token_mint,\n        governing_token_owner_info.key,\n    );\n\n    if token_owner_record_info.data_is_empty() {\n        // Deposited tokens can only be withdrawn by the owner so let's make sure the\n        // owner signed the transaction\n        if !governing_token_owner_info.is_signer {\n            return Err(GovernanceError::GoverningTokenOwnerMustSign.into());\n        }\n\n        let token_owner_record_data = TokenOwnerRecordV2 {\n            account_type: GovernanceAccountType::TokenOwnerRecordV2,\n            realm: *realm_info.key,\n            governing_token_owner: *governing_token_owner_info.key,\n            governing_token_deposit_amount: amount,\n            governing_token_mint,\n            governance_delegate: None,\n            unrelinquished_votes_count: 0,\n            outstanding_proposal_count: 0,\n            version: TOKEN_OWNER_RECORD_LAYOUT_VERSION,\n            reserved: [0; 6],\n            reserved_v2: [0; 124],\n            locks: vec![],\n        };\n\n        create_and_serialize_account_signed(\n            payer_info,\n            token_owner_record_info,\n            &token_owner_record_data,\n            &token_owner_record_address_seeds,\n            program_id,\n            system_info,\n            &rent,\n            0,\n        )?;\n    } else {\n        let mut token_owner_record_data = get_token_owner_record_data_for_seeds(\n            program_id,\n            token_owner_record_info,\n            &token_owner_record_address_seeds,\n        )?;\n\n        token_owner_record_data.governing_token_deposit_amount = token_owner_record_data\n            .governing_token_deposit_amount\n            .checked_add(amount)\n            .unwrap();\n\n        token_owner_record_data.serialize(&mut token_owner_record_info.data.borrow_mut()[..])?;\n    }\n\n    Ok(())\n}",
    "pub fn process_execute_transaction(program_id: &Pubkey, accounts: &[AccountInfo]) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n\n    let governance_info = next_account_info(account_info_iter)?; // 0\n    let proposal_info = next_account_info(account_info_iter)?; // 1\n    let proposal_transaction_info = next_account_info(account_info_iter)?; // 2\n\n    let clock = Clock::get()?;\n\n    let governance_data = get_governance_data(program_id, governance_info)?;\n\n    let mut proposal_data =\n        get_proposal_data_for_governance(program_id, proposal_info, governance_info.key)?;\n\n    let mut proposal_transaction_data = get_proposal_transaction_data_for_proposal(\n        program_id,\n        proposal_transaction_info,\n        proposal_info.key,\n    )?;\n\n    proposal_data.assert_can_execute_transaction(\n        &proposal_transaction_data,\n        &governance_data.config,\n        clock.unix_timestamp,\n    )?;\n\n    // Execute instruction with Governance PDA as signer\n    let instructions = proposal_transaction_data\n        .instructions\n        .iter()\n        .map(Instruction::from);\n\n    // In the current implementation accounts for all instructions are passed to\n    // each instruction invocation. This is an overhead but shouldn't be a\n    // showstopper because if we can invoke the parent instruction with that many\n    // accounts then we should also be able to invoke all the nested ones\n    // TODO: Optimize the invocation to split the provided accounts for each\n    // individual instruction\n    let instruction_account_infos = account_info_iter.as_slice();\n\n    let mut signers_seeds: Vec<&[&[u8]]> = vec![];\n\n    // Sign the transaction using the governance PDA\n    let mut governance_seeds = governance_data.get_governance_address_seeds()?.to_vec();\n    let (_, bump_seed) = Pubkey::find_program_address(&governance_seeds, program_id);\n    let bump = &[bump_seed];\n    governance_seeds.push(bump);\n\n    signers_seeds.push(&governance_seeds[..]);\n\n    // Sign the transaction using the governance treasury PDA if required by the\n    // instruction\n    let mut treasury_seeds = get_native_treasury_address_seeds(governance_info.key).to_vec();\n    let (treasury_address, treasury_bump_seed) =\n        Pubkey::find_program_address(&treasury_seeds, program_id);\n    let treasury_bump = &[treasury_bump_seed];\n\n    if instruction_account_infos\n        .iter()\n        .any(|a| a.key == &treasury_address)\n    {\n        treasury_seeds.push(treasury_bump);\n        signers_seeds.push(&treasury_seeds[..]);\n    }\n\n    for instruction in instructions {\n        invoke_signed(&instruction, instruction_account_infos, &signers_seeds[..])?;\n    }\n\n    // Update proposal and instruction accounts\n    if proposal_data.state == ProposalState::Succeeded {\n        proposal_data.executing_at = Some(clock.unix_timestamp);\n        proposal_data.state = ProposalState::Executing;\n    }\n\n    let option = &mut proposal_data.options[proposal_transaction_data.option_index as usize];\n    option.transactions_executed_count = option.transactions_executed_count.checked_add(1).unwrap();\n\n    // Checking for Executing and ExecutingWithErrors states because instruction can\n    // still be executed after being flagged with error The check for\n    // instructions_executed_count ensures Proposal can't be transitioned to\n    // Completed state from ExecutingWithErrors\n    if (proposal_data.state == ProposalState::Executing\n        || proposal_data.state == ProposalState::ExecutingWithErrors)\n        && proposal_data\n            .options\n            .iter()\n            .filter(|o| o.vote_result == OptionVoteResult::Succeeded)\n            .all(|o| o.transactions_executed_count == o.transactions_count)\n    {\n        proposal_data.closed_at = Some(clock.unix_timestamp);\n        proposal_data.state = ProposalState::Completed;\n    }\n\n    proposal_data.serialize(&mut proposal_info.data.borrow_mut()[..])?;\n\n    proposal_transaction_data.executed_at = Some(clock.unix_timestamp);\n    proposal_transaction_data.execution_status = TransactionExecutionStatus::Success;\n    proposal_transaction_data.serialize(&mut proposal_transaction_info.data.borrow_mut()[..])?;\n\n    Ok(())\n}",
    "pub fn process_finalize_vote(program_id: &Pubkey, accounts: &[AccountInfo]) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n\n    let realm_info = next_account_info(account_info_iter)?; // 0\n    let governance_info = next_account_info(account_info_iter)?; // 1\n    let proposal_info = next_account_info(account_info_iter)?; // 2\n    let proposal_owner_record_info = next_account_info(account_info_iter)?; // 3\n\n    let governing_token_mint_info = next_account_info(account_info_iter)?; // 4\n\n    let clock = Clock::get()?;\n\n    let realm_data = get_realm_data_for_governing_token_mint(\n        program_id,\n        realm_info,\n        governing_token_mint_info.key,\n    )?;\n    let mut governance_data =\n        get_governance_data_for_realm(program_id, governance_info, realm_info.key)?;\n\n    let mut proposal_data = get_proposal_data_for_governance_and_governing_mint(\n        program_id,\n        proposal_info,\n        governance_info.key,\n        governing_token_mint_info.key,\n    )?;\n\n    let realm_config_info = next_account_info(account_info_iter)?; //5\n    let realm_config_data =\n        get_realm_config_data_for_realm(program_id, realm_config_info, realm_info.key)?;\n\n    let max_voter_weight = proposal_data.resolve_max_voter_weight(\n        account_info_iter, // *6\n        realm_info.key,\n        &realm_data,\n        &realm_config_data,\n        governing_token_mint_info,\n        &VoteKind::Electorate,\n    )?;\n\n    let vote_threshold = governance_data.resolve_vote_threshold(\n        &realm_data,\n        governing_token_mint_info.key,\n        &VoteKind::Electorate,\n    )?;\n\n    proposal_data.finalize_vote(\n        max_voter_weight,\n        &governance_data.config,\n        clock.unix_timestamp,\n        &vote_threshold,\n    )?;\n\n    let mut proposal_owner_record_data = get_token_owner_record_data_for_proposal_owner(\n        program_id,\n        proposal_owner_record_info,\n        &proposal_data.token_owner_record,\n    )?;\n\n    proposal_owner_record_data.decrease_outstanding_proposal_count();\n    proposal_owner_record_data.serialize(&mut proposal_owner_record_info.data.borrow_mut()[..])?;\n\n    proposal_data.serialize(&mut proposal_info.data.borrow_mut()[..])?;\n\n    // Update  Governance active_proposal_count\n    governance_data.active_proposal_count = governance_data.active_proposal_count.saturating_sub(1);\n    governance_data.serialize(&mut governance_info.data.borrow_mut()[..])?;\n\n    Ok(())\n}",
    "pub fn process_insert_transaction(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    option_index: u8,\n    instruction_index: u16,\n    instructions: Vec<InstructionData>,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n\n    let governance_info = next_account_info(account_info_iter)?; // 0\n    let proposal_info = next_account_info(account_info_iter)?; // 1\n    let token_owner_record_info = next_account_info(account_info_iter)?; // 2\n    let governance_authority_info = next_account_info(account_info_iter)?; // 3\n\n    let proposal_transaction_info = next_account_info(account_info_iter)?; // 4\n\n    let payer_info = next_account_info(account_info_iter)?; // 5\n    let system_info = next_account_info(account_info_iter)?; // 6\n\n    let rent_sysvar_info = next_account_info(account_info_iter)?; // 7\n    let rent = &Rent::from_account_info(rent_sysvar_info)?;\n\n    if !proposal_transaction_info.data_is_empty() {\n        return Err(GovernanceError::TransactionAlreadyExists.into());\n    }\n\n    // Governance account is no longer used and it's deserialized only to validate\n    // the provided account\n    let _governance_data = get_governance_data(program_id, governance_info)?;\n\n    let mut proposal_data =\n        get_proposal_data_for_governance(program_id, proposal_info, governance_info.key)?;\n    proposal_data.assert_can_edit_instructions()?;\n\n    let token_owner_record_data = get_token_owner_record_data_for_proposal_owner(\n        program_id,\n        token_owner_record_info,\n        &proposal_data.token_owner_record,\n    )?;\n\n    token_owner_record_data.assert_token_owner_or_delegate_is_signer(governance_authority_info)?;\n\n    let option = &mut proposal_data.options[option_index as usize];\n\n    match instruction_index.cmp(&option.transactions_next_index) {\n        Ordering::Greater => return Err(GovernanceError::InvalidTransactionIndex.into()),\n        // If the index is the same as instructions_next_index then we are adding a new instruction\n        // If the index is below instructions_next_index then we are inserting into an existing\n        // empty space\n        Ordering::Equal => {\n            option.transactions_next_index = option.transactions_next_index.checked_add(1).unwrap();\n        }\n        Ordering::Less => {}\n    }\n\n    option.transactions_count = option.transactions_count.checked_add(1).unwrap();\n    proposal_data.serialize(&mut proposal_info.data.borrow_mut()[..])?;\n\n    let proposal_transaction_data = ProposalTransactionV2 {\n        account_type: GovernanceAccountType::ProposalTransactionV2,\n        option_index,\n        transaction_index: instruction_index,\n        legacy: 0,\n        instructions,\n        executed_at: None,\n        execution_status: TransactionExecutionStatus::None,\n        proposal: *proposal_info.key,\n        reserved_v2: [0; 8],\n    };\n\n    create_and_serialize_account_signed::<ProposalTransactionV2>(\n        payer_info,\n        proposal_transaction_info,\n        &proposal_transaction_data,\n        &get_proposal_transaction_address_seeds(\n            proposal_info.key,\n            &option_index.to_le_bytes(),\n            &instruction_index.to_le_bytes(),\n        ),\n        program_id,\n        system_info,\n        rent,\n        0,\n    )?;\n\n    Ok(())\n}",
    "pub fn process_refund_proposal_deposit(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n\n    let proposal_info = next_account_info(account_info_iter)?; // 0\n\n    let proposal_deposit_info = next_account_info(account_info_iter)?; // 1\n    let proposal_deposit_payer_info = next_account_info(account_info_iter)?; // 2\n\n    let proposal_data = get_proposal_data(program_id, proposal_info)?;\n\n    proposal_data.assert_can_refund_proposal_deposit()?;\n\n    // Assert we are disposing a deposit which belongs to the Proposal and the\n    // deposit payer\n    let _proposal_deposit_data = get_proposal_deposit_data_for_proposal_and_deposit_payer(\n        program_id,\n        proposal_deposit_info,\n        proposal_info.key,\n        proposal_deposit_payer_info.key,\n    )?;\n\n    dispose_account(proposal_deposit_info, proposal_deposit_payer_info)?;\n\n    Ok(())\n}",
    "pub fn process_relinquish_token_owner_record_locks(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    lock_ids: Option<Vec<u8>>,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n\n    let realm_info = next_account_info(account_info_iter)?; // 0\n    let realm_config_info = next_account_info(account_info_iter)?; // 1\n    let token_owner_record_info = next_account_info(account_info_iter)?; // 2\n\n    let realm_data = get_realm_data(program_id, realm_info)?;\n    let realm_config_data =\n        get_realm_config_data_for_realm(program_id, realm_config_info, realm_info.key)?;\n\n    let mut token_owner_record_data = get_token_owner_record_data_for_realm(\n        program_id,\n        token_owner_record_info,\n        &realm_config_data.realm,\n    )?;\n\n    if let Some(lock_ids) = lock_ids {\n        let token_owner_record_lock_authority_info = next_account_info(account_info_iter)?; // 3\n\n        if realm_config_data\n            .get_token_config(&realm_data, &token_owner_record_data.governing_token_mint)?\n            .lock_authorities\n            .contains(token_owner_record_lock_authority_info.key)\n        {\n            // If the authority is a configured lock authority it must sign the transaction\n            if !token_owner_record_lock_authority_info.is_signer {\n                return Err(GovernanceError::TokenOwnerRecordLockAuthorityMustSign.into());\n            }\n        }\n\n        // Remove the locks\n        for lock_id in lock_ids {\n            token_owner_record_data\n                .remove_lock(lock_id, token_owner_record_lock_authority_info.key)?;\n        }\n    }\n\n    // Trim expired locks\n    let clock = Clock::get()?;\n    token_owner_record_data.remove_expired_locks(clock.unix_timestamp);\n\n    token_owner_record_data.serialize(&mut token_owner_record_info.data.borrow_mut()[..])?;\n\n    Ok(())\n}",
    "pub fn process_relinquish_vote(program_id: &Pubkey, accounts: &[AccountInfo]) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n\n    let realm_info = next_account_info(account_info_iter)?; // 0\n    let governance_info = next_account_info(account_info_iter)?; // 1\n    let proposal_info = next_account_info(account_info_iter)?; // 2\n    let token_owner_record_info = next_account_info(account_info_iter)?; // 3\n\n    let vote_record_info = next_account_info(account_info_iter)?; // 4\n    let vote_governing_token_mint_info = next_account_info(account_info_iter)?; // 5\n\n    let realm_data = get_realm_data_for_governing_token_mint(\n        program_id,\n        realm_info,\n        vote_governing_token_mint_info.key,\n    )?;\n\n    let governance_data =\n        get_governance_data_for_realm(program_id, governance_info, realm_info.key)?;\n\n    let mut proposal_data =\n        get_proposal_data_for_governance(program_id, proposal_info, governance_info.key)?;\n\n    let mut token_owner_record_data = get_token_owner_record_data_for_realm_and_governing_mint(\n        program_id,\n        token_owner_record_info,\n        &governance_data.realm,\n        vote_governing_token_mint_info.key,\n    )?;\n\n    let mut vote_record_data = get_vote_record_data_for_proposal_and_token_owner_record(\n        program_id,\n        vote_record_info,\n        &realm_data,\n        proposal_info.key,\n        &proposal_data,\n        &token_owner_record_data,\n    )?;\n    vote_record_data.assert_can_relinquish_vote()?;\n\n    let clock = Clock::get()?;\n\n    // If the Proposal is still being voted on then the token owner vote will be\n    // withdrawn and it won't count towards the vote outcome Note: If there is\n    // no tipping point the proposal can be still in Voting state but already past\n    // the configured max voting time (base + cool off voting time)\n    //       It means it awaits manual finalization (FinalizeVote) and it should no\n    // longer be possible to withdraw the vote\n    if proposal_data.state == ProposalState::Voting\n        && !proposal_data.has_voting_max_time_ended(&governance_data.config, clock.unix_timestamp)\n    {\n        let governance_authority_info = next_account_info(account_info_iter)?; // 5\n        let beneficiary_info = next_account_info(account_info_iter)?; // 6\n\n        // Note: It's only required to sign by governing_authority if relinquishing the\n        // vote results in vote change If the Proposal is already decided then\n        // anybody can prune active votes for token owner\n        token_owner_record_data\n            .assert_token_owner_or_delegate_is_signer(governance_authority_info)?;\n\n        match vote_record_data.vote {\n            Vote::Approve(choices) => {\n                for (option, choice) in proposal_data.options.iter_mut().zip(choices) {\n                    option.vote_weight = option\n                        .vote_weight\n                        .checked_sub(choice.get_choice_weight(vote_record_data.voter_weight)?)\n                        .unwrap();\n                }\n            }\n            Vote::Deny => {\n                proposal_data.deny_vote_weight = Some(\n                    proposal_data\n                        .deny_vote_weight\n                        .unwrap()\n                        .checked_sub(vote_record_data.voter_weight)\n                        .unwrap(),\n                )\n            }",
    "pub fn process_remove_required_signatory(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n\n    let governance_info = next_account_info(account_info_iter)?; // 0\n    let required_signatory_info = next_account_info(account_info_iter)?; // 1\n    let beneficiary_info = next_account_info(account_info_iter)?; // 2\n\n    if !governance_info.is_signer {\n        return Err(GovernanceError::GovernancePdaMustSign.into());\n    };\n\n    let mut governance_data = get_governance_data(program_id, governance_info)?;\n\n    get_required_signatory_data_for_governance(\n        program_id,\n        required_signatory_info,\n        governance_info.key,\n    )?;\n\n    governance_data.required_signatories_count = governance_data\n        .required_signatories_count\n        .checked_sub(1)\n        .unwrap();\n    governance_data.serialize(&mut governance_info.data.borrow_mut()[..])?;\n\n    dispose_account(required_signatory_info, beneficiary_info)?;\n\n    Ok(())\n}",
    "pub fn process_remove_transaction(program_id: &Pubkey, accounts: &[AccountInfo]) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n\n    let proposal_info = next_account_info(account_info_iter)?; // 0\n    let token_owner_record_info = next_account_info(account_info_iter)?; // 1\n    let governance_authority_info = next_account_info(account_info_iter)?; // 2\n\n    let proposal_transaction_info = next_account_info(account_info_iter)?; // 3\n    let beneficiary_info = next_account_info(account_info_iter)?; // 4\n\n    let mut proposal_data = get_proposal_data(program_id, proposal_info)?;\n    proposal_data.assert_can_edit_instructions()?;\n\n    let token_owner_record_data = get_token_owner_record_data_for_proposal_owner(\n        program_id,\n        token_owner_record_info,\n        &proposal_data.token_owner_record,\n    )?;\n\n    token_owner_record_data.assert_token_owner_or_delegate_is_signer(governance_authority_info)?;\n\n    let proposal_transaction_data = get_proposal_transaction_data_for_proposal(\n        program_id,\n        proposal_transaction_info,\n        proposal_info.key,\n    )?;\n\n    dispose_account(proposal_transaction_info, beneficiary_info)?;\n\n    let option = &mut proposal_data.options[proposal_transaction_data.option_index as usize];\n    option.transactions_count = option.transactions_count.checked_sub(1).unwrap();\n\n    proposal_data.serialize(&mut proposal_info.data.borrow_mut()[..])?;\n\n    Ok(())\n}",
    "pub fn process_revoke_governing_tokens(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    amount: u64,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n\n    let realm_info = next_account_info(account_info_iter)?; // 0\n\n    let governing_token_holding_info = next_account_info(account_info_iter)?; // 1\n    let token_owner_record_info = next_account_info(account_info_iter)?; // 2\n\n    let governing_token_mint_info = next_account_info(account_info_iter)?; // 3\n    let revoke_authority_info = next_account_info(account_info_iter)?; // 4\n\n    let realm_config_info = next_account_info(account_info_iter)?; // 5\n    let spl_token_info = next_account_info(account_info_iter)?; // 6\n\n    let realm_data = get_realm_data(program_id, realm_info)?;\n\n    realm_data.assert_is_valid_governing_token_mint_and_holding(\n        program_id,\n        realm_info.key,\n        governing_token_mint_info.key,\n        governing_token_holding_info.key,\n    )?;\n\n    let realm_config_data =\n        get_realm_config_data_for_realm(program_id, realm_config_info, realm_info.key)?;\n\n    realm_config_data\n        .assert_can_revoke_governing_token(&realm_data, governing_token_mint_info.key)?;\n\n    let mut token_owner_record_data = get_token_owner_record_data_for_realm_and_governing_mint(\n        program_id,\n        token_owner_record_info,\n        realm_info.key,\n        governing_token_mint_info.key,\n    )?;\n\n    // If the governing token owner voluntarily revokes their own membership then\n    // the owner must sign the transaction\n    if *revoke_authority_info.key == token_owner_record_data.governing_token_owner {\n        if !revoke_authority_info.is_signer {\n            return Err(GovernanceError::GoverningTokenOwnerMustSign.into());\n        }\n    } else {\n        // If its a forceful membership revocation then the governing_token_mint\n        // authority must sign the transaction\n        assert_spl_token_mint_authority_is_signer(\n            governing_token_mint_info,\n            revoke_authority_info,\n        )?;\n    }\n\n    token_owner_record_data.governing_token_deposit_amount = token_owner_record_data\n        .governing_token_deposit_amount\n        .checked_sub(amount)\n        .ok_or(GovernanceError::InvalidRevokeAmount)?;\n\n    token_owner_record_data.serialize(&mut token_owner_record_info.data.borrow_mut()[..])?;\n\n    burn_spl_tokens_signed(\n        governing_token_holding_info,\n        governing_token_mint_info,\n        realm_info,\n        &get_realm_address_seeds(&realm_data.name),\n        program_id,\n        amount,\n        spl_token_info,\n    )?;\n\n    Ok(())\n}",
    "pub fn process_set_governance_config(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    config: GovernanceConfig,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n\n    let governance_info = next_account_info(account_info_iter)?; // 0\n\n    // Only governance PDA via a proposal can authorize change to its own config\n    if !governance_info.is_signer {\n        return Err(GovernanceError::GovernancePdaMustSign.into());\n    };\n\n    assert_is_valid_governance_config(&config)?;\n\n    let mut governance_data = get_governance_data(program_id, governance_info)?;\n\n    // Note: Config change leaves voting proposals in unpredictable state and it's\n    // DAOs responsibility to ensure the changes are made when there are no\n    // proposals in voting state For example changing approval quorum could\n    // accidentally make proposals to succeed which would otherwise be defeated\n\n    governance_data.config = config;\n\n    governance_data.serialize(&mut governance_info.data.borrow_mut()[..])?;\n\n    Ok(())\n}",
    "pub fn process_set_governance_delegate(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    new_governance_delegate: &Option<Pubkey>,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n\n    let governance_authority_info = next_account_info(account_info_iter)?; // 0\n    let token_owner_record_info = next_account_info(account_info_iter)?; // 1\n\n    let mut token_owner_record_data =\n        get_token_owner_record_data(program_id, token_owner_record_info)?;\n\n    token_owner_record_data.assert_token_owner_or_delegate_is_signer(governance_authority_info)?;\n\n    token_owner_record_data.governance_delegate = *new_governance_delegate;\n    token_owner_record_data.serialize(&mut token_owner_record_info.data.borrow_mut()[..])?;\n\n    Ok(())\n}",
    "pub fn process_set_realm_authority(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    action: SetRealmAuthorityAction,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n\n    let realm_info = next_account_info(account_info_iter)?; // 0\n    let realm_authority_info = next_account_info(account_info_iter)?; // 1\n\n    let mut realm_data =\n        get_realm_data_for_authority(program_id, realm_info, realm_authority_info.key)?;\n\n    if !realm_authority_info.is_signer {\n        return Err(GovernanceError::RealmAuthorityMustSign.into());\n    }\n\n    let new_realm_authority = match action {\n        SetRealmAuthorityAction::SetUnchecked | SetRealmAuthorityAction::SetChecked => {\n            let new_realm_authority_info = next_account_info(account_info_iter)?; // 2\n\n            if action == SetRealmAuthorityAction::SetChecked {\n                // Ensure the new realm authority is one of the governances from the realm\n                assert_governance_for_realm(program_id, new_realm_authority_info, realm_info.key)?;\n            }\n\n            Some(*new_realm_authority_info.key)\n        }",
    "pub fn process_set_realm_config(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    realm_config_args: RealmConfigArgs,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n\n    let realm_info = next_account_info(account_info_iter)?; // 0\n    let realm_authority_info = next_account_info(account_info_iter)?; // 1\n\n    let mut realm_data =\n        get_realm_data_for_authority(program_id, realm_info, realm_authority_info.key)?;\n\n    if !realm_authority_info.is_signer {\n        return Err(GovernanceError::RealmAuthorityMustSign.into());\n    }\n\n    // Note: Config change leaves voting proposals in unpredictable state and it's\n    // DAOs responsibility to ensure the changes are made when there are no\n    // proposals in voting state For example changing voter-weight or\n    // max-voter-weight addin could accidentally make proposals to succeed which\n    // would otherwise be defeated\n\n    assert_valid_realm_config_args(&realm_config_args)?;\n\n    // Setup council\n    if realm_config_args.use_council_mint {\n        let council_token_mint_info = next_account_info(account_info_iter)?; // 2\n        let _council_token_holding_info = next_account_info(account_info_iter)?; // 3\n\n        // Council mint can only be at present set to None (removed) and changing it to\n        // other mint is not supported It might be implemented in future\n        // versions but it needs careful planning It can potentially open a can\n        // of warms like what happens with existing deposits or pending proposals\n        if let Some(council_token_mint) = realm_data.config.council_mint {\n            // Council mint can't be changed to different one\n            if council_token_mint != *council_token_mint_info.key {\n                return Err(GovernanceError::RealmCouncilMintChangeIsNotSupported.into());\n            }\n        } else {\n            // Council mint can't be restored (changed from None)\n            return Err(GovernanceError::RealmCouncilMintChangeIsNotSupported.into());\n        }\n    } else {\n        // Remove council mint from realm\n        // Note: In the current implementation this also makes it impossible to withdraw\n        // council tokens\n        realm_data.config.council_mint = None;\n    }\n\n    let system_info = next_account_info(account_info_iter)?; // 4\n\n    let realm_config_info = next_account_info(account_info_iter)?; // 5\n    let mut realm_config_data =\n        get_realm_config_data_for_realm(program_id, realm_config_info, realm_info.key)?;\n\n    realm_config_data.assert_can_change_config(&realm_config_args)?;\n\n    // Setup configs for tokens (plugins and token types)\n\n    // 6, 7\n    let community_token_config = resolve_governing_token_config(\n        account_info_iter,\n        &realm_config_args.community_token_config_args,\n        Some(realm_config_data.community_token_config.clone()),\n    )?;\n\n    // 8, 9\n    let council_token_config = resolve_governing_token_config(\n        account_info_iter,\n        &realm_config_args.council_token_config_args,\n        Some(realm_config_data.council_token_config.clone()),\n    )?;\n\n    realm_config_data.community_token_config = community_token_config;\n    realm_config_data.council_token_config = council_token_config;\n\n    let payer_info = next_account_info(account_info_iter)?; // 10\n    let rent = Rent::get()?;\n\n    realm_config_data.serialize(\n        program_id,\n        realm_config_info,\n        payer_info,\n        system_info,\n        &rent,\n    )?;\n\n    // Update RealmConfig (Realm.config field)\n    realm_data.config.community_mint_max_voter_weight_source =\n        realm_config_args.community_mint_max_voter_weight_source;\n\n    realm_data.config.min_community_weight_to_create_governance =\n        realm_config_args.min_community_weight_to_create_governance;\n\n    realm_data.config.legacy1 = 0;\n    realm_data.config.legacy2 = 0;\n\n    realm_data.serialize(&mut realm_info.data.borrow_mut()[..])?;\n\n    Ok(())\n}",
    "pub fn process_set_realm_config_item(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    args: SetRealmConfigItemArgs,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n\n    let realm_info = next_account_info(account_info_iter)?; // 0\n    let realm_config_info = next_account_info(account_info_iter)?; // 1\n    let realm_authority_info = next_account_info(account_info_iter)?; // 2\n    let payer_info = next_account_info(account_info_iter)?; // 3\n    let system_info = next_account_info(account_info_iter)?; // 4\n\n    let rent = Rent::get()?;\n\n    let realm_data =\n        get_realm_data_for_authority(program_id, realm_info, realm_authority_info.key)?;\n\n    if !realm_authority_info.is_signer {\n        return Err(GovernanceError::RealmAuthorityMustSign.into());\n    }\n\n    let mut realm_config_data =\n        get_realm_config_data_for_realm(program_id, realm_config_info, realm_info.key)?;\n\n    match args {\n        SetRealmConfigItemArgs::TokenOwnerRecordLockAuthority {\n            action,\n            governing_token_mint,\n            authority,\n        } => {\n            let token_config =\n                realm_config_data.get_token_config_mut(&realm_data, &governing_token_mint)?;\n\n            match action {\n                SetConfigItemActionType::Add => {\n                    if token_config.lock_authorities.contains(&authority) {\n                        return Err(\n                            GovernanceError::TokenOwnerRecordLockAuthorityAlreadyExists.into()\n                        );\n                    }\n\n                    token_config.lock_authorities.push(authority);\n                }\n                SetConfigItemActionType::Remove => {\n                    if let Some(lock_authority_index) = token_config\n                        .lock_authorities\n                        .iter()\n                        .position(|lock_authority| lock_authority == &authority)\n                    {\n                        token_config.lock_authorities.remove(lock_authority_index);\n                    } else {\n                        return Err(GovernanceError::TokenOwnerRecordLockAuthorityNotFound.into());\n                    }\n                }\n            }\n        }\n    }\n\n    realm_config_data.serialize(\n        program_id,\n        realm_config_info,\n        payer_info,\n        system_info,\n        &rent,\n    )?;\n\n    Ok(())\n}",
    "pub fn process_set_token_owner_record_lock(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    lock_id: u8,\n    expiry: Option<UnixTimestamp>,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n\n    let realm_info = next_account_info(account_info_iter)?; // 0\n    let realm_config_info = next_account_info(account_info_iter)?; // 1\n    let token_owner_record_info = next_account_info(account_info_iter)?; // 2\n    let token_owner_record_lock_authority_info = next_account_info(account_info_iter)?; // 3\n    let payer_info = next_account_info(account_info_iter)?; // 4\n    let system_info = next_account_info(account_info_iter)?; // 5\n\n    let rent = Rent::get()?;\n    let clock = Clock::get()?;\n\n    if !token_owner_record_lock_authority_info.is_signer {\n        return Err(GovernanceError::TokenOwnerRecordLockAuthorityMustSign.into());\n    }\n\n    let token_owner_record_lock = TokenOwnerRecordLock {\n        lock_id,\n        authority: *token_owner_record_lock_authority_info.key,\n        expiry,\n    };\n\n    // Reject the lock if already expired\n    if token_owner_record_lock.is_expired(clock.unix_timestamp) {\n        return Err(GovernanceError::ExpiredTokenOwnerRecordLock.into());\n    }\n\n    let realm_data = get_realm_data(program_id, realm_info)?;\n    let realm_config_data =\n        get_realm_config_data_for_realm(program_id, realm_config_info, realm_info.key)?;\n\n    let mut token_owner_record_data = get_token_owner_record_data_for_realm(\n        program_id,\n        token_owner_record_info,\n        &realm_config_data.realm,\n    )?;\n\n    if !realm_config_data\n        .get_token_config(&realm_data, &token_owner_record_data.governing_token_mint)?\n        .lock_authorities\n        .contains(token_owner_record_lock_authority_info.key)\n    {\n        return Err(GovernanceError::InvalidTokenOwnerRecordLockAuthority.into());\n    }\n\n    // Trim expired locks\n    token_owner_record_data.remove_expired_locks(clock.unix_timestamp);\n\n    // Add or update the lock for the given authority and lock id\n    token_owner_record_data.upsert_lock(token_owner_record_lock);\n\n    token_owner_record_data.serialize_with_resize(\n        token_owner_record_info,\n        payer_info,\n        system_info,\n        &rent,\n    )?;\n\n    Ok(())\n}",
    "pub fn process_sign_off_proposal(program_id: &Pubkey, accounts: &[AccountInfo]) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n\n    let realm_info = next_account_info(account_info_iter)?; // 0\n    let governance_info = next_account_info(account_info_iter)?; // 1\n    let proposal_info = next_account_info(account_info_iter)?; // 2\n\n    let signatory_info = next_account_info(account_info_iter)?; // 3\n\n    let clock = Clock::get()?;\n\n    assert_is_valid_realm(program_id, realm_info)?;\n\n    let governance_data =\n        get_governance_data_for_realm(program_id, governance_info, realm_info.key)?;\n\n    let mut proposal_data =\n        get_proposal_data_for_governance(program_id, proposal_info, governance_info.key)?;\n\n    proposal_data.assert_can_sign_off()?;\n\n    if governance_data.required_signatories_count > 0\n        && proposal_data.signatories_count < governance_data.required_signatories_count\n    {\n        return Err(GovernanceError::MissingRequiredSignatories.into());\n    }\n\n    // If the owner of the proposal hasn't appointed any signatories then can sign\n    // off the proposal themself\n    if proposal_data.signatories_count == 0 {\n        let proposal_owner_record_info = next_account_info(account_info_iter)?; // 4\n\n        let proposal_owner_record_data = get_token_owner_record_data_for_proposal_owner(\n            program_id,\n            proposal_owner_record_info,\n            &proposal_data.token_owner_record,\n        )?;\n\n        // Proposal owner (TokenOwner) or its governance_delegate must be the signatory\n        // and sign this transaction\n        proposal_owner_record_data.assert_token_owner_or_delegate_is_signer(signatory_info)?;\n\n        proposal_data.signing_off_at = Some(clock.unix_timestamp);\n    } else {\n        let signatory_record_info = next_account_info(account_info_iter)?; // 4\n\n        let mut signatory_record_data = get_signatory_record_data_for_seeds(\n            program_id,\n            signatory_record_info,\n            proposal_info.key,\n            signatory_info.key,\n        )?;\n\n        signatory_record_data.assert_can_sign_off(signatory_info)?;\n\n        signatory_record_data.signed_off = true;\n        signatory_record_data.serialize(&mut signatory_record_info.data.borrow_mut()[..])?;\n\n        if proposal_data.signatories_signed_off_count == 0 {\n            proposal_data.signing_off_at = Some(clock.unix_timestamp);\n            proposal_data.state = ProposalState::SigningOff;\n        }\n\n        proposal_data.signatories_signed_off_count = proposal_data\n            .signatories_signed_off_count\n            .checked_add(1)\n            .unwrap();\n    }\n\n    // If all Signatories signed off we can start voting\n    if proposal_data.signatories_signed_off_count == proposal_data.signatories_count {\n        proposal_data.voting_at = Some(clock.unix_timestamp);\n        proposal_data.voting_at_slot = Some(clock.slot);\n        proposal_data.state = ProposalState::Voting;\n    }\n\n    proposal_data.serialize(&mut proposal_info.data.borrow_mut()[..])?;\n\n    Ok(())\n}",
    "pub fn process_update_program_metadata(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n\n    let program_metadata_info = next_account_info(account_info_iter)?; // 0\n    let payer_info = next_account_info(account_info_iter)?; // 1\n    let system_info = next_account_info(account_info_iter)?; // 2\n\n    let rent = Rent::get()?;\n    let updated_at = Clock::get()?.slot;\n\n    const VERSION: &str = env!(\"CARGO_PKG_VERSION\");\n\n    // Put the metadata info into the logs to make it possible to extract it using\n    // Tx simulation\n    msg!(\"PROGRAM-VERSION:{:?}\", VERSION);\n\n    if program_metadata_info.data_is_empty() {\n        let program_metadata_data = ProgramMetadata {\n            account_type: GovernanceAccountType::ProgramMetadata,\n            updated_at,\n            version: VERSION.to_string(),\n            reserved: [0; 64],\n        };\n\n        create_and_serialize_account_signed(\n            payer_info,\n            program_metadata_info,\n            &program_metadata_data,\n            &get_program_metadata_seeds(),\n            program_id,\n            system_info,\n            &rent,\n            0,\n        )?;\n    } else {\n        let mut program_metadata_data =\n            get_program_metadata_data(program_id, program_metadata_info)?;\n\n        program_metadata_data.version = VERSION.to_string();\n        program_metadata_data.updated_at = updated_at;\n\n        borsh::to_writer(\n            &mut program_metadata_info.data.borrow_mut()[..],\n            &program_metadata_data,\n        )?;\n    }\n\n    Ok(())\n}",
    "pub fn process_withdraw_governing_tokens(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n\n    let realm_info = next_account_info(account_info_iter)?; // 0\n    let governing_token_holding_info = next_account_info(account_info_iter)?; // 1\n    let governing_token_destination_info = next_account_info(account_info_iter)?; // 2\n    let governing_token_owner_info = next_account_info(account_info_iter)?; // 3\n    let token_owner_record_info = next_account_info(account_info_iter)?; // 4\n    let spl_token_info = next_account_info(account_info_iter)?; // 5\n    let realm_config_info = next_account_info(account_info_iter)?; // 6\n    let clock = Clock::get()?;\n\n    if !governing_token_owner_info.is_signer {\n        return Err(GovernanceError::GoverningTokenOwnerMustSign.into());\n    }\n\n    let realm_data = get_realm_data(program_id, realm_info)?;\n    let governing_token_mint = get_spl_token_mint(governing_token_holding_info)?;\n\n    realm_data.assert_is_valid_governing_token_mint_and_holding(\n        program_id,\n        realm_info.key,\n        &governing_token_mint,\n        governing_token_holding_info.key,\n    )?;\n\n    let realm_config_data =\n        get_realm_config_data_for_realm(program_id, realm_config_info, realm_info.key)?;\n\n    realm_config_data.assert_can_withdraw_governing_token(&realm_data, &governing_token_mint)?;\n\n    let token_owner_record_address_seeds = get_token_owner_record_address_seeds(\n        realm_info.key,\n        &governing_token_mint,\n        governing_token_owner_info.key,\n    );\n\n    let mut token_owner_record_data = get_token_owner_record_data_for_seeds(\n        program_id,\n        token_owner_record_info,\n        &token_owner_record_address_seeds,\n    )?;\n\n    token_owner_record_data.assert_can_withdraw_governing_tokens(clock.unix_timestamp)?;\n\n    transfer_spl_tokens_signed(\n        governing_token_holding_info,\n        governing_token_destination_info,\n        realm_info,\n        &get_realm_address_seeds(&realm_data.name),\n        program_id,\n        token_owner_record_data.governing_token_deposit_amount,\n        spl_token_info,\n    )?;\n\n    token_owner_record_data.governing_token_deposit_amount = 0;\n    token_owner_record_data.serialize(&mut token_owner_record_info.data.borrow_mut()[..])?;\n\n    Ok(())\n}",
    "pub fn is_governance_v2_account_type(account_type: &GovernanceAccountType) -> bool {\n    match account_type {\n        GovernanceAccountType::GovernanceV2\n        | GovernanceAccountType::ProgramGovernanceV2\n        | GovernanceAccountType::MintGovernanceV2\n        | GovernanceAccountType::TokenGovernanceV2 => true,\n        GovernanceAccountType::Uninitialized\n        | GovernanceAccountType::RealmV1\n        | GovernanceAccountType::RealmV2\n        | GovernanceAccountType::RealmConfig\n        | GovernanceAccountType::TokenOwnerRecordV1\n        | GovernanceAccountType::TokenOwnerRecordV2\n        | GovernanceAccountType::GovernanceV1\n        | GovernanceAccountType::ProgramGovernanceV1\n        | GovernanceAccountType::MintGovernanceV1\n        | GovernanceAccountType::TokenGovernanceV1\n        | GovernanceAccountType::ProposalV1\n        | GovernanceAccountType::ProposalV2\n        | GovernanceAccountType::SignatoryRecordV1\n        | GovernanceAccountType::SignatoryRecordV2\n        | GovernanceAccountType::ProposalInstructionV1\n        | GovernanceAccountType::ProposalTransactionV2\n        | GovernanceAccountType::VoteRecordV1\n        | GovernanceAccountType::VoteRecordV2\n        | GovernanceAccountType::ProgramMetadata\n        | GovernanceAccountType::ProposalDeposit\n        | GovernanceAccountType::RequiredSignatory => false,\n    }\n}\n\n/// Returns GovernanceV2 type for given GovernanceV1 type or None if the given\n/// account type is not GovernanceV1\npub fn try_get_governance_v2_type_for_v1(\n    account_type: &GovernanceAccountType,\n) -> Option<GovernanceAccountType> {\n    match account_type {\n        GovernanceAccountType::GovernanceV1 => Some(GovernanceAccountType::GovernanceV2),\n        GovernanceAccountType::ProgramGovernanceV1 => {\n            Some(GovernanceAccountType::ProgramGovernanceV2)\n        }",
    "pub fn is_governance_account_type(account_type: &GovernanceAccountType) -> bool {\n    is_governance_v1_account_type(account_type) || is_governance_v2_account_type(account_type)\n}",
    "pub fn get_governance_address_seeds(&self) -> Result<[&[u8]; 3], ProgramError> {\n        let seeds = match self.account_type {\n            GovernanceAccountType::GovernanceV1 | GovernanceAccountType::GovernanceV2 => {\n                get_governance_address_seeds(&self.realm, &self.governance_seed)\n            }",
    "pub fn assert_governing_token_mint_can_vote(\n        &self,\n        realm_data: &RealmV2,\n        vote_governing_token_mint: &Pubkey,\n        vote_kind: &VoteKind,\n    ) -> Result<(), ProgramError> {\n        // resolve_vote_threshold() asserts the vote threshold exists for the given\n        // governing_token_mint and is not disabled\n        let _ = self.resolve_vote_threshold(realm_data, vote_governing_token_mint, vote_kind)?;\n\n        Ok(())\n    }",
    "pub fn resolve_vote_threshold(\n        &self,\n        realm_data: &RealmV2,\n        vote_governing_token_mint: &Pubkey,\n        vote_kind: &VoteKind,\n    ) -> Result<VoteThreshold, ProgramError> {\n        let vote_threshold = if realm_data.community_mint == *vote_governing_token_mint {\n            match vote_kind {\n                VoteKind::Electorate => &self.config.community_vote_threshold,\n                VoteKind::Veto => &self.config.community_veto_vote_threshold,\n            }\n        } else if realm_data.config.council_mint == Some(*vote_governing_token_mint) {\n            match vote_kind {\n                VoteKind::Electorate => &self.config.council_vote_threshold,\n                VoteKind::Veto => &self.config.council_veto_vote_threshold,\n            }\n        } else {\n            return Err(GovernanceError::InvalidGoverningTokenMint.into());\n        };\n\n        if *vote_threshold == VoteThreshold::Disabled {\n            return Err(GovernanceError::GoverningTokenMintNotAllowedToVote.into());\n        }\n\n        Ok(vote_threshold.clone())\n    }",
    "pub fn get_vote_tipping(\n        &self,\n        realm_data: &RealmV2,\n        governing_token_mint: &Pubkey,\n    ) -> Result<&VoteTipping, ProgramError> {\n        let vote_tipping = if *governing_token_mint == realm_data.community_mint {\n            &self.config.community_vote_tipping\n        } else if Some(*governing_token_mint) == realm_data.config.council_mint {\n            &self.config.council_vote_tipping\n        } else {\n            return Err(GovernanceError::InvalidGoverningTokenMint.into());\n        };\n\n        Ok(vote_tipping)\n    }",
    "pub fn get_proposal_deposit_amount(&self) -> u64 {\n        self.active_proposal_count\n            .saturating_sub(self.config.deposit_exempt_proposal_count as u64)\n            .saturating_mul(SECURITY_DEPOSIT_BASE_LAMPORTS)\n    }",
    "pub fn get_governance_data(\n    program_id: &Pubkey,\n    governance_info: &AccountInfo,\n) -> Result<GovernanceV2, ProgramError> {\n    let account_type: GovernanceAccountType = get_account_type(program_id, governance_info)?;\n\n    // If the account is V1 version then translate to V2\n    let mut governance_data = if is_governance_v1_account_type(&account_type) {\n        let governance_data_v1 = get_account_data::<GovernanceV1>(program_id, governance_info)?;\n\n        GovernanceV2 {\n            account_type,\n            realm: governance_data_v1.realm,\n            governance_seed: governance_data_v1.governance_seed,\n            reserved1: 0,\n            config: governance_data_v1.config,\n            reserved_v2: Reserved119::default(),\n            required_signatories_count: 0,\n            // GovernanceV1 layout doesn't support active_proposal_count\n            // For any legacy GovernanceV1 account it's not preserved until the account layout is\n            // migrated to GovernanceV2 in CreateProposal\n            active_proposal_count: 0,\n        }\n    } else {\n        get_account_data::<GovernanceV2>(program_id, governance_info)?\n    };\n\n    // In previous versions of spl-gov (< 3) we had\n    // config.proposal_cool_off_time:u32 which was unused and always 0\n    // In version 3.0.0 proposal_cool_off_time was replaced with\n    // council_vote_threshold:VoteThreshold and\n    // council_veto_vote_threshold:VoteThreshold If we read a legacy account\n    // then council_vote_threshold == VoteThreshold::YesVotePercentage(0)\n    //\n    // Note: assert_is_valid_governance_config() prevents setting\n    // council_vote_threshold to VoteThreshold::YesVotePercentage(0) which gives\n    // as guarantee that it is a legacy account layout set with\n    // proposal_cool_off_time = 0\n    //\n    // Note: All the settings below are one time config migration from program V1 &\n    // V2 account data to V3\n    if governance_data.config.council_vote_threshold == VoteThreshold::YesVotePercentage(0) {\n        // Set council_vote_threshold to community_vote_threshold which was used for\n        // both council and community thresholds before\n        governance_data.config.council_vote_threshold =\n            governance_data.config.community_vote_threshold.clone();\n\n        // The assumption here is that council should have Veto vote enabled by default\n        // and equal to council_vote_threshold\n        governance_data.config.council_veto_vote_threshold =\n            governance_data.config.council_vote_threshold.clone();\n\n        // For legacy accounts default Council VoteTipping to the Community\n        governance_data.config.council_vote_tipping =\n            governance_data.config.community_vote_tipping.clone();\n\n        // For legacy accounts set the community Veto threshold to Disabled\n        governance_data.config.community_veto_vote_threshold = VoteThreshold::Disabled;\n\n        // Reset voting_cool_off_time and deposit_exempt_proposal_count  previously used\n        // for voting_proposal_count\n        governance_data.config.voting_cool_off_time = 0;\n        governance_data.config.deposit_exempt_proposal_count =\n            DEFAULT_DEPOSIT_EXEMPT_PROPOSAL_COUNT;\n\n        // Reset reserved space previously used for proposal_count\n        governance_data.reserved1 = 0;\n    }\n\n    Ok(governance_data)\n}",
    "pub fn get_governance_data_for_realm(\n    program_id: &Pubkey,\n    governance_info: &AccountInfo,\n    realm: &Pubkey,\n) -> Result<GovernanceV2, ProgramError> {\n    let governance_data = get_governance_data(program_id, governance_info)?;\n\n    if governance_data.realm != *realm {\n        return Err(GovernanceError::InvalidRealmForGovernance.into());\n    }\n\n    Ok(governance_data)\n}",
    "pub fn assert_governance_for_realm(\n    program_id: &Pubkey,\n    governance_info: &AccountInfo,\n    realm: &Pubkey,\n) -> Result<(), ProgramError> {\n    get_governance_data_for_realm(program_id, governance_info, realm)?;\n    Ok(())\n}",
    "pub fn assert_is_valid_governance(\n    program_id: &Pubkey,\n    governance_info: &AccountInfo,\n) -> Result<(), ProgramError> {\n    assert_is_valid_account_of_types(program_id, governance_info, is_governance_account_type)\n}",
    "pub fn assert_valid_create_governance_args(\n    program_id: &Pubkey,\n    governance_config: &GovernanceConfig,\n    realm_info: &AccountInfo,\n) -> Result<(), ProgramError> {\n    assert_is_valid_realm(program_id, realm_info)?;\n\n    assert_is_valid_governance_config(governance_config)?;\n\n    Ok(())\n}",
    "pub fn assert_is_valid_governance_config(\n    governance_config: &GovernanceConfig,\n) -> Result<(), ProgramError> {\n    assert_is_valid_vote_threshold(&governance_config.community_vote_threshold)?;\n    assert_is_valid_vote_threshold(&governance_config.community_veto_vote_threshold)?;\n\n    assert_is_valid_vote_threshold(&governance_config.council_vote_threshold)?;\n    assert_is_valid_vote_threshold(&governance_config.council_veto_vote_threshold)?;\n\n    // Setting both thresholds to Disabled is not allowed, however we might\n    // reconsider it as a way to disable Governance permanently\n    if governance_config.community_vote_threshold == VoteThreshold::Disabled\n        && governance_config.council_vote_threshold == VoteThreshold::Disabled\n    {\n        return Err(GovernanceError::AtLeastOneVoteThresholdRequired.into());\n    }\n\n    // Make u8::MAX invalid value in case we would like to use the magic number as\n    // Disabled value in the future\n    if governance_config.deposit_exempt_proposal_count == u8::MAX {\n        return Err(GovernanceError::InvalidDepositExemptProposalCount.into());\n    }\n\n    Ok(())\n}",
    "pub fn assert_is_valid_vote_threshold(vote_threshold: &VoteThreshold) -> Result<(), ProgramError> {\n    match *vote_threshold {\n        VoteThreshold::YesVotePercentage(yes_vote_threshold_percentage) => {\n            if !(1..=100).contains(&yes_vote_threshold_percentage) {\n                return Err(GovernanceError::InvalidVoteThresholdPercentage.into());\n            }\n        }\n        VoteThreshold::QuorumPercentage(_) => {\n            return Err(GovernanceError::VoteThresholdTypeNotSupported.into());\n        }\n        VoteThreshold::Disabled => {}\n    }\n\n    Ok(())\n}",
    "pub fn is_governance_v1_account_type(account_type: &GovernanceAccountType) -> bool {\n    match account_type {\n        GovernanceAccountType::GovernanceV1\n        | GovernanceAccountType::ProgramGovernanceV1\n        | GovernanceAccountType::MintGovernanceV1\n        | GovernanceAccountType::TokenGovernanceV1 => true,\n        GovernanceAccountType::Uninitialized\n        | GovernanceAccountType::RealmV1\n        | GovernanceAccountType::RealmV2\n        | GovernanceAccountType::RealmConfig\n        | GovernanceAccountType::TokenOwnerRecordV1\n        | GovernanceAccountType::TokenOwnerRecordV2\n        | GovernanceAccountType::GovernanceV2\n        | GovernanceAccountType::ProgramGovernanceV2\n        | GovernanceAccountType::MintGovernanceV2\n        | GovernanceAccountType::TokenGovernanceV2\n        | GovernanceAccountType::ProposalV1\n        | GovernanceAccountType::ProposalV2\n        | GovernanceAccountType::SignatoryRecordV1\n        | GovernanceAccountType::SignatoryRecordV2\n        | GovernanceAccountType::ProposalInstructionV1\n        | GovernanceAccountType::ProposalTransactionV2\n        | GovernanceAccountType::VoteRecordV1\n        | GovernanceAccountType::VoteRecordV2\n        | GovernanceAccountType::ProgramMetadata\n        | GovernanceAccountType::ProposalDeposit\n        | GovernanceAccountType::RequiredSignatory => false,\n    }\n}\n\nimpl IsInitialized for GovernanceV1 {\n    fn is_initialized(&self) -> bool {\n        is_governance_v1_account_type(&self.account_type)\n    }",
    "pub fn get_program_metadata_address(program_id: &Pubkey) -> Pubkey {\n    Pubkey::find_program_address(&get_program_metadata_seeds(), program_id).0\n}\n\n/// Returns ProgramMetadata PDA seeds\npub fn get_program_metadata_seeds<'a>() -> [&'a [u8]; 1] {\n    [b\"metadata\"]\n}\n\n/// Deserializes account and checks owner program\npub fn get_program_metadata_data(\n    program_id: &Pubkey,\n    program_metadata_info: &AccountInfo,\n) -> Result<ProgramMetadata, ProgramError> {\n    get_account_data::<ProgramMetadata>(program_id, program_metadata_info)\n}",
    "pub fn assert_can_edit_signatories(&self) -> Result<(), ProgramError> {\n        self.assert_is_draft_state()\n            .map_err(|_| GovernanceError::InvalidStateCannotEditSignatories.into())\n    }",
    "pub fn assert_can_sign_off(&self) -> Result<(), ProgramError> {\n        match self.state {\n            ProposalState::Draft | ProposalState::SigningOff => Ok(()),\n            ProposalState::Executing\n            | ProposalState::ExecutingWithErrors\n            | ProposalState::Completed\n            | ProposalState::Cancelled\n            | ProposalState::Voting\n            | ProposalState::Succeeded\n            | ProposalState::Defeated\n            | ProposalState::Vetoed => Err(GovernanceError::InvalidStateCannotSignOff.into()),\n        }\n    }\n\n    /// Checks the Proposal is in Voting state\n    fn assert_is_voting_state(&self) -> Result<(), ProgramError> {\n        if self.state != ProposalState::Voting {\n            return Err(GovernanceError::InvalidProposalState.into());\n        }\n\n        Ok(())\n    }",
    "pub fn assert_is_final_state(&self) -> Result<(), ProgramError> {\n        match self.state {\n            ProposalState::Completed\n            | ProposalState::Cancelled\n            | ProposalState::Defeated\n            | ProposalState::Vetoed => Ok(()),\n            ProposalState::Executing\n            | ProposalState::ExecutingWithErrors\n            | ProposalState::SigningOff\n            | ProposalState::Voting\n            | ProposalState::Draft\n            | ProposalState::Succeeded => Err(GovernanceError::InvalidStateNotFinal.into()),\n        }\n    }\n\n    /// Checks if Proposal can be voted on\n    pub fn assert_can_cast_vote(\n        &self,\n        config: &GovernanceConfig,\n        vote: &Vote,\n        current_unix_timestamp: UnixTimestamp,\n    ) -> Result<(), ProgramError> {\n        self.assert_is_voting_state()\n            .map_err(|_| GovernanceError::InvalidStateCannotVote)?;\n\n        // Check if we are still within the configured max voting time period\n        if self.has_voting_max_time_ended(config, current_unix_timestamp) {\n            return Err(GovernanceError::ProposalVotingTimeExpired.into());\n        }\n\n        match vote {\n            Vote::Approve(_) | Vote::Abstain => {\n                // Once the base voting time passes and we are in the voting cool off time\n                // approving votes are no longer accepted Abstain is considered\n                // as positive vote because when attendance quorum is used it can tip the scales\n                if self.has_voting_base_time_ended(config, current_unix_timestamp) {\n                    Err(GovernanceError::VoteNotAllowedInCoolOffTime.into())\n                }",
    "pub fn assert_can_refund_proposal_deposit(&self) -> Result<(), ProgramError> {\n        match self.state {\n            ProposalState::Succeeded\n            | ProposalState::Executing\n            | ProposalState::Completed\n            | ProposalState::Cancelled\n            | ProposalState::Defeated\n            | ProposalState::ExecutingWithErrors\n            | ProposalState::Vetoed => Ok(()),\n            ProposalState::Draft | ProposalState::SigningOff | ProposalState::Voting => {\n                Err(GovernanceError::CannotRefundProposalDeposit.into())\n            }",
    "pub fn voting_base_time_end(&self, config: &GovernanceConfig) -> UnixTimestamp {\n        self.voting_at\n            .unwrap()\n            .checked_add(config.voting_base_time as i64)\n            .unwrap()\n    }",
    "pub fn has_voting_base_time_ended(\n        &self,\n        config: &GovernanceConfig,\n        current_unix_timestamp: UnixTimestamp,\n    ) -> bool {\n        // Check if we passed the configured base vote end time\n        self.voting_base_time_end(config) < current_unix_timestamp\n    }\n\n    /// Expected max vote end time determined by the configured\n    /// base_voting_time, optional voting_cool_off_time and actual voting start\n    /// time\n    pub fn voting_max_time_end(&self, config: &GovernanceConfig) -> UnixTimestamp {\n        self.voting_base_time_end(config)\n            .checked_add(config.voting_cool_off_time as i64)\n            .unwrap()\n    }",
    "pub fn has_voting_max_time_ended(\n        &self,\n        config: &GovernanceConfig,\n        current_unix_timestamp: UnixTimestamp,\n    ) -> bool {\n        // Check if we passed the max vote end time\n        self.voting_max_time_end(config) < current_unix_timestamp\n    }\n\n    /// Checks if Proposal can be finalized\n    pub fn assert_can_finalize_vote(\n        &self,\n        config: &GovernanceConfig,\n        current_unix_timestamp: UnixTimestamp,\n    ) -> Result<(), ProgramError> {\n        self.assert_is_voting_state()\n            .map_err(|_| GovernanceError::InvalidStateCannotFinalize)?;\n\n        // We can only finalize the vote after the configured max_voting_time has\n        // expired and vote time ended\n        if !self.has_voting_max_time_ended(config, current_unix_timestamp) {\n            return Err(GovernanceError::CannotFinalizeVotingInProgress.into());\n        }\n\n        Ok(())\n    }",
    "pub fn finalize_vote(\n        &mut self,\n        max_voter_weight: u64,\n        config: &GovernanceConfig,\n        current_unix_timestamp: UnixTimestamp,\n        vote_threshold: &VoteThreshold,\n    ) -> Result<(), ProgramError> {\n        self.assert_can_finalize_vote(config, current_unix_timestamp)?;\n\n        self.state = self.resolve_final_vote_state(max_voter_weight, vote_threshold)?;\n        self.voting_completed_at = Some(self.voting_max_time_end(config));\n\n        // Capture vote params to correctly display historical results\n        self.max_vote_weight = Some(max_voter_weight);\n        self.vote_threshold = Some(vote_threshold.clone());\n\n        Ok(())\n    }",
    "pub fn resolve_max_voter_weight(\n        &mut self,\n        account_info_iter: &mut Iter<AccountInfo>,\n        realm: &Pubkey,\n        realm_data: &RealmV2,\n        realm_config_data: &RealmConfigAccount,\n        vote_governing_token_mint_info: &AccountInfo,\n        vote_kind: &VoteKind,\n    ) -> Result<u64, ProgramError> {\n        // if the Realm is configured to use max voter weight for the given voting\n        // governing_token_mint then use the externally provided max_voter_weight\n        // instead of the supply based max\n        if let Some(max_voter_weight_addin) = realm_config_data\n            .get_token_config(realm_data, vote_governing_token_mint_info.key)?\n            .max_voter_weight_addin\n        {\n            let max_voter_weight_record_info = next_account_info(account_info_iter)?;\n\n            let max_voter_weight_record_data =\n                get_max_voter_weight_record_data_for_realm_and_governing_token_mint(\n                    &max_voter_weight_addin,\n                    max_voter_weight_record_info,\n                    realm,\n                    vote_governing_token_mint_info.key,\n                )?;\n\n            assert_is_valid_max_voter_weight(&max_voter_weight_record_data)?;\n\n            // When the max voter weight addin is used it's possible it can be inaccurate\n            // and we can have more votes then the max provided by the addin and\n            // we have to adjust it to whatever result is higher\n            return Ok(self.coerce_max_voter_weight(\n                max_voter_weight_record_data.max_voter_weight,\n                vote_kind,\n            ));\n        }\n\n        let vote_governing_token_mint_supply =\n            get_spl_token_mint_supply(vote_governing_token_mint_info)?;\n\n        let max_voter_weight = self.get_max_voter_weight_from_mint_supply(\n            realm_data,\n            vote_governing_token_mint_info.key,\n            vote_governing_token_mint_supply,\n            vote_kind,\n        )?;\n\n        Ok(max_voter_weight)\n    }",
    "pub fn try_tip_vote(\n        &mut self,\n        max_voter_weight: u64,\n        vote_tipping: &VoteTipping,\n        current_unix_timestamp: UnixTimestamp,\n        vote_threshold: &VoteThreshold,\n        vote_kind: &VoteKind,\n    ) -> Result<bool, ProgramError> {\n        if let Some(tipped_state) = self.try_get_tipped_vote_state(\n            max_voter_weight,\n            vote_tipping,\n            vote_threshold,\n            vote_kind,\n        ) {\n            self.state = tipped_state;\n            self.voting_completed_at = Some(current_unix_timestamp);\n\n            // Capture vote params to correctly display historical results\n            // Note: For Veto vote the captured params are from the Veto config\n            self.max_vote_weight = Some(max_voter_weight);\n            self.vote_threshold = Some(vote_threshold.clone());\n\n            Ok(true)\n        }",
    "pub fn try_get_tipped_vote_state(\n        &mut self,\n        max_voter_weight: u64,\n        vote_tipping: &VoteTipping,\n        vote_threshold: &VoteThreshold,\n        vote_kind: &VoteKind,\n    ) -> Option<ProposalState> {\n        let min_vote_threshold_weight =\n            get_min_vote_threshold_weight(vote_threshold, max_voter_weight).unwrap();\n\n        match vote_kind {\n            VoteKind::Electorate => self.try_get_tipped_electorate_vote_state(\n                max_voter_weight,\n                vote_tipping,\n                min_vote_threshold_weight,\n            ),\n            VoteKind::Veto => self.try_get_tipped_veto_vote_state(min_vote_threshold_weight),\n        }\n    }\n\n    /// Checks if Electorate vote can be tipped and automatically transitioned\n    /// to Succeeded or Defeated state.\n    /// If yes then Some(ProposalState) is returned and None otherwise\n    fn try_get_tipped_electorate_vote_state(\n        &mut self,\n        max_voter_weight: u64,\n        vote_tipping: &VoteTipping,\n        min_vote_threshold_weight: u64,\n    ) -> Option<ProposalState> {\n        // Vote tipping is currently supported for SingleChoice votes with\n        // single Yes and No (rejection) options only.\n        // Note: Tipping for multiple options (single choice and multiple\n        // choices) should be possible but it requires a great deal of\n        // considerations and I decided to fight it another day\n        if self.vote_type != VoteType::SingleChoice\n            // Tipping should not be allowed for opinion only proposals (surveys\n            // without rejection) to allow everybody's voice to be heard\n            || self.deny_vote_weight.is_none()\n            || self.options.len() != 1\n        {\n            return None;\n        };\n\n        let yes_option = &mut self.options[0];\n\n        let yes_vote_weight = yes_option.vote_weight;\n        let deny_vote_weight = self.deny_vote_weight.unwrap();\n\n        match vote_tipping {\n            VoteTipping::Disabled => {}\n            VoteTipping::Strict => {\n                if yes_vote_weight >= min_vote_threshold_weight\n                    && yes_vote_weight > (max_voter_weight.saturating_sub(yes_vote_weight))\n                {\n                    yes_option.vote_result = OptionVoteResult::Succeeded;\n                    return Some(ProposalState::Succeeded);\n                }\n            }\n            VoteTipping::Early => {\n                if yes_vote_weight >= min_vote_threshold_weight\n                    && yes_vote_weight > deny_vote_weight\n                {\n                    yes_option.vote_result = OptionVoteResult::Succeeded;\n                    return Some(ProposalState::Succeeded);\n                }\n            }\n        }\n\n        // If vote tipping isn't disabled entirely, allow a vote to complete as\n        // \"defeated\" if there is no possible way of reaching majority or the\n        // min_vote_threshold_weight for another option. This tipping is always\n        // strict, there's no equivalent to \"early\" tipping for deny votes.\n        if *vote_tipping != VoteTipping::Disabled\n            && (deny_vote_weight > (max_voter_weight.saturating_sub(min_vote_threshold_weight))\n                || deny_vote_weight >= (max_voter_weight.saturating_sub(deny_vote_weight)))\n        {\n            yes_option.vote_result = OptionVoteResult::Defeated;\n            return Some(ProposalState::Defeated);\n        }\n\n        None\n    }\n\n    /// Checks if vote can be tipped and transitioned to Vetoed state\n    /// If yes then Some(ProposalState::Vetoed) is returned and None otherwise\n    fn try_get_tipped_veto_vote_state(\n        &mut self,\n        min_vote_threshold_weight: u64,\n    ) -> Option<ProposalState> {\n        // Veto vote tips as soon as the required threshold is reached\n        // It's irrespectively of vote_tipping config because the outcome of the\n        // Proposal can't change any longer after being vetoed\n        if self.veto_vote_weight >= min_vote_threshold_weight {\n            // Note: Since we don't tip multi option votes all options vote_result would\n            // remain as None\n            Some(ProposalState::Vetoed)\n        }",
    "pub fn assert_can_cancel(\n        &self,\n        config: &GovernanceConfig,\n        current_unix_timestamp: UnixTimestamp,\n    ) -> Result<(), ProgramError> {\n        match self.state {\n            ProposalState::Draft | ProposalState::SigningOff => Ok(()),\n            ProposalState::Voting => {\n                // Note: If there is no tipping point the proposal can be still in Voting state\n                // but already past the configured max_voting_time In that case\n                // we treat the proposal as finalized and it's no longer allowed to be canceled\n                if self.has_voting_max_time_ended(config, current_unix_timestamp) {\n                    return Err(GovernanceError::ProposalVotingTimeExpired.into());\n                }\n                Ok(())\n            }",
    "pub fn assert_can_edit_instructions(&self) -> Result<(), ProgramError> {\n        if self.assert_is_draft_state().is_err() {\n            return Err(GovernanceError::InvalidStateCannotEditTransactions.into());\n        }\n\n        // For security purposes only proposals with the reject option can have\n        // executable instructions\n        if self.deny_vote_weight.is_none() {\n            return Err(GovernanceError::ProposalIsNotExecutable.into());\n        }\n\n        Ok(())\n    }",
    "pub fn assert_can_execute_transaction(\n        &self,\n        proposal_transaction_data: &ProposalTransactionV2,\n        governance_config: &GovernanceConfig,\n        current_unix_timestamp: UnixTimestamp,\n    ) -> Result<(), ProgramError> {\n        match self.state {\n            ProposalState::Succeeded\n            | ProposalState::Executing\n            | ProposalState::ExecutingWithErrors => {}\n            ProposalState::Draft\n            | ProposalState::SigningOff\n            | ProposalState::Completed\n            | ProposalState::Voting\n            | ProposalState::Cancelled\n            | ProposalState::Defeated\n            | ProposalState::Vetoed => {\n                return Err(GovernanceError::InvalidStateCannotExecuteTransaction.into())\n            }",
    "pub fn assert_can_complete(&self) -> Result<(), ProgramError> {\n        // Proposal vote must be successful\n        if self.state != ProposalState::Succeeded {\n            return Err(GovernanceError::InvalidStateToCompleteProposal.into());\n        }\n\n        // There must be no on-chain executable actions\n        if self.options.iter().any(|o| o.transactions_count != 0) {\n            return Err(GovernanceError::InvalidStateToCompleteProposal.into());\n        }\n\n        Ok(())\n    }",
    "pub fn assert_valid_vote(&self, vote: &Vote) -> Result<(), ProgramError> {\n        match vote {\n            Vote::Approve(choices) => {\n                if self.options.len() != choices.len() {\n                    return Err(GovernanceError::InvalidNumberOfVoteChoices.into());\n                }\n\n                let mut choice_count = 0u16;\n                let mut total_choice_weight_percentage = 0u8;\n\n                for choice in choices {\n                    if choice.rank > 0 {\n                        return Err(GovernanceError::RankedVoteIsNotSupported.into());\n                    }\n\n                    if choice.weight_percentage > 0 {\n                        choice_count = choice_count.checked_add(1).unwrap();\n\n                        match self.vote_type {\n                            VoteType::MultiChoice {\n                                choice_type: MultiChoiceType::Weighted,\n                                min_voter_options: _,\n                                max_voter_options: _,\n                                max_winning_options: _,\n                            } => {\n                                // Calculate the total percentage for all choices for weighted\n                                // choice vote. The total must add up\n                                // to exactly 100%\n                                total_choice_weight_percentage = total_choice_weight_percentage\n                                    .checked_add(choice.weight_percentage)\n                                    .ok_or(GovernanceError::TotalVoteWeightMustBe100Percent)?;\n                            }\n                            _ => {\n                                if choice.weight_percentage != 100 {\n                                    return Err(\n                                        GovernanceError::ChoiceWeightMustBe100Percent.into()\n                                    );\n                                }\n                            }\n                        }\n                    }\n                }\n\n                match self.vote_type {\n                    VoteType::SingleChoice => {\n                        if choice_count != 1 {\n                            return Err(GovernanceError::SingleChoiceOnlyIsAllowed.into());\n                        }\n                    }\n                    VoteType::MultiChoice {\n                        choice_type: MultiChoiceType::FullWeight,\n                        min_voter_options: _,\n                        max_voter_options: _,\n                        max_winning_options: _,\n                    } => {\n                        if choice_count == 0 {\n                            return Err(GovernanceError::AtLeastSingleChoiceIsRequired.into());\n                        }\n                    }\n                    VoteType::MultiChoice {\n                        choice_type: MultiChoiceType::Weighted,\n                        min_voter_options: _,\n                        max_voter_options: _,\n                        max_winning_options: _,\n                    } => {\n                        if choice_count == 0 {\n                            return Err(GovernanceError::AtLeastSingleChoiceIsRequired.into());\n                        }\n                        if total_choice_weight_percentage != 100 {\n                            return Err(GovernanceError::TotalVoteWeightMustBe100Percent.into());\n                        }\n                    }\n                }\n            }\n            Vote::Deny => {\n                if self.deny_vote_weight.is_none() {\n                    return Err(GovernanceError::DenyVoteIsNotAllowed.into());\n                }\n            }\n            Vote::Abstain => {\n                return Err(GovernanceError::NotSupportedVoteType.into());\n            }\n            Vote::Veto => {}\n        }\n\n        Ok(())\n    }",
    "pub fn get_proposal_data(\n    program_id: &Pubkey,\n    proposal_info: &AccountInfo,\n) -> Result<ProposalV2, ProgramError> {\n    let account_type: GovernanceAccountType = get_account_type(program_id, proposal_info)?;\n\n    // If the account is V1 version then translate to V2\n    if account_type == GovernanceAccountType::ProposalV1 {\n        let proposal_data_v1 = get_account_data::<ProposalV1>(program_id, proposal_info)?;\n\n        let vote_result = match proposal_data_v1.state {\n            ProposalState::Draft\n            | ProposalState::SigningOff\n            | ProposalState::Voting\n            | ProposalState::Cancelled => OptionVoteResult::None,\n            ProposalState::Succeeded\n            | ProposalState::Executing\n            | ProposalState::ExecutingWithErrors\n            | ProposalState::Completed => OptionVoteResult::Succeeded,\n            ProposalState::Vetoed | ProposalState::Defeated => OptionVoteResult::None,\n        };\n\n        return Ok(ProposalV2 {\n            account_type,\n            governance: proposal_data_v1.governance,\n            governing_token_mint: proposal_data_v1.governing_token_mint,\n            state: proposal_data_v1.state,\n            token_owner_record: proposal_data_v1.token_owner_record,\n            signatories_count: proposal_data_v1.signatories_count,\n            signatories_signed_off_count: proposal_data_v1.signatories_signed_off_count,\n            vote_type: VoteType::SingleChoice,\n            options: vec![ProposalOption {\n                label: \"Yes\".to_string(),\n                vote_weight: proposal_data_v1.yes_votes_count,\n                vote_result,\n                transactions_executed_count: proposal_data_v1.instructions_executed_count,\n                transactions_count: proposal_data_v1.instructions_count,\n                transactions_next_index: proposal_data_v1.instructions_next_index,\n            }],\n            deny_vote_weight: Some(proposal_data_v1.no_votes_count),\n            veto_vote_weight: 0,\n            abstain_vote_weight: None,\n            start_voting_at: None,\n            draft_at: proposal_data_v1.draft_at,\n            signing_off_at: proposal_data_v1.signing_off_at,\n            voting_at: proposal_data_v1.voting_at,\n            voting_at_slot: proposal_data_v1.voting_at_slot,\n            voting_completed_at: proposal_data_v1.voting_completed_at,\n            executing_at: proposal_data_v1.executing_at,\n            closed_at: proposal_data_v1.closed_at,\n            execution_flags: proposal_data_v1.execution_flags,\n            max_vote_weight: proposal_data_v1.max_vote_weight,\n            max_voting_time: None,\n            vote_threshold: proposal_data_v1.vote_threshold,\n            name: proposal_data_v1.name,\n            description_link: proposal_data_v1.description_link,\n            reserved: [0; 64],\n            reserved1: 0,\n        });\n    }\n\n    get_account_data::<ProposalV2>(program_id, proposal_info)\n}",
    "pub fn get_proposal_data_for_governance_and_governing_mint(\n    program_id: &Pubkey,\n    proposal_info: &AccountInfo,\n    governance: &Pubkey,\n    governing_token_mint: &Pubkey,\n) -> Result<ProposalV2, ProgramError> {\n    let proposal_data = get_proposal_data_for_governance(program_id, proposal_info, governance)?;\n\n    if proposal_data.governing_token_mint != *governing_token_mint {\n        return Err(GovernanceError::InvalidGoverningMintForProposal.into());\n    }\n\n    Ok(proposal_data)\n}",
    "pub fn get_proposal_data_for_governance(\n    program_id: &Pubkey,\n    proposal_info: &AccountInfo,\n    governance: &Pubkey,\n) -> Result<ProposalV2, ProgramError> {\n    let proposal_data = get_proposal_data(program_id, proposal_info)?;\n\n    if proposal_data.governance != *governance {\n        return Err(GovernanceError::InvalidGovernanceForProposal.into());\n    }\n\n    Ok(proposal_data)\n}",
    "pub fn assert_valid_proposal_options(\n    options: &[String],\n    vote_type: &VoteType,\n) -> Result<(), ProgramError> {\n    if options.is_empty() || options.len() > 10 {\n        return Err(GovernanceError::InvalidProposalOptions.into());\n    }\n\n    if let VoteType::MultiChoice {\n        choice_type: _,\n        min_voter_options,\n        max_voter_options,\n        max_winning_options,\n    } = vote_type\n    {\n        if options.len() == 1\n            || *max_voter_options as usize != options.len()\n            || *max_winning_options as usize != options.len()\n            || *min_voter_options != 1\n        {\n            return Err(GovernanceError::InvalidMultiChoiceProposalParameters.into());\n        }\n    }\n\n    // TODO: Check for duplicated option labels\n    // The options are identified by index so it's ok for now\n\n    if options.iter().any(|o| o.is_empty()) {\n        return Err(GovernanceError::InvalidProposalOptions.into());\n    }\n\n    Ok(())\n}",
    "pub fn test_finalize_vote_with_expired_voting_time_error() {\n        // Arrange\n        let mut proposal = create_test_proposal();\n        proposal.state = ProposalState::Voting;\n        let governance_config = create_test_governance_config();\n\n        let current_timestamp =\n            proposal.voting_at.unwrap() + governance_config.voting_base_time as i64;\n\n        let realm = create_test_realm();\n        let governing_token_mint = proposal.governing_token_mint;\n        let vote_kind = VoteKind::Electorate;\n\n        let max_voter_weight = proposal\n            .get_max_voter_weight_from_mint_supply(&realm, &governing_token_mint, 100, &vote_kind)\n            .unwrap();\n\n        let vote_threshold = &governance_config.community_vote_threshold;\n\n        // Act\n        let err = proposal\n            .finalize_vote(\n                max_voter_weight,\n                &governance_config,\n                current_timestamp,\n                vote_threshold,\n            )\n            .err()\n            .unwrap();\n\n        // Assert\n        assert_eq!(err, GovernanceError::CannotFinalizeVotingInProgress.into());\n    }\n\n    #[test]\n    pub fn test_finalize_vote_after_voting_time() {\n        // Arrange\n        let mut proposal = create_test_proposal();\n        proposal.state = ProposalState::Voting;\n        let governance_config = create_test_governance_config();\n\n        let current_timestamp =\n            proposal.voting_at.unwrap() + governance_config.voting_base_time as i64 + 1;\n\n        let realm = create_test_realm();\n        let governing_token_mint = proposal.governing_token_mint;\n        let vote_kind = VoteKind::Electorate;\n\n        let max_voter_weight = proposal\n            .get_max_voter_weight_from_mint_supply(&realm, &governing_token_mint, 100, &vote_kind)\n            .unwrap();\n\n        let vote_threshold = &governance_config.community_vote_threshold;\n\n        // Act\n        let result = proposal.finalize_vote(\n            max_voter_weight,\n            &governance_config,\n            current_timestamp,\n            vote_threshold,\n        );\n\n        // Assert\n        assert_eq!(result, Ok(()));\n    }\n\n    #[test]\n    pub fn test_assert_can_vote_with_expired_voting_time_error() {\n        // Arrange\n        let mut proposal = create_test_proposal();\n        proposal.state = ProposalState::Voting;\n        let governance_config = create_test_governance_config();\n\n        let current_timestamp =\n            proposal.voting_at.unwrap() + governance_config.voting_base_time as i64 + 1;\n\n        let vote = Vote::Approve(vec![]);\n\n        // Act\n        let err = proposal\n            .assert_can_cast_vote(&governance_config, &vote, current_timestamp)\n            .err()\n            .unwrap();\n\n        // Assert\n        assert_eq!(err, GovernanceError::ProposalVotingTimeExpired.into());\n    }\n\n    #[test]\n    pub fn test_assert_can_vote_within_voting_time() {\n        // Arrange\n        let mut proposal = create_test_proposal();\n        proposal.state = ProposalState::Voting;\n        let governance_config = create_test_governance_config();\n\n        let current_timestamp =\n            proposal.voting_at.unwrap() + governance_config.voting_base_time as i64;\n\n        let vote = Vote::Approve(vec![]);\n\n        // Act\n        let result = proposal.assert_can_cast_vote(&governance_config, &vote, current_timestamp);\n\n        // Assert\n        assert_eq!(result, Ok(()));\n    }\n\n    #[test]\n    pub fn test_assert_can_vote_approve_before_voting_cool_off_time() {\n        // Arrange\n        let mut proposal = create_test_proposal();\n        proposal.state = ProposalState::Voting;\n\n        let mut governance_config = create_test_governance_config();\n        governance_config.voting_cool_off_time = 2;\n\n        let current_timestamp =\n            proposal.voting_at.unwrap() + governance_config.voting_base_time as i64 - 1;\n\n        let vote = Vote::Approve(vec![]);\n\n        // Act\n        let result = proposal.assert_can_cast_vote(&governance_config, &vote, current_timestamp);\n\n        // Assert\n        assert_eq!(result, Ok(()));\n    }\n\n    #[test]\n    pub fn test_assert_cannot_vote_approve_within_voting_cool_off_time() {\n        // Arrange\n        let mut proposal = create_test_proposal();\n        proposal.state = ProposalState::Voting;\n\n        let mut governance_config = create_test_governance_config();\n        governance_config.voting_cool_off_time = 2;\n\n        let current_timestamp =\n            proposal.voting_at.unwrap() + governance_config.voting_base_time as i64 + 1;\n\n        let vote = Vote::Approve(vec![]);\n\n        // Act\n        let err = proposal\n            .assert_can_cast_vote(&governance_config, &vote, current_timestamp)\n            .err()\n            .unwrap();\n\n        // Assert\n        assert_eq!(err, GovernanceError::VoteNotAllowedInCoolOffTime.into());\n    }\n\n    #[test]\n    pub fn test_assert_can_vote_veto_within_voting_cool_off_time() {\n        // Arrange\n        let mut proposal = create_test_proposal();\n        proposal.state = ProposalState::Voting;\n\n        let mut governance_config = create_test_governance_config();\n        governance_config.voting_cool_off_time = 2;\n\n        let current_timestamp =\n            proposal.voting_at.unwrap() + governance_config.voting_base_time as i64 + 1;\n\n        let vote = Vote::Veto;\n\n        // Act\n        let result = proposal.assert_can_cast_vote(&governance_config, &vote, current_timestamp);\n\n        // Assert\n        assert_eq!(result, Ok(()));\n    }\n\n    #[test]\n    pub fn test_assert_can_vote_deny_within_voting_cool_off_time() {\n        // Arrange\n        let mut proposal = create_test_proposal();\n        proposal.state = ProposalState::Voting;\n\n        let mut governance_config = create_test_governance_config();\n        governance_config.voting_cool_off_time = 1;\n\n        let current_timestamp =\n            proposal.voting_at.unwrap() + governance_config.voting_base_time as i64 + 1;\n\n        let vote = Vote::Deny;\n\n        // Act\n        let result = proposal.assert_can_cast_vote(&governance_config, &vote, current_timestamp);\n\n        // Assert\n        assert_eq!(result, Ok(()));\n    }\n\n    #[test]\n    pub fn test_assert_valid_vote_with_deny_vote_for_survey_only_proposal_error() {\n        // Arrange\n        let mut proposal = create_test_proposal();\n        proposal.deny_vote_weight = None;\n\n        // Survey only proposal can't be denied\n        let vote = Vote::Deny;\n\n        // Act\n        let result = proposal.assert_valid_vote(&vote);\n\n        // Assert\n        assert_eq!(result, Err(GovernanceError::DenyVoteIsNotAllowed.into()));\n    }\n\n    #[test]\n    pub fn test_assert_valid_vote_with_too_many_options_error() {\n        // Arrange\n        let proposal = create_test_proposal();\n\n        let choices = vec![\n            VoteChoice {\n                rank: 0,\n                weight_percentage: 100,\n            },\n            VoteChoice {\n                rank: 0,\n                weight_percentage: 100,\n            },\n        ];\n\n        let vote = Vote::Approve(choices.clone());\n\n        // Ensure\n        assert!(proposal.options.len() != choices.len());\n\n        // Act\n        let result = proposal.assert_valid_vote(&vote);\n\n        // Assert\n        assert_eq!(\n            result,\n            Err(GovernanceError::InvalidNumberOfVoteChoices.into())\n        );\n    }\n\n    #[test]\n    pub fn test_assert_valid_vote_with_no_choice_for_single_choice_error() {\n        // Arrange\n        let proposal = create_test_proposal();\n\n        let choices = vec![VoteChoice {\n            rank: 0,\n            weight_percentage: 0,\n        }];\n\n        let vote = Vote::Approve(choices.clone());\n\n        // Ensure\n        assert_eq!(proposal.options.len(), choices.len());\n\n        // Act\n        let result = proposal.assert_valid_vote(&vote);\n\n        // Assert\n        assert_eq!(\n            result,\n            Err(GovernanceError::SingleChoiceOnlyIsAllowed.into())\n        );\n    }\n\n    #[test]\n    pub fn test_assert_valid_vote_with_to_many_choices_for_single_choice_error() {\n        // Arrange\n        let proposal = create_test_multi_option_proposal();\n        let choices = vec![\n            VoteChoice {\n                rank: 0,\n                weight_percentage: 100,\n            },\n            VoteChoice {\n                rank: 0,\n                weight_percentage: 100,\n            },\n            VoteChoice {\n                rank: 0,\n                weight_percentage: 0,\n            },\n        ];\n\n        let vote = Vote::Approve(choices.clone());\n\n        // Ensure\n        assert_eq!(proposal.options.len(), choices.len());\n\n        // Act\n        let result = proposal.assert_valid_vote(&vote);\n\n        // Assert\n        assert_eq!(\n            result,\n            Err(GovernanceError::SingleChoiceOnlyIsAllowed.into())\n        );\n    }\n\n    #[test]\n    pub fn test_assert_valid_multi_choice_full_weight_vote() {\n        // Arrange\n        let mut proposal = create_test_multi_option_proposal();\n        proposal.vote_type = VoteType::MultiChoice {\n            choice_type: MultiChoiceType::FullWeight,\n            min_voter_options: 1,\n            max_voter_options: 4,\n            max_winning_options: 4,\n        };\n        let choices = vec![\n            VoteChoice {\n                rank: 0,\n                weight_percentage: 100,\n            },\n            VoteChoice {\n                rank: 0,\n                weight_percentage: 100,\n            },\n            VoteChoice {\n                rank: 0,\n                weight_percentage: 100,\n            },\n        ];\n\n        let vote = Vote::Approve(choices.clone());\n\n        // Ensure\n        assert_eq!(proposal.options.len(), choices.len());\n\n        // Act\n        let result = proposal.assert_valid_vote(&vote);\n\n        // Assert\n        assert_eq!(result, Ok(()));\n    }\n\n    #[test]\n    pub fn test_assert_valid_vote_with_no_choices_for_multi_choice_error() {\n        // Arrange\n        let mut proposal = create_test_multi_option_proposal();\n        proposal.vote_type = VoteType::MultiChoice {\n            choice_type: MultiChoiceType::FullWeight,\n            min_voter_options: 1,\n            max_voter_options: 3,\n            max_winning_options: 3,\n        };\n\n        let choices = vec![\n            VoteChoice {\n                rank: 0,\n                weight_percentage: 0,\n            },\n            VoteChoice {\n                rank: 0,\n                weight_percentage: 0,\n            },\n            VoteChoice {\n                rank: 0,\n                weight_percentage: 0,\n            },\n        ];\n\n        let vote = Vote::Approve(choices.clone());\n\n        // Ensure\n        assert_eq!(proposal.options.len(), choices.len());\n\n        // Act\n        let result = proposal.assert_valid_vote(&vote);\n\n        // Assert\n        assert_eq!(\n            result,\n            Err(GovernanceError::AtLeastSingleChoiceIsRequired.into())\n        );\n    }\n\n    #[test]\n    pub fn test_assert_valid_vote_with_choice_weight_not_100_percent_error() {\n        // Arrange\n        let mut proposal = create_test_multi_option_proposal();\n        proposal.vote_type = VoteType::MultiChoice {\n            choice_type: MultiChoiceType::FullWeight,\n            min_voter_options: 1,\n            max_voter_options: 3,\n            max_winning_options: 3,\n        };\n\n        let choices = vec![\n            VoteChoice {\n                rank: 0,\n                weight_percentage: 50,\n            },\n            VoteChoice {\n                rank: 0,\n                weight_percentage: 50,\n            },\n            VoteChoice {\n                rank: 0,\n                weight_percentage: 0,\n            },\n        ];\n\n        let vote = Vote::Approve(choices.clone());\n\n        // Ensure\n        assert_eq!(proposal.options.len(), choices.len());\n\n        // Act\n        let result = proposal.assert_valid_vote(&vote);\n\n        // Assert\n        assert_eq!(\n            result,\n            Err(GovernanceError::ChoiceWeightMustBe100Percent.into())\n        );\n    }\n\n    #[test]\n    pub fn test_assert_valid_proposal_options_with_invalid_choice_number_for_multi_choice_vote_error(\n    ) {\n        // Arrange\n        let vote_type = VoteType::MultiChoice {\n            choice_type: MultiChoiceType::FullWeight,\n            min_voter_options: 1,\n            max_voter_options: 3,\n            max_winning_options: 3,\n        };\n\n        let options = vec![\"option 1\".to_string(), \"option 2\".to_string()];\n\n        // Act\n        let result = assert_valid_proposal_options(&options, &vote_type);\n\n        // Assert\n        assert_eq!(\n            result,\n            Err(GovernanceError::InvalidMultiChoiceProposalParameters.into())\n        );\n    }\n\n    #[test]\n    pub fn test_assert_valid_proposal_options_with_no_options_for_multi_choice_vote_error() {\n        // Arrange\n        let vote_type = VoteType::MultiChoice {\n            choice_type: MultiChoiceType::FullWeight,\n            min_voter_options: 1,\n            max_voter_options: 3,\n            max_winning_options: 3,\n        };\n\n        let options = vec![];\n\n        // Act\n        let result = assert_valid_proposal_options(&options, &vote_type);\n\n        // Assert\n        assert_eq!(result, Err(GovernanceError::InvalidProposalOptions.into()));\n    }\n\n    #[test]\n    pub fn test_assert_valid_proposal_options_with_no_options_for_single_choice_vote_error() {\n        // Arrange\n        let vote_type = VoteType::SingleChoice;\n\n        let options = vec![];\n\n        // Act\n        let result = assert_valid_proposal_options(&options, &vote_type);\n\n        // Assert\n        assert_eq!(result, Err(GovernanceError::InvalidProposalOptions.into()));\n    }\n\n    #[test]\n    pub fn test_assert_valid_proposal_options_for_multi_choice_vote() {\n        // Arrange\n        let vote_type = VoteType::MultiChoice {\n            choice_type: MultiChoiceType::FullWeight,\n            min_voter_options: 1,\n            max_voter_options: 3,\n            max_winning_options: 3,\n        };\n\n        let options = vec![\n            \"option 1\".to_string(),\n            \"option 2\".to_string(),\n            \"option 3\".to_string(),\n        ];\n\n        // Act\n        let result = assert_valid_proposal_options(&options, &vote_type);\n\n        // Assert\n        assert_eq!(result, Ok(()));\n    }\n\n    #[test]\n    pub fn test_assert_valid_proposal_options_for_multi_choice_vote_with_empty_option_error() {\n        // Arrange\n        let vote_type = VoteType::MultiChoice {\n            choice_type: MultiChoiceType::FullWeight,\n            min_voter_options: 1,\n            max_voter_options: 3,\n            max_winning_options: 3,\n        };\n\n        let options = vec![\n            \"\".to_string(),\n            \"option 2\".to_string(),\n            \"option 3\".to_string(),\n        ];\n\n        // Act\n        let result = assert_valid_proposal_options(&options, &vote_type);\n\n        // Assert\n        assert_eq!(result, Err(GovernanceError::InvalidProposalOptions.into()));\n    }\n\n    #[test]\n    pub fn test_assert_valid_vote_for_multi_weighted_choice() {\n        // Multi weighted choice may be weighted but sum of choices has to be 100%\n        // Arrange\n        let mut proposal = create_test_multi_option_proposal();\n        proposal.vote_type = VoteType::MultiChoice {\n            choice_type: MultiChoiceType::Weighted,\n            min_voter_options: 1,\n            max_voter_options: 3,\n            max_winning_options: 3,\n        };\n\n        let choices = vec![\n            VoteChoice {\n                rank: 0,\n                weight_percentage: 42,\n            },\n            VoteChoice {\n                rank: 0,\n                weight_percentage: 42,\n            },\n            VoteChoice {\n                rank: 0,\n                weight_percentage: 16,\n            },\n        ];\n        let vote = Vote::Approve(choices.clone());\n\n        // Ensure\n        assert_eq!(proposal.options.len(), choices.len());\n\n        // Act\n        let result = proposal.assert_valid_vote(&vote);\n\n        // Assert\n        assert_eq!(result, Ok(()));\n    }\n\n    #[test]\n    pub fn test_assert_valid_full_vote_for_multi_weighted_choice() {\n        // Multi weighted choice may be weighted to 100% and 0% rest\n        // Arrange\n        let mut proposal = create_test_multi_option_proposal();\n        proposal.vote_type = VoteType::MultiChoice {\n            choice_type: MultiChoiceType::Weighted,\n            min_voter_options: 1,\n            max_voter_options: 3,\n            max_winning_options: 3,\n        };\n\n        let choices = vec![\n            VoteChoice {\n                rank: 0,\n                weight_percentage: 0,\n            },\n            VoteChoice {\n                rank: 0,\n                weight_percentage: 100,\n            },\n            VoteChoice {\n                rank: 0,\n                weight_percentage: 0,\n            },\n        ];\n        let vote = Vote::Approve(choices.clone());\n\n        // Ensure\n        assert_eq!(proposal.options.len(), choices.len());\n\n        // Act\n        let result = proposal.assert_valid_vote(&vote);\n\n        // Assert\n        assert_eq!(result, Ok(()));\n    }\n\n    #[test]\n    pub fn test_assert_valid_vote_with_total_vote_weight_above_100_percent_for_multi_weighted_choice_error(\n    ) {\n        // Arrange\n        let mut proposal = create_test_multi_option_proposal();\n        proposal.vote_type = VoteType::MultiChoice {\n            choice_type: MultiChoiceType::Weighted,\n            min_voter_options: 1,\n            max_voter_options: 2,\n            max_winning_options: 2,\n        };\n\n        let choices = vec![\n            VoteChoice {\n                rank: 0,\n                weight_percentage: 34,\n            },\n            VoteChoice {\n                rank: 0,\n                weight_percentage: 34,\n            },\n            VoteChoice {\n                rank: 0,\n                weight_percentage: 34,\n            },\n        ];\n        let vote = Vote::Approve(choices.clone());\n\n        // Ensure\n        assert_eq!(proposal.options.len(), choices.len());\n\n        // Act\n        let result = proposal.assert_valid_vote(&vote);\n\n        // Assert\n        assert_eq!(\n            result,\n            Err(GovernanceError::TotalVoteWeightMustBe100Percent.into())\n        );\n    }\n\n    #[test]\n    pub fn test_assert_valid_vote_with_over_percentage_for_multi_weighted_choice_error() {\n        // Multi weighted choice does not permit vote with sum weight over 100%\n        // Arrange\n        let mut proposal = create_test_multi_option_proposal();\n        proposal.vote_type = VoteType::MultiChoice {\n            choice_type: MultiChoiceType::Weighted,\n            min_voter_options: 1,\n            max_voter_options: 3,\n            max_winning_options: 3,\n        };\n\n        let choices = vec![\n            VoteChoice {\n                rank: 0,\n                weight_percentage: 34,\n            },\n            VoteChoice {\n                rank: 0,\n                weight_percentage: 34,\n            },\n            VoteChoice {\n                rank: 0,\n                weight_percentage: 34,\n            },\n        ];\n        let vote = Vote::Approve(choices.clone());\n\n        // Ensure\n        assert_eq!(proposal.options.len(), choices.len());\n\n        // Act\n        let result = proposal.assert_valid_vote(&vote);\n\n        // Assert\n        assert_eq!(\n            result,\n            Err(GovernanceError::TotalVoteWeightMustBe100Percent.into())\n        );\n    }\n\n    #[test]\n    pub fn test_assert_valid_vote_with_overflow_weight_for_multi_weighted_choice_error() {\n        // Multi weighted choice does not permit vote with sum weight over 100%\n        // Arrange\n        let mut proposal = create_test_multi_option_proposal();\n        proposal.vote_type = VoteType::MultiChoice {\n            choice_type: MultiChoiceType::Weighted,\n            min_voter_options: 1,\n            max_voter_options: 3,\n            max_winning_options: 3,\n        };\n\n        let choices = vec![\n            VoteChoice {\n                rank: 0,\n                weight_percentage: 100,\n            },\n            VoteChoice {\n                rank: 0,\n                weight_percentage: 100,\n            },\n            VoteChoice {\n                rank: 0,\n                weight_percentage: 100,\n            },\n        ];\n        let vote = Vote::Approve(choices.clone());\n\n        // Ensure\n        assert_eq!(proposal.options.len(), choices.len());\n\n        // Act\n        let result = proposal.assert_valid_vote(&vote);\n\n        // Assert\n        assert_eq!(\n            result,\n            Err(GovernanceError::TotalVoteWeightMustBe100Percent.into())\n        );\n    }\n\n    #[test]\n    pub fn test_assert_valid_proposal_options_with_invalid_choice_number_for_multi_weighted_choice_vote_error(\n    ) {\n        // Arrange\n        let vote_type = VoteType::MultiChoice {\n            choice_type: MultiChoiceType::Weighted,\n            min_voter_options: 1,\n            max_voter_options: 3,\n            max_winning_options: 3,\n        };\n\n        let options = vec![\"option 1\".to_string(), \"option 2\".to_string()];\n\n        // Act\n        let result = assert_valid_proposal_options(&options, &vote_type);\n\n        // Assert\n        assert_eq!(\n            result,\n            Err(GovernanceError::InvalidMultiChoiceProposalParameters.into())\n        );\n    }\n\n    #[test]\n    pub fn test_assert_valid_proposal_options_with_no_options_for_multi_weighted_choice_vote_error()\n    {\n        // Arrange\n        let vote_type = VoteType::MultiChoice {\n            choice_type: MultiChoiceType::Weighted,\n            min_voter_options: 1,\n            max_voter_options: 3,\n            max_winning_options: 3,\n        };\n\n        let options = vec![];\n\n        // Act\n        let result = assert_valid_proposal_options(&options, &vote_type);\n\n        // Assert\n        assert_eq!(result, Err(GovernanceError::InvalidProposalOptions.into()));\n    }\n\n    #[test]\n    pub fn test_assert_valid_proposal_options_for_multi_weighted_choice_vote() {\n        // Arrange\n        let vote_type = VoteType::MultiChoice {\n            choice_type: MultiChoiceType::Weighted,\n            min_voter_options: 1,\n            max_voter_options: 3,\n            max_winning_options: 3,\n        };\n\n        let options = vec![\n            \"option 1\".to_string(),\n            \"option 2\".to_string(),\n            \"option 3\".to_string(),\n        ];\n\n        // Act\n        let result = assert_valid_proposal_options(&options, &vote_type);\n\n        // Assert\n        assert_eq!(result, Ok(()));\n    }\n\n    #[test]\n    pub fn test_assert_valid_proposal_options_for_multi_weighted_choice_vote_with_empty_option_error(\n    ) {\n        // Arrange\n        let vote_type = VoteType::MultiChoice {\n            choice_type: MultiChoiceType::Weighted,\n            min_voter_options: 1,\n            max_voter_options: 3,\n            max_winning_options: 3,\n        };\n\n        let options = vec![\n            \"\".to_string(),\n            \"option 2\".to_string(),\n            \"option 3\".to_string(),\n        ];\n\n        // Act\n        let result = assert_valid_proposal_options(&options, &vote_type);\n\n        // Assert\n        assert_eq!(result, Err(GovernanceError::InvalidProposalOptions.into()));\n    }\n\n    #[test]\n    pub fn test_assert_more_than_ten_proposal_options_for_multi_weighted_choice_error() {\n        // Arrange\n        let vote_type = VoteType::MultiChoice {\n            choice_type: MultiChoiceType::Weighted,\n            min_voter_options: 1,\n            max_voter_options: 3,\n            max_winning_options: 3,\n        };\n\n        let options = vec![\n            \"option 1\".to_string(),\n            \"option 2\".to_string(),\n            \"option 3\".to_string(),\n            \"option 4\".to_string(),\n            \"option 5\".to_string(),\n            \"option 6\".to_string(),\n            \"option 7\".to_string(),\n            \"option 8\".to_string(),\n            \"option 9\".to_string(),\n            \"option 10\".to_string(),\n            \"option 11\".to_string(),\n        ];\n\n        // Act\n        let result = assert_valid_proposal_options(&options, &vote_type);\n\n        // Assert\n        assert_eq!(result, Err(GovernanceError::InvalidProposalOptions.into()));\n    }\n\n    #[test]\n    fn test_proposal_v1_to_v2_serialisation_roundtrip() {\n        // Arrange\n\n        let proposal_v1_source = ProposalV1 {\n            account_type: GovernanceAccountType::ProposalV1,\n            governance: Pubkey::new_unique(),\n            governing_token_mint: Pubkey::new_unique(),\n            state: ProposalState::Executing,\n            token_owner_record: Pubkey::new_unique(),\n            signatories_count: 5,\n            signatories_signed_off_count: 4,\n            yes_votes_count: 100,\n            no_votes_count: 80,\n            instructions_executed_count: 7,\n            instructions_count: 8,\n            instructions_next_index: 9,\n            draft_at: 200,\n            signing_off_at: Some(201),\n            voting_at: Some(202),\n            voting_at_slot: Some(203),\n            voting_completed_at: Some(204),\n            executing_at: Some(205),\n            closed_at: Some(206),\n            execution_flags: InstructionExecutionFlags::None,\n            max_vote_weight: Some(250),\n            vote_threshold: Some(VoteThreshold::YesVotePercentage(65)),\n            name: \"proposal\".to_string(),\n            description_link: \"proposal-description\".to_string(),\n        };\n\n        let mut account_data = vec![];\n        proposal_v1_source.serialize(&mut account_data).unwrap();\n\n        let program_id = Pubkey::new_unique();\n\n        let info_key = Pubkey::new_unique();\n        let mut lamports = 10u64;\n\n        let account_info = AccountInfo::new(\n            &info_key,\n            false,\n            false,\n            &mut lamports,\n            &mut account_data[..],\n            &program_id,\n            false,\n            Epoch::default(),\n        );\n\n        // Act\n\n        let proposal_v2 = get_proposal_data(&program_id, &account_info).unwrap();\n\n        proposal_v2\n            .serialize(&mut account_info.data.borrow_mut()[..])\n            .unwrap();\n\n        // Assert\n        let proposal_v1_target =\n            get_account_data::<ProposalV1>(&program_id, &account_info).unwrap();\n\n        assert_eq!(proposal_v1_source, proposal_v1_target)\n    }",
    "pub fn get_proposal_deposit_address(\n    program_id: &Pubkey,\n    proposal: &Pubkey,\n    proposal_deposit_payer: &Pubkey,\n) -> Pubkey {\n    Pubkey::find_program_address(\n        &get_proposal_deposit_address_seeds(proposal, proposal_deposit_payer),\n        program_id,\n    )\n    .0\n}\n\n/// Deserializes ProposalDeposit account and checks owner program and account\n/// type\npub fn get_proposal_deposit_data(\n    program_id: &Pubkey,\n    proposal_deposit_info: &AccountInfo,\n) -> Result<ProposalDeposit, ProgramError> {\n    get_account_data::<ProposalDeposit>(program_id, proposal_deposit_info)\n}",
    "pub fn get_proposal_deposit_data_for_proposal_and_deposit_payer(\n    program_id: &Pubkey,\n    proposal_deposit_info: &AccountInfo,\n    proposal: &Pubkey,\n    proposal_deposit_payer: &Pubkey,\n) -> Result<ProposalDeposit, ProgramError> {\n    let proposal_deposit_data = get_proposal_deposit_data(program_id, proposal_deposit_info)?;\n\n    if proposal_deposit_data.proposal != *proposal {\n        return Err(GovernanceError::InvalidProposalForProposalDeposit.into());\n    }\n\n    if proposal_deposit_data.deposit_payer != *proposal_deposit_payer {\n        return Err(GovernanceError::InvalidDepositPayerForProposalDeposit.into());\n    }\n\n    Ok(proposal_deposit_data)\n}",
    "pub fn get_proposal_transaction_data(\n    program_id: &Pubkey,\n    proposal_transaction_info: &AccountInfo,\n) -> Result<ProposalTransactionV2, ProgramError> {\n    let account_type: GovernanceAccountType =\n        get_account_type(program_id, proposal_transaction_info)?;\n\n    // If the account is V1 version then translate to V2\n    if account_type == GovernanceAccountType::ProposalInstructionV1 {\n        let proposal_transaction_data_v1 =\n            get_account_data::<ProposalInstructionV1>(program_id, proposal_transaction_info)?;\n\n        return Ok(ProposalTransactionV2 {\n            account_type,\n            proposal: proposal_transaction_data_v1.proposal,\n            option_index: 0, // V1 has a single implied option at index 0\n            transaction_index: proposal_transaction_data_v1.instruction_index,\n            legacy: proposal_transaction_data_v1.legacy,\n            instructions: vec![proposal_transaction_data_v1.instruction],\n            executed_at: proposal_transaction_data_v1.executed_at,\n            execution_status: proposal_transaction_data_v1.execution_status,\n            reserved_v2: [0; 8],\n        });\n    }\n\n    get_account_data::<ProposalTransactionV2>(program_id, proposal_transaction_info)\n}",
    "pub fn get_proposal_transaction_data_for_proposal(\n    program_id: &Pubkey,\n    proposal_transaction_info: &AccountInfo,\n    proposal: &Pubkey,\n) -> Result<ProposalTransactionV2, ProgramError> {\n    let proposal_transaction_data =\n        get_proposal_transaction_data(program_id, proposal_transaction_info)?;\n\n    if proposal_transaction_data.proposal != *proposal {\n        return Err(GovernanceError::InvalidProposalForProposalTransaction.into());\n    }\n\n    Ok(proposal_transaction_data)\n}",
    "pub fn is_realm_account_type(account_type: &GovernanceAccountType) -> bool {\n    match account_type {\n        GovernanceAccountType::RealmV1 | GovernanceAccountType::RealmV2 => true,\n        GovernanceAccountType::GovernanceV2\n        | GovernanceAccountType::ProgramGovernanceV2\n        | GovernanceAccountType::MintGovernanceV2\n        | GovernanceAccountType::TokenGovernanceV2\n        | GovernanceAccountType::Uninitialized\n        | GovernanceAccountType::RealmConfig\n        | GovernanceAccountType::TokenOwnerRecordV1\n        | GovernanceAccountType::TokenOwnerRecordV2\n        | GovernanceAccountType::GovernanceV1\n        | GovernanceAccountType::ProgramGovernanceV1\n        | GovernanceAccountType::MintGovernanceV1\n        | GovernanceAccountType::TokenGovernanceV1\n        | GovernanceAccountType::ProposalV1\n        | GovernanceAccountType::ProposalV2\n        | GovernanceAccountType::SignatoryRecordV1\n        | GovernanceAccountType::SignatoryRecordV2\n        | GovernanceAccountType::ProposalInstructionV1\n        | GovernanceAccountType::ProposalTransactionV2\n        | GovernanceAccountType::VoteRecordV1\n        | GovernanceAccountType::VoteRecordV2\n        | GovernanceAccountType::ProgramMetadata\n        | GovernanceAccountType::ProposalDeposit\n        | GovernanceAccountType::RequiredSignatory => false,\n    }\n}\n\nimpl RealmV2 {\n    /// Asserts the given mint is either Community or Council mint of the Realm\n    pub fn assert_is_valid_governing_token_mint(\n        &self,\n        governing_token_mint: &Pubkey,\n    ) -> Result<(), ProgramError> {\n        if self.community_mint == *governing_token_mint {\n            return Ok(());\n        }\n\n        if self.config.council_mint == Some(*governing_token_mint) {\n            return Ok(());\n        }\n\n        Err(GovernanceError::InvalidGoverningTokenMint.into())\n    }",
    "pub fn get_proposal_governing_token_mint_for_vote(\n        &self,\n        vote_governing_token_mint: &Pubkey,\n        vote_kind: &VoteKind,\n    ) -> Result<Pubkey, ProgramError> {\n        match vote_kind {\n            VoteKind::Electorate => Ok(*vote_governing_token_mint),\n            VoteKind::Veto => {\n                // When Community veto Council proposal then return council_token_mint as the\n                // Proposal governing_token_mint\n                if self.community_mint == *vote_governing_token_mint {\n                    return Ok(self.config.council_mint.unwrap());\n                }\n\n                // When Council veto Community proposal then return community_token_mint as the\n                // Proposal governing_token_mint\n                if self.config.council_mint == Some(*vote_governing_token_mint) {\n                    return Ok(self.community_mint);\n                }\n\n                Err(GovernanceError::InvalidGoverningTokenMint.into())\n            }",
    "pub fn assert_is_valid_governing_token_mint_and_holding(\n        &self,\n        program_id: &Pubkey,\n        realm: &Pubkey,\n        governing_token_mint: &Pubkey,\n        governing_token_holding: &Pubkey,\n    ) -> Result<(), ProgramError> {\n        self.assert_is_valid_governing_token_mint(governing_token_mint)?;\n\n        let governing_token_holding_address =\n            get_governing_token_holding_address(program_id, realm, governing_token_mint);\n\n        if governing_token_holding_address != *governing_token_holding {\n            return Err(GovernanceError::InvalidGoverningTokenHoldingAccount.into());\n        }\n\n        Ok(())\n    }",
    "pub fn assert_create_authority_can_create_governance(\n        &self,\n        program_id: &Pubkey,\n        realm: &Pubkey,\n        token_owner_record_info: &AccountInfo,\n        create_authority_info: &AccountInfo,\n        account_info_iter: &mut Iter<AccountInfo>,\n    ) -> Result<(), ProgramError> {\n        // Check if create_authority_info is realm_authority and if yes then it must\n        // signed the transaction\n        if self.authority == Some(*create_authority_info.key) {\n            return if !create_authority_info.is_signer {\n                Err(GovernanceError::RealmAuthorityMustSign.into())\n            }",
    "pub fn assert_is_valid_realm(\n    program_id: &Pubkey,\n    realm_info: &AccountInfo,\n) -> Result<(), ProgramError> {\n    assert_is_valid_account_of_types(program_id, realm_info, is_realm_account_type)\n}",
    "pub fn get_realm_data(\n    program_id: &Pubkey,\n    realm_info: &AccountInfo,\n) -> Result<RealmV2, ProgramError> {\n    let account_type: GovernanceAccountType = get_account_type(program_id, realm_info)?;\n\n    // If the account is V1 version then translate to V2\n    if account_type == GovernanceAccountType::RealmV1 {\n        let realm_data_v1 = get_account_data::<RealmV1>(program_id, realm_info)?;\n\n        return Ok(RealmV2 {\n            account_type,\n            community_mint: realm_data_v1.community_mint,\n            config: realm_data_v1.config,\n            reserved: realm_data_v1.reserved,\n            legacy1: 0,\n            authority: realm_data_v1.authority,\n            name: realm_data_v1.name,\n            // Add the extra reserved_v2 padding\n            reserved_v2: [0; 128],\n        });\n    }\n\n    get_account_data::<RealmV2>(program_id, realm_info)\n}",
    "pub fn get_realm_data_for_authority(\n    program_id: &Pubkey,\n    realm_info: &AccountInfo,\n    realm_authority: &Pubkey,\n) -> Result<RealmV2, ProgramError> {\n    let realm_data = get_realm_data(program_id, realm_info)?;\n\n    if realm_data.authority.is_none() {\n        return Err(GovernanceError::RealmHasNoAuthority.into());\n    }\n\n    if realm_data.authority.unwrap() != *realm_authority {\n        return Err(GovernanceError::InvalidAuthorityForRealm.into());\n    }\n\n    Ok(realm_data)\n}",
    "pub fn get_realm_data_for_governing_token_mint(\n    program_id: &Pubkey,\n    realm_info: &AccountInfo,\n    governing_token_mint: &Pubkey,\n) -> Result<RealmV2, ProgramError> {\n    let realm_data = get_realm_data(program_id, realm_info)?;\n\n    realm_data.assert_is_valid_governing_token_mint(governing_token_mint)?;\n\n    Ok(realm_data)\n}",
    "pub fn get_realm_address_seeds(name: &str) -> [&[u8]; 2] {\n    [PROGRAM_AUTHORITY_SEED, name.as_bytes()]\n}\n\n/// Returns Realm PDA address\npub fn get_realm_address(program_id: &Pubkey, name: &str) -> Pubkey {\n    Pubkey::find_program_address(&get_realm_address_seeds(name), program_id).0\n}\n\n/// Returns Realm Token Holding PDA seeds\npub fn get_governing_token_holding_address_seeds<'a>(\n    realm: &'a Pubkey,\n    governing_token_mint: &'a Pubkey,\n) -> [&'a [u8]; 3] {\n    [\n        PROGRAM_AUTHORITY_SEED,\n        realm.as_ref(),\n        governing_token_mint.as_ref(),\n    ]\n}\n\n/// Returns Realm Token Holding PDA address\npub fn get_governing_token_holding_address(\n    program_id: &Pubkey,\n    realm: &Pubkey,\n    governing_token_mint: &Pubkey,\n) -> Pubkey {\n    Pubkey::find_program_address(\n        &get_governing_token_holding_address_seeds(realm, governing_token_mint),\n        program_id,\n    )\n    .0\n}\n\n/// Asserts given realm config args are correct\npub fn assert_valid_realm_config_args(\n    realm_config_args: &RealmConfigArgs,\n) -> Result<(), ProgramError> {\n    match realm_config_args.community_mint_max_voter_weight_source {\n        MintMaxVoterWeightSource::SupplyFraction(fraction) => {\n            if !(1..=MintMaxVoterWeightSource::SUPPLY_FRACTION_BASE).contains(&fraction) {\n                return Err(GovernanceError::InvalidMaxVoterWeightSupplyFraction.into());\n            }\n        }\n        MintMaxVoterWeightSource::Absolute(value) => {\n            if value == 0 {\n                return Err(GovernanceError::InvalidMaxVoterWeightAbsoluteValue.into());\n            }\n        }\n    }\n\n    Ok(())\n}",
    "pub fn get_token_config(\n        &self,\n        realm_data: &RealmV2,\n        governing_token_mint: &Pubkey,\n    ) -> Result<&GoverningTokenConfig, ProgramError> {\n        let token_config = if *governing_token_mint == realm_data.community_mint {\n            &self.community_token_config\n        } else if Some(*governing_token_mint) == realm_data.config.council_mint {\n            &self.council_token_config\n        } else {\n            return Err(GovernanceError::InvalidGoverningTokenMint.into());\n        };\n\n        Ok(token_config)\n    }",
    "pub fn get_token_config_mut(\n        &mut self,\n        realm_data: &RealmV2,\n        governing_token_mint: &Pubkey,\n    ) -> Result<&mut GoverningTokenConfig, ProgramError> {\n        let token_config = if *governing_token_mint == realm_data.community_mint {\n            &mut self.community_token_config\n        } else if Some(*governing_token_mint) == realm_data.config.council_mint {\n            &mut self.council_token_config\n        } else {\n            return Err(GovernanceError::InvalidGoverningTokenMint.into());\n        };\n\n        Ok(token_config)\n    }",
    "pub fn assert_can_revoke_governing_token(\n        &self,\n        realm_data: &RealmV2,\n        governing_token_mint: &Pubkey,\n    ) -> Result<(), ProgramError> {\n        let governing_token_type = &self\n            .get_token_config(realm_data, governing_token_mint)?\n            .token_type;\n\n        match governing_token_type {\n            GoverningTokenType::Membership => Ok(()),\n            GoverningTokenType::Liquid | GoverningTokenType::Dormant => {\n                Err(GovernanceError::CannotRevokeGoverningTokens.into())\n            }",
    "pub fn assert_can_deposit_governing_token(\n        &self,\n        realm_data: &RealmV2,\n        governing_token_mint: &Pubkey,\n    ) -> Result<(), ProgramError> {\n        let governing_token_type = &self\n            .get_token_config(realm_data, governing_token_mint)?\n            .token_type;\n\n        match governing_token_type {\n            GoverningTokenType::Membership | GoverningTokenType::Liquid => Ok(()),\n            // Note: Preventing deposits of the Dormant type tokens is not a direct security concern\n            // It only makes the intention of not using deposited tokens as governance power\n            // stronger\n            GoverningTokenType::Dormant => Err(GovernanceError::CannotDepositDormantTokens.into()),\n        }\n    }\n\n    /// Asserts the given governing token can be withdrawn\n    pub fn assert_can_withdraw_governing_token(\n        &self,\n        realm_data: &RealmV2,\n        governing_token_mint: &Pubkey,\n    ) -> Result<(), ProgramError> {\n        let governing_token_type = &self\n            .get_token_config(realm_data, governing_token_mint)?\n            .token_type;\n\n        match governing_token_type {\n            GoverningTokenType::Dormant | GoverningTokenType::Liquid => Ok(()),\n            GoverningTokenType::Membership => {\n                Err(GovernanceError::CannotWithdrawMembershipTokens.into())\n            }",
    "pub fn assert_can_change_config(\n        &self,\n        realm_config_args: &RealmConfigArgs,\n    ) -> Result<(), ProgramError> {\n        // Existing community token type can't be changed to Membership because it would\n        // give the Realm authority the right to burn members tokens which should not be\n        // the case because the tokens belong to the members On the other had\n        // for the Council token it's acceptable and in fact desired change because\n        // council tokens denote membership which should be controlled by the\n        // Realm\n        if self.community_token_config.token_type != GoverningTokenType::Membership\n            && realm_config_args.community_token_config_args.token_type\n                == GoverningTokenType::Membership\n        {\n            return Err(GovernanceError::CannotChangeCommunityTokenTypeToMembership.into());\n        }\n\n        Ok(())\n    }",
    "pub fn get_realm_config_data(\n    program_id: &Pubkey,\n    realm_config_info: &AccountInfo,\n) -> Result<RealmConfigAccount, ProgramError> {\n    get_account_data::<RealmConfigAccount>(program_id, realm_config_info)\n}",
    "pub fn get_realm_config_data_for_realm(\n    program_id: &Pubkey,\n    realm_config_info: &AccountInfo,\n    realm: &Pubkey,\n) -> Result<RealmConfigAccount, ProgramError> {\n    let realm_config_data = if realm_config_info.data_is_empty() {\n        // If RealmConfigAccount doesn't exist yet then validate its PDA\n        // PDA validation is required because RealmConfigAccount might not exist for\n        // legacy Realms and then its absence is used as default\n        // RealmConfigAccount value with no plugins and Liquid governance tokens\n        let realm_config_address = get_realm_config_address(program_id, realm);\n\n        if realm_config_address != *realm_config_info.key {\n            return Err(GovernanceError::InvalidRealmConfigAddress.into());\n        }\n\n        RealmConfigAccount {\n            account_type: GovernanceAccountType::RealmConfig,\n            realm: *realm,\n            community_token_config: GoverningTokenConfig::default(),\n            council_token_config: GoverningTokenConfig::default(),\n            reserved: Reserved110::default(),\n        }\n    } else {\n        let realm_config_data = get_realm_config_data(program_id, realm_config_info)?;\n\n        if realm_config_data.realm != *realm {\n            return Err(GovernanceError::InvalidRealmConfigForRealm.into());\n        }\n\n        realm_config_data\n    };\n\n    Ok(realm_config_data)\n}",
    "pub fn get_realm_config_address_seeds(realm: &Pubkey) -> [&[u8]; 2] {\n    [b\"realm-config\", realm.as_ref()]\n}\n\n/// Returns RealmConfig PDA address\npub fn get_realm_config_address(program_id: &Pubkey, realm: &Pubkey) -> Pubkey {\n    Pubkey::find_program_address(&get_realm_config_address_seeds(realm), program_id).0\n}\n/// Resolves GoverningTokenConfig from GoverningTokenConfigArgs and instruction\n/// accounts\npub fn resolve_governing_token_config(\n    account_info_iter: &mut Iter<AccountInfo>,\n    governing_token_config_args: &GoverningTokenConfigArgs,\n    existing_governing_token_config: Option<GoverningTokenConfig>,\n) -> Result<GoverningTokenConfig, ProgramError> {\n    let voter_weight_addin = if governing_token_config_args.use_voter_weight_addin {\n        let voter_weight_addin_info = next_account_info(account_info_iter)?;\n        Some(*voter_weight_addin_info.key)\n    }",
    "pub fn get_required_signatory_data_for_governance(\n    program_id: &Pubkey,\n    required_signatory_info: &AccountInfo,\n    governance: &Pubkey,\n) -> Result<RequiredSignatory, ProgramError> {\n    let required_signatory_data =\n        get_account_data::<RequiredSignatory>(program_id, required_signatory_info)?;\n\n    if required_signatory_data.governance != *governance {\n        return Err(GovernanceError::InvalidGovernanceForRequiredSignatory.into());\n    }\n\n    Ok(required_signatory_data)\n}",
    "pub fn assert_can_sign_off(&self, signatory_info: &AccountInfo) -> Result<(), ProgramError> {\n        if self.signed_off {\n            return Err(GovernanceError::SignatoryAlreadySignedOff.into());\n        }\n\n        if !signatory_info.is_signer {\n            return Err(GovernanceError::SignatoryMustSign.into());\n        }\n\n        Ok(())\n    }",
    "pub fn assert_can_remove_signatory(&self) -> Result<(), ProgramError> {\n        if self.signed_off {\n            return Err(GovernanceError::SignatoryAlreadySignedOff.into());\n        }\n\n        Ok(())\n    }",
    "pub fn get_signatory_record_data(\n    program_id: &Pubkey,\n    signatory_record_info: &AccountInfo,\n) -> Result<SignatoryRecordV2, ProgramError> {\n    let account_type: GovernanceAccountType = get_account_type(program_id, signatory_record_info)?;\n\n    // If the account is V1 version then translate to V2\n    if account_type == GovernanceAccountType::SignatoryRecordV1 {\n        let signatory_record_data_v1 =\n            get_account_data::<SignatoryRecordV1>(program_id, signatory_record_info)?;\n\n        return Ok(SignatoryRecordV2 {\n            account_type,\n\n            proposal: signatory_record_data_v1.proposal,\n            signatory: signatory_record_data_v1.signatory,\n            signed_off: signatory_record_data_v1.signed_off,\n\n            // Add the extra reserved_v2 padding\n            reserved_v2: [0; 8],\n        });\n    }\n\n    get_account_data::<SignatoryRecordV2>(program_id, signatory_record_info)\n}",
    "pub fn get_signatory_record_data_for_seeds(\n    program_id: &Pubkey,\n    signatory_record_info: &AccountInfo,\n    proposal: &Pubkey,\n    signatory: &Pubkey,\n) -> Result<SignatoryRecordV2, ProgramError> {\n    let (signatory_record_address, _) = Pubkey::find_program_address(\n        &get_signatory_record_address_seeds(proposal, signatory),\n        program_id,\n    );\n\n    if signatory_record_address != *signatory_record_info.key {\n        return Err(GovernanceError::InvalidSignatoryAddress.into());\n    }\n\n    get_signatory_record_data(program_id, signatory_record_info)\n}",
    "pub fn is_expired(&self, current_unix_timestamp: UnixTimestamp) -> bool {\n        // If the expiry is None then the lock never expires\n        self.expiry.is_some() && Some(current_unix_timestamp) > self.expiry\n    }\n}\n\n/// Governance Token Owner Record\n/// Account PDA seeds: ['governance', realm, token_mint, token_owner ]\n#[derive(Clone, Debug, PartialEq, Eq, BorshDeserialize, BorshSerialize, BorshSchema)]\npub struct TokenOwnerRecordV2 {\n    /// Governance account type\n    pub account_type: GovernanceAccountType,\n\n    /// The Realm the TokenOwnerRecord belongs to\n    pub realm: Pubkey,\n\n    /// Governing Token Mint the TokenOwnerRecord holds deposit for\n    pub governing_token_mint: Pubkey,\n\n    /// The owner (either single or multisig) of the deposited governing SPL\n    /// Tokens This is who can authorize a withdrawal of the tokens\n    pub governing_token_owner: Pubkey,\n\n    /// The amount of governing tokens deposited into the Realm\n    /// This amount is the voter weight used when voting on proposals\n    pub governing_token_deposit_amount: u64,\n\n    /// The number of votes cast by TokenOwner but not relinquished yet\n    /// Every time a vote is cast this number is increased and it's always\n    /// decreased when relinquishing a vote regardless of the vote state\n    pub unrelinquished_votes_count: u64,\n\n    /// The number of outstanding proposals the TokenOwner currently owns\n    /// The count is increased when TokenOwner creates a proposal\n    /// and decreased  once it's either voted on (Succeeded or Defeated) or\n    /// Cancelled By default it's restricted to 1 outstanding Proposal per\n    /// token owner\n    pub outstanding_proposal_count: u8,\n\n    /// Version of the account layout\n    /// Note: In future versions (>program V3) we should introduce\n    /// GovernanceAccountType::TokenOwnerRecord(version:u8) as a way to version\n    /// this account (and all other accounts too) It can't be done in\n    /// program V3  because it would require to fetch another\n    /// GovernanceAccountType by the UI and the RPC is already overloaded with\n    /// all the existing types The new account type and versioning scheme\n    /// can be introduced once we migrate UI to use indexer to fetch all the\n    /// accounts Once the new versioning scheme is introduced this field can\n    /// be migrated and removed\n    ///\n    /// The other issues which need to be addressed before we can cleanup the\n    /// account versioning code:\n    /// 1) Remove the specific governance accounts (ProgramGovernance,\n    ///    TokenGovernance, MintGovernance) The only reason they exist is the UI\n    ///    which can't handle the generic use case for those assets\n    /// 2) For account layout breaking changes all plugins would have to be\n    ///    upgraded\n    /// 3) For account layout changes the Holaplex indexer would have to be\n    ///    upgraded\n    /// 4) We should migrate the UI to use the indexer for fetching data and\n    ///    stop using getProgramAccounts\n    /// 5) The UI would have to be upgraded to support account migration to the\n    ///    latest version\n    /// 6) The client sdk is already messy because of the different\n    ///    program/account versions and it should be cleaned up before we add\n    ///    even more versions.\n    pub version: u8,\n\n    /// Reserved space for future versions\n    pub reserved: [u8; 6],\n\n    /// A single account that is allowed to operate governance with the\n    /// deposited governing tokens It can be delegated to by the\n    /// governing_token_owner or current governance_delegate\n    pub governance_delegate: Option<Pubkey>,\n\n    /// Reserved space for versions v2 and onwards\n    /// Note: V1 accounts must be resized before using this space\n    pub reserved_v2: [u8; 124],\n\n    /// A list of locks which can be issued by external authorities\n    /// to prevent token withdrawals\n    pub locks: Vec<TokenOwnerRecordLock>,\n}\n\n/// The current version of TokenOwnerRecord account layout\n/// Note: It's the version of the account layout and not the version of the\n/// program or the account type\n///\n/// program V1,V2 -> account layout version 0\n/// program V3 -> account layout version 1\npub const TOKEN_OWNER_RECORD_LAYOUT_VERSION: u8 = 1;\n\nimpl AccountMaxSize for TokenOwnerRecordV2 {\n    fn get_max_size(&self) -> Option<usize> {\n        Some(282 + self.locks.len() * 42)\n    }",
    "pub fn assert_token_owner_or_delegate_is_signer(\n        &self,\n        governance_authority_info: &AccountInfo,\n    ) -> Result<(), ProgramError> {\n        if governance_authority_info.is_signer {\n            if &self.governing_token_owner == governance_authority_info.key {\n                return Ok(());\n            }\n\n            if let Some(governance_delegate) = self.governance_delegate {\n                if &governance_delegate == governance_authority_info.key {\n                    return Ok(());\n                }\n            };\n        }\n\n        Err(GovernanceError::GoverningTokenOwnerOrDelegateMustSign.into())\n    }",
    "pub fn assert_can_create_proposal(\n        &self,\n        realm_data: &RealmV2,\n        config: &GovernanceConfig,\n        voter_weight: u64,\n    ) -> Result<(), ProgramError> {\n        let min_weight_to_create_proposal =\n            if self.governing_token_mint == realm_data.community_mint {\n                config.min_community_weight_to_create_proposal\n            } else if Some(self.governing_token_mint) == realm_data.config.council_mint {\n                config.min_council_weight_to_create_proposal\n            } else {\n                return Err(GovernanceError::InvalidGoverningTokenMint.into());\n            };\n\n        // If the weight threshold is set to u64::MAX then it indicates explicitly\n        // Disabled value which should prevent any possibility of using it\n        if min_weight_to_create_proposal == u64::MAX {\n            return Err(GovernanceError::VoterWeightThresholdDisabled.into());\n        }\n\n        if voter_weight < min_weight_to_create_proposal {\n            return Err(GovernanceError::NotEnoughTokensToCreateProposal.into());\n        }\n\n        // The number of outstanding proposals is currently restricted to 10\n        // If there is a need to change it in the future then it should be added to\n        // realm or governance config\n        if self.outstanding_proposal_count >= 10 {\n            return Err(GovernanceError::TooManyOutstandingProposals.into());\n        }\n\n        Ok(())\n    }",
    "pub fn assert_can_create_governance(\n        &self,\n        realm_data: &RealmV2,\n        voter_weight: u64,\n    ) -> Result<(), ProgramError> {\n        let min_weight_to_create_governance =\n            if self.governing_token_mint == realm_data.community_mint {\n                realm_data.config.min_community_weight_to_create_governance\n            } else if Some(self.governing_token_mint) == realm_data.config.council_mint {\n                // For council tokens it's enough to be in possession of any number of tokens\n                1\n            } else {\n                return Err(GovernanceError::InvalidGoverningTokenMint.into());\n            };\n\n        // If the weight threshold is set to u64::MAX then it indicates explicitly\n        // Disabled value which should prevent any possibility of using it\n        if min_weight_to_create_governance == u64::MAX {\n            return Err(GovernanceError::VoterWeightThresholdDisabled.into());\n        }\n\n        if voter_weight < min_weight_to_create_governance {\n            return Err(GovernanceError::NotEnoughTokensToCreateGovernance.into());\n        }\n\n        Ok(())\n    }",
    "pub fn assert_can_withdraw_governing_tokens(\n        &self,\n        current_unix_timestamp: UnixTimestamp,\n    ) -> Result<(), ProgramError> {\n        if self.unrelinquished_votes_count > 0 {\n            return Err(\n                GovernanceError::AllVotesMustBeRelinquishedToWithdrawGoverningTokens.into(),\n            );\n        }\n\n        if self.outstanding_proposal_count > 0 {\n            return Err(\n                GovernanceError::AllProposalsMustBeFinalisedToWithdrawGoverningTokens.into(),\n            );\n        }\n\n        if self\n            .locks\n            .iter()\n            .any(|lock| !lock.is_expired(current_unix_timestamp))\n        {\n            return Err(GovernanceError::TokenOwnerRecordLocked.into());\n        }\n\n        Ok(())\n    }",
    "pub fn decrease_outstanding_proposal_count(&mut self) {\n        // Previous versions didn't use the count and it can be already 0\n        // TODO: Remove this check once all outstanding proposals on mainnet are\n        // resolved\n        if self.outstanding_proposal_count != 0 {\n            self.outstanding_proposal_count =\n                self.outstanding_proposal_count.checked_sub(1).unwrap();\n        }\n    }\n\n    /// Resolves voter's weight using either the amount deposited into the realm\n    /// or weight provided by voter weight addin (if configured)\n    #[allow(clippy::too_many_arguments)]\n    pub fn resolve_voter_weight(\n        &self,\n        account_info_iter: &mut Iter<AccountInfo>,\n        realm_data: &RealmV2,\n        realm_config_data: &RealmConfigAccount,\n        weight_action: VoterWeightAction,\n        weight_action_target: &Pubkey,\n    ) -> Result<u64, ProgramError> {\n        // if the Realm is configured to use voter weight plugin for our\n        // governing_token_mint then use the externally provided voter_weight\n        // instead of governing_token_deposit_amount\n        if let Some(voter_weight_addin) = realm_config_data\n            .get_token_config(realm_data, &self.governing_token_mint)?\n            .voter_weight_addin\n        {\n            let voter_weight_record_info = next_account_info(account_info_iter)?;\n\n            let voter_weight_record_data = get_voter_weight_record_data_for_token_owner_record(\n                &voter_weight_addin,\n                voter_weight_record_info,\n                self,\n            )?;\n\n            assert_is_valid_voter_weight(\n                &voter_weight_record_data,\n                weight_action,\n                weight_action_target,\n            )?;\n\n            Ok(voter_weight_record_data.voter_weight)\n        }",
    "pub fn remove_expired_locks(&mut self, current_unix_timestamp: UnixTimestamp) {\n        self.locks\n            .retain(|lock| !lock.is_expired(current_unix_timestamp));\n    }\n\n    /// Removes a lock by its id and authority\n    pub fn remove_lock(\n        &mut self,\n        lock_id: u8,\n        lock_authority: &Pubkey,\n    ) -> Result<(), ProgramError> {\n        if let Some(lock_index) = self\n            .locks\n            .iter()\n            .position(|lock| lock.lock_id == lock_id && lock.authority == *lock_authority)\n        {\n            self.locks.remove(lock_index);\n            Ok(())\n        }",
    "pub fn upsert_lock(&mut self, lock: TokenOwnerRecordLock) {\n        if let Some(lock_index) = self.locks.iter().position(|existing_lock| {\n            existing_lock.lock_id == lock.lock_id && existing_lock.authority == lock.authority\n        }) {\n            self.locks[lock_index] = lock;\n        } else {\n            self.locks.push(lock);\n        }\n    }\n\n    /// Serializes TokenOwnerRecord and resizes it if required\n    /// If the account is TokenOwnerRecordV1 and needs to be resized\n    /// then its type is changed to TokenOwnerRecordV2 to preserve the extra\n    /// data\n    pub fn serialize_with_resize<'a>(\n        mut self,\n        token_owner_record_info: &AccountInfo<'a>,\n        payer_info: &AccountInfo<'a>,\n        system_info: &AccountInfo<'a>,\n        rent: &Rent,\n    ) -> Result<(), ProgramError> {\n        let token_owner_record_data_max_size = self.get_max_size().unwrap();\n        if token_owner_record_info.data_len() < token_owner_record_data_max_size {\n            extend_account_size(\n                token_owner_record_info,\n                payer_info,\n                token_owner_record_data_max_size,\n                rent,\n                system_info,\n            )?;\n\n            // When the account is resized we have to change the type to V2 to preserve\n            // the extra data\n            if self.account_type == GovernanceAccountType::TokenOwnerRecordV1 {\n                self.account_type = GovernanceAccountType::TokenOwnerRecordV2;\n            }\n        }\n\n        self.serialize(&mut token_owner_record_info.data.borrow_mut()[..])\n    }",
    "pub fn get_token_owner_record_address(\n    program_id: &Pubkey,\n    realm: &Pubkey,\n    governing_token_mint: &Pubkey,\n    governing_token_owner: &Pubkey,\n) -> Pubkey {\n    Pubkey::find_program_address(\n        &get_token_owner_record_address_seeds(realm, governing_token_mint, governing_token_owner),\n        program_id,\n    )\n    .0\n}\n\n/// Returns TokenOwnerRecord PDA seeds\npub fn get_token_owner_record_address_seeds<'a>(\n    realm: &'a Pubkey,\n    governing_token_mint: &'a Pubkey,\n    governing_token_owner: &'a Pubkey,\n) -> [&'a [u8]; 4] {\n    [\n        PROGRAM_AUTHORITY_SEED,\n        realm.as_ref(),\n        governing_token_mint.as_ref(),\n        governing_token_owner.as_ref(),\n    ]\n}\n\n/// Deserializes TokenOwnerRecord account and checks owner program\npub fn get_token_owner_record_data(\n    program_id: &Pubkey,\n    token_owner_record_info: &AccountInfo,\n) -> Result<TokenOwnerRecordV2, ProgramError> {\n    let account_type: GovernanceAccountType =\n        get_account_type(program_id, token_owner_record_info)?;\n\n    // If the account is V1 version then translate to V2\n    let mut token_owner_record_data = if account_type == GovernanceAccountType::TokenOwnerRecordV1 {\n        let token_owner_record_data_v1 =\n            get_account_data::<TokenOwnerRecordV1>(program_id, token_owner_record_info)?;\n\n        TokenOwnerRecordV2 {\n            account_type,\n            realm: token_owner_record_data_v1.realm,\n            governing_token_mint: token_owner_record_data_v1.governing_token_mint,\n            governing_token_owner: token_owner_record_data_v1.governing_token_owner,\n            governing_token_deposit_amount: token_owner_record_data_v1\n                .governing_token_deposit_amount,\n            unrelinquished_votes_count: token_owner_record_data_v1.unrelinquished_votes_count,\n            outstanding_proposal_count: token_owner_record_data_v1.outstanding_proposal_count,\n            version: token_owner_record_data_v1.version,\n            reserved: token_owner_record_data_v1.reserved,\n            governance_delegate: token_owner_record_data_v1.governance_delegate,\n\n            // Add the extra reserved_v2 padding\n            reserved_v2: [0; 124],\n            locks: vec![],\n        }\n    } else {\n        get_account_data::<TokenOwnerRecordV2>(program_id, token_owner_record_info)?\n    };\n\n    // If the deserialized account uses the old account layout indicated by the\n    // version value then migrate the data to version 1\n    if token_owner_record_data.version < 1 {\n        token_owner_record_data.version = 1;\n\n        // In previous versions unrelinquished_votes_count was u32 followed by\n        // total_votes_count:u32 In program V3 unrelinquished_votes_count was\n        // changed to u64 by extending it into the space previously used by\n        // total_votes_count:u32 Since total_votes_count could have some value\n        // we have to zero the upper 4 bytes of unrelinquished_votes_count\n        token_owner_record_data.unrelinquished_votes_count &= u32::MAX as u64;\n    }\n\n    Ok(token_owner_record_data)\n}",
    "pub fn get_token_owner_record_data_for_seeds(\n    program_id: &Pubkey,\n    token_owner_record_info: &AccountInfo,\n    token_owner_record_seeds: &[&[u8]],\n) -> Result<TokenOwnerRecordV2, ProgramError> {\n    let (token_owner_record_address, _) =\n        Pubkey::find_program_address(token_owner_record_seeds, program_id);\n\n    if token_owner_record_address != *token_owner_record_info.key {\n        return Err(GovernanceError::InvalidTokenOwnerRecordAccountAddress.into());\n    }\n\n    get_token_owner_record_data(program_id, token_owner_record_info)\n}",
    "pub fn get_token_owner_record_data_for_realm(\n    program_id: &Pubkey,\n    token_owner_record_info: &AccountInfo,\n    realm: &Pubkey,\n) -> Result<TokenOwnerRecordV2, ProgramError> {\n    let token_owner_record_data = get_token_owner_record_data(program_id, token_owner_record_info)?;\n\n    if token_owner_record_data.realm != *realm {\n        return Err(GovernanceError::InvalidRealmForTokenOwnerRecord.into());\n    }\n\n    Ok(token_owner_record_data)\n}",
    "pub fn get_token_owner_record_data_for_realm_and_governing_mint(\n    program_id: &Pubkey,\n    token_owner_record_info: &AccountInfo,\n    realm: &Pubkey,\n    governing_token_mint: &Pubkey,\n) -> Result<TokenOwnerRecordV2, ProgramError> {\n    let token_owner_record_data =\n        get_token_owner_record_data_for_realm(program_id, token_owner_record_info, realm)?;\n\n    if token_owner_record_data.governing_token_mint != *governing_token_mint {\n        return Err(GovernanceError::InvalidGoverningMintForTokenOwnerRecord.into());\n    }\n\n    Ok(token_owner_record_data)\n}",
    "pub fn get_token_owner_record_data_for_proposal_owner(\n    program_id: &Pubkey,\n    token_owner_record_info: &AccountInfo,\n    proposal_owner: &Pubkey,\n) -> Result<TokenOwnerRecordV2, ProgramError> {\n    if token_owner_record_info.key != proposal_owner {\n        return Err(GovernanceError::InvalidProposalOwnerAccount.into());\n    }\n\n    get_token_owner_record_data(program_id, token_owner_record_info)\n}",
    "pub fn get_choice_weight(&self, voter_weight: u64) -> Result<u64, ProgramError> {\n        Ok(match self.weight_percentage {\n            // Avoid any rounding errors for full weight\n            100 => voter_weight,\n            // Note: The total weight for all choices might not equal voter_weight due to rounding\n            // errors\n            0..=99 => (voter_weight as u128)\n                .checked_mul(self.weight_percentage as u128)\n                .unwrap()\n                .checked_div(100)\n                .unwrap() as u64,\n            _ => return Err(GovernanceError::InvalidVoteChoiceWeightPercentage.into()),\n        })\n    }",
    "pub fn get_vote_kind(vote: &Vote) -> VoteKind {\n    match vote {\n        Vote::Approve(_) | Vote::Deny | Vote::Abstain => VoteKind::Electorate,\n        Vote::Veto => VoteKind::Veto,\n    }\n}\n\n/// Proposal VoteRecord\n#[derive(Clone, Debug, PartialEq, Eq, BorshDeserialize, BorshSerialize, BorshSchema)]\npub struct VoteRecordV2 {\n    /// Governance account type\n    pub account_type: GovernanceAccountType,\n\n    /// Proposal account\n    pub proposal: Pubkey,\n\n    /// The user who casted this vote\n    /// This is the Governing Token Owner who deposited governing tokens into\n    /// the Realm\n    pub governing_token_owner: Pubkey,\n\n    /// Indicates whether the vote was relinquished by voter\n    pub is_relinquished: bool,\n\n    /// The weight of the user casting the vote\n    pub voter_weight: u64,\n\n    /// Voter's vote\n    pub vote: Vote,\n\n    /// Reserved space for versions v2 and onwards\n    /// Note: V1 accounts must be resized before using this space\n    pub reserved_v2: [u8; 8],\n}\n\nimpl AccountMaxSize for VoteRecordV2 {}\n\nimpl IsInitialized for VoteRecordV2 {\n    fn is_initialized(&self) -> bool {\n        self.account_type == GovernanceAccountType::VoteRecordV2\n    }\n}\nimpl VoteRecordV2 {\n    /// Checks the vote can be relinquished\n    pub fn assert_can_relinquish_vote(&self) -> Result<(), ProgramError> {\n        if self.is_relinquished {\n            return Err(GovernanceError::VoteAlreadyRelinquished.into());\n        }\n\n        Ok(())\n    }",
    "pub fn get_vote_record_data(\n    program_id: &Pubkey,\n    vote_record_info: &AccountInfo,\n) -> Result<VoteRecordV2, ProgramError> {\n    let account_type: GovernanceAccountType = get_account_type(program_id, vote_record_info)?;\n\n    // If the account is V1 version then translate to V2\n    if account_type == GovernanceAccountType::VoteRecordV1 {\n        let vote_record_data_v1 = get_account_data::<VoteRecordV1>(program_id, vote_record_info)?;\n\n        let (vote, voter_weight) = match vote_record_data_v1.vote_weight {\n            VoteWeightV1::Yes(weight) => (\n                Vote::Approve(vec![VoteChoice {\n                    rank: 0,\n                    weight_percentage: 100,\n                }]),\n                weight,\n            ),\n            VoteWeightV1::No(weight) => (Vote::Deny, weight),\n        };\n\n        return Ok(VoteRecordV2 {\n            account_type,\n            proposal: vote_record_data_v1.proposal,\n            governing_token_owner: vote_record_data_v1.governing_token_owner,\n            is_relinquished: vote_record_data_v1.is_relinquished,\n            voter_weight,\n            vote,\n            reserved_v2: [0; 8],\n        });\n    }\n\n    get_account_data::<VoteRecordV2>(program_id, vote_record_info)\n}",
    "pub fn get_vote_record_data_for_proposal_and_token_owner_record(\n    program_id: &Pubkey,\n    vote_record_info: &AccountInfo,\n    realm_data: &RealmV2,\n    proposal: &Pubkey,\n    proposal_data: &ProposalV2,\n    token_owner_record_data: &TokenOwnerRecordV2,\n) -> Result<VoteRecordV2, ProgramError> {\n    let vote_record_data = get_vote_record_data(program_id, vote_record_info)?;\n\n    if vote_record_data.proposal != *proposal {\n        return Err(GovernanceError::InvalidProposalForVoterRecord.into());\n    }\n\n    if vote_record_data.governing_token_owner != token_owner_record_data.governing_token_owner {\n        return Err(GovernanceError::InvalidGoverningTokenOwnerForVoteRecord.into());\n    }\n\n    // Assert governing_token_mint between Proposal and TokenOwnerRecord match for\n    // the deserialized VoteRecord For Approve, Deny and Abstain votes\n    // Proposal.governing_token_mint must equal\n    // TokenOwnerRecord.governing_token_mint For Veto vote it must be the\n    // governing_token_mint of the opposite voting population\n    let proposal_governing_token_mint = realm_data.get_proposal_governing_token_mint_for_vote(\n        &token_owner_record_data.governing_token_mint,\n        &get_vote_kind(&vote_record_data.vote),\n    )?;\n\n    if proposal_data.governing_token_mint != proposal_governing_token_mint {\n        return Err(GovernanceError::InvalidGoverningMintForProposal.into());\n    }\n\n    Ok(vote_record_data)\n}",
    "pub fn get_program_data_address(program: &Pubkey) -> Pubkey {\n    Pubkey::find_program_address(&[program.as_ref()], &bpf_loader_upgradeable::id()).0\n}\n\n/// Returns upgrade_authority from the given Upgradable Loader Account\npub fn get_program_upgrade_authority(\n    upgradable_loader_state: &UpgradeableLoaderState,\n) -> Result<Option<Pubkey>, ProgramError> {\n    let upgrade_authority = match upgradable_loader_state {\n        UpgradeableLoaderState::ProgramData {\n            slot: _,\n            upgrade_authority_address,\n        } => *upgrade_authority_address,\n        _ => return Err(ProgramError::InvalidAccountData),\n    };\n\n    Ok(upgrade_authority)\n}",
    "pub fn assert_program_upgrade_authority_is_signer(\n    program_address: &Pubkey,\n    program_data_info: &AccountInfo,\n    program_upgrade_authority_info: &AccountInfo,\n) -> Result<(), ProgramError> {\n    if program_data_info.owner != &bpf_loader_upgradeable::id() {\n        return Err(ProgramError::IncorrectProgramId);\n    }\n    let program_data_address = get_program_data_address(program_address);\n\n    if program_data_address != *program_data_info.key {\n        return Err(GovernanceError::InvalidProgramDataAccountAddress.into());\n    }\n\n    let upgrade_authority = if let UpgradeableLoaderState::ProgramData {\n        slot: _,\n        upgrade_authority_address,\n    } = deserialize(&program_data_info.data.borrow())\n        .map_err(|_| GovernanceError::InvalidProgramDataAccountData)?\n    {\n        upgrade_authority_address\n    } else {\n        None\n    };\n\n    let upgrade_authority = upgrade_authority.ok_or(GovernanceError::ProgramNotUpgradable)?;\n\n    if upgrade_authority != *program_upgrade_authority_info.key {\n        return Err(GovernanceError::InvalidUpgradeAuthority.into());\n    }\n    if !program_upgrade_authority_info.is_signer {\n        return Err(GovernanceError::UpgradeAuthorityMustSign.into());\n    }\n\n    Ok(())\n}",
    "pub fn assert_is_valid_spl_token_account(account_info: &AccountInfo) -> Result<(), ProgramError> {\n    if account_info.data_is_empty() {\n        return Err(GovernanceError::SplTokenAccountDoesNotExist.into());\n    }\n\n    if account_info.owner != &spl_token::id() {\n        return Err(GovernanceError::SplTokenAccountWithInvalidOwner.into());\n    }\n\n    if account_info.data_len() != Account::LEN {\n        return Err(GovernanceError::SplTokenInvalidTokenAccountData.into());\n    }\n\n    // TokenAccount layout:\n    //  mint(32)\n    //  owner(32)\n    //  amount(8)\n    //  delegate(36)\n    //  state(1)\n    //  ...\n    let data = account_info.try_borrow_data()?;\n    let state = array_ref![data, 108, 1];\n\n    if state == &[0] {\n        return Err(GovernanceError::SplTokenAccountNotInitialized.into());\n    }\n\n    Ok(())\n}",
    "pub fn is_spl_token_account(account_info: &AccountInfo) -> bool {\n    assert_is_valid_spl_token_account(account_info).is_ok()\n}",
    "pub fn assert_is_valid_spl_token_mint(mint_info: &AccountInfo) -> Result<(), ProgramError> {\n    if mint_info.data_is_empty() {\n        return Err(GovernanceError::SplTokenMintDoesNotExist.into());\n    }\n\n    if mint_info.owner != &spl_token::id() {\n        return Err(GovernanceError::SplTokenMintWithInvalidOwner.into());\n    }\n\n    if mint_info.data_len() != Mint::LEN {\n        return Err(GovernanceError::SplTokenInvalidMintAccountData.into());\n    }\n\n    // In token program [36, 8, 1, is_initialized(1), 36] is the layout\n    let data = mint_info.try_borrow_data()?;\n    let is_initialized = array_ref![data, 45, 1];\n\n    if is_initialized == &[0] {\n        return Err(GovernanceError::SplTokenMintNotInitialized.into());\n    }\n\n    Ok(())\n}",
    "pub fn is_spl_token_mint(mint_info: &AccountInfo) -> bool {\n    assert_is_valid_spl_token_mint(mint_info).is_ok()\n}",
    "pub fn get_spl_token_mint(token_account_info: &AccountInfo) -> Result<Pubkey, ProgramError> {\n    assert_is_valid_spl_token_account(token_account_info)?;\n\n    // TokeAccount layout:   mint(32), owner(32), amount(8), ...\n    let data = token_account_info.try_borrow_data()?;\n    let mint_data = array_ref![data, 0, 32];\n    Ok(Pubkey::new_from_array(*mint_data))\n}",
    "pub fn get_spl_token_owner(token_account_info: &AccountInfo) -> Result<Pubkey, ProgramError> {\n    assert_is_valid_spl_token_account(token_account_info)?;\n\n    // TokeAccount layout:   mint(32), owner(32), amount(8)\n    let data = token_account_info.try_borrow_data()?;\n    let owner_data = array_ref![data, 32, 32];\n    Ok(Pubkey::new_from_array(*owner_data))\n}",
    "pub fn get_spl_token_mint_supply(mint_info: &AccountInfo) -> Result<u64, ProgramError> {\n    assert_is_valid_spl_token_mint(mint_info)?;\n    // In token program, 36, 8, 1, 1 is the layout, where the first 8 is supply u64.\n    // so we start at 36.\n    let data = mint_info.try_borrow_data().unwrap();\n    let bytes = array_ref![data, 36, 8];\n\n    Ok(u64::from_le_bytes(*bytes))\n}",
    "pub fn get_spl_token_mint_authority(\n    mint_info: &AccountInfo,\n) -> Result<COption<Pubkey>, ProgramError> {\n    assert_is_valid_spl_token_mint(mint_info)?;\n    // In token program, 36, 8, 1, 1 is the layout, where the first 36 is authority.\n    let data = mint_info.try_borrow_data().unwrap();\n    let bytes = array_ref![data, 0, 36];\n\n    unpack_coption_pubkey(bytes)\n}",
    "pub fn assert_spl_token_mint_authority_is_signer(\n    mint_info: &AccountInfo,\n    mint_authority_info: &AccountInfo,\n) -> Result<(), ProgramError> {\n    let mint_authority = get_spl_token_mint_authority(mint_info)?;\n\n    if mint_authority.is_none() {\n        return Err(GovernanceError::MintHasNoAuthority.into());\n    }\n\n    if !mint_authority.contains(mint_authority_info.key) {\n        return Err(GovernanceError::InvalidMintAuthority.into());\n    }\n\n    if !mint_authority_info.is_signer {\n        return Err(GovernanceError::MintAuthorityMustSign.into());\n    }\n\n    Ok(())\n}",
    "pub fn assert_spl_token_owner_is_signer(\n    token_info: &AccountInfo,\n    token_owner_info: &AccountInfo,\n) -> Result<(), ProgramError> {\n    let token_owner = get_spl_token_owner(token_info)?;\n\n    if token_owner != *token_owner_info.key {\n        return Err(GovernanceError::InvalidTokenOwner.into());\n    }\n\n    if !token_owner_info.is_signer {\n        return Err(GovernanceError::TokenOwnerMustSign.into());\n    }\n\n    Ok(())\n}",
    "pub fn get_governance_authority(&self) -> &Keypair {\n        self.governance_authority\n            .as_ref()\n            .unwrap_or(&self.token_owner)\n    }",
    "pub fn clone_governance_delegate(&self) -> Keypair {\n        clone_keypair(&self.governance_delegate)\n    }",
    "pub fn get_default_governance_config(&mut self) -> GovernanceConfig {\n        GovernanceConfig {\n            community_vote_threshold: VoteThreshold::YesVotePercentage(60),\n            min_community_weight_to_create_proposal: 5,\n            transactions_hold_up_time: 10,\n            voting_base_time: 10,\n            community_vote_tipping: spl_governance::state::enums::VoteTipping::Strict,\n            council_vote_threshold: VoteThreshold::YesVotePercentage(80),\n            council_veto_vote_threshold: VoteThreshold::YesVotePercentage(55),\n            min_council_weight_to_create_proposal: 2,\n            council_vote_tipping: spl_governance::state::enums::VoteTipping::Strict,\n            community_veto_vote_threshold: VoteThreshold::YesVotePercentage(80),\n            voting_cool_off_time: 0,\n            deposit_exempt_proposal_count: DEFAULT_DEPOSIT_EXEMPT_PROPOSAL_COUNT,\n        }\n    }\n\n    #[allow(dead_code)]\n    pub async fn with_governance(\n        &mut self,\n        realm_cookie: &RealmCookie,\n        token_owner_record_cookie: &TokenOwnerRecordCookie,\n    ) -> Result<GovernanceCookie, ProgramError> {\n        let config = self.get_default_governance_config();\n        self.with_governance_using_config(realm_cookie, token_owner_record_cookie, &config)\n            .await\n    }\n\n    #[allow(dead_code)]\n    pub async fn with_governance_using_config(\n        &mut self,\n        realm_cookie: &RealmCookie,\n        token_owner_record_cookie: &TokenOwnerRecordCookie,\n        governance_config: &GovernanceConfig,\n    ) -> Result<GovernanceCookie, ProgramError> {\n        let voter_weight_record = token_owner_record_cookie\n            .voter_weight_record\n            .as_ref()\n            .map(|voter_weight_record| voter_weight_record.address);\n\n        self.with_governance_impl(\n            realm_cookie,\n            Some(&token_owner_record_cookie.address),\n            &token_owner_record_cookie.token_owner,\n            voter_weight_record,\n            governance_config,\n            None,\n        )\n        .await\n    }\n\n    #[allow(dead_code)]\n    #[allow(clippy::too_many_arguments)]\n    pub async fn with_governance_impl(\n        &mut self,\n        realm_cookie: &RealmCookie,\n        token_owner_record: Option<&Pubkey>,\n        create_authority: &Keypair,\n        voter_weight_record: Option<Pubkey>,\n        governance_config: &GovernanceConfig,\n        signers_override: Option<&[&Keypair]>,\n    ) -> Result<GovernanceCookie, ProgramError> {\n        let governance_seed = Pubkey::new_unique();\n\n        let mut create_governance_ix = create_governance(\n            &self.program_id,\n            &realm_cookie.address,\n            &governance_seed,\n            token_owner_record.unwrap_or(&Pubkey::new_unique()),\n            &self.bench.payer.pubkey(),\n            &create_authority.pubkey(),\n            voter_weight_record,\n            governance_config.clone(),\n        );\n\n        let account = GovernanceV2 {\n            account_type: GovernanceAccountType::GovernanceV2,\n            realm: realm_cookie.address,\n            governance_seed,\n            config: governance_config.clone(),\n            reserved1: 0,\n            reserved_v2: Reserved119::default(),\n            required_signatories_count: 0,\n            active_proposal_count: 0,\n        };\n\n        let default_signers = &[create_authority];\n        let signers = signers_override.unwrap_or(default_signers);\n\n        if signers.is_empty() {\n            create_governance_ix.accounts[6].is_signer = false;\n        }\n\n        self.bench\n            .process_transaction(&[create_governance_ix], Some(signers))\n            .await?;\n\n        let governance_address =\n            get_governance_address(&self.program_id, &realm_cookie.address, &governance_seed);\n\n        Ok(GovernanceCookie {\n            address: governance_address,\n            account,\n            next_proposal_index: 0,\n        })\n    }",
    "pub fn remove_realm_config_account(&mut self, realm_config_address: &Pubkey) {\n        self.bench.remove_account(realm_config_address);\n    }\n\n    #[allow(dead_code)]\n    pub async fn get_governance_account(&mut self, governance_address: &Pubkey) -> GovernanceV2 {\n        self.bench\n            .get_borsh_account::<GovernanceV2>(governance_address)\n            .await\n    }\n\n    #[allow(dead_code)]\n    pub async fn get_proposal_account(&mut self, proposal_address: &Pubkey) -> ProposalV2 {\n        self.bench\n            .get_borsh_account::<ProposalV2>(proposal_address)\n            .await\n    }\n\n    #[allow(dead_code)]\n    pub async fn get_vote_record_account(&mut self, vote_record_address: &Pubkey) -> VoteRecordV2 {\n        self.bench\n            .get_borsh_account::<VoteRecordV2>(vote_record_address)\n            .await\n    }\n\n    #[allow(dead_code)]\n    pub async fn get_proposal_transaction_account(\n        &mut self,\n        proposal_transaction_address: &Pubkey,\n    ) -> ProposalTransactionV2 {\n        self.bench\n            .get_borsh_account::<ProposalTransactionV2>(proposal_transaction_address)\n            .await\n    }\n\n    #[allow(dead_code)]\n    pub async fn get_required_signatory_account(\n        &mut self,\n        required_signatory_address: &Pubkey,\n    ) -> RequiredSignatory {\n        self.bench\n            .get_borsh_account::<RequiredSignatory>(required_signatory_address)\n            .await\n    }\n\n    #[allow(dead_code)]\n    pub async fn get_signatory_record_account(\n        &mut self,\n        proposal_address: &Pubkey,\n    ) -> SignatoryRecordV2 {\n        self.bench\n            .get_borsh_account::<SignatoryRecordV2>(proposal_address)\n            .await\n    }\n\n    #[allow(dead_code)]\n    async fn get_packed_account<T: Pack + IsInitialized>(&mut self, address: &Pubkey) -> T {\n        self.bench\n            .context\n            .banks_client\n            .get_packed_account_data::<T>(*address)\n            .await\n            .unwrap()\n    }",
    "pub fn get_unique_name(&mut self, prefix: &str) -> String {\n        self.next_id += 1;\n\n        format!(\"{}.{}\", prefix, self.next_id)\n    }",
    "pub fn remove_account(&mut self, address: &Pubkey) {\n        let data =\n            AccountSharedData::create(0, vec![], system_program::id(), false, Epoch::default());\n\n        self.context.set_account(address, &data);\n    }\n\n    #[allow(dead_code)]\n    pub async fn get_account(&mut self, address: &Pubkey) -> Option<Account> {\n        self.context\n            .banks_client\n            .get_account(*address)\n            .await\n            .unwrap()\n    }",
    "pub fn map_transaction_error(transport_error: TransportError) -> ProgramError {\n    match transport_error {\n        TransportError::TransactionError(TransactionError::InstructionError(\n            _,\n            InstructionError::Custom(error_index),\n        )) => ProgramError::Custom(error_index),\n        TransportError::TransactionError(TransactionError::InstructionError(\n            _,\n            instruction_error,\n        )) => match instruction_error {\n            // In solana-sdk v1.19.0, there is a ProgramError for\n            // InstructionError::IncorrectAuthority. This results in the error mapping\n            // returning two different values: one for sdk < v1.19 and another for sdk >= v1.19.0.\n            // To avoid this situation, handle InstructionError::IncorrectAuthority earlier.\n            // Can be removed when Solana v1.19.0 becomes a stable channel (also need to update the\n            // test assert for\n            // `test_create_program_governance_with_incorrect_upgrade_authority_error`)\n            InstructionError::IncorrectAuthority => {\n                ProgramInstructionError::IncorrectAuthority.into()\n            }",
    "pub fn clone_keypair(source: &Keypair) -> Keypair {\n    Keypair::from_bytes(&source.to_bytes()).unwrap()\n}",
    "pub fn dispose_account(\n    account_info: &AccountInfo,\n    beneficiary_info: &AccountInfo,\n) -> Result<(), ProgramError> {\n    let account_lamports = account_info.lamports();\n    **account_info.lamports.borrow_mut() = 0;\n\n    **beneficiary_info.lamports.borrow_mut() = beneficiary_info\n        .lamports()\n        .checked_add(account_lamports)\n        .unwrap();\n\n    account_info.assign(&system_program::id());\n    account_info.realloc(0, false)\n}",
    "pub fn new() -> Self {\n        Self::default()\n    }",
    "pub fn is_initialized(&self) -> bool {\n        !(self.buffer_size == 0 && self.sequence_number == 0 && self.active_index == 0)\n    }",
    "pub fn initialize(&mut self) -> Result<Node, ConcurrentMerkleTreeError> {\n        check_bounds(MAX_DEPTH, MAX_BUFFER_SIZE);\n        if self.is_initialized() {\n            return Err(ConcurrentMerkleTreeError::TreeAlreadyInitialized);\n        }\n        let mut rightmost_proof = Path::default();\n        let empty_node_cache = [Node::default(); MAX_DEPTH];\n        for (i, node) in rightmost_proof.proof.iter_mut().enumerate() {\n            *node = empty_node_cached::<MAX_DEPTH>(i as u32, &empty_node_cache);\n        }\n        let mut path = [Node::default(); MAX_DEPTH];\n        for (i, node) in path.iter_mut().enumerate() {\n            *node = empty_node_cached::<MAX_DEPTH>(i as u32, &empty_node_cache);\n        }\n        self.change_logs[0].root = empty_node(MAX_DEPTH as u32);\n        self.change_logs[0].path = path;\n        self.sequence_number = 0;\n        self.active_index = 0;\n        self.buffer_size = 1;\n        self.rightmost_proof = rightmost_proof;\n        Ok(self.change_logs[0].root)\n    }",
    "pub fn initialize_with_root(\n        &mut self,\n        args: &InitializeWithRootArgs,\n    ) -> Result<Node, ConcurrentMerkleTreeError> {\n        check_bounds(MAX_DEPTH, MAX_BUFFER_SIZE);\n        check_leaf_index(args.index, MAX_DEPTH)?;\n\n        if self.is_initialized() {\n            return Err(ConcurrentMerkleTreeError::TreeAlreadyInitialized);\n        }\n        let mut proof: [Node; MAX_DEPTH] = [Node::default(); MAX_DEPTH];\n        proof.copy_from_slice(&args.proof_vec);\n        let rightmost_proof = Path {\n            proof,\n            index: args.index + 1,\n            leaf: args.rightmost_leaf,\n            _padding: 0,\n        };\n        self.change_logs[0].root = args.root;\n        self.sequence_number = 1;\n        self.active_index = 0;\n        self.buffer_size = 1;\n        self.rightmost_proof = rightmost_proof;\n        if args.root != recompute(args.rightmost_leaf, &proof, args.index) {\n            solana_logging!(\"Proof failed to verify\");\n            return Err(ConcurrentMerkleTreeError::InvalidProof);\n        }\n        Ok(args.root)\n    }",
    "pub fn prove_tree_is_empty(&self) -> Result<(), ConcurrentMerkleTreeError> {\n        if !self.is_initialized() {\n            return Err(ConcurrentMerkleTreeError::TreeNotInitialized);\n        }\n        let empty_node_cache = [EMPTY; MAX_DEPTH];\n        if self.get_root() != empty_node_cached::<MAX_DEPTH>(MAX_DEPTH as u32, &empty_node_cache) {\n            return Err(ConcurrentMerkleTreeError::TreeNonEmpty);\n        }\n        Ok(())\n    }",
    "pub fn get_root(&self) -> [u8; 32] {\n        self.get_change_log().root\n    }\n\n    /// Returns the most recent changelog\n    pub fn get_change_log(&self) -> Box<ChangeLog<MAX_DEPTH>> {\n        if !self.is_initialized() {\n            solana_logging!(\"Tree is not initialized, returning default change log\");\n            return Box::<ChangeLog<MAX_DEPTH>>::default();\n        }\n        Box::new(self.change_logs[self.active_index as usize])\n    }",
    "pub fn prove_leaf(&self, args: &ProveLeafArgs) -> Result<(), ConcurrentMerkleTreeError> {\n        check_bounds(MAX_DEPTH, MAX_BUFFER_SIZE);\n        check_leaf_index(args.index, MAX_DEPTH)?;\n        if !self.is_initialized() {\n            return Err(ConcurrentMerkleTreeError::TreeNotInitialized);\n        }\n\n        if args.index > self.rightmost_proof.index {\n            solana_logging!(\n                \"Received an index larger than the rightmost index {} > {}\",\n                args.index,\n                self.rightmost_proof.index\n            );\n            Err(ConcurrentMerkleTreeError::LeafIndexOutOfBounds)\n        }",
    "pub fn append(&mut self, mut node: Node) -> Result<Node, ConcurrentMerkleTreeError> {\n        check_bounds(MAX_DEPTH, MAX_BUFFER_SIZE);\n        if !self.is_initialized() {\n            return Err(ConcurrentMerkleTreeError::TreeNotInitialized);\n        }\n        if node == EMPTY {\n            return Err(ConcurrentMerkleTreeError::CannotAppendEmptyNode);\n        }\n        if self.rightmost_proof.index >= 1 << MAX_DEPTH {\n            return Err(ConcurrentMerkleTreeError::TreeFull);\n        }\n        if self.rightmost_proof.index == 0 {\n            return self.initialize_tree_from_append(node, self.rightmost_proof.proof);\n        }\n        let leaf = node;\n        let intersection = self.rightmost_proof.index.trailing_zeros() as usize;\n        let mut change_list = [EMPTY; MAX_DEPTH];\n        let mut intersection_node = self.rightmost_proof.leaf;\n        let empty_node_cache = [Node::default(); MAX_DEPTH];\n\n        for (i, cl_item) in change_list.iter_mut().enumerate().take(MAX_DEPTH) {\n            *cl_item = node;\n            match i {\n                i if i < intersection => {\n                    // Compute proof to the appended node from empty nodes\n                    let sibling = empty_node_cached::<MAX_DEPTH>(i as u32, &empty_node_cache);\n                    hash_to_parent(\n                        &mut intersection_node,\n                        &self.rightmost_proof.proof[i],\n                        ((self.rightmost_proof.index - 1) >> i) & 1 == 0,\n                    );\n                    hash_to_parent(&mut node, &sibling, true);\n                    self.rightmost_proof.proof[i] = sibling;\n                }\n                i if i == intersection => {\n                    // Compute the where the new node intersects the main tree\n                    hash_to_parent(&mut node, &intersection_node, false);\n                    self.rightmost_proof.proof[intersection] = intersection_node;\n                }\n                _ => {\n                    // Update the change list path up to the root\n                    hash_to_parent(\n                        &mut node,\n                        &self.rightmost_proof.proof[i],\n                        ((self.rightmost_proof.index - 1) >> i) & 1 == 0,\n                    );\n                }\n            }\n        }\n\n        self.update_internal_counters();\n        self.change_logs[self.active_index as usize] =\n            ChangeLog::<MAX_DEPTH>::new(node, change_list, self.rightmost_proof.index);\n        self.rightmost_proof.index += 1;\n        self.rightmost_proof.leaf = leaf;\n        Ok(node)\n    }",
    "pub fn fill_empty_or_append(\n        &mut self,\n        args: &FillEmptyOrAppendArgs,\n    ) -> Result<Node, ConcurrentMerkleTreeError> {\n        check_bounds(MAX_DEPTH, MAX_BUFFER_SIZE);\n        check_leaf_index(args.index, MAX_DEPTH)?;\n        if !self.is_initialized() {\n            return Err(ConcurrentMerkleTreeError::TreeNotInitialized);\n        }\n\n        let mut proof: [Node; MAX_DEPTH] = [Node::default(); MAX_DEPTH];\n        fill_in_proof::<MAX_DEPTH>(&args.proof_vec, &mut proof);\n\n        log_compute!();\n        match self.try_apply_proof(\n            args.current_root,\n            EMPTY,\n            args.leaf,\n            &mut proof,\n            args.index,\n            false,\n        ) {\n            Ok(new_root) => Ok(new_root),\n            Err(error) => match error {\n                ConcurrentMerkleTreeError::LeafContentsModified => self.append(args.leaf),\n                _ => Err(error),\n            },\n        }\n    }\n\n    /// This method will update the leaf at `index`.\n    ///\n    /// However if the proof cannot be verified, this method will fail.\n    pub fn set_leaf(&mut self, args: &SetLeafArgs) -> Result<Node, ConcurrentMerkleTreeError> {\n        check_bounds(MAX_DEPTH, MAX_BUFFER_SIZE);\n        check_leaf_index(args.index, MAX_DEPTH)?;\n        if !self.is_initialized() {\n            return Err(ConcurrentMerkleTreeError::TreeNotInitialized);\n        }\n\n        if args.index > self.rightmost_proof.index {\n            Err(ConcurrentMerkleTreeError::LeafIndexOutOfBounds)\n        }",
    "pub fn get_seq(&self) -> u64 {\n        self.sequence_number\n    }\n\n    /// Modifies the `proof` for leaf at `leaf_index`\n    /// in place by fast-forwarding the given `proof` through the\n    /// `changelog`s, starting at index `changelog_buffer_index`\n    /// Returns false if the leaf was updated in the change log\n    #[inline(always)]\n    fn fast_forward_proof(\n        &self,\n        leaf: &mut Node,\n        proof: &mut [Node; MAX_DEPTH],\n        leaf_index: u32,\n        mut changelog_buffer_index: u64,\n        use_full_buffer: bool,\n    ) -> bool {\n        solana_logging!(\n            \"Fast-forwarding proof, starting index {}\",\n            changelog_buffer_index\n        );\n        let mask: usize = MAX_BUFFER_SIZE - 1;\n\n        let mut updated_leaf = *leaf;\n        log_compute!();\n        // Modifies proof by iterating through the change log\n        loop {\n            // If use_full_buffer is false, this loop will terminate if the initial value of\n            // changelog_buffer_index is the active index\n            if !use_full_buffer && changelog_buffer_index == self.active_index {\n                break;\n            }\n            changelog_buffer_index = (changelog_buffer_index + 1) & mask as u64;\n            self.change_logs[changelog_buffer_index as usize].update_proof_or_leaf(\n                leaf_index,\n                proof,\n                &mut updated_leaf,\n            );\n            // If use_full_buffer is true, this loop will do 1 full pass of the change logs\n            if use_full_buffer && changelog_buffer_index == self.active_index {\n                break;\n            }\n        }\n        log_compute!();\n        let proof_leaf_unchanged = updated_leaf == *leaf;\n        *leaf = updated_leaf;\n        proof_leaf_unchanged\n    }\n\n    #[inline(always)]\n    fn find_root_in_changelog(&self, current_root: Node) -> Option<u64> {\n        let mask: usize = MAX_BUFFER_SIZE - 1;\n        for i in 0..self.buffer_size {\n            let j = self.active_index.wrapping_sub(i) & mask as u64;\n            if self.change_logs[j as usize].root == current_root {\n                return Some(j);\n            }\n        }\n        None\n    }\n\n    #[inline(always)]\n    fn check_valid_leaf(\n        &self,\n        current_root: Node,\n        leaf: Node,\n        proof: &mut [Node; MAX_DEPTH],\n        leaf_index: u32,\n        allow_inferred_proof: bool,\n    ) -> Result<bool, ConcurrentMerkleTreeError> {\n        let mask: usize = MAX_BUFFER_SIZE - 1;\n        let (changelog_index, use_full_buffer) = match self.find_root_in_changelog(current_root) {\n            Some(matching_changelog_index) => (matching_changelog_index, false),\n            None => {\n                if allow_inferred_proof {\n                    solana_logging!(\"Failed to find root in change log -> replaying full buffer\");\n                    (\n                        self.active_index.wrapping_sub(self.buffer_size - 1) & mask as u64,\n                        true,\n                    )\n                }",
    "pub fn check_valid_proof(\n        &self,\n        leaf: Node,\n        proof: &[Node; MAX_DEPTH],\n        leaf_index: u32,\n    ) -> bool {\n        if !self.is_initialized() {\n            solana_logging!(\"Tree is not initialized, returning false\");\n            return false;\n        }\n        if check_leaf_index(leaf_index, MAX_DEPTH).is_err() {\n            solana_logging!(\"Leaf index out of bounds for max_depth\");\n            return false;\n        }\n        recompute(leaf, proof, leaf_index) == self.get_root()\n    }",
    "pub fn recompute(leaf: Node, proof: &[Node], index: u32) -> Node {\n    let mut current_node = leaf;\n    for (depth, sibling) in proof.iter().enumerate() {\n        hash_to_parent(&mut current_node, sibling, index >> depth & 1 == 0);\n    }\n    current_node\n}\n\n/// Computes the parent node of `node` and `sibling` and copies the result into\n/// `node`\n#[inline(always)]\npub fn hash_to_parent(node: &mut Node, sibling: &Node, is_left: bool) {\n    let parent = if is_left {\n        hashv(&[node, sibling])\n    }",
    "pub fn empty_node(level: u32) -> Node {\n    empty_node_cached::<0>(level, &[])\n}",
    "pub fn f32_normal_cdf(argument: f32) -> f32 {\n    const PI: f32 = std::f32::consts::PI;\n\n    let mod_argument = if argument < 0.0 {\n        -1.0 * argument\n    } else {\n        argument\n    };\n    let tabulation_numerator: f32 =\n        (1.0 / (1.0 * (2.0 * PI).sqrt())) * (-1.0 * (mod_argument * mod_argument) / 2.0).exp();\n    let tabulation_denominator: f32 =\n        0.226 + 0.64 * mod_argument + 0.33 * (mod_argument * mod_argument + 3.0).sqrt();\n    let y: f32 = 1.0 - tabulation_numerator / tabulation_denominator;\n    if argument < 0.0 {\n        1.0 - y\n    } else {\n        y\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use {super::*, proptest::prelude::*};\n\n    fn check_square_root(radicand: u128) {\n        let root = sqrt(radicand).unwrap();\n        let lower_bound = root.saturating_sub(1).checked_pow(2).unwrap();\n        let upper_bound = root.checked_add(1).unwrap().checked_pow(2).unwrap();\n        assert!(radicand <= upper_bound);\n        assert!(radicand >= lower_bound);\n    }\n\n    #[test]\n    fn test_square_root_min_max() {\n        let test_roots = [0, u64::MAX];\n        for i in test_roots.iter() {\n            check_square_root(*i as u128);\n        }\n    }\n\n    proptest! {\n        #[test]\n        fn test_square_root(a in 0..u64::MAX) {\n            check_square_root(a as u128);\n        }\n    }\n\n    fn check_normal_cdf_f32(argument: f32) {\n        let result = f32_normal_cdf(argument);\n        let check_result = 0.5 * (1.0 + libm::erff(argument / std::f32::consts::SQRT_2));\n        let abs_difference: f32 = (result - check_result).abs();\n        assert!(abs_difference <= 0.000_2);\n    }\n\n    #[test]\n    fn test_normal_cdf_f32_min_max() {\n        let test_arguments: [f32; 2] = [f32::MIN, f32::MAX];\n        for i in test_arguments.iter() {\n            check_normal_cdf_f32(*i)\n        }",
    "pub fn new(value: u128) -> Option<Self> {\n        let value = InnerUint::from(value).checked_mul(one())?;\n        Some(Self { value })\n    }",
    "pub fn to_imprecise(&self) -> Option<u128> {\n        self.value\n            .checked_add(Self::rounding_correction())?\n            .checked_div(one())\n            .map(|v| v.as_u128())\n    }",
    "pub fn almost_eq(&self, rhs: &Self, precision: InnerUint) -> bool {\n        let (difference, _) = self.unsigned_sub(rhs);\n        difference.value < precision\n    }\n\n    /// Checks that a number is less than another\n    pub fn less_than(&self, rhs: &Self) -> bool {\n        self.value < rhs.value\n    }\n\n    /// Checks that a number is greater than another\n    pub fn greater_than(&self, rhs: &Self) -> bool {\n        self.value > rhs.value\n    }\n\n    /// Checks that a number is less than another\n    pub fn less_than_or_equal(&self, rhs: &Self) -> bool {\n        self.value <= rhs.value\n    }\n\n    /// Checks that a number is greater than another\n    pub fn greater_than_or_equal(&self, rhs: &Self) -> bool {\n        self.value >= rhs.value\n    }\n\n    /// Floors a precise value to a precision of ONE\n    pub fn floor(&self) -> Option<Self> {\n        let value = self.value.checked_div(one())?.checked_mul(one())?;\n        Some(Self { value })\n    }",
    "pub fn ceiling(&self) -> Option<Self> {\n        let value = self\n            .value\n            .checked_add(one().checked_sub(InnerUint::from(1))?)?\n            .checked_div(one())?\n            .checked_mul(one())?;\n        Some(Self { value })\n    }",
    "pub fn checked_div(&self, rhs: &Self) -> Option<Self> {\n        if *rhs == Self::zero() {\n            return None;\n        }\n        match self.value.checked_mul(one()) {\n            Some(v) => {\n                let value = v\n                    .checked_add(Self::rounding_correction())?\n                    .checked_div(rhs.value)?;\n                Some(Self { value })\n            }",
    "pub fn checked_mul(&self, rhs: &Self) -> Option<Self> {\n        match self.value.checked_mul(rhs.value) {\n            Some(v) => {\n                let value = v\n                    .checked_add(Self::rounding_correction())?\n                    .checked_div(one())?;\n                Some(Self { value })\n            }",
    "pub fn checked_add(&self, rhs: &Self) -> Option<Self> {\n        let value = self.value.checked_add(rhs.value)?;\n        Some(Self { value })\n    }",
    "pub fn checked_sub(&self, rhs: &Self) -> Option<Self> {\n        let value = self.value.checked_sub(rhs.value)?;\n        Some(Self { value })\n    }",
    "pub fn unsigned_sub(&self, rhs: &Self) -> (Self, bool) {\n        match self.value.checked_sub(rhs.value) {\n            None => {\n                let value = rhs.value.checked_sub(self.value).unwrap();\n                (Self { value }, true)\n            }",
    "pub fn checked_pow(&self, exponent: u128) -> Option<Self> {\n        // For odd powers, start with a multiplication by base since we halve the\n        // exponent at the start\n        let value = if exponent.checked_rem(2)? == 0 {\n            one()\n        }",
    "pub fn sqrt(&self) -> Option<Self> {\n        if self.less_than(&Self::minimum_sqrt_base())\n            || self.greater_than(&Self::maximum_sqrt_base())\n        {\n            return None;\n        }\n        let two = PreciseNumber::new(2)?;\n        let one = PreciseNumber::new(1)?;\n        // A good initial guess is the average of the interval that contains the\n        // input number.  For all numbers, that will be between 1 and the given number.\n        let guess = self.checked_add(&one)?.checked_div(&two)?;\n        self.newtonian_root_approximation(&two, guess, Self::MAX_APPROXIMATION_ITERATIONS)\n    }",
    "pub fn precise_sqrt(radicand: u64) -> Instruction {\n    Instruction {\n        program_id: id(),\n        accounts: vec![],\n        data: borsh::to_vec(&MathInstruction::PreciseSquareRoot { radicand }).unwrap(),\n    }\n}\n\n/// Create U64 SquareRoot instruction\npub fn sqrt_u64(radicand: u64) -> Instruction {\n    Instruction {\n        program_id: id(),\n        accounts: vec![],\n        data: borsh::to_vec(&MathInstruction::SquareRootU64 { radicand }).unwrap(),\n    }\n}\n\n/// Create U128 SquareRoot instruction\npub fn sqrt_u128(radicand: u128) -> Instruction {\n    Instruction {\n        program_id: id(),\n        accounts: vec![],\n        data: borsh::to_vec(&MathInstruction::SquareRootU128 { radicand }).unwrap(),\n    }\n}\n\n/// Create U64 Multiplication instruction\npub fn u64_multiply(multiplicand: u64, multiplier: u64) -> Instruction {\n    Instruction {\n        program_id: id(),\n        accounts: vec![],\n        data: borsh::to_vec(&MathInstruction::U64Multiply {\n            multiplicand,\n            multiplier,\n        })\n        .unwrap(),\n    }\n}\n\n/// Create U64 Division instruction\npub fn u64_divide(dividend: u64, divisor: u64) -> Instruction {\n    Instruction {\n        program_id: id(),\n        accounts: vec![],\n        data: borsh::to_vec(&MathInstruction::U64Divide { dividend, divisor }).unwrap(),\n    }\n}\n\n/// Create F32 Multiplication instruction\npub fn f32_multiply(multiplicand: f32, multiplier: f32) -> Instruction {\n    Instruction {\n        program_id: id(),\n        accounts: vec![],\n        data: borsh::to_vec(&MathInstruction::F32Multiply {\n            multiplicand,\n            multiplier,\n        })\n        .unwrap(),\n    }\n}\n\n/// Create F32 Division instruction\npub fn f32_divide(dividend: f32, divisor: f32) -> Instruction {\n    Instruction {\n        program_id: id(),\n        accounts: vec![],\n        data: borsh::to_vec(&MathInstruction::F32Divide { dividend, divisor }).unwrap(),\n    }\n}\n\n/// Create F32 Exponentiate instruction\npub fn f32_exponentiate(base: f32, exponent: f32) -> Instruction {\n    Instruction {\n        program_id: id(),\n        accounts: vec![],\n        data: borsh::to_vec(&MathInstruction::F32Exponentiate { base, exponent }).unwrap(),\n    }\n}\n\n/// Create F32 Natural Log instruction\npub fn f32_natural_log(argument: f32) -> Instruction {\n    Instruction {\n        program_id: id(),\n        accounts: vec![],\n        data: borsh::to_vec(&MathInstruction::F32NaturalLog { argument }).unwrap(),\n    }\n}\n\n/// Create F32 Normal CDF instruction\npub fn f32_normal_cdf(argument: f32) -> Instruction {\n    Instruction {\n        program_id: id(),\n        accounts: vec![],\n        data: borsh::to_vec(&MathInstruction::F32NormalCDF { argument }).unwrap(),\n    }\n}\n\n/// Create F64Pow instruction\npub fn f64_pow(base: f64, exponent: f64) -> Instruction {\n    Instruction {\n        program_id: id(),\n        accounts: vec![],\n        data: borsh::to_vec(&MathInstruction::F64Pow { base, exponent }).unwrap(),\n    }\n}\n\n/// Create U128 Multiplication instruction\npub fn u128_multiply(multiplicand: u128, multiplier: u128) -> Instruction {\n    Instruction {\n        program_id: id(),\n        accounts: vec![],\n        data: borsh::to_vec(&MathInstruction::U128Multiply {\n            multiplicand,\n            multiplier,\n        })\n        .unwrap(),\n    }\n}\n\n/// Create U128 Division instruction\npub fn u128_divide(dividend: u128, divisor: u128) -> Instruction {\n    Instruction {\n        program_id: id(),\n        accounts: vec![],\n        data: borsh::to_vec(&MathInstruction::U128Divide { dividend, divisor }).unwrap(),\n    }\n}\n\n/// Create F64 Multiplication instruction\npub fn f64_multiply(multiplicand: f64, multiplier: f64) -> Instruction {\n    Instruction {\n        program_id: id(),\n        accounts: vec![],\n        data: borsh::to_vec(&MathInstruction::F64Multiply {\n            multiplicand,\n            multiplier,\n        })\n        .unwrap(),\n    }\n}\n\n/// Create F64 Division instruction\npub fn f64_divide(dividend: f64, divisor: f64) -> Instruction {\n    Instruction {\n        program_id: id(),\n        accounts: vec![],\n        data: borsh::to_vec(&MathInstruction::F64Divide { dividend, divisor }).unwrap(),\n    }\n}\n\n/// Create Noop instruction\npub fn noop() -> Instruction {\n    Instruction {\n        program_id: id(),\n        accounts: vec![],\n        data: borsh::to_vec(&MathInstruction::Noop).unwrap(),\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_precise_sqrt() {\n        let instruction = precise_sqrt(u64::MAX);\n        assert_eq!(0, instruction.accounts.len());\n        assert_eq!(\n            instruction.data,\n            borsh::to_vec(&MathInstruction::PreciseSquareRoot { radicand: u64::MAX }).unwrap()\n        );\n        assert_eq!(instruction.program_id, crate::id());\n    }\n\n    #[test]\n    fn test_sqrt_u64() {\n        let instruction = sqrt_u64(u64::MAX);\n        assert_eq!(0, instruction.accounts.len());\n        assert_eq!(\n            instruction.data,\n            borsh::to_vec(&MathInstruction::SquareRootU64 { radicand: u64::MAX }).unwrap()\n        );\n        assert_eq!(instruction.program_id, crate::id());\n    }\n\n    #[test]\n    fn test_sqrt_u128() {\n        let instruction = sqrt_u128(u128::MAX);\n        assert_eq!(0, instruction.accounts.len());\n        assert_eq!(\n            instruction.data,\n            borsh::to_vec(&MathInstruction::SquareRootU128 {\n                radicand: u128::MAX\n            })\n            .unwrap()\n        );\n        assert_eq!(instruction.program_id, crate::id());\n    }\n\n    #[test]\n    fn test_u64_multiply() {\n        let instruction = u64_multiply(u64::MAX, u64::MAX);\n        assert_eq!(0, instruction.accounts.len());\n        assert_eq!(\n            instruction.data,\n            borsh::to_vec(&MathInstruction::U64Multiply {\n                multiplicand: u64::MAX,\n                multiplier: u64::MAX\n            })\n            .unwrap()\n        );\n        assert_eq!(instruction.program_id, crate::id());\n    }\n\n    #[test]\n    fn test_u64_divide() {\n        let instruction = u64_divide(u64::MAX, u64::MAX);\n        assert_eq!(0, instruction.accounts.len());\n        assert_eq!(\n            instruction.data,\n            borsh::to_vec(&MathInstruction::U64Divide {\n                dividend: u64::MAX,\n                divisor: u64::MAX\n            })\n            .unwrap()\n        );\n        assert_eq!(instruction.program_id, crate::id());\n    }\n\n    #[test]\n    fn test_f32_multiply() {\n        let instruction = f32_multiply(f32::MAX, f32::MAX);\n        assert_eq!(0, instruction.accounts.len());\n        assert_eq!(\n            instruction.data,\n            borsh::to_vec(&MathInstruction::F32Multiply {\n                multiplicand: f32::MAX,\n                multiplier: f32::MAX\n            })\n            .unwrap()\n        );\n        assert_eq!(instruction.program_id, crate::id());\n    }\n\n    #[test]\n    fn test_f32_divide() {\n        let instruction = f32_divide(f32::MAX, f32::MAX);\n        assert_eq!(0, instruction.accounts.len());\n        assert_eq!(\n            instruction.data,\n            borsh::to_vec(&MathInstruction::F32Divide {\n                dividend: f32::MAX,\n                divisor: f32::MAX\n            })\n            .unwrap()\n        );\n        assert_eq!(instruction.program_id, crate::id());\n    }\n\n    #[test]\n    fn test_f32_exponentiate() {\n        let instruction = f32_exponentiate(f32::MAX, f32::MAX);\n        assert_eq!(0, instruction.accounts.len());\n        assert_eq!(\n            instruction.data,\n            borsh::to_vec(&MathInstruction::F32Exponentiate {\n                base: f32::MAX,\n                exponent: f32::MAX\n            })\n            .unwrap()\n        );\n        assert_eq!(instruction.program_id, crate::id())\n    }",
    "pub fn process_instruction(\n    _program_id: &Pubkey,\n    _accounts: &[AccountInfo],\n    input: &[u8],\n) -> ProgramResult {\n    let instruction = MathInstruction::try_from_slice(input).unwrap();\n    match instruction {\n        MathInstruction::PreciseSquareRoot { radicand } => {\n            msg!(\"Calculating square root using PreciseNumber\");\n            let radicand = PreciseNumber::new(radicand as u128).unwrap();\n            sol_log_compute_units();\n            let result = radicand.sqrt().unwrap().to_imprecise().unwrap() as u64;\n            sol_log_compute_units();\n            msg!(\"{}\", result);\n            Ok(())\n        }",
    "pub fn recompute(mut leaf: Node, proof: &[Node], index: u32) -> Node {\n    for (i, s) in proof.iter().enumerate() {\n        if index >> i & 1 == 0 {\n            let res = hashv(&[&leaf, s.as_ref()]);\n            leaf.copy_from_slice(res.as_ref());\n        } else {\n            let res = hashv(&[s.as_ref(), &leaf]);\n            leaf.copy_from_slice(res.as_ref());\n        }\n    }\n    leaf\n}\n\n// Off-chain implementation to keep track of nodes\npub struct MerkleTree {\n    pub leaf_nodes: Vec<Rc<RefCell<TreeNode>>>,\n    pub root: Node,\n}\n\nimpl MerkleTree {\n    /// Calculates updated root from the passed leaves\n    pub fn new(leaves: &[Node]) -> Self {\n        let mut leaf_nodes = vec![];\n        for (i, node) in leaves.iter().enumerate() {\n            let mut tree_node = TreeNode::new_empty(0, i as u128);\n            tree_node.node = *node;\n            leaf_nodes.push(Rc::new(RefCell::new(tree_node)));\n        }\n        let root = MerkleTree::build_root(leaf_nodes.as_slice());\n        Self { leaf_nodes, root }\n    }\n\n    /// Builds root from stack of leaves\n    pub fn build_root(leaves: &[Rc<RefCell<TreeNode>>]) -> Node {\n        let mut tree = VecDeque::from_iter(leaves.iter().map(Rc::clone));\n        let mut seq_num = leaves.len() as u128;\n        while tree.len() > 1 {\n            let left = tree.pop_front().unwrap();\n            let level = left.borrow().level;\n            let right = if level != tree[0].borrow().level {\n                let node = Rc::new(RefCell::new(TreeNode::new_empty(level, seq_num)));\n                seq_num += 1;\n                node\n            } else {\n                tree.pop_front().unwrap()\n            }",
    "pub fn get_proof_of_leaf(&self, idx: usize) -> Vec<Node> {\n        let mut proof = vec![];\n        let mut node = self.leaf_nodes[idx].clone();\n        loop {\n            let ref_node = node.clone();\n            if ref_node.borrow().parent.is_none() {\n                break;\n            }\n            let parent = ref_node.borrow().parent.as_ref().unwrap().clone();\n            if parent.borrow().left.as_ref().unwrap().borrow().id == ref_node.borrow().id {\n                proof.push(parent.borrow().right.as_ref().unwrap().borrow().node);\n            } else {\n                proof.push(parent.borrow().left.as_ref().unwrap().borrow().node);\n            }\n            node = parent;\n        }\n        proof\n    }\n\n    /// Updates root from an updated leaf node set at index: `idx`\n    fn update_root_from_leaf(&mut self, leaf_idx: usize) {\n        let mut node = self.leaf_nodes[leaf_idx].clone();\n        loop {\n            let ref_node = node.clone();\n            if ref_node.borrow().parent.is_none() {\n                self.root = ref_node.borrow().node;\n                break;\n            }\n            let parent = ref_node.borrow().parent.as_ref().unwrap().clone();\n            let hash = if parent.borrow().left.as_ref().unwrap().borrow().id == ref_node.borrow().id\n            {\n                hashv(&[\n                    &ref_node.borrow().node,\n                    &parent.borrow().right.as_ref().unwrap().borrow().node,\n                ])\n            }",
    "pub fn get_node(&self, idx: usize) -> Node {\n        self.leaf_nodes[idx].borrow().node\n    }\n\n    pub fn get_root(&self) -> Node {\n        self.root\n    }\n\n    pub fn add_leaf(&mut self, leaf: Node, leaf_idx: usize) {\n        self.leaf_nodes[leaf_idx].borrow_mut().node = leaf;\n        self.update_root_from_leaf(leaf_idx)\n    }",
    "pub fn remove_leaf(&mut self, leaf_idx: usize) {\n        self.leaf_nodes[leaf_idx].borrow_mut().node = EMPTY;\n        self.update_root_from_leaf(leaf_idx)\n    }",
    "pub fn load(accounts: &'a [AccountInfo<'info>]) -> Result<Self, ProgramError> {\n        let account_iter = &mut accounts.iter();\n        let ctx = Self {\n            mint: next_account_info(account_iter)?,\n            payer: next_account_info(account_iter)?,\n            upstream_authority: next_account_info(account_iter)?,\n            system_program: next_account_info(account_iter)?,\n            token_program: next_account_info(account_iter)?,\n        };\n        assert_with_msg(\n            ctx.mint.data_is_empty(),\n            ProgramError::InvalidAccountData,\n            \"Mint account must be uninitialized\",\n        )?;\n        assert_with_msg(\n            ctx.mint.owner == &system_program::id(),\n            ProgramError::IllegalOwner,\n            \"Mint account must be owned by the System Program when uninitialized\",\n        )?;\n        assert_with_msg(\n            ctx.token_program.key == &spl_token::id(),\n            ProgramError::InvalidInstructionData,\n            \"Invalid key supplied for Token Program\",\n        )?;\n        assert_with_msg(\n            ctx.system_program.key == &system_program::id(),\n            ProgramError::InvalidInstructionData,\n            \"Invalid key supplied for System Program\",\n        )?;\n        assert_with_msg(\n            ctx.mint.is_writable,\n            ProgramError::InvalidInstructionData,\n            \"Mint account must be writable\",\n        )?;\n        assert_with_msg(\n            ctx.payer.is_writable,\n            ProgramError::InvalidInstructionData,\n            \"Payer account must be writable (lamport balance will change)\",\n        )?;\n        assert_with_msg(\n            ctx.payer.is_signer,\n            ProgramError::MissingRequiredSignature,\n            \"Payer must sign for initialization\",\n        )?;\n        Ok(ctx)\n    }",
    "pub fn load(accounts: &'a [AccountInfo<'info>]) -> Result<Self, ProgramError> {\n        let account_iter = &mut accounts.iter();\n        let ctx = Self {\n            token_account: next_account_info(account_iter)?,\n            owner: next_account_info(account_iter)?,\n            payer: next_account_info(account_iter)?,\n            upstream_authority: next_account_info(account_iter)?,\n            freeze_authority: next_account_info(account_iter)?,\n            mint: next_account_info(account_iter)?,\n            system_program: next_account_info(account_iter)?,\n            associated_token_program: next_account_info(account_iter)?,\n            token_program: next_account_info(account_iter)?,\n        };\n        assert_with_msg(\n            ctx.token_account.data_is_empty(),\n            ProgramError::InvalidAccountData,\n            \"Token account must be uninitialized\",\n        )?;\n        assert_with_msg(\n            ctx.token_account.owner == &system_program::id(),\n            ProgramError::IllegalOwner,\n            \"Token account must be owned by System Program when uninitialized\",\n        )?;\n        assert_with_msg(\n            ctx.mint.owner == ctx.token_program.key,\n            ProgramError::IllegalOwner,\n            \"Mint account must be owned by the Token Program\",\n        )?;\n        assert_with_msg(\n            ctx.token_program.key == &spl_token::id(),\n            ProgramError::InvalidInstructionData,\n            \"Invalid key supplied for Token Program\",\n        )?;\n        assert_with_msg(\n            ctx.system_program.key == &system_program::id(),\n            ProgramError::InvalidInstructionData,\n            \"Invalid key supplied for System Program\",\n        )?;\n        assert_with_msg(\n            ctx.associated_token_program.key == &spl_associated_token_account_client::program::id(),\n            ProgramError::InvalidInstructionData,\n            \"Invalid key supplied for Associataed Token Program\",\n        )?;\n        assert_with_msg(\n            ctx.token_account.is_writable,\n            ProgramError::InvalidInstructionData,\n            \"Token account must be writable\",\n        )?;\n        assert_with_msg(\n            ctx.payer.is_writable,\n            ProgramError::InvalidInstructionData,\n            \"Payer account must be writable (lamport balance will change)\",\n        )?;\n        assert_with_msg(\n            ctx.payer.is_signer,\n            ProgramError::MissingRequiredSignature,\n            \"Payer must sign for initialization\",\n        )?;\n        assert_with_msg(\n            ctx.upstream_authority.is_signer,\n            ProgramError::MissingRequiredSignature,\n            \"Freeze authority must sign for initialization\",\n        )?;\n        Ok(ctx)\n    }",
    "pub fn load(accounts: &'a [AccountInfo<'info>]) -> Result<Self, ProgramError> {\n        let account_iter = &mut accounts.iter();\n        let ctx = Self {\n            mint: next_account_info(account_iter)?,\n            token_account: next_account_info(account_iter)?,\n            upstream_authority: next_account_info(account_iter)?,\n            freeze_and_mint_authority: next_account_info(account_iter)?,\n            token_program: next_account_info(account_iter)?,\n        };\n        assert_with_msg(\n            ctx.mint.owner == ctx.token_program.key,\n            ProgramError::IllegalOwner,\n            \"Mint account must be owned by the Token Program\",\n        )?;\n        assert_with_msg(\n            ctx.token_account.owner == ctx.token_program.key,\n            ProgramError::IllegalOwner,\n            \"Token account must be owned by the Token Program\",\n        )?;\n        assert_with_msg(\n            ctx.token_program.key == &spl_token::id(),\n            ProgramError::InvalidInstructionData,\n            \"Invalid key supplied for Token Program\",\n        )?;\n        assert_with_msg(\n            ctx.mint.is_writable,\n            ProgramError::InvalidInstructionData,\n            \"Mint must be writable\",\n        )?;\n        assert_with_msg(\n            ctx.token_account.is_writable,\n            ProgramError::InvalidInstructionData,\n            \"Token Account must be writable\",\n        )?;\n        assert_with_msg(\n            ctx.upstream_authority.is_signer,\n            ProgramError::MissingRequiredSignature,\n            \"Freeze authority must sign for modification\",\n        )?;\n        Ok(ctx)\n    }",
    "pub fn load(accounts: &'a [AccountInfo<'info>]) -> Result<Self, ProgramError> {\n        let account_iter = &mut accounts.iter();\n        let ctx = Self {\n            mint: next_account_info(account_iter)?,\n            token_account: next_account_info(account_iter)?,\n            owner: next_account_info(account_iter)?,\n            upstream_authority: next_account_info(account_iter)?,\n            freeze_authority: next_account_info(account_iter)?,\n            token_program: next_account_info(account_iter)?,\n        };\n        assert_with_msg(\n            ctx.mint.owner == ctx.token_program.key,\n            ProgramError::IllegalOwner,\n            \"Mint account must be owned by the Token Program\",\n        )?;\n        assert_with_msg(\n            ctx.token_account.owner == ctx.token_program.key,\n            ProgramError::IllegalOwner,\n            \"Token account must be owned by the Token Program\",\n        )?;\n        assert_with_msg(\n            ctx.token_program.key == &spl_token::id(),\n            ProgramError::InvalidInstructionData,\n            \"Invalid key supplied for Token Program\",\n        )?;\n        assert_with_msg(\n            ctx.mint.is_writable,\n            ProgramError::InvalidInstructionData,\n            \"Mint must be writable\",\n        )?;\n        assert_with_msg(\n            ctx.token_account.is_writable,\n            ProgramError::InvalidInstructionData,\n            \"Token Account must be writable\",\n        )?;\n        assert_with_msg(\n            ctx.upstream_authority.is_signer,\n            ProgramError::MissingRequiredSignature,\n            \"Freeze authority must sign for modification\",\n        )?;\n        assert_with_msg(\n            ctx.owner.is_signer,\n            ProgramError::MissingRequiredSignature,\n            \"Owner must sign for modification\",\n        )?;\n        Ok(ctx)\n    }",
    "pub fn load(accounts: &'a [AccountInfo<'info>]) -> Result<Self, ProgramError> {\n        let account_iter = &mut accounts.iter();\n        let ctx = Self {\n            src_account: next_account_info(account_iter)?,\n            dst_account: next_account_info(account_iter)?,\n            mint: next_account_info(account_iter)?,\n            owner: next_account_info(account_iter)?,\n            upstream_authority: next_account_info(account_iter)?,\n            freeze_authority: next_account_info(account_iter)?,\n            token_program: next_account_info(account_iter)?,\n        };\n        assert_with_msg(\n            ctx.mint.owner == &spl_token::id(),\n            ProgramError::IllegalOwner,\n            \"Mint account must be owned by the Token Program\",\n        )?;\n        assert_with_msg(\n            ctx.src_account.owner == &spl_token::id(),\n            ProgramError::IllegalOwner,\n            \"Source token account must be owned by the Token Program\",\n        )?;\n        assert_with_msg(\n            ctx.dst_account.owner == &spl_token::id(),\n            ProgramError::IllegalOwner,\n            \"Destination token account must be owned by the Token Program\",\n        )?;\n        assert_with_msg(\n            ctx.token_program.key == &spl_token::id(),\n            ProgramError::InvalidInstructionData,\n            \"Invalid key supplied for Token Program\",\n        )?;\n        assert_with_msg(\n            ctx.src_account.is_writable,\n            ProgramError::InvalidInstructionData,\n            \"Source token account must be writable\",\n        )?;\n        assert_with_msg(\n            ctx.dst_account.is_writable,\n            ProgramError::InvalidInstructionData,\n            \"Destination token account must be writable\",\n        )?;\n        assert_with_msg(\n            ctx.owner.is_signer,\n            ProgramError::MissingRequiredSignature,\n            \"Owner must sign for modification\",\n        )?;\n        assert_with_msg(\n            ctx.upstream_authority.is_signer,\n            ProgramError::MissingRequiredSignature,\n            \"Freeze authority must sign for modification\",\n        )?;\n        Ok(ctx)\n    }",
    "pub fn load(accounts: &'a [AccountInfo<'info>]) -> Result<Self, ProgramError> {\n        let account_iter = &mut accounts.iter();\n        let ctx = Self {\n            token_account: next_account_info(account_iter)?,\n            dst_account: next_account_info(account_iter)?,\n            mint: next_account_info(account_iter)?,\n            owner: next_account_info(account_iter)?,\n            upstream_authority: next_account_info(account_iter)?,\n            freeze_authority: next_account_info(account_iter)?,\n            token_program: next_account_info(account_iter)?,\n        };\n        assert_with_msg(\n            ctx.mint.owner == ctx.token_program.key,\n            ProgramError::IllegalOwner,\n            \"Mint account must be owned by the Token Program\",\n        )?;\n        assert_with_msg(\n            ctx.token_account.owner == ctx.token_program.key,\n            ProgramError::IllegalOwner,\n            \"Token account must be owned by the Token Program\",\n        )?;\n        assert_with_msg(\n            ctx.dst_account.owner == &system_program::id(),\n            ProgramError::IllegalOwner,\n            \"Destination account must be owned by the System Program\",\n        )?;\n        assert_with_msg(\n            ctx.token_program.key == &spl_token::id(),\n            ProgramError::InvalidInstructionData,\n            \"Invalid key supplied for Token Program\",\n        )?;\n        assert_with_msg(\n            ctx.token_account.is_writable,\n            ProgramError::InvalidInstructionData,\n            \"Token Account must be writable\",\n        )?;\n        assert_with_msg(\n            ctx.dst_account.is_writable,\n            ProgramError::InvalidInstructionData,\n            \"Destination account must be writable\",\n        )?;\n        assert_with_msg(\n            ctx.owner.is_signer,\n            ProgramError::MissingRequiredSignature,\n            \"Owner must sign for close\",\n        )?;\n        assert_with_msg(\n            ctx.upstream_authority.is_signer,\n            ProgramError::MissingRequiredSignature,\n            \"Freeze authority must sign for close\",\n        )?;\n        Ok(ctx)\n    }",
    "pub fn load(accounts: &'a [AccountInfo<'info>]) -> Result<Self, ProgramError> {\n        let account_iter = &mut accounts.iter();\n        let ctx = Self {\n            mint: next_account_info(account_iter)?,\n            token_account: next_account_info(account_iter)?,\n            owner: next_account_info(account_iter)?,\n            upstream_authority: next_account_info(account_iter)?,\n            delegate: next_account_info(account_iter)?,\n            freeze_authority: next_account_info(account_iter)?,\n            token_program: next_account_info(account_iter)?,\n        };\n        assert_with_msg(\n            ctx.mint.owner == &spl_token::id(),\n            ProgramError::IllegalOwner,\n            \"Mint account must be owned by the Token Program\",\n        )?;\n        assert_with_msg(\n            ctx.token_account.owner == ctx.token_program.key,\n            ProgramError::IllegalOwner,\n            \"Token account must be owned by the Token Program\",\n        )?;\n        assert_with_msg(\n            ctx.token_account.is_writable,\n            ProgramError::InvalidInstructionData,\n            \"Token Account must be writable\",\n        )?;\n        assert_with_msg(\n            ctx.token_program.key == &spl_token::id(),\n            ProgramError::InvalidInstructionData,\n            \"Invalid key supplied for Token Program\",\n        )?;\n        assert_with_msg(\n            ctx.upstream_authority.is_signer,\n            ProgramError::MissingRequiredSignature,\n            \"Freeze authority must sign for modification\",\n        )?;\n        assert_with_msg(\n            ctx.owner.is_signer,\n            ProgramError::MissingRequiredSignature,\n            \"Owner must sign for modification\",\n        )?;\n        Ok(ctx)\n    }",
    "pub fn load(accounts: &'a [AccountInfo<'info>]) -> Result<Self, ProgramError> {\n        let account_iter = &mut accounts.iter();\n        let ctx = Self {\n            mint: next_account_info(account_iter)?,\n            token_account: next_account_info(account_iter)?,\n            owner: next_account_info(account_iter)?,\n            upstream_authority: next_account_info(account_iter)?,\n            freeze_authority: next_account_info(account_iter)?,\n            token_program: next_account_info(account_iter)?,\n        };\n        assert_with_msg(\n            ctx.mint.owner == &spl_token::id(),\n            ProgramError::IllegalOwner,\n            \"Mint account must be owned by the Token Program\",\n        )?;\n        assert_with_msg(\n            ctx.token_account.owner == ctx.token_program.key,\n            ProgramError::IllegalOwner,\n            \"Token account must be owned by the Token Program\",\n        )?;\n        assert_with_msg(\n            ctx.token_account.is_writable,\n            ProgramError::InvalidInstructionData,\n            \"Token Account must be writable\",\n        )?;\n        assert_with_msg(\n            ctx.token_program.key == &spl_token::id(),\n            ProgramError::InvalidInstructionData,\n            \"Invalid key supplied for Token Program\",\n        )?;\n        assert_with_msg(\n            ctx.upstream_authority.is_signer,\n            ProgramError::MissingRequiredSignature,\n            \"Freeze authority must sign for modification\",\n        )?;\n        assert_with_msg(\n            ctx.owner.is_signer,\n            ProgramError::MissingRequiredSignature,\n            \"Owner must sign for modification\",\n        )?;\n        Ok(ctx)\n    }",
    "pub fn create_initialize_mint_instruction(\n    mint: &Pubkey,\n    payer: &Pubkey,\n    upstream_authority: &Pubkey,\n    decimals: u8,\n) -> Result<Instruction, ProgramError> {\n    Ok(Instruction {\n        program_id: crate::id(),\n        accounts: vec![\n            AccountMeta::new(*mint, true),\n            AccountMeta::new(*payer, true),\n            AccountMeta::new_readonly(*upstream_authority, false),\n            AccountMeta::new_readonly(system_program::id(), false),\n            AccountMeta::new_readonly(spl_token::id(), false),\n        ],\n        data: borsh::to_vec(&ManagedTokenInstruction::InitializeMint { decimals })?,\n    })\n}",
    "pub fn create_initialize_account_instruction(\n    mint: &Pubkey,\n    owner: &Pubkey,\n    payer: &Pubkey,\n    upstream_authority: &Pubkey,\n) -> Result<Instruction, ProgramError> {\n    let account = get_associated_token_address(owner, mint);\n    let (freeze_authority, _) = get_authority(upstream_authority);\n    Ok(Instruction {\n        program_id: crate::id(),\n        accounts: vec![\n            AccountMeta::new(account, false),\n            AccountMeta::new_readonly(*owner, false),\n            AccountMeta::new(*payer, true),\n            AccountMeta::new_readonly(*upstream_authority, true),\n            AccountMeta::new_readonly(freeze_authority, false),\n            AccountMeta::new_readonly(*mint, false),\n            AccountMeta::new_readonly(system_program::id(), false),\n            AccountMeta::new_readonly(spl_associated_token_account_client::program::id(), false),\n            AccountMeta::new_readonly(spl_token::id(), false),\n        ],\n        data: borsh::to_vec(&ManagedTokenInstruction::InitializeAccount)?,\n    })\n}",
    "pub fn create_mint_to_instruction(\n    mint: &Pubkey,\n    owner: &Pubkey,\n    upstream_authority: &Pubkey,\n    amount: u64,\n) -> Result<Instruction, ProgramError> {\n    let account = get_associated_token_address(owner, mint);\n    let (authority, _) = get_authority(upstream_authority);\n    Ok(Instruction {\n        program_id: crate::id(),\n        accounts: vec![\n            AccountMeta::new(*mint, false),\n            AccountMeta::new(account, false),\n            AccountMeta::new_readonly(*upstream_authority, true),\n            AccountMeta::new_readonly(authority, false),\n            AccountMeta::new_readonly(spl_token::id(), false),\n        ],\n        data: borsh::to_vec(&ManagedTokenInstruction::MintTo { amount })?,\n    })\n}",
    "pub fn create_transfer_instruction(\n    src: &Pubkey,\n    dst: &Pubkey,\n    mint: &Pubkey,\n    upstream_authority: &Pubkey,\n    amount: u64,\n) -> Result<Instruction, ProgramError> {\n    let src_account = get_associated_token_address(src, mint);\n    let dst_account = get_associated_token_address(dst, mint);\n    let (freeze_authority, _) = get_authority(upstream_authority);\n    Ok(Instruction {\n        program_id: crate::id(),\n        accounts: vec![\n            AccountMeta::new(src_account, false),\n            AccountMeta::new(dst_account, false),\n            AccountMeta::new_readonly(*mint, false),\n            AccountMeta::new_readonly(*src, true),\n            AccountMeta::new_readonly(*upstream_authority, true),\n            AccountMeta::new_readonly(freeze_authority, false),\n            AccountMeta::new_readonly(spl_token::id(), false),\n        ],\n        data: borsh::to_vec(&ManagedTokenInstruction::Transfer { amount })?,\n    })\n}",
    "pub fn create_transfer_with_delegate_instruction(\n    src: &Pubkey,\n    dst: &Pubkey,\n    delegate: &Pubkey,\n    mint: &Pubkey,\n    upstream_authority: &Pubkey,\n    amount: u64,\n) -> Result<Instruction, ProgramError> {\n    let src_account = get_associated_token_address(src, mint);\n    let dst_account = get_associated_token_address(dst, mint);\n    let (freeze_authority, _) = get_authority(upstream_authority);\n    Ok(Instruction {\n        program_id: crate::id(),\n        accounts: vec![\n            AccountMeta::new(src_account, false),\n            AccountMeta::new(dst_account, false),\n            AccountMeta::new_readonly(*mint, false),\n            AccountMeta::new_readonly(*delegate, true),\n            AccountMeta::new_readonly(*upstream_authority, true),\n            AccountMeta::new_readonly(freeze_authority, false),\n            AccountMeta::new_readonly(spl_token::id(), false),\n        ],\n        data: borsh::to_vec(&ManagedTokenInstruction::Transfer { amount })?,\n    })\n}",
    "pub fn create_burn_instruction(\n    mint: &Pubkey,\n    owner: &Pubkey,\n    upstream_authority: &Pubkey,\n    amount: u64,\n) -> Result<Instruction, ProgramError> {\n    let account = get_associated_token_address(owner, mint);\n    let (freeze_authority, _) = get_authority(upstream_authority);\n    Ok(Instruction {\n        program_id: crate::id(),\n        accounts: vec![\n            AccountMeta::new(*mint, false),\n            AccountMeta::new(account, false),\n            AccountMeta::new_readonly(*owner, true),\n            AccountMeta::new_readonly(*upstream_authority, true),\n            AccountMeta::new_readonly(freeze_authority, false),\n            AccountMeta::new_readonly(spl_token::id(), false),\n        ],\n        data: borsh::to_vec(&ManagedTokenInstruction::Burn { amount })?,\n    })\n}",
    "pub fn create_close_account_instruction(\n    mint: &Pubkey,\n    owner: &Pubkey,\n    upstream_authority: &Pubkey,\n) -> Result<Instruction, ProgramError> {\n    let account = get_associated_token_address(owner, mint);\n    let (freeze_authority, _) = get_authority(upstream_authority);\n    Ok(Instruction {\n        program_id: crate::id(),\n        accounts: vec![\n            AccountMeta::new(account, false),\n            AccountMeta::new(*owner, false),\n            AccountMeta::new_readonly(*mint, false),\n            AccountMeta::new_readonly(*owner, true),\n            AccountMeta::new_readonly(*upstream_authority, true),\n            AccountMeta::new_readonly(freeze_authority, false),\n            AccountMeta::new_readonly(spl_token::id(), false),\n        ],\n        data: borsh::to_vec(&ManagedTokenInstruction::CloseAccount)?,\n    })\n}",
    "pub fn create_approve_instruction(\n    mint: &Pubkey,\n    owner: &Pubkey,\n    delegate: &Pubkey,\n    upstream_authority: &Pubkey,\n    amount: u64,\n) -> Result<Instruction, ProgramError> {\n    let (freeze_authority, _) = get_authority(upstream_authority);\n    let account = get_associated_token_address(owner, mint);\n    Ok(Instruction {\n        program_id: crate::id(),\n        accounts: vec![\n            AccountMeta::new_readonly(*mint, false),\n            AccountMeta::new(account, false),\n            AccountMeta::new_readonly(*owner, true),\n            AccountMeta::new_readonly(*upstream_authority, true),\n            AccountMeta::new_readonly(*delegate, false),\n            AccountMeta::new_readonly(freeze_authority, false),\n            AccountMeta::new_readonly(spl_token::id(), false),\n        ],\n        data: borsh::to_vec(&ManagedTokenInstruction::Approve { amount })?,\n    })\n}",
    "pub fn create_revoke_instruction(\n    mint: &Pubkey,\n    owner: &Pubkey,\n    upstream_authority: &Pubkey,\n) -> Result<Instruction, ProgramError> {\n    let (freeze_authority, _) = get_authority(upstream_authority);\n    let account = get_associated_token_address(owner, mint);\n    Ok(Instruction {\n        program_id: crate::id(),\n        accounts: vec![\n            AccountMeta::new_readonly(*mint, false),\n            AccountMeta::new(account, false),\n            AccountMeta::new_readonly(*owner, true),\n            AccountMeta::new_readonly(*upstream_authority, true),\n            AccountMeta::new_readonly(freeze_authority, false),\n            AccountMeta::new_readonly(spl_token::id(), false),\n        ],\n        data: borsh::to_vec(&ManagedTokenInstruction::Revoke)?,\n    })\n}",
    "pub fn assert_with_msg(v: bool, err: impl Into<ProgramError>, msg: &str) -> ProgramResult {\n    if v {\n        Ok(())\n    }",
    "pub fn process_instruction(\n    _program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    instruction_data: &[u8],\n) -> ProgramResult {\n    let instruction = ManagedTokenInstruction::try_from_slice(instruction_data)?;\n    match instruction {\n        ManagedTokenInstruction::InitializeMint { decimals } => {\n            msg!(\"ManagedTokenInstruction::InitializeMint\");\n            process_initialize_mint(accounts, decimals)\n        }",
    "pub fn process_initialize_mint(accounts: &[AccountInfo], decimals: u8) -> ProgramResult {\n    let InitializeMint {\n        mint,\n        payer,\n        upstream_authority,\n        system_program,\n        token_program,\n    } = InitializeMint::load(accounts)?;\n    let space = spl_token::state::Mint::LEN;\n    invoke(\n        &system_instruction::create_account(\n            payer.key,\n            mint.key,\n            Rent::get()?.minimum_balance(space),\n            space as u64,\n            token_program.key,\n        ),\n        &[payer.clone(), mint.clone(), system_program.clone()],\n    )?;\n    let (authority, _) = get_authority(upstream_authority.key);\n    initialize_mint(&authority, &authority, mint, token_program, decimals)\n}",
    "pub fn process_initialize_account(accounts: &[AccountInfo]) -> ProgramResult {\n    let InitializeAccount {\n        token_account,\n        owner,\n        payer,\n        upstream_authority,\n        freeze_authority,\n        mint,\n        system_program,\n        associated_token_program,\n        token_program,\n    } = InitializeAccount::load(accounts)?;\n    invoke(\n        &create_associated_token_account(payer.key, owner.key, mint.key, token_program.key),\n        &[\n            associated_token_program.clone(),\n            payer.clone(),\n            owner.clone(),\n            token_account.clone(),\n            mint.clone(),\n            system_program.clone(),\n            token_program.clone(),\n        ],\n    )?;\n    let seeds = get_authority_seeds_checked(upstream_authority.key, freeze_authority.key)?;\n    freeze(freeze_authority, mint, token_account, token_program, &seeds)\n}",
    "pub fn process_transfer(accounts: &[AccountInfo], amount: u64) -> ProgramResult {\n    let Transfer {\n        src_account,\n        dst_account,\n        mint,\n        owner,\n        upstream_authority,\n        freeze_authority,\n        token_program,\n    } = Transfer::load(accounts)?;\n    let seeds = get_authority_seeds_checked(upstream_authority.key, freeze_authority.key)?;\n    thaw(freeze_authority, mint, src_account, token_program, &seeds)?;\n    thaw(freeze_authority, mint, dst_account, token_program, &seeds)?;\n    transfer(src_account, dst_account, owner, token_program, amount)?;\n    freeze(freeze_authority, mint, dst_account, token_program, &seeds)?;\n    freeze(freeze_authority, mint, src_account, token_program, &seeds)\n}",
    "pub fn process_mint_to(accounts: &[AccountInfo], amount: u64) -> ProgramResult {\n    let Mint {\n        mint,\n        token_account,\n        upstream_authority,\n        freeze_and_mint_authority: authority,\n        token_program,\n    } = Mint::load(accounts)?;\n    let authority_seeds = get_authority_seeds_checked(upstream_authority.key, authority.key)?;\n    thaw(\n        authority,\n        mint,\n        token_account,\n        token_program,\n        &authority_seeds,\n    )?;\n    mint_to(\n        mint,\n        token_account,\n        authority,\n        token_program,\n        amount,\n        &authority_seeds,\n    )?;\n    freeze(\n        authority,\n        mint,\n        token_account,\n        token_program,\n        &authority_seeds,\n    )\n}",
    "pub fn process_burn(accounts: &[AccountInfo], amount: u64) -> ProgramResult {\n    let Burn {\n        mint,\n        token_account,\n        owner,\n        upstream_authority,\n        freeze_authority,\n        token_program,\n    } = Burn::load(accounts)?;\n    let seeds = get_authority_seeds_checked(upstream_authority.key, freeze_authority.key)?;\n    thaw(freeze_authority, mint, token_account, token_program, &seeds)?;\n    burn(mint, token_account, owner, token_program, amount)?;\n    freeze(freeze_authority, mint, token_account, token_program, &seeds)\n}",
    "pub fn process_close(accounts: &[AccountInfo]) -> ProgramResult {\n    let Close {\n        token_account,\n        dst_account,\n        mint,\n        owner,\n        upstream_authority,\n        freeze_authority,\n        token_program,\n    } = Close::load(accounts)?;\n    let seeds = get_authority_seeds_checked(upstream_authority.key, freeze_authority.key)?;\n    thaw(freeze_authority, mint, token_account, token_program, &seeds)?;\n    close(token_account, dst_account, owner, token_program)\n}",
    "pub fn process_approve(accounts: &[AccountInfo], amount: u64) -> ProgramResult {\n    let Approve {\n        mint,\n        token_account,\n        owner,\n        upstream_authority,\n        delegate,\n        freeze_authority,\n        token_program,\n    } = Approve::load(accounts)?;\n    let seeds = get_authority_seeds_checked(upstream_authority.key, freeze_authority.key)?;\n    thaw(freeze_authority, mint, token_account, token_program, &seeds)?;\n    approve(token_account, owner, delegate, token_program, amount)?;\n    freeze(freeze_authority, mint, token_account, token_program, &seeds)\n}",
    "pub fn process_revoke(accounts: &[AccountInfo]) -> ProgramResult {\n    let Revoke {\n        mint,\n        token_account,\n        owner,\n        upstream_authority,\n        freeze_authority,\n        token_program,\n    } = Revoke::load(accounts)?;\n    let seeds = get_authority_seeds_checked(upstream_authority.key, freeze_authority.key)?;\n    thaw(freeze_authority, mint, token_account, token_program, &seeds)?;\n    revoke(token_account, owner, token_program)?;\n    freeze(freeze_authority, mint, token_account, token_program, &seeds)\n}",
    "pub fn sol(amount: f64) -> u64 {\n    (amount * LAMPORTS_PER_SOL as f64) as u64\n}\n\nasync fn process_transaction(\n    client: &mut BanksClient,\n    instructions: Vec<Instruction>,\n    signers: Vec<&Keypair>,\n) -> Result<Signature, BanksClientError> {\n    let mut tx = Transaction::new_with_payer(&instructions, Some(&signers[0].pubkey()));\n    tx.partial_sign(&signers, client.get_latest_blockhash().await?);\n    let sig = tx.signatures[0];\n    client\n        .process_transaction_with_commitment(tx, CommitmentLevel::Confirmed)\n        .await?;\n    Ok(sig)\n}",
    "pub fn process_instruction(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    instruction_data: &[u8],\n) -> ProgramResult {\n    msg!(\"Entrypoint\");\n    if let Err(error) = Processor::process_instruction(program_id, accounts, instruction_data) {\n        // catch the error so we can print it\n        error.print::<NameServiceError>();\n        return Err(error);\n    }\n    Ok(())\n}",
    "pub fn create(\n    name_service_program_id: Pubkey,\n    instruction_data: NameRegistryInstruction,\n    name_account_key: Pubkey,\n    payer_key: Pubkey,\n    name_owner: Pubkey,\n    name_class_opt: Option<Pubkey>,\n    name_parent_opt: Option<Pubkey>,\n    name_parent_owner_opt: Option<Pubkey>,\n) -> Result<Instruction, ProgramError> {\n    let data = borsh::to_vec(&instruction_data).unwrap();\n    let mut accounts = vec![\n        AccountMeta::new_readonly(system_program::id(), false),\n        AccountMeta::new(payer_key, true),\n        AccountMeta::new(name_account_key, false),\n        AccountMeta::new_readonly(name_owner, false),\n    ];\n    if let Some(name_class) = name_class_opt {\n        accounts.push(AccountMeta::new_readonly(name_class, true));\n    } else {\n        accounts.push(AccountMeta::new_readonly(Pubkey::default(), false));\n    }\n    if let Some(name_parent) = name_parent_opt {\n        accounts.push(AccountMeta::new_readonly(name_parent, false));\n    } else {\n        accounts.push(AccountMeta::new_readonly(Pubkey::default(), false));\n    }\n    if let Some(key) = name_parent_owner_opt {\n        accounts.push(AccountMeta::new_readonly(key, true));\n    }\n\n    Ok(Instruction {\n        program_id: name_service_program_id,\n        accounts,\n        data,\n    })\n}",
    "pub fn update(\n    name_service_program_id: Pubkey,\n    offset: u32,\n    data: Vec<u8>,\n    name_account_key: Pubkey,\n    name_update_signer: Pubkey,\n    name_parent: Option<Pubkey>,\n) -> Result<Instruction, ProgramError> {\n    let instruction_data = NameRegistryInstruction::Update { offset, data };\n    let data = borsh::to_vec(&instruction_data).unwrap();\n    let mut accounts = vec![\n        AccountMeta::new(name_account_key, false),\n        AccountMeta::new_readonly(name_update_signer, true),\n    ];\n\n    if let Some(name_parent_key) = name_parent {\n        accounts.push(AccountMeta::new(name_parent_key, false))\n    }",
    "pub fn transfer(\n    name_service_program_id: Pubkey,\n    new_owner: Pubkey,\n    name_account_key: Pubkey,\n    name_owner_key: Pubkey,\n    name_class_opt: Option<Pubkey>,\n) -> Result<Instruction, ProgramError> {\n    let instruction_data = NameRegistryInstruction::Transfer { new_owner };\n    let data = borsh::to_vec(&instruction_data).unwrap();\n    let mut accounts = vec![\n        AccountMeta::new(name_account_key, false),\n        AccountMeta::new_readonly(name_owner_key, true),\n    ];\n\n    if let Some(key) = name_class_opt {\n        accounts.push(AccountMeta::new_readonly(key, true));\n    }\n\n    Ok(Instruction {\n        program_id: name_service_program_id,\n        accounts,\n        data,\n    })\n}",
    "pub fn delete(\n    name_service_program_id: Pubkey,\n    name_account_key: Pubkey,\n    name_owner_key: Pubkey,\n    refund_target: Pubkey,\n) -> Result<Instruction, ProgramError> {\n    let instruction_data = NameRegistryInstruction::Delete;\n    let data = borsh::to_vec(&instruction_data).unwrap();\n    let accounts = vec![\n        AccountMeta::new(name_account_key, false),\n        AccountMeta::new_readonly(name_owner_key, true),\n        AccountMeta::new(refund_target, false),\n    ];\n\n    Ok(Instruction {\n        program_id: name_service_program_id,\n        accounts,\n        data,\n    })\n}",
    "pub fn realloc(\n    name_service_program_id: Pubkey,\n    payer_key: Pubkey,\n    name_account_key: Pubkey,\n    name_owner_key: Pubkey,\n    space: u32,\n) -> Result<Instruction, ProgramError> {\n    let instruction_data = NameRegistryInstruction::Realloc { space };\n    let data = borsh::to_vec(&instruction_data).unwrap();\n    let accounts = vec![\n        AccountMeta::new_readonly(system_program::id(), false),\n        AccountMeta::new(payer_key, true),\n        AccountMeta::new(name_account_key, false),\n        AccountMeta::new_readonly(name_owner_key, true),\n    ];\n\n    Ok(Instruction {\n        program_id: name_service_program_id,\n        accounts,\n        data,\n    })\n}",
    "pub fn process_create(\n        program_id: &Pubkey,\n        accounts: &[AccountInfo],\n        hashed_name: Vec<u8>,\n        lamports: u64,\n        space: u32,\n    ) -> ProgramResult {\n        let accounts_iter = &mut accounts.iter();\n\n        let system_program = next_account_info(accounts_iter)?;\n        let payer_account = next_account_info(accounts_iter)?;\n        let name_account = next_account_info(accounts_iter)?;\n        let name_owner = next_account_info(accounts_iter)?;\n        let name_class = next_account_info(accounts_iter)?;\n        let parent_name_account = next_account_info(accounts_iter)?;\n        let parent_name_owner = next_account_info(accounts_iter).ok();\n\n        let (name_account_key, seeds) = get_seeds_and_key(\n            program_id,\n            hashed_name,\n            Some(name_class.key),\n            Some(parent_name_account.key),\n        );\n\n        // Verifications\n        if name_account_key != *name_account.key {\n            msg!(\"The given name account is incorrect.\");\n            return Err(ProgramError::InvalidArgument);\n        }\n        if name_account.data.borrow().len() > 0 {\n            let name_record_header =\n                NameRecordHeader::unpack_from_slice(&name_account.data.borrow())?;\n            if name_record_header.owner != Pubkey::default() {\n                msg!(\"The given name account already exists.\");\n                return Err(ProgramError::InvalidArgument);\n            }\n        }\n        if *name_class.key != Pubkey::default() && !name_class.is_signer {\n            msg!(\"The given name class is not a signer.\");\n            return Err(ProgramError::InvalidArgument);\n        }\n        if *parent_name_account.key != Pubkey::default() {\n            if !parent_name_owner.unwrap().is_signer {\n                msg!(\"The given parent name account owner is not a signer.\");\n                return Err(ProgramError::InvalidArgument);\n            } else {\n                let parent_name_record_header =\n                    NameRecordHeader::unpack_from_slice(&parent_name_account.data.borrow())?;\n                if &parent_name_record_header.owner != parent_name_owner.unwrap().key {\n                    msg!(\"The given parent name account owner is not correct.\");\n                    return Err(ProgramError::InvalidArgument);\n                }\n            }\n        }\n        if name_owner.key == &Pubkey::default() {\n            msg!(\"The owner cannot be `Pubkey::default()`.\");\n            return Err(ProgramError::InvalidArgument);\n        }\n\n        if name_account.data.borrow().len() == 0 {\n            // Issue the name registry account\n            // The creation is done in three steps: transfer, allocate and assign, because\n            // one cannot `system_instruction::create` an account to which lamports have\n            // been transferred before.\n            invoke(\n                &system_instruction::transfer(payer_account.key, &name_account_key, lamports),\n                &[\n                    payer_account.clone(),\n                    name_account.clone(),\n                    system_program.clone(),\n                ],\n            )?;\n\n            invoke_signed(\n                &system_instruction::allocate(\n                    &name_account_key,\n                    NameRecordHeader::LEN.saturating_add(space as usize) as u64,\n                ),\n                &[name_account.clone(), system_program.clone()],\n                &[&seeds.chunks(32).collect::<Vec<&[u8]>>()],\n            )?;\n\n            invoke_signed(\n                &system_instruction::assign(name_account.key, program_id),\n                &[name_account.clone(), system_program.clone()],\n                &[&seeds.chunks(32).collect::<Vec<&[u8]>>()],\n            )?;\n        }\n\n        let name_state = NameRecordHeader {\n            parent_name: *parent_name_account.key,\n            owner: *name_owner.key,\n            class: *name_class.key,\n        };\n\n        name_state.pack_into_slice(&mut name_account.data.borrow_mut());\n\n        Ok(())\n    }",
    "pub fn process_update(accounts: &[AccountInfo], offset: u32, data: Vec<u8>) -> ProgramResult {\n        let accounts_iter = &mut accounts.iter();\n\n        let name_account = next_account_info(accounts_iter)?;\n        let name_update_signer = next_account_info(accounts_iter)?;\n        let parent_name = next_account_info(accounts_iter).ok();\n\n        let name_record_header = NameRecordHeader::unpack_from_slice(&name_account.data.borrow())?;\n\n        // Verifications\n        let is_parent_owner = if let Some(parent_name) = parent_name {\n            if name_record_header.parent_name != *parent_name.key {\n                msg!(\"Invalid parent name account\");\n                return Err(ProgramError::InvalidArgument);\n            }\n            let parent_name_record_header =\n                NameRecordHeader::unpack_from_slice(&parent_name.data.borrow())?;\n            parent_name_record_header.owner == *name_update_signer.key\n        } else {\n            false\n        };\n        if !name_update_signer.is_signer {\n            msg!(\"The given name class or owner is not a signer.\");\n            return Err(ProgramError::InvalidArgument);\n        }\n        if name_record_header.class != Pubkey::default()\n            && *name_update_signer.key != name_record_header.class\n        {\n            msg!(\"The given name class account is incorrect.\");\n            return Err(ProgramError::InvalidArgument);\n        }\n        if name_record_header.class == Pubkey::default()\n            && *name_update_signer.key != name_record_header.owner\n            && !is_parent_owner\n        {\n            msg!(\"The given name owner account is incorrect.\");\n            return Err(ProgramError::InvalidArgument);\n        }\n\n        write_data(\n            name_account,\n            &data,\n            NameRecordHeader::LEN.saturating_add(offset as usize),\n        );\n\n        Ok(())\n    }",
    "pub fn process_transfer(accounts: &[AccountInfo], new_owner: Pubkey) -> ProgramResult {\n        let accounts_iter = &mut accounts.iter();\n\n        let name_account = next_account_info(accounts_iter)?;\n        let name_owner = next_account_info(accounts_iter)?;\n        let name_class_opt = next_account_info(accounts_iter).ok();\n        let parent_name = next_account_info(accounts_iter).ok();\n\n        let mut name_record_header =\n            NameRecordHeader::unpack_from_slice(&name_account.data.borrow())?;\n\n        // Verifications\n        let is_parent_owner = if let Some(parent_name) = parent_name {\n            if name_record_header.parent_name != *parent_name.key {\n                msg!(\"Invalid parent name account\");\n                return Err(ProgramError::InvalidArgument);\n            }\n            let parent_name_record_header =\n                NameRecordHeader::unpack_from_slice(&parent_name.data.borrow())?;\n            parent_name_record_header.owner == *name_owner.key\n        } else {\n            false\n        };\n        if !name_owner.is_signer\n            || (name_record_header.owner != *name_owner.key && !is_parent_owner)\n        {\n            msg!(\"The given name owner is incorrect or not a signer.\");\n            return Err(ProgramError::InvalidArgument);\n        }\n        if name_record_header.class != Pubkey::default()\n            && (name_class_opt.is_none()\n                || name_record_header.class != *name_class_opt.unwrap().key\n                || !name_class_opt.unwrap().is_signer)\n        {\n            msg!(\"The given name class account is incorrect or not a signer.\");\n            return Err(ProgramError::InvalidArgument);\n        }\n\n        name_record_header.owner = new_owner;\n        name_record_header\n            .pack_into_slice(&mut name_account.data.borrow_mut()[..NameRecordHeader::LEN]);\n\n        Ok(())\n    }",
    "pub fn process_delete(accounts: &[AccountInfo]) -> ProgramResult {\n        let accounts_iter = &mut accounts.iter();\n\n        let name_account = next_account_info(accounts_iter)?;\n        let name_owner = next_account_info(accounts_iter)?;\n        let refund_target = next_account_info(accounts_iter)?;\n\n        let name_record_header = NameRecordHeader::unpack_from_slice(&name_account.data.borrow())?;\n\n        // Verifications\n        if !name_owner.is_signer || name_record_header.owner != *name_owner.key {\n            msg!(\"The given name owner is incorrect or not a signer.\");\n            return Err(ProgramError::InvalidArgument);\n        }\n\n        // Overwrite the data with zeroes\n        write_data(name_account, &vec![0; name_account.data_len()], 0);\n\n        // Close the account by transferring the rent sol\n        let source_amount: &mut u64 = &mut name_account.lamports.borrow_mut();\n        let dest_amount: &mut u64 = &mut refund_target.lamports.borrow_mut();\n        *dest_amount = dest_amount.saturating_add(*source_amount);\n        *source_amount = 0;\n\n        Ok(())\n    }",
    "pub fn process_instruction(\n        program_id: &Pubkey,\n        accounts: &[AccountInfo],\n        instruction_data: &[u8],\n    ) -> ProgramResult {\n        msg!(\"Beginning processing\");\n        let instruction = NameRegistryInstruction::try_from_slice(instruction_data)\n            .map_err(|_| ProgramError::InvalidInstructionData)?;\n        msg!(\"Instruction unpacked\");\n\n        match instruction {\n            NameRegistryInstruction::Create {\n                hashed_name,\n                lamports,\n                space,\n            } => {\n                msg!(\"Instruction: Create\");\n                Processor::process_create(program_id, accounts, hashed_name, lamports, space)?;\n            }\n            NameRegistryInstruction::Update { offset, data } => {\n                msg!(\"Instruction: Update Data\");\n                Processor::process_update(accounts, offset, data)?;\n            }\n            NameRegistryInstruction::Transfer { new_owner } => {\n                msg!(\"Instruction: Transfer Ownership\");\n                Processor::process_transfer(accounts, new_owner)?;\n            }\n            NameRegistryInstruction::Delete => {\n                msg!(\"Instruction: Delete Name\");\n                Processor::process_delete(accounts)?;\n            }\n            NameRegistryInstruction::Realloc { space } => {\n                msg!(\"Instruction: Realloc Name Record\");\n                Processor::process_realloc(accounts, space)?;\n            }\n        }\n        Ok(())\n    }",
    "pub fn write_data(account: &AccountInfo, input: &[u8], offset: usize) {\n    let mut account_data = account.data.borrow_mut();\n    account_data[offset..offset.saturating_add(input.len())].copy_from_slice(input);\n}\n\n////////////////////////////////////////////////////////////\n\npub const HASH_PREFIX: &str = \"SPL Name Service\";\n\n////////////////////////////////////////////////////////////\n\npub fn get_seeds_and_key(\n    program_id: &Pubkey,\n    hashed_name: Vec<u8>, // Hashing is done off-chain\n    name_class_opt: Option<&Pubkey>,\n    parent_name_address_opt: Option<&Pubkey>,\n) -> (Pubkey, Vec<u8>) {\n    // let hashed_name: Vec<u8> = hashv(&[\n    //     (HASH_PREFIX.to_owned() + name).as_bytes()\n    // ]).0.to_vec();\n    let mut seeds_vec: Vec<u8> = hashed_name;\n\n    let name_class = name_class_opt.cloned().unwrap_or_default();\n\n    for b in name_class.to_bytes() {\n        seeds_vec.push(b);\n    }\n\n    let parent_name_address = parent_name_address_opt.cloned().unwrap_or_default();\n\n    for b in parent_name_address.to_bytes() {\n        seeds_vec.push(b);\n    }\n\n    let (name_account_key, bump) =\n        Pubkey::find_program_address(&seeds_vec.chunks(32).collect::<Vec<&[u8]>>(), program_id);\n    seeds_vec.push(bump);\n\n    (name_account_key, seeds_vec)\n}",
    "pub fn process(program_id: &Pubkey, accounts: &[AccountInfo], input: &[u8]) -> ProgramResult {\n        let instruction = StatelessOfferInstruction::try_from_slice(input)?;\n        match instruction {\n            StatelessOfferInstruction::AcceptOffer {\n                has_metadata,\n                maker_size,\n                taker_size,\n                bump_seed,\n            } => {\n                msg!(\"Instruction: accept offer\");\n                process_accept_offer(\n                    program_id,\n                    accounts,\n                    has_metadata,\n                    maker_size,\n                    taker_size,\n                    bump_seed,\n                )\n            }",
    "pub fn assert_is_ata(ata: &AccountInfo, wallet: &Pubkey, mint: &Pubkey) -> ProgramResult {\n    assert_owned_by(ata, &spl_token::id())?;\n    let ata_account: Account = assert_initialized(ata)?;\n    assert_keys_equal(ata_account.owner, *wallet)?;\n    assert_keys_equal(get_associated_token_address(wallet, mint), *ata.key)?;\n    Ok(())\n}",
    "pub fn assert_keys_equal(key1: Pubkey, key2: Pubkey) -> ProgramResult {\n    if key1 != key2 {\n        Err(UtilError::PublicKeyMismatch.into())\n    }",
    "pub fn assert_owned_by(account: &AccountInfo, owner: &Pubkey) -> ProgramResult {\n    if account.owner != owner {\n        Err(UtilError::IncorrectOwner.into())\n    }",
    "pub fn process_initialize_collection(\n    _program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    data: InitializeGroup,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n\n    let collection_info = next_account_info(account_info_iter)?;\n    let mint_info = next_account_info(account_info_iter)?;\n    let mint_authority_info = next_account_info(account_info_iter)?;\n\n    check_mint_and_metadata(mint_info, mint_authority_info)?;\n\n    // Initialize the collection\n    let mut buffer = collection_info.try_borrow_mut_data()?;\n    let mut state = TlvStateMut::unpack(&mut buffer)?;\n    let (collection, _) = state.init_value::<TokenGroup>(false)?;\n    *collection = TokenGroup::new(mint_info.key, data.update_authority, data.max_size.into());\n\n    Ok(())\n}",
    "pub fn process_initialize_collection_member(\n    _program_id: &Pubkey,\n    accounts: &[AccountInfo],\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n\n    let member_info = next_account_info(account_info_iter)?;\n    let mint_info = next_account_info(account_info_iter)?;\n    let mint_authority_info = next_account_info(account_info_iter)?;\n    let collection_info = next_account_info(account_info_iter)?;\n    let collection_update_authority_info = next_account_info(account_info_iter)?;\n\n    check_mint_and_metadata(mint_info, mint_authority_info)?;\n\n    if member_info.key == collection_info.key {\n        return Err(TokenGroupError::MemberAccountIsGroupAccount.into());\n    }\n\n    let mut buffer = collection_info.try_borrow_mut_data()?;\n    let mut state = TlvStateMut::unpack(&mut buffer)?;\n    let collection = state.get_first_value_mut::<TokenGroup>()?;\n\n    check_update_authority(\n        collection_update_authority_info,\n        &collection.update_authority,\n    )?;\n    let member_number = collection.increment_size()?;\n\n    let mut buffer = member_info.try_borrow_mut_data()?;\n    let mut state = TlvStateMut::unpack(&mut buffer)?;\n\n    // This program uses `allow_repetition: true` because the same mint can be\n    // a member of multiple collections.\n    let (member, _) = state.init_value::<TokenGroupMember>(/* allow_repetition */ true)?;\n    *member = TokenGroupMember::new(mint_info.key, collection_info.key, member_number);\n\n    Ok(())\n}",
    "pub fn process(program_id: &Pubkey, accounts: &[AccountInfo], input: &[u8]) -> ProgramResult {\n    let instruction = TokenGroupInstruction::unpack(input)?;\n    match instruction {\n        TokenGroupInstruction::InitializeGroup(data) => {\n            msg!(\"Instruction: InitializeCollection\");\n            process_initialize_collection(program_id, accounts, data)\n        }",
    "pub fn process_instruction(\n    _program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    input: &[u8],\n) -> ProgramResult {\n    msg!(\"Flash Loan Receiver invoked.\");\n    let account_info_iter = &mut accounts.iter();\n    let destination_liq_info = next_account_info(account_info_iter)?;\n    let source_liq_info = next_account_info(account_info_iter)?;\n    let spl_token_program_info = next_account_info(account_info_iter)?;\n    let user_transfer_authority_info = next_account_info(account_info_iter)?;\n\n    let (tag, rest) = input\n        .split_first()\n        .ok_or(ProgramError::InvalidInstructionData)?;\n\n    if *tag != 0 {\n        msg!(\n            \"Expecting the 0th instruction to be called. Instead {}th was called.\",\n            tag\n        );\n        return Err(ProgramError::InvalidInstructionData);\n    }\n\n    let amount = unpack_amount(rest)?;\n\n    invoke(\n        &spl_token::instruction::transfer(\n            spl_token_program_info.key,\n            destination_liq_info.key,\n            source_liq_info.key,\n            user_transfer_authority_info.key,\n            &[],\n            amount,\n        )?,\n        &[\n            source_liq_info.clone(),\n            destination_liq_info.clone(),\n            user_transfer_authority_info.clone(),\n            spl_token_program_info.clone(),\n        ],\n    )?;\n    Ok(())\n}",
    "pub fn unpack(input: &[u8]) -> Result<Self, ProgramError> {\n        let (&tag, rest) = input\n            .split_first()\n            .ok_or(LendingError::InstructionUnpackError)?;\n        Ok(match tag {\n            0 => {\n                let (owner, rest) = Self::unpack_pubkey(rest)?;\n                let (quote_currency, _rest) = Self::unpack_bytes32(rest)?;\n                Self::InitLendingMarket {\n                    owner,\n                    quote_currency: *quote_currency,\n                }\n            }\n            1 => {\n                let (new_owner, _rest) = Self::unpack_pubkey(rest)?;\n                Self::SetLendingMarketOwner { new_owner }\n            }\n            2 => {\n                let (liquidity_amount, rest) = Self::unpack_u64(rest)?;\n                let config = Self::unpack_reserve_config(rest)?;\n                Self::InitReserve {\n                    liquidity_amount,\n                    config,\n                }\n            }\n            3 => Self::RefreshReserve,\n            4 => {\n                let (liquidity_amount, _rest) = Self::unpack_u64(rest)?;\n                Self::DepositReserveLiquidity { liquidity_amount }\n            }\n            5 => {\n                let (collateral_amount, _rest) = Self::unpack_u64(rest)?;\n                Self::RedeemReserveCollateral { collateral_amount }\n            }\n            6 => Self::InitObligation,\n            7 => Self::RefreshObligation,\n            8 => {\n                let (collateral_amount, _rest) = Self::unpack_u64(rest)?;\n                Self::DepositObligationCollateral { collateral_amount }\n            }\n            9 => {\n                let (collateral_amount, _rest) = Self::unpack_u64(rest)?;\n                Self::WithdrawObligationCollateral { collateral_amount }\n            }\n            10 => {\n                let (liquidity_amount, rest) = Self::unpack_u64(rest)?;\n                let (slippage_limit, _rest) = Self::unpack_u64(rest).unwrap_or((0, &[]));\n                Self::BorrowObligationLiquidity {\n                    liquidity_amount,\n                    slippage_limit,\n                }\n            }\n            11 => {\n                let (liquidity_amount, _rest) = Self::unpack_u64(rest)?;\n                Self::RepayObligationLiquidity { liquidity_amount }\n            }\n            12 => {\n                let (liquidity_amount, _rest) = Self::unpack_u64(rest)?;\n                Self::LiquidateObligation { liquidity_amount }\n            }\n            13 => {\n                let (amount, _rest) = Self::unpack_u64(rest)?;\n                Self::FlashLoan { amount }\n            }\n            14 => {\n                let new_config = Self::unpack_reserve_config(rest)?;\n                Self::ModifyReserveConfig { new_config }\n            }\n            _ => {\n                msg!(\"Instruction cannot be unpacked\");\n                return Err(LendingError::InstructionUnpackError.into());\n            }\n        })\n    }",
    "pub fn process_instruction(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    input: &[u8],\n) -> ProgramResult {\n    let instruction = LendingInstruction::unpack(input)?;\n    match instruction {\n        LendingInstruction::InitLendingMarket {\n            owner,\n            quote_currency,\n        } => {\n            msg!(\"Instruction: Init Lending Market\");\n            process_init_lending_market(program_id, owner, quote_currency, accounts)\n        }",
    "pub fn one() -> Self {\n        Self(Self::wad())\n    }",
    "pub fn zero() -> Self {\n        Self(U192::zero())\n    }",
    "pub fn from_percent(percent: u8) -> Self {\n        Self(U192::from(percent as u64 * PERCENT_SCALER))\n    }",
    "pub fn to_scaled_val(&self) -> Result<u128, ProgramError> {\n        Ok(u128::try_from(self.0).map_err(|_| LendingError::MathOverflow)?)\n    }",
    "pub fn from_scaled_val(scaled_val: u128) -> Self {\n        Self(U192::from(scaled_val))\n    }",
    "pub fn try_round_u64(&self) -> Result<u64, ProgramError> {\n        let rounded_val = Self::half_wad()\n            .checked_add(self.0)\n            .ok_or(LendingError::MathOverflow)?\n            .checked_div(Self::wad())\n            .ok_or(LendingError::MathOverflow)?;\n        Ok(u64::try_from(rounded_val).map_err(|_| LendingError::MathOverflow)?)\n    }",
    "pub fn try_ceil_u64(&self) -> Result<u64, ProgramError> {\n        let ceil_val = Self::wad()\n            .checked_sub(U192::from(1u64))\n            .ok_or(LendingError::MathOverflow)?\n            .checked_add(self.0)\n            .ok_or(LendingError::MathOverflow)?\n            .checked_div(Self::wad())\n            .ok_or(LendingError::MathOverflow)?;\n        Ok(u64::try_from(ceil_val).map_err(|_| LendingError::MathOverflow)?)\n    }",
    "pub fn try_floor_u64(&self) -> Result<u64, ProgramError> {\n        let ceil_val = self\n            .0\n            .checked_div(Self::wad())\n            .ok_or(LendingError::MathOverflow)?;\n        Ok(u64::try_from(ceil_val).map_err(|_| LendingError::MathOverflow)?)\n    }",
    "pub fn one() -> Self {\n        Self(Self::wad())\n    }",
    "pub fn zero() -> Self {\n        Self(U128::from(0))\n    }",
    "pub fn from_percent(percent: u8) -> Self {\n        Self(U128::from(percent as u64 * PERCENT_SCALER))\n    }",
    "pub fn to_scaled_val(&self) -> u128 {\n        self.0.as_u128()\n    }",
    "pub fn from_scaled_val(scaled_val: u64) -> Self {\n        Self(U128::from(scaled_val))\n    }",
    "pub fn try_pow(&self, mut exp: u64) -> Result<Rate, ProgramError> {\n        let mut base = *self;\n        let mut ret = if exp % 2 != 0 {\n            base\n        } else {\n            Rate(Self::wad())\n        }",
    "pub fn new(slot: Slot) -> Self {\n        Self { slot, stale: true }\n    }\n\n    /// Return slots elapsed since given slot\n    pub fn slots_elapsed(&self, slot: Slot) -> Result<u64, ProgramError> {\n        let slots_elapsed = slot\n            .checked_sub(self.slot)\n            .ok_or(LendingError::MathOverflow)?;\n        Ok(slots_elapsed)\n    }",
    "pub fn update_slot(&mut self, slot: Slot) {\n        self.slot = slot;\n        self.stale = false;\n    }\n\n    /// Set stale to true\n    pub fn mark_stale(&mut self) {\n        self.stale = true;\n    }\n\n    /// Check if marked stale or last update slot is too long ago\n    pub fn is_stale(&self, slot: Slot) -> Result<bool, ProgramError> {\n        Ok(self.stale || self.slots_elapsed(slot)? >= STALE_AFTER_SLOTS_ELAPSED)\n    }",
    "pub fn new(params: InitLendingMarketParams) -> Self {\n        let mut lending_market = Self::default();\n        Self::init(&mut lending_market, params);\n        lending_market\n    }\n\n    /// Initialize a lending market\n    pub fn init(&mut self, params: InitLendingMarketParams) {\n        self.version = PROGRAM_VERSION;\n        self.bump_seed = params.bump_seed;\n        self.owner = params.owner;\n        self.quote_currency = params.quote_currency;\n        self.token_program_id = params.token_program_id;\n        self.oracle_program_id = params.oracle_program_id;\n    }\n}\n\n/// Initialize a lending market\npub struct InitLendingMarketParams {\n    /// Bump seed for derived authority address\n    pub bump_seed: u8,\n    /// Owner authority which can add new reserves\n    pub owner: Pubkey,\n    /// Currency market prices are quoted in\n    /// e.g. \"USD\" null padded\n    /// (`*b\"USD\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\"`) or\n    /// a SPL token mint pubkey\n    pub quote_currency: [u8; 32],\n    /// Token program id\n    pub token_program_id: Pubkey,\n    /// Oracle (Pyth) program id\n    pub oracle_program_id: Pubkey,\n}\n\nimpl Sealed for LendingMarket {}\nimpl IsInitialized for LendingMarket {\n    fn is_initialized(&self) -> bool {\n        self.version != UNINITIALIZED_VERSION\n    }\n}\n\nconst LENDING_MARKET_LEN: usize = 258; // 1 + 1 + 32 + 32 + 32 + 32 + 128\nimpl Pack for LendingMarket {\n    const LEN: usize = LENDING_MARKET_LEN;\n\n    fn pack_into_slice(&self, output: &mut [u8]) {\n        let output = array_mut_ref![output, 0, LENDING_MARKET_LEN];\n        #[allow(clippy::ptr_offset_with_cast)]\n        let (\n            version,\n            bump_seed,\n            owner,\n            quote_currency,\n            token_program_id,\n            oracle_program_id,\n            _padding,\n        ) = mut_array_refs![\n            output,\n            1,\n            1,\n            PUBKEY_BYTES,\n            32,\n            PUBKEY_BYTES,\n            PUBKEY_BYTES,\n            128\n        ];\n\n        *version = self.version.to_le_bytes();\n        *bump_seed = self.bump_seed.to_le_bytes();\n        owner.copy_from_slice(self.owner.as_ref());\n        quote_currency.copy_from_slice(self.quote_currency.as_ref());\n        token_program_id.copy_from_slice(self.token_program_id.as_ref());\n        oracle_program_id.copy_from_slice(self.oracle_program_id.as_ref());\n    }\n\n    /// Unpacks a byte buffer into a\n    /// [LendingMarketInfo](struct.LendingMarketInfo.html)\n    fn unpack_from_slice(input: &[u8]) -> Result<Self, ProgramError> {\n        let input = array_ref![input, 0, LENDING_MARKET_LEN];\n        #[allow(clippy::ptr_offset_with_cast)]\n        let (\n            version,\n            bump_seed,\n            owner,\n            quote_currency,\n            token_program_id,\n            oracle_program_id,\n            _padding,\n        ) = array_refs![\n            input,\n            1,\n            1,\n            PUBKEY_BYTES,\n            32,\n            PUBKEY_BYTES,\n            PUBKEY_BYTES,\n            128\n        ];\n\n        let version = u8::from_le_bytes(*version);\n        if version > PROGRAM_VERSION {\n            msg!(\"Lending market version does not match lending program version\");\n            return Err(ProgramError::InvalidAccountData);\n        }\n\n        Ok(Self {\n            version,\n            bump_seed: u8::from_le_bytes(*bump_seed),\n            owner: Pubkey::new_from_array(*owner),\n            quote_currency: *quote_currency,\n            token_program_id: Pubkey::new_from_array(*token_program_id),\n            oracle_program_id: Pubkey::new_from_array(*oracle_program_id),\n        })\n    }",
    "pub fn new(params: InitObligationParams) -> Self {\n        let mut obligation = Self::default();\n        Self::init(&mut obligation, params);\n        obligation\n    }\n\n    /// Initialize an obligation\n    pub fn init(&mut self, params: InitObligationParams) {\n        self.version = PROGRAM_VERSION;\n        self.last_update = LastUpdate::new(params.current_slot);\n        self.lending_market = params.lending_market;\n        self.owner = params.owner;\n        self.deposits = params.deposits;\n        self.borrows = params.borrows;\n    }\n\n    /// Calculate the current ratio of borrowed value to deposited value\n    pub fn loan_to_value(&self) -> Result<Decimal, ProgramError> {\n        self.borrowed_value.try_div(self.deposited_value)\n    }",
    "pub fn repay(&mut self, settle_amount: Decimal, liquidity_index: usize) -> ProgramResult {\n        let liquidity = &mut self.borrows[liquidity_index];\n        if settle_amount == liquidity.borrowed_amount_wads {\n            self.borrows.remove(liquidity_index);\n        } else {\n            liquidity.repay(settle_amount)?;\n        }\n        Ok(())\n    }",
    "pub fn withdraw(&mut self, withdraw_amount: u64, collateral_index: usize) -> ProgramResult {\n        let collateral = &mut self.deposits[collateral_index];\n        if withdraw_amount == collateral.deposited_amount {\n            self.deposits.remove(collateral_index);\n        } else {\n            collateral.withdraw(withdraw_amount)?;\n        }\n        Ok(())\n    }",
    "pub fn max_withdraw_value(\n        &self,\n        withdraw_collateral_ltv: Rate,\n    ) -> Result<Decimal, ProgramError> {\n        if self.allowed_borrow_value <= self.borrowed_value {\n            return Ok(Decimal::zero());\n        }\n        if withdraw_collateral_ltv == Rate::zero() {\n            return Ok(self.deposited_value);\n        }\n        self.allowed_borrow_value\n            .try_sub(self.borrowed_value)?\n            .try_div(withdraw_collateral_ltv)\n    }",
    "pub fn remaining_borrow_value(&self) -> Result<Decimal, ProgramError> {\n        self.allowed_borrow_value.try_sub(self.borrowed_value)\n    }",
    "pub fn max_liquidation_amount(\n        &self,\n        liquidity: &ObligationLiquidity,\n    ) -> Result<Decimal, ProgramError> {\n        let max_liquidation_value = self\n            .borrowed_value\n            .try_mul(Rate::from_percent(LIQUIDATION_CLOSE_FACTOR))?\n            .min(liquidity.market_value);\n        let max_liquidation_pct = max_liquidation_value.try_div(liquidity.market_value)?;\n        liquidity.borrowed_amount_wads.try_mul(max_liquidation_pct)\n    }",
    "pub fn find_collateral_in_deposits(\n        &self,\n        deposit_reserve: Pubkey,\n    ) -> Result<(&ObligationCollateral, usize), ProgramError> {\n        if self.deposits.is_empty() {\n            msg!(\"Obligation has no deposits\");\n            return Err(LendingError::ObligationDepositsEmpty.into());\n        }\n        let collateral_index = self\n            ._find_collateral_index_in_deposits(deposit_reserve)\n            .ok_or(LendingError::InvalidObligationCollateral)?;\n        Ok((&self.deposits[collateral_index], collateral_index))\n    }",
    "pub fn find_or_add_collateral_to_deposits(\n        &mut self,\n        deposit_reserve: Pubkey,\n    ) -> Result<&mut ObligationCollateral, ProgramError> {\n        if let Some(collateral_index) = self._find_collateral_index_in_deposits(deposit_reserve) {\n            return Ok(&mut self.deposits[collateral_index]);\n        }\n        if self.deposits.len() + self.borrows.len() >= MAX_OBLIGATION_RESERVES {\n            msg!(\n                \"Obligation cannot have more than {} deposits and borrows combined\",\n                MAX_OBLIGATION_RESERVES\n            );\n            return Err(LendingError::ObligationReserveLimit.into());\n        }\n        let collateral = ObligationCollateral::new(deposit_reserve);\n        self.deposits.push(collateral);\n        Ok(self.deposits.last_mut().unwrap())\n    }",
    "pub fn find_liquidity_in_borrows(\n        &self,\n        borrow_reserve: Pubkey,\n    ) -> Result<(&ObligationLiquidity, usize), ProgramError> {\n        if self.borrows.is_empty() {\n            msg!(\"Obligation has no borrows\");\n            return Err(LendingError::ObligationBorrowsEmpty.into());\n        }\n        let liquidity_index = self\n            ._find_liquidity_index_in_borrows(borrow_reserve)\n            .ok_or(LendingError::InvalidObligationLiquidity)?;\n        Ok((&self.borrows[liquidity_index], liquidity_index))\n    }",
    "pub fn find_or_add_liquidity_to_borrows(\n        &mut self,\n        borrow_reserve: Pubkey,\n    ) -> Result<&mut ObligationLiquidity, ProgramError> {\n        if let Some(liquidity_index) = self._find_liquidity_index_in_borrows(borrow_reserve) {\n            return Ok(&mut self.borrows[liquidity_index]);\n        }\n        if self.deposits.len() + self.borrows.len() >= MAX_OBLIGATION_RESERVES {\n            msg!(\n                \"Obligation cannot have more than {} deposits and borrows combined\",\n                MAX_OBLIGATION_RESERVES\n            );\n            return Err(LendingError::ObligationReserveLimit.into());\n        }\n        let liquidity = ObligationLiquidity::new(borrow_reserve);\n        self.borrows.push(liquidity);\n        Ok(self.borrows.last_mut().unwrap())\n    }",
    "pub fn new(deposit_reserve: Pubkey) -> Self {\n        Self {\n            deposit_reserve,\n            deposited_amount: 0,\n            market_value: Decimal::zero(),\n        }\n    }\n\n    /// Increase deposited collateral\n    pub fn deposit(&mut self, collateral_amount: u64) -> ProgramResult {\n        self.deposited_amount = self\n            .deposited_amount\n            .checked_add(collateral_amount)\n            .ok_or(LendingError::MathOverflow)?;\n        Ok(())\n    }",
    "pub fn withdraw(&mut self, collateral_amount: u64) -> ProgramResult {\n        self.deposited_amount = self\n            .deposited_amount\n            .checked_sub(collateral_amount)\n            .ok_or(LendingError::MathOverflow)?;\n        Ok(())\n    }",
    "pub fn new(borrow_reserve: Pubkey) -> Self {\n        Self {\n            borrow_reserve,\n            cumulative_borrow_rate_wads: Decimal::one(),\n            borrowed_amount_wads: Decimal::zero(),\n            market_value: Decimal::zero(),\n        }\n    }\n\n    /// Decrease borrowed liquidity\n    pub fn repay(&mut self, settle_amount: Decimal) -> ProgramResult {\n        self.borrowed_amount_wads = self.borrowed_amount_wads.try_sub(settle_amount)?;\n        Ok(())\n    }",
    "pub fn borrow(&mut self, borrow_amount: Decimal) -> ProgramResult {\n        self.borrowed_amount_wads = self.borrowed_amount_wads.try_add(borrow_amount)?;\n        Ok(())\n    }",
    "pub fn accrue_interest(&mut self, cumulative_borrow_rate_wads: Decimal) -> ProgramResult {\n        match cumulative_borrow_rate_wads.cmp(&self.cumulative_borrow_rate_wads) {\n            Ordering::Less => {\n                msg!(\"Interest rate cannot be negative\");\n                return Err(LendingError::NegativeInterestRate.into());\n            }\n            Ordering::Equal => {}\n            Ordering::Greater => {\n                let compounded_interest_rate: Rate = cumulative_borrow_rate_wads\n                    .try_div(self.cumulative_borrow_rate_wads)?\n                    .try_into()?;\n\n                self.borrowed_amount_wads = self\n                    .borrowed_amount_wads\n                    .try_mul(compounded_interest_rate)?;\n                self.cumulative_borrow_rate_wads = cumulative_borrow_rate_wads;\n            }\n        }\n\n        Ok(())\n    }",
    "pub fn new(params: InitReserveParams) -> Self {\n        let mut reserve = Self::default();\n        Self::init(&mut reserve, params);\n        reserve\n    }\n\n    /// Initialize a reserve\n    pub fn init(&mut self, params: InitReserveParams) {\n        self.version = PROGRAM_VERSION;\n        self.last_update = LastUpdate::new(params.current_slot);\n        self.lending_market = params.lending_market;\n        self.liquidity = params.liquidity;\n        self.collateral = params.collateral;\n        self.config = params.config;\n    }\n\n    /// Record deposited liquidity and return amount of collateral tokens to\n    /// mint\n    pub fn deposit_liquidity(&mut self, liquidity_amount: u64) -> Result<u64, ProgramError> {\n        let collateral_amount = self\n            .collateral_exchange_rate()?\n            .liquidity_to_collateral(liquidity_amount)?;\n\n        self.liquidity.deposit(liquidity_amount)?;\n        self.collateral.mint(collateral_amount)?;\n\n        Ok(collateral_amount)\n    }",
    "pub fn redeem_collateral(&mut self, collateral_amount: u64) -> Result<u64, ProgramError> {\n        let collateral_exchange_rate = self.collateral_exchange_rate()?;\n        let liquidity_amount =\n            collateral_exchange_rate.collateral_to_liquidity(collateral_amount)?;\n\n        self.collateral.burn(collateral_amount)?;\n        self.liquidity.withdraw(liquidity_amount)?;\n\n        Ok(liquidity_amount)\n    }",
    "pub fn current_borrow_rate(&self) -> Result<Rate, ProgramError> {\n        let utilization_rate = self.liquidity.utilization_rate()?;\n        let optimal_utilization_rate = Rate::from_percent(self.config.optimal_utilization_rate);\n        let low_utilization = utilization_rate < optimal_utilization_rate;\n        if low_utilization || self.config.optimal_utilization_rate == 100 {\n            let normalized_rate = utilization_rate.try_div(optimal_utilization_rate)?;\n            let min_rate = Rate::from_percent(self.config.min_borrow_rate);\n            let rate_range = Rate::from_percent(\n                self.config\n                    .optimal_borrow_rate\n                    .checked_sub(self.config.min_borrow_rate)\n                    .ok_or(LendingError::MathOverflow)?,\n            );\n\n            Ok(normalized_rate.try_mul(rate_range)?.try_add(min_rate)?)\n        }",
    "pub fn collateral_exchange_rate(&self) -> Result<CollateralExchangeRate, ProgramError> {\n        let total_liquidity = self.liquidity.total_supply()?;\n        self.collateral.exchange_rate(total_liquidity)\n    }",
    "pub fn accrue_interest(&mut self, current_slot: Slot) -> ProgramResult {\n        let slots_elapsed = self.last_update.slots_elapsed(current_slot)?;\n        if slots_elapsed > 0 {\n            let current_borrow_rate = self.current_borrow_rate()?;\n            self.liquidity\n                .compound_interest(current_borrow_rate, slots_elapsed)?;\n        }\n        Ok(())\n    }",
    "pub fn calculate_borrow(\n        &self,\n        amount_to_borrow: u64,\n        max_borrow_value: Decimal,\n    ) -> Result<CalculateBorrowResult, ProgramError> {\n        // @TODO: add lookup table https://git.io/JOCYq\n        let decimals = 10u64\n            .checked_pow(self.liquidity.mint_decimals as u32)\n            .ok_or(LendingError::MathOverflow)?;\n        if amount_to_borrow == u64::MAX {\n            let borrow_amount = max_borrow_value\n                .try_mul(decimals)?\n                .try_div(self.liquidity.market_price)?\n                .min(self.liquidity.available_amount.into());\n            let (borrow_fee, host_fee) = self\n                .config\n                .fees\n                .calculate_borrow_fees(borrow_amount, FeeCalculation::Inclusive)?;\n            let receive_amount = borrow_amount\n                .try_floor_u64()?\n                .checked_sub(borrow_fee)\n                .ok_or(LendingError::MathOverflow)?;\n\n            Ok(CalculateBorrowResult {\n                borrow_amount,\n                receive_amount,\n                borrow_fee,\n                host_fee,\n            })\n        }",
    "pub fn calculate_repay(\n        &self,\n        amount_to_repay: u64,\n        borrowed_amount: Decimal,\n    ) -> Result<CalculateRepayResult, ProgramError> {\n        let settle_amount = if amount_to_repay == u64::MAX {\n            borrowed_amount\n        } else {\n            Decimal::from(amount_to_repay).min(borrowed_amount)\n        }",
    "pub fn calculate_liquidation(\n        &self,\n        amount_to_liquidate: u64,\n        obligation: &Obligation,\n        liquidity: &ObligationLiquidity,\n        collateral: &ObligationCollateral,\n    ) -> Result<CalculateLiquidationResult, ProgramError> {\n        let bonus_rate = Rate::from_percent(self.config.liquidation_bonus).try_add(Rate::one())?;\n\n        let max_amount = if amount_to_liquidate == u64::MAX {\n            liquidity.borrowed_amount_wads\n        } else {\n            Decimal::from(amount_to_liquidate).min(liquidity.borrowed_amount_wads)\n        }",
    "pub fn new(params: NewReserveLiquidityParams) -> Self {\n        Self {\n            mint_pubkey: params.mint_pubkey,\n            mint_decimals: params.mint_decimals,\n            supply_pubkey: params.supply_pubkey,\n            fee_receiver: params.fee_receiver,\n            oracle_pubkey: params.oracle_pubkey,\n            available_amount: 0,\n            borrowed_amount_wads: Decimal::zero(),\n            cumulative_borrow_rate_wads: Decimal::one(),\n            market_price: params.market_price,\n        }\n    }\n\n    /// Calculate the total reserve supply including active loans\n    pub fn total_supply(&self) -> Result<Decimal, ProgramError> {\n        Decimal::from(self.available_amount).try_add(self.borrowed_amount_wads)\n    }",
    "pub fn deposit(&mut self, liquidity_amount: u64) -> ProgramResult {\n        self.available_amount = self\n            .available_amount\n            .checked_add(liquidity_amount)\n            .ok_or(LendingError::MathOverflow)?;\n        Ok(())\n    }",
    "pub fn withdraw(&mut self, liquidity_amount: u64) -> ProgramResult {\n        if liquidity_amount > self.available_amount {\n            msg!(\"Withdraw amount cannot exceed available amount\");\n            return Err(LendingError::InsufficientLiquidity.into());\n        }\n        self.available_amount = self\n            .available_amount\n            .checked_sub(liquidity_amount)\n            .ok_or(LendingError::MathOverflow)?;\n        Ok(())\n    }",
    "pub fn borrow(&mut self, borrow_decimal: Decimal) -> ProgramResult {\n        let borrow_amount = borrow_decimal.try_floor_u64()?;\n        if borrow_amount > self.available_amount {\n            msg!(\"Borrow amount cannot exceed available amount\");\n            return Err(LendingError::InsufficientLiquidity.into());\n        }\n\n        self.available_amount = self\n            .available_amount\n            .checked_sub(borrow_amount)\n            .ok_or(LendingError::MathOverflow)?;\n        self.borrowed_amount_wads = self.borrowed_amount_wads.try_add(borrow_decimal)?;\n\n        Ok(())\n    }",
    "pub fn repay(&mut self, repay_amount: u64, settle_amount: Decimal) -> ProgramResult {\n        self.available_amount = self\n            .available_amount\n            .checked_add(repay_amount)\n            .ok_or(LendingError::MathOverflow)?;\n        self.borrowed_amount_wads = self.borrowed_amount_wads.try_sub(settle_amount)?;\n\n        Ok(())\n    }",
    "pub fn utilization_rate(&self) -> Result<Rate, ProgramError> {\n        let total_supply = self.total_supply()?;\n        if total_supply == Decimal::zero() {\n            return Ok(Rate::zero());\n        }\n        self.borrowed_amount_wads.try_div(total_supply)?.try_into()\n    }",
    "pub fn new(params: NewReserveCollateralParams) -> Self {\n        Self {\n            mint_pubkey: params.mint_pubkey,\n            mint_total_supply: 0,\n            supply_pubkey: params.supply_pubkey,\n        }\n    }\n\n    /// Add collateral to total supply\n    pub fn mint(&mut self, collateral_amount: u64) -> ProgramResult {\n        self.mint_total_supply = self\n            .mint_total_supply\n            .checked_add(collateral_amount)\n            .ok_or(LendingError::MathOverflow)?;\n        Ok(())\n    }",
    "pub fn burn(&mut self, collateral_amount: u64) -> ProgramResult {\n        self.mint_total_supply = self\n            .mint_total_supply\n            .checked_sub(collateral_amount)\n            .ok_or(LendingError::MathOverflow)?;\n        Ok(())\n    }",
    "pub fn collateral_to_liquidity(&self, collateral_amount: u64) -> Result<u64, ProgramError> {\n        self.decimal_collateral_to_liquidity(collateral_amount.into())?\n            .try_floor_u64()\n    }",
    "pub fn decimal_collateral_to_liquidity(\n        &self,\n        collateral_amount: Decimal,\n    ) -> Result<Decimal, ProgramError> {\n        collateral_amount.try_div(self.0)\n    }",
    "pub fn liquidity_to_collateral(&self, liquidity_amount: u64) -> Result<u64, ProgramError> {\n        self.decimal_liquidity_to_collateral(liquidity_amount.into())?\n            .try_floor_u64()\n    }",
    "pub fn decimal_liquidity_to_collateral(\n        &self,\n        liquidity_amount: Decimal,\n    ) -> Result<Decimal, ProgramError> {\n        liquidity_amount.try_mul(self.0)\n    }",
    "pub fn validate(&self) -> ProgramResult {\n        if self.optimal_utilization_rate > 100 {\n            msg!(\"Optimal utilization rate must be in range [0, 100]\");\n            return Err(LendingError::InvalidConfig.into());\n        }\n        if self.loan_to_value_ratio >= 100 {\n            msg!(\"Loan to value ratio must be in range [0, 100)\");\n            return Err(LendingError::InvalidConfig.into());\n        }\n        if self.liquidation_bonus > 100 {\n            msg!(\"Liquidation bonus must be in range [0, 100]\");\n            return Err(LendingError::InvalidConfig.into());\n        }\n        if self.liquidation_threshold <= self.loan_to_value_ratio\n            || self.liquidation_threshold > 100\n        {\n            msg!(\"Liquidation threshold must be in range (LTV, 100]\");\n            return Err(LendingError::InvalidConfig.into());\n        }\n        if self.optimal_borrow_rate < self.min_borrow_rate {\n            msg!(\"Optimal borrow rate must be >= min borrow rate\");\n            return Err(LendingError::InvalidConfig.into());\n        }\n        if self.optimal_borrow_rate > self.max_borrow_rate {\n            msg!(\"Optimal borrow rate must be <= max borrow rate\");\n            return Err(LendingError::InvalidConfig.into());\n        }\n        if self.fees.borrow_fee_wad >= WAD {\n            msg!(\"Borrow fee must be in range [0, 1_000_000_000_000_000_000)\");\n            return Err(LendingError::InvalidConfig.into());\n        }\n        if self.fees.flash_loan_fee_wad >= WAD {\n            msg!(\"Flash loan fee must be in range [0, 1_000_000_000_000_000_000)\");\n            return Err(LendingError::InvalidConfig.into());\n        }\n        if self.fees.host_fee_percentage > 100 {\n            msg!(\"Host fee percentage must be in range [0, 100]\");\n            return Err(LendingError::InvalidConfig.into());\n        }\n\n        Ok(())\n    }",
    "pub fn calculate_borrow_fees(\n        &self,\n        borrow_amount: Decimal,\n        fee_calculation: FeeCalculation,\n    ) -> Result<(u64, u64), ProgramError> {\n        self.calculate_fees(borrow_amount, self.borrow_fee_wad, fee_calculation)\n    }",
    "pub fn calculate_flash_loan_fees(\n        &self,\n        flash_loan_amount: Decimal,\n    ) -> Result<(u64, u64), ProgramError> {\n        self.calculate_fees(\n            flash_loan_amount,\n            self.flash_loan_fee_wad,\n            FeeCalculation::Exclusive,\n        )\n    }",
    "pub fn process_instruction(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    instruction_data: &[u8],\n) -> ProgramResult {\n    Processor::process(program_id, accounts, instruction_data)\n}",
    "pub fn process(\n        program_id: &Pubkey,\n        accounts: &[AccountInfo],\n        instruction_data: &[u8],\n    ) -> ProgramResult {\n        let instruction = FlashLoanReceiverInstruction::unpack(instruction_data)?;\n\n        match instruction {\n            FlashLoanReceiverInstruction::ReceiveFlashLoan { amount } => {\n                msg!(\"Instruction: Receive Flash Loan\");\n                Self::process_receive_flash_loan(accounts, amount, program_id)\n            }",
    "pub fn unpack(input: &[u8]) -> Result<Self, ProgramError> {\n        let (tag, rest) = input.split_first().ok_or(InvalidInstruction)?;\n\n        Ok(match tag {\n            0 => Self::ReceiveFlashLoan {\n                amount: Self::unpack_amount(rest)?,\n            },\n            _ => return Err(InvalidInstruction.into()),\n        })\n    }",
    "pub fn add_lending_market(test: &mut ProgramTest) -> TestLendingMarket {\n    let lending_market_pubkey = Pubkey::new_unique();\n    let (lending_market_authority, bump_seed) =\n        Pubkey::find_program_address(&[lending_market_pubkey.as_ref()], &spl_token_lending::id());\n\n    let lending_market_owner =\n        read_keypair_file(\"tests/fixtures/lending_market_owner.json\").unwrap();\n    let oracle_program_id = read_keypair_file(\"tests/fixtures/oracle_program_id.json\")\n        .unwrap()\n        .pubkey();\n\n    test.add_packable_account(\n        lending_market_pubkey,\n        u32::MAX as u64,\n        &LendingMarket::new(InitLendingMarketParams {\n            bump_seed,\n            owner: lending_market_owner.pubkey(),\n            quote_currency: QUOTE_CURRENCY,\n            token_program_id: spl_token::id(),\n            oracle_program_id,\n        }),\n        &spl_token_lending::id(),\n    );\n\n    TestLendingMarket {\n        pubkey: lending_market_pubkey,\n        owner: lending_market_owner,\n        authority: lending_market_authority,\n        quote_currency: QUOTE_CURRENCY,\n        oracle_program_id,\n    }\n}\n\n#[derive(Default)]\npub struct AddObligationArgs<'a> {\n    pub deposits: &'a [(&'a TestReserve, u64)],\n    pub borrows: &'a [(&'a TestReserve, u64)],\n    pub mark_fresh: bool,\n    pub slots_elapsed: u64,\n}\n\npub fn add_obligation(\n    test: &mut ProgramTest,\n    lending_market: &TestLendingMarket,\n    user_accounts_owner: &Keypair,\n    args: AddObligationArgs,\n) -> TestObligation {\n    let AddObligationArgs {\n        deposits,\n        borrows,\n        mark_fresh,\n        slots_elapsed,\n    } = args;\n\n    let obligation_keypair = Keypair::new();\n    let obligation_pubkey = obligation_keypair.pubkey();\n\n    let (obligation_deposits, test_deposits) = deposits\n        .iter()\n        .map(|(deposit_reserve, collateral_amount)| {\n            let mut collateral = ObligationCollateral::new(deposit_reserve.pubkey);\n            collateral.deposited_amount = *collateral_amount;\n\n            (\n                collateral,\n                TestObligationCollateral {\n                    obligation_pubkey,\n                    deposit_reserve: deposit_reserve.pubkey,\n                    deposited_amount: *collateral_amount,\n                },\n            )\n        }",
    "pub fn add_reserve(\n    test: &mut ProgramTest,\n    lending_market: &TestLendingMarket,\n    oracle: &TestOracle,\n    user_accounts_owner: &Keypair,\n    args: AddReserveArgs,\n) -> TestReserve {\n    let AddReserveArgs {\n        name,\n        config,\n        liquidity_amount,\n        liquidity_mint_pubkey,\n        liquidity_mint_decimals,\n        user_liquidity_amount,\n        borrow_amount,\n        initial_borrow_rate,\n        collateral_amount,\n        mark_fresh,\n        slots_elapsed,\n    } = args;\n\n    let is_native = if liquidity_mint_pubkey == spl_token::native_mint::id() {\n        COption::Some(1)\n    }",
    "pub fn add_account_for_program(\n    test: &mut ProgramTest,\n    program_derived_account: &Pubkey,\n    amount: u64,\n    mint_pubkey: &Pubkey,\n) -> Pubkey {\n    let program_owned_token_account = Keypair::new();\n    test.add_packable_account(\n        program_owned_token_account.pubkey(),\n        u32::MAX as u64,\n        &Token {\n            mint: *mint_pubkey,\n            owner: *program_derived_account,\n            amount,\n            state: AccountState::Initialized,\n            is_native: COption::None,\n            ..Token::default()\n        }",
    "pub fn add_usdc_mint(test: &mut ProgramTest) -> TestMint {\n    let authority = Keypair::new();\n    let pubkey = Pubkey::from_str(USDC_MINT).unwrap();\n    let decimals = 6;\n    test.add_packable_account(\n        pubkey,\n        u32::MAX as u64,\n        &Mint {\n            is_initialized: true,\n            mint_authority: COption::Some(authority.pubkey()),\n            decimals,\n            ..Mint::default()\n        }",
    "pub fn add_sol_oracle(test: &mut ProgramTest) -> TestOracle {\n    add_oracle(\n        test,\n        Pubkey::from_str(SOL_PYTH_PRODUCT).unwrap(),\n        Pubkey::from_str(SOL_PYTH_PRICE).unwrap(),\n        // Set SOL price to $20\n        Decimal::from(20u64),\n    )\n}",
    "pub fn add_usdc_oracle(test: &mut ProgramTest) -> TestOracle {\n    add_oracle(\n        test,\n        // Mock with SRM since Pyth doesn't have USDC yet\n        Pubkey::from_str(SRM_PYTH_PRODUCT).unwrap(),\n        Pubkey::from_str(SRM_PYTH_PRICE).unwrap(),\n        // Set USDC price to $1\n        Decimal::from(1u64),\n    )\n}",
    "pub fn new(size: usize, program_id: Pubkey) -> Self {\n        Self {\n            key: Pubkey::new_unique(),\n            lamports: 0,\n            data: vec![0; size],\n            program_id,\n            is_signer: false,\n        }\n    }\n\n    pub fn new_from_account_info(account_info: &AccountInfo) -> Self {\n        Self {\n            key: *account_info.key,\n            lamports: **account_info.lamports.borrow(),\n            data: account_info.data.borrow().to_vec(),\n            program_id: *account_info.owner,\n            is_signer: account_info.is_signer,\n        }\n    }\n\n    pub fn as_account_info(&mut self) -> AccountInfo {\n        AccountInfo::new(\n            &self.key,\n            self.is_signer,\n            false,\n            &mut self.lamports,\n            &mut self.data[..],\n            &self.program_id,\n            false,\n            Epoch::default(),\n        )\n    }",
    "pub fn do_process_instruction(instruction: Instruction, accounts: &[AccountInfo]) -> ProgramResult {\n    test_syscall_stubs();\n\n    // approximate the logic in the actual runtime which runs the instruction\n    // and only updates accounts if the instruction is successful\n    let mut account_data = accounts\n        .iter()\n        .map(NativeAccountData::new_from_account_info)\n        .collect::<Vec<_>>();\n    let account_infos = account_data\n        .iter_mut()\n        .map(NativeAccountData::as_account_info)\n        .collect::<Vec<_>>();\n    let res = if instruction.program_id == spl_token_swap::id() {\n        spl_token_swap::processor::Processor::process(\n            &instruction.program_id,\n            &account_infos,\n            &instruction.data,\n        )\n    }",
    "pub fn create_mint(owner: &Pubkey) -> NativeAccountData {\n    let mut account_data = NativeAccountData::new(Mint::LEN, spl_token::id());\n    let mint = Mint {\n        is_initialized: true,\n        mint_authority: COption::Some(*owner),\n        ..Default::default()\n    }",
    "pub fn create_token_account(\n    mint_account: &mut NativeAccountData,\n    owner: &Pubkey,\n    amount: u64,\n) -> NativeAccountData {\n    let mut mint = Mint::unpack(&mint_account.data).unwrap();\n    let mut account_data = NativeAccountData::new(TokenAccount::LEN, spl_token::id());\n    let account = TokenAccount {\n        state: TokenAccountState::Initialized,\n        mint: mint_account.key,\n        owner: *owner,\n        amount,\n        ..Default::default()\n    }",
    "pub fn create_program_account(program_id: Pubkey) -> NativeAccountData {\n    let mut account_data = NativeAccountData::new(0, bpf_loader::id());\n    account_data.key = program_id;\n    account_data\n}\n\nimpl NativeTokenSwap {\n    pub fn new(\n        fees: Fees,\n        swap_curve: SwapCurve,\n        token_a_amount: u64,\n        token_b_amount: u64,\n    ) -> Self {\n        let mut user_account = NativeAccountData::new(0, system_program::id());\n        user_account.is_signer = true;\n        let mut swap_account =\n            NativeAccountData::new(SwapVersion::LATEST_LEN, spl_token_swap::id());\n        let (authority_key, bump_seed) = Pubkey::find_program_address(\n            &[&swap_account.key.to_bytes()[..]],\n            &spl_token_swap::id(),\n        );\n        let mut authority_account = create_program_account(authority_key);\n        let mut pool_token_program_account = create_program_account(spl_token::id());\n        let token_a_program_account = create_program_account(spl_token::id());\n        let token_b_program_account = create_program_account(spl_token::id());\n\n        let mut pool_mint_account = native_token::create_mint(&authority_account.key);\n        let mut pool_token_account =\n            native_token::create_token_account(&mut pool_mint_account, &user_account.key, 0);\n        let mut pool_fee_account =\n            native_token::create_token_account(&mut pool_mint_account, &user_account.key, 0);\n        let mut token_a_mint_account = native_token::create_mint(&user_account.key);\n        let mut token_a_account = native_token::create_token_account(\n            &mut token_a_mint_account,\n            &authority_account.key,\n            token_a_amount,\n        );\n        let mut token_b_mint_account = native_token::create_mint(&user_account.key);\n        let mut token_b_account = native_token::create_token_account(\n            &mut token_b_mint_account,\n            &authority_account.key,\n            token_b_amount,\n        );\n\n        let init_instruction = instruction::initialize(\n            &spl_token_swap::id(),\n            &spl_token::id(),\n            &swap_account.key,\n            &authority_account.key,\n            &token_a_account.key,\n            &token_b_account.key,\n            &pool_mint_account.key,\n            &pool_fee_account.key,\n            &pool_token_account.key,\n            fees.clone(),\n            swap_curve.clone(),\n        )\n        .unwrap();\n\n        do_process_instruction(\n            init_instruction,\n            &[\n                swap_account.as_account_info(),\n                authority_account.as_account_info(),\n                token_a_account.as_account_info(),\n                token_b_account.as_account_info(),\n                pool_mint_account.as_account_info(),\n                pool_fee_account.as_account_info(),\n                pool_token_account.as_account_info(),\n                pool_token_program_account.as_account_info(),\n            ],\n        )\n        .unwrap();\n\n        Self {\n            user_account,\n            bump_seed,\n            authority_account,\n            fees,\n            swap_curve,\n            swap_account,\n            pool_mint_account,\n            pool_fee_account,\n            pool_token_account,\n            token_a_account,\n            token_a_mint_account,\n            token_b_account,\n            token_b_mint_account,\n            pool_token_program_account,\n            token_a_program_account,\n            token_b_program_account,\n        }\n    }\n\n    pub fn create_pool_account(&mut self) -> NativeAccountData {\n        native_token::create_token_account(&mut self.pool_mint_account, &self.user_account.key, 0)\n    }",
    "pub fn create_token_a_account(&mut self, amount: u64) -> NativeAccountData {\n        native_token::create_token_account(\n            &mut self.token_a_mint_account,\n            &self.user_account.key,\n            amount,\n        )\n    }",
    "pub fn create_token_b_account(&mut self, amount: u64) -> NativeAccountData {\n        native_token::create_token_account(\n            &mut self.token_b_mint_account,\n            &self.user_account.key,\n            amount,\n        )\n    }",
    "pub fn swap_a_to_b(\n        &mut self,\n        token_a_account: &mut NativeAccountData,\n        token_b_account: &mut NativeAccountData,\n        instruction: Swap,\n    ) -> ProgramResult {\n        let mut user_transfer_account = NativeAccountData::new(0, system_program::id());\n        user_transfer_account.is_signer = true;\n        do_process_instruction(\n            approve(\n                &self.token_a_program_account.key,\n                &token_a_account.key,\n                &user_transfer_account.key,\n                &self.user_account.key,\n                &[],\n                instruction.amount_in,\n            )\n            .unwrap(),\n            &[\n                token_a_account.as_account_info(),\n                user_transfer_account.as_account_info(),\n                self.user_account.as_account_info(),\n            ],\n        )\n        .unwrap();\n        let swap_instruction = instruction::swap(\n            &spl_token_swap::id(),\n            &spl_token::id(),\n            &spl_token::id(),\n            &spl_token::id(),\n            &self.swap_account.key,\n            &self.authority_account.key,\n            &user_transfer_account.key,\n            &token_a_account.key,\n            &self.token_a_account.key,\n            &self.token_b_account.key,\n            &token_b_account.key,\n            &self.pool_mint_account.key,\n            &self.pool_fee_account.key,\n            &self.token_a_mint_account.key,\n            &self.token_b_mint_account.key,\n            Some(&self.pool_token_account.key),\n            instruction,\n        )\n        .unwrap();\n\n        do_process_instruction(\n            swap_instruction,\n            &[\n                self.swap_account.as_account_info(),\n                self.authority_account.as_account_info(),\n                user_transfer_account.as_account_info(),\n                token_a_account.as_account_info(),\n                self.token_a_account.as_account_info(),\n                self.token_b_account.as_account_info(),\n                token_b_account.as_account_info(),\n                self.pool_mint_account.as_account_info(),\n                self.pool_fee_account.as_account_info(),\n                self.token_a_mint_account.as_account_info(),\n                self.token_b_mint_account.as_account_info(),\n                self.token_a_program_account.as_account_info(),\n                self.token_b_program_account.as_account_info(),\n                self.pool_token_program_account.as_account_info(),\n                self.pool_token_account.as_account_info(),\n            ],\n        )\n    }",
    "pub fn swap_b_to_a(\n        &mut self,\n        token_b_account: &mut NativeAccountData,\n        token_a_account: &mut NativeAccountData,\n        instruction: Swap,\n    ) -> ProgramResult {\n        let mut user_transfer_account = NativeAccountData::new(0, system_program::id());\n        user_transfer_account.is_signer = true;\n        do_process_instruction(\n            approve(\n                &self.token_b_program_account.key,\n                &token_b_account.key,\n                &user_transfer_account.key,\n                &self.user_account.key,\n                &[],\n                instruction.amount_in,\n            )\n            .unwrap(),\n            &[\n                token_b_account.as_account_info(),\n                user_transfer_account.as_account_info(),\n                self.user_account.as_account_info(),\n            ],\n        )\n        .unwrap();\n\n        let swap_instruction = instruction::swap(\n            &spl_token_swap::id(),\n            &spl_token::id(),\n            &spl_token::id(),\n            &spl_token::id(),\n            &self.swap_account.key,\n            &self.authority_account.key,\n            &user_transfer_account.key,\n            &token_b_account.key,\n            &self.token_b_account.key,\n            &self.token_a_account.key,\n            &token_a_account.key,\n            &self.pool_mint_account.key,\n            &self.pool_fee_account.key,\n            &self.token_b_mint_account.key,\n            &self.token_a_mint_account.key,\n            Some(&self.pool_token_account.key),\n            instruction,\n        )\n        .unwrap();\n\n        do_process_instruction(\n            swap_instruction,\n            &[\n                self.swap_account.as_account_info(),\n                self.authority_account.as_account_info(),\n                user_transfer_account.as_account_info(),\n                token_b_account.as_account_info(),\n                self.token_b_account.as_account_info(),\n                self.token_a_account.as_account_info(),\n                token_a_account.as_account_info(),\n                self.pool_mint_account.as_account_info(),\n                self.pool_fee_account.as_account_info(),\n                self.token_b_mint_account.as_account_info(),\n                self.token_a_mint_account.as_account_info(),\n                self.token_b_program_account.as_account_info(),\n                self.token_a_program_account.as_account_info(),\n                self.pool_token_program_account.as_account_info(),\n                self.pool_token_account.as_account_info(),\n            ],\n        )\n    }",
    "pub fn deposit_all_token_types(\n        &mut self,\n        token_a_account: &mut NativeAccountData,\n        token_b_account: &mut NativeAccountData,\n        pool_account: &mut NativeAccountData,\n        mut instruction: DepositAllTokenTypes,\n    ) -> ProgramResult {\n        let mut user_transfer_account = NativeAccountData::new(0, system_program::id());\n        user_transfer_account.is_signer = true;\n        do_process_instruction(\n            approve(\n                &self.token_a_program_account.key,\n                &token_a_account.key,\n                &user_transfer_account.key,\n                &self.user_account.key,\n                &[],\n                instruction.maximum_token_a_amount,\n            )\n            .unwrap(),\n            &[\n                token_a_account.as_account_info(),\n                user_transfer_account.as_account_info(),\n                self.user_account.as_account_info(),\n            ],\n        )\n        .unwrap();\n\n        do_process_instruction(\n            approve(\n                &self.token_b_program_account.key,\n                &token_b_account.key,\n                &user_transfer_account.key,\n                &self.user_account.key,\n                &[],\n                instruction.maximum_token_b_amount,\n            )\n            .unwrap(),\n            &[\n                token_b_account.as_account_info(),\n                user_transfer_account.as_account_info(),\n                self.user_account.as_account_info(),\n            ],\n        )\n        .unwrap();\n\n        // special logic: if we only deposit 1 pool token, we can't withdraw it\n        // because we incur a withdrawal fee, so we hack it to not be 1\n        if instruction.pool_token_amount == 1 {\n            instruction.pool_token_amount = 2;\n        }\n\n        let deposit_instruction = instruction::deposit_all_token_types(\n            &spl_token_swap::id(),\n            &spl_token::id(),\n            &spl_token::id(),\n            &spl_token::id(),\n            &self.swap_account.key,\n            &self.authority_account.key,\n            &user_transfer_account.key,\n            &token_a_account.key,\n            &token_b_account.key,\n            &self.token_a_account.key,\n            &self.token_b_account.key,\n            &self.pool_mint_account.key,\n            &pool_account.key,\n            &self.token_a_mint_account.key,\n            &self.token_b_mint_account.key,\n            instruction,\n        )\n        .unwrap();\n\n        do_process_instruction(\n            deposit_instruction,\n            &[\n                self.swap_account.as_account_info(),\n                self.authority_account.as_account_info(),\n                user_transfer_account.as_account_info(),\n                token_a_account.as_account_info(),\n                token_b_account.as_account_info(),\n                self.token_a_account.as_account_info(),\n                self.token_b_account.as_account_info(),\n                self.pool_mint_account.as_account_info(),\n                pool_account.as_account_info(),\n                self.token_a_mint_account.as_account_info(),\n                self.token_b_mint_account.as_account_info(),\n                self.token_a_program_account.as_account_info(),\n                self.token_b_program_account.as_account_info(),\n                self.pool_token_program_account.as_account_info(),\n            ],\n        )\n    }",
    "pub fn withdraw_all_token_types(\n        &mut self,\n        pool_account: &mut NativeAccountData,\n        token_a_account: &mut NativeAccountData,\n        token_b_account: &mut NativeAccountData,\n        mut instruction: WithdrawAllTokenTypes,\n    ) -> ProgramResult {\n        let mut user_transfer_account = NativeAccountData::new(0, system_program::id());\n        user_transfer_account.is_signer = true;\n        let pool_token_amount = native_token::get_token_balance(pool_account);\n        // special logic to avoid withdrawing down to 1 pool token, which\n        // eventually causes an error on withdrawing all\n        if pool_token_amount.saturating_sub(instruction.pool_token_amount) == 1 {\n            instruction.pool_token_amount = pool_token_amount;\n        }\n        do_process_instruction(\n            approve(\n                &self.pool_token_program_account.key,\n                &pool_account.key,\n                &user_transfer_account.key,\n                &self.user_account.key,\n                &[],\n                instruction.pool_token_amount,\n            )\n            .unwrap(),\n            &[\n                pool_account.as_account_info(),\n                user_transfer_account.as_account_info(),\n                self.user_account.as_account_info(),\n            ],\n        )\n        .unwrap();\n\n        let withdraw_instruction = instruction::withdraw_all_token_types(\n            &spl_token_swap::id(),\n            &spl_token::id(),\n            &spl_token::id(),\n            &spl_token::id(),\n            &self.swap_account.key,\n            &self.authority_account.key,\n            &user_transfer_account.key,\n            &self.pool_mint_account.key,\n            &self.pool_fee_account.key,\n            &pool_account.key,\n            &self.token_a_account.key,\n            &self.token_b_account.key,\n            &token_a_account.key,\n            &token_b_account.key,\n            &self.token_a_mint_account.key,\n            &self.token_b_mint_account.key,\n            instruction,\n        )\n        .unwrap();\n\n        do_process_instruction(\n            withdraw_instruction,\n            &[\n                self.swap_account.as_account_info(),\n                self.authority_account.as_account_info(),\n                user_transfer_account.as_account_info(),\n                self.pool_mint_account.as_account_info(),\n                pool_account.as_account_info(),\n                self.token_a_account.as_account_info(),\n                self.token_b_account.as_account_info(),\n                token_a_account.as_account_info(),\n                token_b_account.as_account_info(),\n                self.pool_fee_account.as_account_info(),\n                self.token_a_mint_account.as_account_info(),\n                self.token_b_mint_account.as_account_info(),\n                self.pool_token_program_account.as_account_info(),\n                self.token_a_program_account.as_account_info(),\n                self.token_b_program_account.as_account_info(),\n            ],\n        )\n    }",
    "pub fn deposit_single_token_type_exact_amount_in(\n        &mut self,\n        source_token_account: &mut NativeAccountData,\n        trade_direction: TradeDirection,\n        pool_account: &mut NativeAccountData,\n        mut instruction: DepositSingleTokenTypeExactAmountIn,\n    ) -> ProgramResult {\n        let mut user_transfer_account = NativeAccountData::new(0, system_program::id());\n        user_transfer_account.is_signer = true;\n        let source_token_program = match trade_direction {\n            TradeDirection::AtoB => &mut self.token_a_program_account,\n            TradeDirection::BtoA => &mut self.token_b_program_account,\n        };\n        do_process_instruction(\n            approve(\n                &source_token_program.key,\n                &source_token_account.key,\n                &user_transfer_account.key,\n                &self.user_account.key,\n                &[],\n                instruction.source_token_amount,\n            )\n            .unwrap(),\n            &[\n                source_token_account.as_account_info(),\n                user_transfer_account.as_account_info(),\n                self.user_account.as_account_info(),\n            ],\n        )\n        .unwrap();\n\n        // special logic: if we only deposit 1 pool token, we can't withdraw it\n        // because we incur a withdrawal fee, so we hack it to not be 1\n        if instruction.minimum_pool_token_amount < 2 {\n            instruction.minimum_pool_token_amount = 2;\n        }\n\n        let source_token_mint_account = match trade_direction {\n            TradeDirection::AtoB => &mut self.token_a_mint_account,\n            TradeDirection::BtoA => &mut self.token_b_mint_account,\n        };\n\n        let deposit_instruction = instruction::deposit_single_token_type_exact_amount_in(\n            &spl_token_swap::id(),\n            &spl_token::id(),\n            &spl_token::id(),\n            &self.swap_account.key,\n            &self.authority_account.key,\n            &user_transfer_account.key,\n            &source_token_account.key,\n            &self.token_a_account.key,\n            &self.token_b_account.key,\n            &self.pool_mint_account.key,\n            &pool_account.key,\n            &source_token_mint_account.key,\n            instruction,\n        )\n        .unwrap();\n\n        do_process_instruction(\n            deposit_instruction,\n            &[\n                self.swap_account.as_account_info(),\n                self.authority_account.as_account_info(),\n                user_transfer_account.as_account_info(),\n                source_token_account.as_account_info(),\n                self.token_a_account.as_account_info(),\n                self.token_b_account.as_account_info(),\n                self.pool_mint_account.as_account_info(),\n                pool_account.as_account_info(),\n                source_token_mint_account.as_account_info(),\n                self.token_a_program_account.as_account_info(),\n                self.pool_token_program_account.as_account_info(),\n            ],\n        )\n    }",
    "pub fn withdraw_single_token_type_exact_amount_out(\n        &mut self,\n        pool_account: &mut NativeAccountData,\n        trade_direction: TradeDirection,\n        destination_token_account: &mut NativeAccountData,\n        mut instruction: WithdrawSingleTokenTypeExactAmountOut,\n    ) -> ProgramResult {\n        let mut user_transfer_account = NativeAccountData::new(0, system_program::id());\n        user_transfer_account.is_signer = true;\n        let pool_token_amount = native_token::get_token_balance(pool_account);\n        // special logic to avoid withdrawing down to 1 pool token, which\n        // eventually causes an error on withdrawing all\n        if pool_token_amount.saturating_sub(instruction.maximum_pool_token_amount) == 1 {\n            instruction.maximum_pool_token_amount = pool_token_amount;\n        }\n        do_process_instruction(\n            approve(\n                &self.pool_token_program_account.key,\n                &pool_account.key,\n                &user_transfer_account.key,\n                &self.user_account.key,\n                &[],\n                instruction.maximum_pool_token_amount,\n            )\n            .unwrap(),\n            &[\n                pool_account.as_account_info(),\n                user_transfer_account.as_account_info(),\n                self.user_account.as_account_info(),\n            ],\n        )\n        .unwrap();\n\n        let destination_token_program = match trade_direction {\n            TradeDirection::AtoB => &mut self.token_a_program_account,\n            TradeDirection::BtoA => &mut self.token_b_program_account,\n        };\n        let destination_token_mint_account = match trade_direction {\n            TradeDirection::AtoB => &mut self.token_a_mint_account,\n            TradeDirection::BtoA => &mut self.token_b_mint_account,\n        };\n        let withdraw_instruction = instruction::withdraw_single_token_type_exact_amount_out(\n            &spl_token_swap::id(),\n            &spl_token::id(),\n            &spl_token::id(),\n            &self.swap_account.key,\n            &self.authority_account.key,\n            &user_transfer_account.key,\n            &self.pool_mint_account.key,\n            &self.pool_fee_account.key,\n            &pool_account.key,\n            &self.token_a_account.key,\n            &self.token_b_account.key,\n            &destination_token_account.key,\n            &destination_token_mint_account.key,\n            instruction,\n        )\n        .unwrap();\n\n        do_process_instruction(\n            withdraw_instruction,\n            &[\n                self.swap_account.as_account_info(),\n                self.authority_account.as_account_info(),\n                user_transfer_account.as_account_info(),\n                self.pool_mint_account.as_account_info(),\n                pool_account.as_account_info(),\n                self.token_a_account.as_account_info(),\n                self.token_b_account.as_account_info(),\n                destination_token_account.as_account_info(),\n                self.pool_fee_account.as_account_info(),\n                destination_token_mint_account.as_account_info(),\n                self.pool_token_program_account.as_account_info(),\n                destination_token_program.as_account_info(),\n            ],\n        )\n    }",
    "pub fn withdraw_all(\n        &mut self,\n        pool_account: &mut NativeAccountData,\n        token_a_account: &mut NativeAccountData,\n        token_b_account: &mut NativeAccountData,\n    ) -> ProgramResult {\n        let pool_token_amount = native_token::get_token_balance(pool_account);\n        if pool_token_amount > 0 {\n            let instruction = WithdrawAllTokenTypes {\n                pool_token_amount,\n                minimum_token_a_amount: 0,\n                minimum_token_b_amount: 0,\n            };\n            self.withdraw_all_token_types(\n                pool_account,\n                token_a_account,\n                token_b_account,\n                instruction,\n            )\n        }",
    "pub fn validate_curve(&self, swap_curve: &SwapCurve) -> Result<(), ProgramError> {\n        if self\n            .valid_curve_types\n            .iter()\n            .any(|x| *x == swap_curve.curve_type)\n        {\n            Ok(())\n        }",
    "pub fn validate_fees(&self, fees: &Fees) -> Result<(), ProgramError> {\n        if fees.trade_fee_numerator >= self.fees.trade_fee_numerator\n            && fees.trade_fee_denominator == self.fees.trade_fee_denominator\n            && fees.owner_trade_fee_numerator >= self.fees.owner_trade_fee_numerator\n            && fees.owner_trade_fee_denominator == self.fees.owner_trade_fee_denominator\n            && fees.owner_withdraw_fee_numerator >= self.fees.owner_withdraw_fee_numerator\n            && fees.owner_withdraw_fee_denominator == self.fees.owner_withdraw_fee_denominator\n            && fees.host_fee_numerator == self.fees.host_fee_numerator\n            && fees.host_fee_denominator == self.fees.host_fee_denominator\n        {\n            Ok(())\n        }",
    "pub fn unpack(input: &[u8]) -> Result<Self, ProgramError> {\n        let (&tag, rest) = input.split_first().ok_or(SwapError::InvalidInstruction)?;\n        Ok(match tag {\n            0 => {\n                if rest.len() >= Fees::LEN {\n                    let (fees, rest) = rest.split_at(Fees::LEN);\n                    let fees = Fees::unpack_unchecked(fees)?;\n                    let swap_curve = SwapCurve::unpack_unchecked(rest)?;\n                    Self::Initialize(Initialize { fees, swap_curve })\n                }",
    "pub fn pack(&self) -> Vec<u8> {\n        let mut buf = Vec::with_capacity(size_of::<Self>());\n        match self {\n            Self::Initialize(Initialize { fees, swap_curve }) => {\n                buf.push(0);\n                let mut fees_slice = [0u8; Fees::LEN];\n                Pack::pack_into_slice(fees, &mut fees_slice[..]);\n                buf.extend_from_slice(&fees_slice);\n                let mut swap_curve_slice = [0u8; SwapCurve::LEN];\n                Pack::pack_into_slice(swap_curve, &mut swap_curve_slice[..]);\n                buf.extend_from_slice(&swap_curve_slice);\n            }\n            Self::Swap(Swap {\n                amount_in,\n                minimum_amount_out,\n            }) => {\n                buf.push(1);\n                buf.extend_from_slice(&amount_in.to_le_bytes());\n                buf.extend_from_slice(&minimum_amount_out.to_le_bytes());\n            }\n            Self::DepositAllTokenTypes(DepositAllTokenTypes {\n                pool_token_amount,\n                maximum_token_a_amount,\n                maximum_token_b_amount,\n            }) => {\n                buf.push(2);\n                buf.extend_from_slice(&pool_token_amount.to_le_bytes());\n                buf.extend_from_slice(&maximum_token_a_amount.to_le_bytes());\n                buf.extend_from_slice(&maximum_token_b_amount.to_le_bytes());\n            }\n            Self::WithdrawAllTokenTypes(WithdrawAllTokenTypes {\n                pool_token_amount,\n                minimum_token_a_amount,\n                minimum_token_b_amount,\n            }) => {\n                buf.push(3);\n                buf.extend_from_slice(&pool_token_amount.to_le_bytes());\n                buf.extend_from_slice(&minimum_token_a_amount.to_le_bytes());\n                buf.extend_from_slice(&minimum_token_b_amount.to_le_bytes());\n            }\n            Self::DepositSingleTokenTypeExactAmountIn(DepositSingleTokenTypeExactAmountIn {\n                source_token_amount,\n                minimum_pool_token_amount,\n            }) => {\n                buf.push(4);\n                buf.extend_from_slice(&source_token_amount.to_le_bytes());\n                buf.extend_from_slice(&minimum_pool_token_amount.to_le_bytes());\n            }\n            Self::WithdrawSingleTokenTypeExactAmountOut(\n                WithdrawSingleTokenTypeExactAmountOut {\n                    destination_token_amount,\n                    maximum_pool_token_amount,\n                },\n            ) => {\n                buf.push(5);\n                buf.extend_from_slice(&destination_token_amount.to_le_bytes());\n                buf.extend_from_slice(&maximum_pool_token_amount.to_le_bytes());\n            }\n        }\n        buf\n    }\n}\n\n/// Creates an 'initialize' instruction.\npub fn initialize(\n    program_id: &Pubkey,\n    token_program_id: &Pubkey,\n    swap_pubkey: &Pubkey,\n    authority_pubkey: &Pubkey,\n    token_a_pubkey: &Pubkey,\n    token_b_pubkey: &Pubkey,\n    pool_pubkey: &Pubkey,\n    fee_pubkey: &Pubkey,\n    destination_pubkey: &Pubkey,\n    fees: Fees,\n    swap_curve: SwapCurve,\n) -> Result<Instruction, ProgramError> {\n    let init_data = SwapInstruction::Initialize(Initialize { fees, swap_curve });\n    let data = init_data.pack();\n\n    let accounts = vec![\n        AccountMeta::new(*swap_pubkey, true),\n        AccountMeta::new_readonly(*authority_pubkey, false),\n        AccountMeta::new_readonly(*token_a_pubkey, false),\n        AccountMeta::new_readonly(*token_b_pubkey, false),\n        AccountMeta::new(*pool_pubkey, false),\n        AccountMeta::new_readonly(*fee_pubkey, false),\n        AccountMeta::new(*destination_pubkey, false),\n        AccountMeta::new_readonly(*token_program_id, false),\n    ];\n\n    Ok(Instruction {\n        program_id: *program_id,\n        accounts,\n        data,\n    })\n}",
    "pub fn deposit_all_token_types(\n    program_id: &Pubkey,\n    token_a_program_id: &Pubkey,\n    token_b_program_id: &Pubkey,\n    pool_token_program_id: &Pubkey,\n    swap_pubkey: &Pubkey,\n    authority_pubkey: &Pubkey,\n    user_transfer_authority_pubkey: &Pubkey,\n    deposit_token_a_pubkey: &Pubkey,\n    deposit_token_b_pubkey: &Pubkey,\n    swap_token_a_pubkey: &Pubkey,\n    swap_token_b_pubkey: &Pubkey,\n    pool_mint_pubkey: &Pubkey,\n    destination_pubkey: &Pubkey,\n    token_a_mint_pubkey: &Pubkey,\n    token_b_mint_pubkey: &Pubkey,\n    instruction: DepositAllTokenTypes,\n) -> Result<Instruction, ProgramError> {\n    let data = SwapInstruction::DepositAllTokenTypes(instruction).pack();\n\n    let accounts = vec![\n        AccountMeta::new_readonly(*swap_pubkey, false),\n        AccountMeta::new_readonly(*authority_pubkey, false),\n        AccountMeta::new_readonly(*user_transfer_authority_pubkey, true),\n        AccountMeta::new(*deposit_token_a_pubkey, false),\n        AccountMeta::new(*deposit_token_b_pubkey, false),\n        AccountMeta::new(*swap_token_a_pubkey, false),\n        AccountMeta::new(*swap_token_b_pubkey, false),\n        AccountMeta::new(*pool_mint_pubkey, false),\n        AccountMeta::new(*destination_pubkey, false),\n        AccountMeta::new_readonly(*token_a_mint_pubkey, false),\n        AccountMeta::new_readonly(*token_b_mint_pubkey, false),\n        AccountMeta::new_readonly(*token_a_program_id, false),\n        AccountMeta::new_readonly(*token_b_program_id, false),\n        AccountMeta::new_readonly(*pool_token_program_id, false),\n    ];\n\n    Ok(Instruction {\n        program_id: *program_id,\n        accounts,\n        data,\n    })\n}",
    "pub fn withdraw_all_token_types(\n    program_id: &Pubkey,\n    pool_token_program_id: &Pubkey,\n    token_a_program_id: &Pubkey,\n    token_b_program_id: &Pubkey,\n    swap_pubkey: &Pubkey,\n    authority_pubkey: &Pubkey,\n    user_transfer_authority_pubkey: &Pubkey,\n    pool_mint_pubkey: &Pubkey,\n    fee_account_pubkey: &Pubkey,\n    source_pubkey: &Pubkey,\n    swap_token_a_pubkey: &Pubkey,\n    swap_token_b_pubkey: &Pubkey,\n    destination_token_a_pubkey: &Pubkey,\n    destination_token_b_pubkey: &Pubkey,\n    token_a_mint_pubkey: &Pubkey,\n    token_b_mint_pubkey: &Pubkey,\n    instruction: WithdrawAllTokenTypes,\n) -> Result<Instruction, ProgramError> {\n    let data = SwapInstruction::WithdrawAllTokenTypes(instruction).pack();\n\n    let accounts = vec![\n        AccountMeta::new_readonly(*swap_pubkey, false),\n        AccountMeta::new_readonly(*authority_pubkey, false),\n        AccountMeta::new_readonly(*user_transfer_authority_pubkey, true),\n        AccountMeta::new(*pool_mint_pubkey, false),\n        AccountMeta::new(*source_pubkey, false),\n        AccountMeta::new(*swap_token_a_pubkey, false),\n        AccountMeta::new(*swap_token_b_pubkey, false),\n        AccountMeta::new(*destination_token_a_pubkey, false),\n        AccountMeta::new(*destination_token_b_pubkey, false),\n        AccountMeta::new(*fee_account_pubkey, false),\n        AccountMeta::new_readonly(*token_a_mint_pubkey, false),\n        AccountMeta::new_readonly(*token_b_mint_pubkey, false),\n        AccountMeta::new_readonly(*pool_token_program_id, false),\n        AccountMeta::new_readonly(*token_a_program_id, false),\n        AccountMeta::new_readonly(*token_b_program_id, false),\n    ];\n\n    Ok(Instruction {\n        program_id: *program_id,\n        accounts,\n        data,\n    })\n}",
    "pub fn deposit_single_token_type_exact_amount_in(\n    program_id: &Pubkey,\n    source_token_program_id: &Pubkey,\n    pool_token_program_id: &Pubkey,\n    swap_pubkey: &Pubkey,\n    authority_pubkey: &Pubkey,\n    user_transfer_authority_pubkey: &Pubkey,\n    source_token_pubkey: &Pubkey,\n    swap_token_a_pubkey: &Pubkey,\n    swap_token_b_pubkey: &Pubkey,\n    pool_mint_pubkey: &Pubkey,\n    destination_pubkey: &Pubkey,\n    source_mint_pubkey: &Pubkey,\n    instruction: DepositSingleTokenTypeExactAmountIn,\n) -> Result<Instruction, ProgramError> {\n    let data = SwapInstruction::DepositSingleTokenTypeExactAmountIn(instruction).pack();\n\n    let accounts = vec![\n        AccountMeta::new_readonly(*swap_pubkey, false),\n        AccountMeta::new_readonly(*authority_pubkey, false),\n        AccountMeta::new_readonly(*user_transfer_authority_pubkey, true),\n        AccountMeta::new(*source_token_pubkey, false),\n        AccountMeta::new(*swap_token_a_pubkey, false),\n        AccountMeta::new(*swap_token_b_pubkey, false),\n        AccountMeta::new(*pool_mint_pubkey, false),\n        AccountMeta::new(*destination_pubkey, false),\n        AccountMeta::new_readonly(*source_mint_pubkey, false),\n        AccountMeta::new_readonly(*source_token_program_id, false),\n        AccountMeta::new_readonly(*pool_token_program_id, false),\n    ];\n\n    Ok(Instruction {\n        program_id: *program_id,\n        accounts,\n        data,\n    })\n}",
    "pub fn withdraw_single_token_type_exact_amount_out(\n    program_id: &Pubkey,\n    pool_token_program_id: &Pubkey,\n    destination_token_program_id: &Pubkey,\n    swap_pubkey: &Pubkey,\n    authority_pubkey: &Pubkey,\n    user_transfer_authority_pubkey: &Pubkey,\n    pool_mint_pubkey: &Pubkey,\n    fee_account_pubkey: &Pubkey,\n    pool_token_source_pubkey: &Pubkey,\n    swap_token_a_pubkey: &Pubkey,\n    swap_token_b_pubkey: &Pubkey,\n    destination_pubkey: &Pubkey,\n    destination_mint_pubkey: &Pubkey,\n    instruction: WithdrawSingleTokenTypeExactAmountOut,\n) -> Result<Instruction, ProgramError> {\n    let data = SwapInstruction::WithdrawSingleTokenTypeExactAmountOut(instruction).pack();\n\n    let accounts = vec![\n        AccountMeta::new_readonly(*swap_pubkey, false),\n        AccountMeta::new_readonly(*authority_pubkey, false),\n        AccountMeta::new_readonly(*user_transfer_authority_pubkey, true),\n        AccountMeta::new(*pool_mint_pubkey, false),\n        AccountMeta::new(*pool_token_source_pubkey, false),\n        AccountMeta::new(*swap_token_a_pubkey, false),\n        AccountMeta::new(*swap_token_b_pubkey, false),\n        AccountMeta::new(*destination_pubkey, false),\n        AccountMeta::new(*fee_account_pubkey, false),\n        AccountMeta::new_readonly(*destination_mint_pubkey, false),\n        AccountMeta::new_readonly(*pool_token_program_id, false),\n        AccountMeta::new_readonly(*destination_token_program_id, false),\n    ];\n\n    Ok(Instruction {\n        program_id: *program_id,\n        accounts,\n        data,\n    })\n}",
    "pub fn swap(\n    program_id: &Pubkey,\n    source_token_program_id: &Pubkey,\n    destination_token_program_id: &Pubkey,\n    pool_token_program_id: &Pubkey,\n    swap_pubkey: &Pubkey,\n    authority_pubkey: &Pubkey,\n    user_transfer_authority_pubkey: &Pubkey,\n    source_pubkey: &Pubkey,\n    swap_source_pubkey: &Pubkey,\n    swap_destination_pubkey: &Pubkey,\n    destination_pubkey: &Pubkey,\n    pool_mint_pubkey: &Pubkey,\n    pool_fee_pubkey: &Pubkey,\n    source_mint_pubkey: &Pubkey,\n    destination_mint_pubkey: &Pubkey,\n    host_fee_pubkey: Option<&Pubkey>,\n    instruction: Swap,\n) -> Result<Instruction, ProgramError> {\n    let data = SwapInstruction::Swap(instruction).pack();\n\n    let mut accounts = vec![\n        AccountMeta::new_readonly(*swap_pubkey, false),\n        AccountMeta::new_readonly(*authority_pubkey, false),\n        AccountMeta::new_readonly(*user_transfer_authority_pubkey, true),\n        AccountMeta::new(*source_pubkey, false),\n        AccountMeta::new(*swap_source_pubkey, false),\n        AccountMeta::new(*swap_destination_pubkey, false),\n        AccountMeta::new(*destination_pubkey, false),\n        AccountMeta::new(*pool_mint_pubkey, false),\n        AccountMeta::new(*pool_fee_pubkey, false),\n        AccountMeta::new_readonly(*source_mint_pubkey, false),\n        AccountMeta::new_readonly(*destination_mint_pubkey, false),\n        AccountMeta::new_readonly(*source_token_program_id, false),\n        AccountMeta::new_readonly(*destination_token_program_id, false),\n        AccountMeta::new_readonly(*pool_token_program_id, false),\n    ];\n    if let Some(host_fee_pubkey) = host_fee_pubkey {\n        accounts.push(AccountMeta::new(*host_fee_pubkey, false));\n    }\n\n    Ok(Instruction {\n        program_id: *program_id,\n        accounts,\n        data,\n    })\n}",
    "pub fn unpack_token_account(\n        account_info: &AccountInfo,\n        token_program_id: &Pubkey,\n    ) -> Result<Account, SwapError> {\n        if account_info.owner != token_program_id\n            && check_spl_token_program_account(account_info.owner).is_err()\n        {\n            Err(SwapError::IncorrectTokenProgramId)\n        }",
    "pub fn unpack_mint(\n        account_info: &AccountInfo,\n        token_program_id: &Pubkey,\n    ) -> Result<Mint, SwapError> {\n        if account_info.owner != token_program_id\n            && check_spl_token_program_account(account_info.owner).is_err()\n        {\n            Err(SwapError::IncorrectTokenProgramId)\n        }",
    "pub fn authority_id(\n        program_id: &Pubkey,\n        my_info: &Pubkey,\n        bump_seed: u8,\n    ) -> Result<Pubkey, SwapError> {\n        Pubkey::create_program_address(&[&my_info.to_bytes()[..32], &[bump_seed]], program_id)\n            .or(Err(SwapError::InvalidProgramAddress))\n    }",
    "pub fn process_initialize(\n        program_id: &Pubkey,\n        fees: Fees,\n        swap_curve: SwapCurve,\n        accounts: &[AccountInfo],\n        swap_constraints: &Option<SwapConstraints>,\n    ) -> ProgramResult {\n        let account_info_iter = &mut accounts.iter();\n        let swap_info = next_account_info(account_info_iter)?;\n        let authority_info = next_account_info(account_info_iter)?;\n        let token_a_info = next_account_info(account_info_iter)?;\n        let token_b_info = next_account_info(account_info_iter)?;\n        let pool_mint_info = next_account_info(account_info_iter)?;\n        let fee_account_info = next_account_info(account_info_iter)?;\n        let destination_info = next_account_info(account_info_iter)?;\n        let pool_token_program_info = next_account_info(account_info_iter)?;\n\n        let token_program_id = *pool_token_program_info.key;\n        if SwapVersion::is_initialized(&swap_info.data.borrow()) {\n            return Err(SwapError::AlreadyInUse.into());\n        }\n\n        let (swap_authority, bump_seed) =\n            Pubkey::find_program_address(&[&swap_info.key.to_bytes()], program_id);\n        if *authority_info.key != swap_authority {\n            return Err(SwapError::InvalidProgramAddress.into());\n        }\n        let token_a = Self::unpack_token_account(token_a_info, &token_program_id)?;\n        let token_b = Self::unpack_token_account(token_b_info, &token_program_id)?;\n        let fee_account = Self::unpack_token_account(fee_account_info, &token_program_id)?;\n        let destination = Self::unpack_token_account(destination_info, &token_program_id)?;\n        let pool_mint = {\n            let pool_mint_data = pool_mint_info.data.borrow();\n            let pool_mint = Self::unpack_mint_with_extensions(\n                &pool_mint_data,\n                pool_mint_info.owner,\n                &token_program_id,\n            )?;\n            if let Ok(extension) = pool_mint.get_extension::<MintCloseAuthority>() {\n                let close_authority: Option<Pubkey> = extension.close_authority.into();\n                if close_authority.is_some() {\n                    return Err(SwapError::InvalidCloseAuthority.into());\n                }\n            }\n            pool_mint.base\n        };\n        if *authority_info.key != token_a.owner {\n            return Err(SwapError::InvalidOwner.into());\n        }\n        if *authority_info.key != token_b.owner {\n            return Err(SwapError::InvalidOwner.into());\n        }\n        if *authority_info.key == destination.owner {\n            return Err(SwapError::InvalidOutputOwner.into());\n        }\n        if *authority_info.key == fee_account.owner {\n            return Err(SwapError::InvalidOutputOwner.into());\n        }\n        if COption::Some(*authority_info.key) != pool_mint.mint_authority {\n            return Err(SwapError::InvalidOwner.into());\n        }\n\n        if token_a.mint == token_b.mint {\n            return Err(SwapError::RepeatedMint.into());\n        }\n        swap_curve\n            .calculator\n            .validate_supply(token_a.amount, token_b.amount)?;\n        if token_a.delegate.is_some() {\n            return Err(SwapError::InvalidDelegate.into());\n        }\n        if token_b.delegate.is_some() {\n            return Err(SwapError::InvalidDelegate.into());\n        }\n        if token_a.close_authority.is_some() {\n            return Err(SwapError::InvalidCloseAuthority.into());\n        }\n        if token_b.close_authority.is_some() {\n            return Err(SwapError::InvalidCloseAuthority.into());\n        }\n\n        if pool_mint.supply != 0 {\n            return Err(SwapError::InvalidSupply.into());\n        }\n        if pool_mint.freeze_authority.is_some() {\n            return Err(SwapError::InvalidFreezeAuthority.into());\n        }\n        if *pool_mint_info.key != fee_account.mint {\n            return Err(SwapError::IncorrectPoolMint.into());\n        }\n\n        if let Some(swap_constraints) = swap_constraints {\n            let owner_key = swap_constraints\n                .owner_key\n                .unwrap()\n                .parse::<Pubkey>()\n                .map_err(|_| SwapError::InvalidOwner)?;\n            if fee_account.owner != owner_key {\n                return Err(SwapError::InvalidOwner.into());\n            }\n            swap_constraints.validate_curve(&swap_curve)?;\n            swap_constraints.validate_fees(&fees)?;\n        }\n        fees.validate()?;\n        swap_curve.calculator.validate()?;\n\n        let initial_amount = swap_curve.calculator.new_pool_supply();\n\n        Self::token_mint_to(\n            swap_info.key,\n            pool_token_program_info.clone(),\n            pool_mint_info.clone(),\n            destination_info.clone(),\n            authority_info.clone(),\n            bump_seed,\n            to_u64(initial_amount)?,\n        )?;\n\n        let obj = SwapVersion::SwapV1(SwapV1 {\n            is_initialized: true,\n            bump_seed,\n            token_program_id,\n            token_a: *token_a_info.key,\n            token_b: *token_b_info.key,\n            pool_mint: *pool_mint_info.key,\n            token_a_mint: token_a.mint,\n            token_b_mint: token_b.mint,\n            pool_fee_account: *fee_account_info.key,\n            fees,\n            swap_curve,\n        });\n        SwapVersion::pack(obj, &mut swap_info.data.borrow_mut())?;\n        Ok(())\n    }",
    "pub fn process_swap(\n        program_id: &Pubkey,\n        amount_in: u64,\n        minimum_amount_out: u64,\n        accounts: &[AccountInfo],\n    ) -> ProgramResult {\n        let account_info_iter = &mut accounts.iter();\n        let swap_info = next_account_info(account_info_iter)?;\n        let authority_info = next_account_info(account_info_iter)?;\n        let user_transfer_authority_info = next_account_info(account_info_iter)?;\n        let source_info = next_account_info(account_info_iter)?;\n        let swap_source_info = next_account_info(account_info_iter)?;\n        let swap_destination_info = next_account_info(account_info_iter)?;\n        let destination_info = next_account_info(account_info_iter)?;\n        let pool_mint_info = next_account_info(account_info_iter)?;\n        let pool_fee_account_info = next_account_info(account_info_iter)?;\n        let source_token_mint_info = next_account_info(account_info_iter)?;\n        let destination_token_mint_info = next_account_info(account_info_iter)?;\n        let source_token_program_info = next_account_info(account_info_iter)?;\n        let destination_token_program_info = next_account_info(account_info_iter)?;\n        let pool_token_program_info = next_account_info(account_info_iter)?;\n\n        if swap_info.owner != program_id {\n            return Err(ProgramError::IncorrectProgramId);\n        }\n        let token_swap = SwapVersion::unpack(&swap_info.data.borrow())?;\n\n        if *authority_info.key\n            != Self::authority_id(program_id, swap_info.key, token_swap.bump_seed())?\n        {\n            return Err(SwapError::InvalidProgramAddress.into());\n        }\n        if !(*swap_source_info.key == *token_swap.token_a_account()\n            || *swap_source_info.key == *token_swap.token_b_account())\n        {\n            return Err(SwapError::IncorrectSwapAccount.into());\n        }\n        if !(*swap_destination_info.key == *token_swap.token_a_account()\n            || *swap_destination_info.key == *token_swap.token_b_account())\n        {\n            return Err(SwapError::IncorrectSwapAccount.into());\n        }\n        if *swap_source_info.key == *swap_destination_info.key {\n            return Err(SwapError::InvalidInput.into());\n        }\n        if swap_source_info.key == source_info.key {\n            return Err(SwapError::InvalidInput.into());\n        }\n        if swap_destination_info.key == destination_info.key {\n            return Err(SwapError::InvalidInput.into());\n        }\n        if *pool_mint_info.key != *token_swap.pool_mint() {\n            return Err(SwapError::IncorrectPoolMint.into());\n        }\n        if *pool_fee_account_info.key != *token_swap.pool_fee_account() {\n            return Err(SwapError::IncorrectFeeAccount.into());\n        }\n        if *pool_token_program_info.key != *token_swap.token_program_id() {\n            return Err(SwapError::IncorrectTokenProgramId.into());\n        }\n\n        let source_account =\n            Self::unpack_token_account(swap_source_info, token_swap.token_program_id())?;\n        let dest_account =\n            Self::unpack_token_account(swap_destination_info, token_swap.token_program_id())?;\n        let pool_mint = Self::unpack_mint(pool_mint_info, token_swap.token_program_id())?;\n\n        // Take transfer fees into account for actual amount transferred in\n        let actual_amount_in = {\n            let source_mint_data = source_token_mint_info.data.borrow();\n            let source_mint = Self::unpack_mint_with_extensions(\n                &source_mint_data,\n                source_token_mint_info.owner,\n                token_swap.token_program_id(),\n            )?;\n\n            if let Ok(transfer_fee_config) = source_mint.get_extension::<TransferFeeConfig>() {\n                amount_in.saturating_sub(\n                    transfer_fee_config\n                        .calculate_epoch_fee(Clock::get()?.epoch, amount_in)\n                        .ok_or(SwapError::FeeCalculationFailure)?,\n                )\n            }",
    "pub fn process_deposit_all_token_types(\n        program_id: &Pubkey,\n        pool_token_amount: u64,\n        maximum_token_a_amount: u64,\n        maximum_token_b_amount: u64,\n        accounts: &[AccountInfo],\n    ) -> ProgramResult {\n        let account_info_iter = &mut accounts.iter();\n        let swap_info = next_account_info(account_info_iter)?;\n        let authority_info = next_account_info(account_info_iter)?;\n        let user_transfer_authority_info = next_account_info(account_info_iter)?;\n        let source_a_info = next_account_info(account_info_iter)?;\n        let source_b_info = next_account_info(account_info_iter)?;\n        let token_a_info = next_account_info(account_info_iter)?;\n        let token_b_info = next_account_info(account_info_iter)?;\n        let pool_mint_info = next_account_info(account_info_iter)?;\n        let dest_info = next_account_info(account_info_iter)?;\n        let token_a_mint_info = next_account_info(account_info_iter)?;\n        let token_b_mint_info = next_account_info(account_info_iter)?;\n        let token_a_program_info = next_account_info(account_info_iter)?;\n        let token_b_program_info = next_account_info(account_info_iter)?;\n        let pool_token_program_info = next_account_info(account_info_iter)?;\n\n        let token_swap = SwapVersion::unpack(&swap_info.data.borrow())?;\n        let calculator = &token_swap.swap_curve().calculator;\n        if !calculator.allows_deposits() {\n            return Err(SwapError::UnsupportedCurveOperation.into());\n        }\n        Self::check_accounts(\n            token_swap.as_ref(),\n            program_id,\n            swap_info,\n            authority_info,\n            token_a_info,\n            token_b_info,\n            pool_mint_info,\n            pool_token_program_info,\n            Some(source_a_info),\n            Some(source_b_info),\n            None,\n        )?;\n\n        let token_a = Self::unpack_token_account(token_a_info, token_swap.token_program_id())?;\n        let token_b = Self::unpack_token_account(token_b_info, token_swap.token_program_id())?;\n        let pool_mint = Self::unpack_mint(pool_mint_info, token_swap.token_program_id())?;\n        let current_pool_mint_supply = u128::from(pool_mint.supply);\n        let (pool_token_amount, pool_mint_supply) = if current_pool_mint_supply > 0 {\n            (u128::from(pool_token_amount), current_pool_mint_supply)\n        }",
    "pub fn process_withdraw_all_token_types(\n        program_id: &Pubkey,\n        pool_token_amount: u64,\n        minimum_token_a_amount: u64,\n        minimum_token_b_amount: u64,\n        accounts: &[AccountInfo],\n    ) -> ProgramResult {\n        let account_info_iter = &mut accounts.iter();\n        let swap_info = next_account_info(account_info_iter)?;\n        let authority_info = next_account_info(account_info_iter)?;\n        let user_transfer_authority_info = next_account_info(account_info_iter)?;\n        let pool_mint_info = next_account_info(account_info_iter)?;\n        let source_info = next_account_info(account_info_iter)?;\n        let token_a_info = next_account_info(account_info_iter)?;\n        let token_b_info = next_account_info(account_info_iter)?;\n        let dest_token_a_info = next_account_info(account_info_iter)?;\n        let dest_token_b_info = next_account_info(account_info_iter)?;\n        let pool_fee_account_info = next_account_info(account_info_iter)?;\n        let token_a_mint_info = next_account_info(account_info_iter)?;\n        let token_b_mint_info = next_account_info(account_info_iter)?;\n        let pool_token_program_info = next_account_info(account_info_iter)?;\n        let token_a_program_info = next_account_info(account_info_iter)?;\n        let token_b_program_info = next_account_info(account_info_iter)?;\n\n        let token_swap = SwapVersion::unpack(&swap_info.data.borrow())?;\n        Self::check_accounts(\n            token_swap.as_ref(),\n            program_id,\n            swap_info,\n            authority_info,\n            token_a_info,\n            token_b_info,\n            pool_mint_info,\n            pool_token_program_info,\n            Some(dest_token_a_info),\n            Some(dest_token_b_info),\n            Some(pool_fee_account_info),\n        )?;\n\n        let token_a = Self::unpack_token_account(token_a_info, token_swap.token_program_id())?;\n        let token_b = Self::unpack_token_account(token_b_info, token_swap.token_program_id())?;\n        let pool_mint = Self::unpack_mint(pool_mint_info, token_swap.token_program_id())?;\n\n        let calculator = &token_swap.swap_curve().calculator;\n\n        let withdraw_fee = match token_swap.check_pool_fee_info(pool_fee_account_info) {\n            Ok(_) => {\n                if *pool_fee_account_info.key == *source_info.key {\n                    // withdrawing from the fee account, don't assess withdraw fee\n                    0\n                } else {\n                    token_swap\n                        .fees()\n                        .owner_withdraw_fee(u128::from(pool_token_amount))\n                        .ok_or(SwapError::FeeCalculationFailure)?\n                }\n            }\n            Err(_) => 0,\n        };\n        let pool_token_amount = u128::from(pool_token_amount)\n            .checked_sub(withdraw_fee)\n            .ok_or(SwapError::CalculationFailure)?;\n\n        let results = calculator\n            .pool_tokens_to_trading_tokens(\n                pool_token_amount,\n                u128::from(pool_mint.supply),\n                u128::from(token_a.amount),\n                u128::from(token_b.amount),\n                RoundDirection::Floor,\n            )\n            .ok_or(SwapError::ZeroTradingTokens)?;\n        let token_a_amount = to_u64(results.token_a_amount)?;\n        let token_a_amount = std::cmp::min(token_a.amount, token_a_amount);\n        if token_a_amount < minimum_token_a_amount {\n            return Err(SwapError::ExceededSlippage.into());\n        }\n        if token_a_amount == 0 && token_a.amount != 0 {\n            return Err(SwapError::ZeroTradingTokens.into());\n        }\n        let token_b_amount = to_u64(results.token_b_amount)?;\n        let token_b_amount = std::cmp::min(token_b.amount, token_b_amount);\n        if token_b_amount < minimum_token_b_amount {\n            return Err(SwapError::ExceededSlippage.into());\n        }\n        if token_b_amount == 0 && token_b.amount != 0 {\n            return Err(SwapError::ZeroTradingTokens.into());\n        }\n\n        if withdraw_fee > 0 {\n            Self::token_transfer(\n                swap_info.key,\n                pool_token_program_info.clone(),\n                source_info.clone(),\n                pool_mint_info.clone(),\n                pool_fee_account_info.clone(),\n                user_transfer_authority_info.clone(),\n                token_swap.bump_seed(),\n                to_u64(withdraw_fee)?,\n                pool_mint.decimals,\n            )?;\n        }\n        Self::token_burn(\n            swap_info.key,\n            pool_token_program_info.clone(),\n            source_info.clone(),\n            pool_mint_info.clone(),\n            user_transfer_authority_info.clone(),\n            token_swap.bump_seed(),\n            to_u64(pool_token_amount)?,\n        )?;\n\n        if token_a_amount > 0 {\n            Self::token_transfer(\n                swap_info.key,\n                token_a_program_info.clone(),\n                token_a_info.clone(),\n                token_a_mint_info.clone(),\n                dest_token_a_info.clone(),\n                authority_info.clone(),\n                token_swap.bump_seed(),\n                token_a_amount,\n                Self::unpack_mint(token_a_mint_info, token_swap.token_program_id())?.decimals,\n            )?;\n        }\n        if token_b_amount > 0 {\n            Self::token_transfer(\n                swap_info.key,\n                token_b_program_info.clone(),\n                token_b_info.clone(),\n                token_b_mint_info.clone(),\n                dest_token_b_info.clone(),\n                authority_info.clone(),\n                token_swap.bump_seed(),\n                token_b_amount,\n                Self::unpack_mint(token_b_mint_info, token_swap.token_program_id())?.decimals,\n            )?;\n        }\n        Ok(())\n    }",
    "pub fn process_deposit_single_token_type_exact_amount_in(\n        program_id: &Pubkey,\n        source_token_amount: u64,\n        minimum_pool_token_amount: u64,\n        accounts: &[AccountInfo],\n    ) -> ProgramResult {\n        let account_info_iter = &mut accounts.iter();\n        let swap_info = next_account_info(account_info_iter)?;\n        let authority_info = next_account_info(account_info_iter)?;\n        let user_transfer_authority_info = next_account_info(account_info_iter)?;\n        let source_info = next_account_info(account_info_iter)?;\n        let swap_token_a_info = next_account_info(account_info_iter)?;\n        let swap_token_b_info = next_account_info(account_info_iter)?;\n        let pool_mint_info = next_account_info(account_info_iter)?;\n        let destination_info = next_account_info(account_info_iter)?;\n        let source_token_mint_info = next_account_info(account_info_iter)?;\n        let source_token_program_info = next_account_info(account_info_iter)?;\n        let pool_token_program_info = next_account_info(account_info_iter)?;\n\n        let token_swap = SwapVersion::unpack(&swap_info.data.borrow())?;\n        let calculator = &token_swap.swap_curve().calculator;\n        if !calculator.allows_deposits() {\n            return Err(SwapError::UnsupportedCurveOperation.into());\n        }\n        let source_account =\n            Self::unpack_token_account(source_info, token_swap.token_program_id())?;\n        let swap_token_a =\n            Self::unpack_token_account(swap_token_a_info, token_swap.token_program_id())?;\n        let swap_token_b =\n            Self::unpack_token_account(swap_token_b_info, token_swap.token_program_id())?;\n\n        let trade_direction = if source_account.mint == swap_token_a.mint {\n            TradeDirection::AtoB\n        } else if source_account.mint == swap_token_b.mint {\n            TradeDirection::BtoA\n        } else {\n            return Err(SwapError::IncorrectSwapAccount.into());\n        };\n\n        let (source_a_info, source_b_info) = match trade_direction {\n            TradeDirection::AtoB => (Some(source_info), None),\n            TradeDirection::BtoA => (None, Some(source_info)),\n        };\n\n        Self::check_accounts(\n            token_swap.as_ref(),\n            program_id,\n            swap_info,\n            authority_info,\n            swap_token_a_info,\n            swap_token_b_info,\n            pool_mint_info,\n            pool_token_program_info,\n            source_a_info,\n            source_b_info,\n            None,\n        )?;\n\n        let pool_mint = Self::unpack_mint(pool_mint_info, token_swap.token_program_id())?;\n        let pool_mint_supply = u128::from(pool_mint.supply);\n        let pool_token_amount = if pool_mint_supply > 0 {\n            token_swap\n                .swap_curve()\n                .deposit_single_token_type(\n                    u128::from(source_token_amount),\n                    u128::from(swap_token_a.amount),\n                    u128::from(swap_token_b.amount),\n                    pool_mint_supply,\n                    trade_direction,\n                    token_swap.fees(),\n                )\n                .ok_or(SwapError::ZeroTradingTokens)?\n        } else {\n            calculator.new_pool_supply()\n        }",
    "pub fn process_withdraw_single_token_type_exact_amount_out(\n        program_id: &Pubkey,\n        destination_token_amount: u64,\n        maximum_pool_token_amount: u64,\n        accounts: &[AccountInfo],\n    ) -> ProgramResult {\n        let account_info_iter = &mut accounts.iter();\n        let swap_info = next_account_info(account_info_iter)?;\n        let authority_info = next_account_info(account_info_iter)?;\n        let user_transfer_authority_info = next_account_info(account_info_iter)?;\n        let pool_mint_info = next_account_info(account_info_iter)?;\n        let source_info = next_account_info(account_info_iter)?;\n        let swap_token_a_info = next_account_info(account_info_iter)?;\n        let swap_token_b_info = next_account_info(account_info_iter)?;\n        let destination_info = next_account_info(account_info_iter)?;\n        let pool_fee_account_info = next_account_info(account_info_iter)?;\n        let destination_token_mint_info = next_account_info(account_info_iter)?;\n        let pool_token_program_info = next_account_info(account_info_iter)?;\n        let destination_token_program_info = next_account_info(account_info_iter)?;\n\n        let token_swap = SwapVersion::unpack(&swap_info.data.borrow())?;\n        let destination_account =\n            Self::unpack_token_account(destination_info, token_swap.token_program_id())?;\n        let swap_token_a =\n            Self::unpack_token_account(swap_token_a_info, token_swap.token_program_id())?;\n        let swap_token_b =\n            Self::unpack_token_account(swap_token_b_info, token_swap.token_program_id())?;\n\n        let trade_direction = if destination_account.mint == swap_token_a.mint {\n            TradeDirection::AtoB\n        } else if destination_account.mint == swap_token_b.mint {\n            TradeDirection::BtoA\n        } else {\n            return Err(SwapError::IncorrectSwapAccount.into());\n        };\n\n        let (destination_a_info, destination_b_info) = match trade_direction {\n            TradeDirection::AtoB => (Some(destination_info), None),\n            TradeDirection::BtoA => (None, Some(destination_info)),\n        };\n        Self::check_accounts(\n            token_swap.as_ref(),\n            program_id,\n            swap_info,\n            authority_info,\n            swap_token_a_info,\n            swap_token_b_info,\n            pool_mint_info,\n            pool_token_program_info,\n            destination_a_info,\n            destination_b_info,\n            Some(pool_fee_account_info),\n        )?;\n\n        let pool_mint = Self::unpack_mint(pool_mint_info, token_swap.token_program_id())?;\n        let pool_mint_supply = u128::from(pool_mint.supply);\n        let swap_token_a_amount = u128::from(swap_token_a.amount);\n        let swap_token_b_amount = u128::from(swap_token_b.amount);\n\n        let burn_pool_token_amount = token_swap\n            .swap_curve()\n            .withdraw_single_token_type_exact_out(\n                u128::from(destination_token_amount),\n                swap_token_a_amount,\n                swap_token_b_amount,\n                pool_mint_supply,\n                trade_direction,\n                token_swap.fees(),\n            )\n            .ok_or(SwapError::ZeroTradingTokens)?;\n\n        let withdraw_fee = match token_swap.check_pool_fee_info(pool_fee_account_info) {\n            Ok(_) => {\n                if *pool_fee_account_info.key == *source_info.key {\n                    // withdrawing from the fee account, don't assess withdraw fee\n                    0\n                } else {\n                    token_swap\n                        .fees()\n                        .owner_withdraw_fee(burn_pool_token_amount)\n                        .ok_or(SwapError::FeeCalculationFailure)?\n                }\n            }\n            Err(_) => 0,\n        };\n        let pool_token_amount = burn_pool_token_amount\n            .checked_add(withdraw_fee)\n            .ok_or(SwapError::CalculationFailure)?;\n\n        if to_u64(pool_token_amount)? > maximum_pool_token_amount {\n            return Err(SwapError::ExceededSlippage.into());\n        }\n        if pool_token_amount == 0 {\n            return Err(SwapError::ZeroTradingTokens.into());\n        }\n\n        if withdraw_fee > 0 {\n            Self::token_transfer(\n                swap_info.key,\n                pool_token_program_info.clone(),\n                source_info.clone(),\n                pool_mint_info.clone(),\n                pool_fee_account_info.clone(),\n                user_transfer_authority_info.clone(),\n                token_swap.bump_seed(),\n                to_u64(withdraw_fee)?,\n                pool_mint.decimals,\n            )?;\n        }\n        Self::token_burn(\n            swap_info.key,\n            pool_token_program_info.clone(),\n            source_info.clone(),\n            pool_mint_info.clone(),\n            user_transfer_authority_info.clone(),\n            token_swap.bump_seed(),\n            to_u64(burn_pool_token_amount)?,\n        )?;\n\n        match trade_direction {\n            TradeDirection::AtoB => {\n                Self::token_transfer(\n                    swap_info.key,\n                    destination_token_program_info.clone(),\n                    swap_token_a_info.clone(),\n                    destination_token_mint_info.clone(),\n                    destination_info.clone(),\n                    authority_info.clone(),\n                    token_swap.bump_seed(),\n                    destination_token_amount,\n                    Self::unpack_mint(destination_token_mint_info, token_swap.token_program_id())?\n                        .decimals,\n                )?;\n            }\n            TradeDirection::BtoA => {\n                Self::token_transfer(\n                    swap_info.key,\n                    destination_token_program_info.clone(),\n                    swap_token_b_info.clone(),\n                    destination_token_mint_info.clone(),\n                    destination_info.clone(),\n                    authority_info.clone(),\n                    token_swap.bump_seed(),\n                    destination_token_amount,\n                    Self::unpack_mint(destination_token_mint_info, token_swap.token_program_id())?\n                        .decimals,\n                )?;\n            }\n        }\n\n        Ok(())\n    }",
    "pub fn process(program_id: &Pubkey, accounts: &[AccountInfo], input: &[u8]) -> ProgramResult {\n        Self::process_with_constraints(program_id, accounts, input, &SWAP_CONSTRAINTS)\n    }",
    "pub fn process_with_constraints(\n        program_id: &Pubkey,\n        accounts: &[AccountInfo],\n        input: &[u8],\n        swap_constraints: &Option<SwapConstraints>,\n    ) -> ProgramResult {\n        let instruction = SwapInstruction::unpack(input)?;\n        match instruction {\n            SwapInstruction::Initialize(Initialize { fees, swap_curve }) => {\n                msg!(\"Instruction: Init\");\n                Self::process_initialize(program_id, fees, swap_curve, accounts, swap_constraints)\n            }",
    "pub fn new(\n            user_key: &Pubkey,\n            fees: Fees,\n            transfer_fees: SwapTransferFees,\n            swap_curve: SwapCurve,\n            token_a_amount: u64,\n            token_b_amount: u64,\n            pool_token_program_id: &Pubkey,\n            token_a_program_id: &Pubkey,\n            token_b_program_id: &Pubkey,\n        ) -> Self {\n            let swap_key = Pubkey::new_unique();\n            let swap_account = SolanaAccount::new(0, SwapVersion::LATEST_LEN, &SWAP_PROGRAM_ID);\n            let (authority_key, bump_seed) =\n                Pubkey::find_program_address(&[&swap_key.to_bytes()[..]], &SWAP_PROGRAM_ID);\n\n            let (pool_mint_key, mut pool_mint_account) = create_mint(\n                pool_token_program_id,\n                &authority_key,\n                None,\n                None,\n                &transfer_fees.pool_token,\n            );\n            let (pool_token_key, pool_token_account) = mint_token(\n                pool_token_program_id,\n                &pool_mint_key,\n                &mut pool_mint_account,\n                &authority_key,\n                user_key,\n                0,\n            );\n            let (pool_fee_key, pool_fee_account) = mint_token(\n                pool_token_program_id,\n                &pool_mint_key,\n                &mut pool_mint_account,\n                &authority_key,\n                user_key,\n                0,\n            );\n            let (token_a_mint_key, mut token_a_mint_account) = create_mint(\n                token_a_program_id,\n                user_key,\n                None,\n                None,\n                &transfer_fees.token_a,\n            );\n            let (token_a_key, token_a_account) = mint_token(\n                token_a_program_id,\n                &token_a_mint_key,\n                &mut token_a_mint_account,\n                user_key,\n                &authority_key,\n                token_a_amount,\n            );\n            let (token_b_mint_key, mut token_b_mint_account) = create_mint(\n                token_b_program_id,\n                user_key,\n                None,\n                None,\n                &transfer_fees.token_b,\n            );\n            let (token_b_key, token_b_account) = mint_token(\n                token_b_program_id,\n                &token_b_mint_key,\n                &mut token_b_mint_account,\n                user_key,\n                &authority_key,\n                token_b_amount,\n            );\n\n            SwapAccountInfo {\n                bump_seed,\n                authority_key,\n                fees,\n                transfer_fees,\n                swap_curve,\n                swap_key,\n                swap_account,\n                pool_mint_key,\n                pool_mint_account,\n                pool_fee_key,\n                pool_fee_account,\n                pool_token_key,\n                pool_token_account,\n                token_a_key,\n                token_a_account,\n                token_a_mint_key,\n                token_a_mint_account,\n                token_b_key,\n                token_b_account,\n                token_b_mint_key,\n                token_b_mint_account,\n                pool_token_program_id: *pool_token_program_id,\n                token_a_program_id: *token_a_program_id,\n                token_b_program_id: *token_b_program_id,\n            }\n        }\n\n        pub fn initialize_swap(&mut self) -> ProgramResult {\n            do_process_instruction(\n                initialize(\n                    &SWAP_PROGRAM_ID,\n                    &self.pool_token_program_id,\n                    &self.swap_key,\n                    &self.authority_key,\n                    &self.token_a_key,\n                    &self.token_b_key,\n                    &self.pool_mint_key,\n                    &self.pool_fee_key,\n                    &self.pool_token_key,\n                    self.fees.clone(),\n                    self.swap_curve.clone(),\n                )\n                .unwrap(),\n                vec![\n                    &mut self.swap_account,\n                    &mut SolanaAccount::default(),\n                    &mut self.token_a_account,\n                    &mut self.token_b_account,\n                    &mut self.pool_mint_account,\n                    &mut self.pool_fee_account,\n                    &mut self.pool_token_account,\n                    &mut SolanaAccount::default(),\n                ],\n            )\n        }",
    "pub fn setup_token_accounts(\n            &mut self,\n            mint_owner: &Pubkey,\n            account_owner: &Pubkey,\n            a_amount: u64,\n            b_amount: u64,\n            pool_amount: u64,\n        ) -> (\n            Pubkey,\n            SolanaAccount,\n            Pubkey,\n            SolanaAccount,\n            Pubkey,\n            SolanaAccount,\n        ) {\n            let (token_a_key, token_a_account) = mint_token(\n                &self.token_a_program_id,\n                &self.token_a_mint_key,\n                &mut self.token_a_mint_account,\n                mint_owner,\n                account_owner,\n                a_amount,\n            );\n            let (token_b_key, token_b_account) = mint_token(\n                &self.token_b_program_id,\n                &self.token_b_mint_key,\n                &mut self.token_b_mint_account,\n                mint_owner,\n                account_owner,\n                b_amount,\n            );\n            let (pool_key, pool_account) = mint_token(\n                &self.pool_token_program_id,\n                &self.pool_mint_key,\n                &mut self.pool_mint_account,\n                &self.authority_key,\n                account_owner,\n                pool_amount,\n            );\n            (\n                token_a_key,\n                token_a_account,\n                token_b_key,\n                token_b_account,\n                pool_key,\n                pool_account,\n            )\n        }",
    "pub fn swap(\n            &mut self,\n            user_key: &Pubkey,\n            user_source_key: &Pubkey,\n            user_source_account: &mut SolanaAccount,\n            swap_source_key: &Pubkey,\n            swap_destination_key: &Pubkey,\n            user_destination_key: &Pubkey,\n            user_destination_account: &mut SolanaAccount,\n            amount_in: u64,\n            minimum_amount_out: u64,\n        ) -> ProgramResult {\n            let user_transfer_key = Pubkey::new_unique();\n            let source_token_program_id = self.get_token_program_id(swap_source_key);\n            let destination_token_program_id = self.get_token_program_id(swap_destination_key);\n            // approve moving from user source account\n            do_process_instruction(\n                approve(\n                    source_token_program_id,\n                    user_source_key,\n                    &user_transfer_key,\n                    user_key,\n                    &[],\n                    amount_in,\n                )\n                .unwrap(),\n                vec![\n                    user_source_account,\n                    &mut SolanaAccount::default(),\n                    &mut SolanaAccount::default(),\n                ],\n            )\n            .unwrap();\n\n            let (source_mint_key, mut source_mint_account) = self.get_token_mint(swap_source_key);\n            let (destination_mint_key, mut destination_mint_account) =\n                self.get_token_mint(swap_destination_key);\n            let mut swap_source_account = self.get_token_account(swap_source_key).clone();\n            let mut swap_destination_account = self.get_token_account(swap_destination_key).clone();\n\n            // perform the swap\n            do_process_instruction(\n                swap(\n                    &SWAP_PROGRAM_ID,\n                    source_token_program_id,\n                    destination_token_program_id,\n                    &self.pool_token_program_id,\n                    &self.swap_key,\n                    &self.authority_key,\n                    &user_transfer_key,\n                    user_source_key,\n                    swap_source_key,\n                    swap_destination_key,\n                    user_destination_key,\n                    &self.pool_mint_key,\n                    &self.pool_fee_key,\n                    &source_mint_key,\n                    &destination_mint_key,\n                    None,\n                    Swap {\n                        amount_in,\n                        minimum_amount_out,\n                    },\n                )\n                .unwrap(),\n                vec![\n                    &mut self.swap_account,\n                    &mut SolanaAccount::default(),\n                    &mut SolanaAccount::default(),\n                    user_source_account,\n                    &mut swap_source_account,\n                    &mut swap_destination_account,\n                    user_destination_account,\n                    &mut self.pool_mint_account,\n                    &mut self.pool_fee_account,\n                    &mut source_mint_account,\n                    &mut destination_mint_account,\n                    &mut SolanaAccount::default(),\n                    &mut SolanaAccount::default(),\n                    &mut SolanaAccount::default(),\n                ],\n            )?;\n\n            self.set_token_account(swap_source_key, swap_source_account);\n            self.set_token_account(swap_destination_key, swap_destination_account);\n\n            Ok(())\n        }",
    "pub fn deposit_all_token_types(\n            &mut self,\n            depositor_key: &Pubkey,\n            depositor_token_a_key: &Pubkey,\n            depositor_token_a_account: &mut SolanaAccount,\n            depositor_token_b_key: &Pubkey,\n            depositor_token_b_account: &mut SolanaAccount,\n            depositor_pool_key: &Pubkey,\n            depositor_pool_account: &mut SolanaAccount,\n            pool_token_amount: u64,\n            maximum_token_a_amount: u64,\n            maximum_token_b_amount: u64,\n        ) -> ProgramResult {\n            let user_transfer_authority = Pubkey::new_unique();\n            let token_a_program_id = depositor_token_a_account.owner;\n            do_process_instruction(\n                approve(\n                    &token_a_program_id,\n                    depositor_token_a_key,\n                    &user_transfer_authority,\n                    depositor_key,\n                    &[],\n                    maximum_token_a_amount,\n                )\n                .unwrap(),\n                vec![\n                    depositor_token_a_account,\n                    &mut SolanaAccount::default(),\n                    &mut SolanaAccount::default(),\n                ],\n            )\n            .unwrap();\n\n            let token_b_program_id = depositor_token_b_account.owner;\n            do_process_instruction(\n                approve(\n                    &token_b_program_id,\n                    depositor_token_b_key,\n                    &user_transfer_authority,\n                    depositor_key,\n                    &[],\n                    maximum_token_b_amount,\n                )\n                .unwrap(),\n                vec![\n                    depositor_token_b_account,\n                    &mut SolanaAccount::default(),\n                    &mut SolanaAccount::default(),\n                ],\n            )\n            .unwrap();\n\n            let pool_token_program_id = depositor_pool_account.owner;\n            do_process_instruction(\n                deposit_all_token_types(\n                    &SWAP_PROGRAM_ID,\n                    &token_a_program_id,\n                    &token_b_program_id,\n                    &pool_token_program_id,\n                    &self.swap_key,\n                    &self.authority_key,\n                    &user_transfer_authority,\n                    depositor_token_a_key,\n                    depositor_token_b_key,\n                    &self.token_a_key,\n                    &self.token_b_key,\n                    &self.pool_mint_key,\n                    depositor_pool_key,\n                    &self.token_a_mint_key,\n                    &self.token_b_mint_key,\n                    DepositAllTokenTypes {\n                        pool_token_amount,\n                        maximum_token_a_amount,\n                        maximum_token_b_amount,\n                    },\n                )\n                .unwrap(),\n                vec![\n                    &mut self.swap_account,\n                    &mut SolanaAccount::default(),\n                    &mut SolanaAccount::default(),\n                    depositor_token_a_account,\n                    depositor_token_b_account,\n                    &mut self.token_a_account,\n                    &mut self.token_b_account,\n                    &mut self.pool_mint_account,\n                    depositor_pool_account,\n                    &mut self.token_a_mint_account,\n                    &mut self.token_b_mint_account,\n                    &mut SolanaAccount::default(),\n                    &mut SolanaAccount::default(),\n                    &mut SolanaAccount::default(),\n                ],\n            )\n        }",
    "pub fn withdraw_all_token_types(\n            &mut self,\n            user_key: &Pubkey,\n            pool_key: &Pubkey,\n            pool_account: &mut SolanaAccount,\n            token_a_key: &Pubkey,\n            token_a_account: &mut SolanaAccount,\n            token_b_key: &Pubkey,\n            token_b_account: &mut SolanaAccount,\n            pool_token_amount: u64,\n            minimum_token_a_amount: u64,\n            minimum_token_b_amount: u64,\n        ) -> ProgramResult {\n            let user_transfer_authority_key = Pubkey::new_unique();\n            let pool_token_program_id = pool_account.owner;\n            // approve user transfer authority to take out pool tokens\n            do_process_instruction(\n                approve(\n                    &pool_token_program_id,\n                    pool_key,\n                    &user_transfer_authority_key,\n                    user_key,\n                    &[],\n                    pool_token_amount,\n                )\n                .unwrap(),\n                vec![\n                    pool_account,\n                    &mut SolanaAccount::default(),\n                    &mut SolanaAccount::default(),\n                ],\n            )\n            .unwrap();\n\n            // withdraw token a and b correctly\n            let token_a_program_id = token_a_account.owner;\n            let token_b_program_id = token_b_account.owner;\n            do_process_instruction(\n                withdraw_all_token_types(\n                    &SWAP_PROGRAM_ID,\n                    &pool_token_program_id,\n                    &token_a_program_id,\n                    &token_b_program_id,\n                    &self.swap_key,\n                    &self.authority_key,\n                    &user_transfer_authority_key,\n                    &self.pool_mint_key,\n                    &self.pool_fee_key,\n                    pool_key,\n                    &self.token_a_key,\n                    &self.token_b_key,\n                    token_a_key,\n                    token_b_key,\n                    &self.token_a_mint_key,\n                    &self.token_b_mint_key,\n                    WithdrawAllTokenTypes {\n                        pool_token_amount,\n                        minimum_token_a_amount,\n                        minimum_token_b_amount,\n                    },\n                )\n                .unwrap(),\n                vec![\n                    &mut self.swap_account,\n                    &mut SolanaAccount::default(),\n                    &mut SolanaAccount::default(),\n                    &mut self.pool_mint_account,\n                    pool_account,\n                    &mut self.token_a_account,\n                    &mut self.token_b_account,\n                    token_a_account,\n                    token_b_account,\n                    &mut self.pool_fee_account,\n                    &mut self.token_a_mint_account,\n                    &mut self.token_b_mint_account,\n                    &mut SolanaAccount::default(),\n                    &mut SolanaAccount::default(),\n                    &mut SolanaAccount::default(),\n                ],\n            )\n        }",
    "pub fn deposit_single_token_type_exact_amount_in(\n            &mut self,\n            depositor_key: &Pubkey,\n            deposit_account_key: &Pubkey,\n            deposit_token_account: &mut SolanaAccount,\n            deposit_pool_key: &Pubkey,\n            deposit_pool_account: &mut SolanaAccount,\n            source_token_amount: u64,\n            minimum_pool_token_amount: u64,\n        ) -> ProgramResult {\n            let user_transfer_authority_key = Pubkey::new_unique();\n            let source_token_program_id = deposit_token_account.owner;\n            do_process_instruction(\n                approve(\n                    &source_token_program_id,\n                    deposit_account_key,\n                    &user_transfer_authority_key,\n                    depositor_key,\n                    &[],\n                    source_token_amount,\n                )\n                .unwrap(),\n                vec![\n                    deposit_token_account,\n                    &mut SolanaAccount::default(),\n                    &mut SolanaAccount::default(),\n                ],\n            )\n            .unwrap();\n\n            let source_mint_key =\n                StateWithExtensions::<Account>::unpack(&deposit_token_account.data)\n                    .unwrap()\n                    .base\n                    .mint;\n            let swap_source_key = self.get_swap_key(&source_mint_key);\n            let (source_mint_key, mut source_mint_account) = self.get_token_mint(swap_source_key);\n\n            let pool_token_program_id = deposit_pool_account.owner;\n            do_process_instruction(\n                deposit_single_token_type_exact_amount_in(\n                    &SWAP_PROGRAM_ID,\n                    &source_token_program_id,\n                    &pool_token_program_id,\n                    &self.swap_key,\n                    &self.authority_key,\n                    &user_transfer_authority_key,\n                    deposit_account_key,\n                    &self.token_a_key,\n                    &self.token_b_key,\n                    &self.pool_mint_key,\n                    deposit_pool_key,\n                    &source_mint_key,\n                    DepositSingleTokenTypeExactAmountIn {\n                        source_token_amount,\n                        minimum_pool_token_amount,\n                    },\n                )\n                .unwrap(),\n                vec![\n                    &mut self.swap_account,\n                    &mut SolanaAccount::default(),\n                    &mut SolanaAccount::default(),\n                    deposit_token_account,\n                    &mut self.token_a_account,\n                    &mut self.token_b_account,\n                    &mut self.pool_mint_account,\n                    deposit_pool_account,\n                    &mut source_mint_account,\n                    &mut SolanaAccount::default(),\n                    &mut SolanaAccount::default(),\n                ],\n            )\n        }",
    "pub fn withdraw_single_token_type_exact_amount_out(\n            &mut self,\n            user_key: &Pubkey,\n            pool_key: &Pubkey,\n            pool_account: &mut SolanaAccount,\n            destination_key: &Pubkey,\n            destination_account: &mut SolanaAccount,\n            destination_token_amount: u64,\n            maximum_pool_token_amount: u64,\n        ) -> ProgramResult {\n            let user_transfer_authority_key = Pubkey::new_unique();\n            let pool_token_program_id = pool_account.owner;\n            // approve user transfer authority to take out pool tokens\n            do_process_instruction(\n                approve(\n                    &pool_token_program_id,\n                    pool_key,\n                    &user_transfer_authority_key,\n                    user_key,\n                    &[],\n                    maximum_pool_token_amount,\n                )\n                .unwrap(),\n                vec![\n                    pool_account,\n                    &mut SolanaAccount::default(),\n                    &mut SolanaAccount::default(),\n                ],\n            )\n            .unwrap();\n\n            let destination_mint_key =\n                StateWithExtensions::<Account>::unpack(&destination_account.data)\n                    .unwrap()\n                    .base\n                    .mint;\n            let swap_destination_key = self.get_swap_key(&destination_mint_key);\n            let (destination_mint_key, mut destination_mint_account) =\n                self.get_token_mint(swap_destination_key);\n\n            let destination_token_program_id = destination_account.owner;\n            do_process_instruction(\n                withdraw_single_token_type_exact_amount_out(\n                    &SWAP_PROGRAM_ID,\n                    &pool_token_program_id,\n                    &destination_token_program_id,\n                    &self.swap_key,\n                    &self.authority_key,\n                    &user_transfer_authority_key,\n                    &self.pool_mint_key,\n                    &self.pool_fee_key,\n                    pool_key,\n                    &self.token_a_key,\n                    &self.token_b_key,\n                    destination_key,\n                    &destination_mint_key,\n                    WithdrawSingleTokenTypeExactAmountOut {\n                        destination_token_amount,\n                        maximum_pool_token_amount,\n                    },\n                )\n                .unwrap(),\n                vec![\n                    &mut self.swap_account,\n                    &mut SolanaAccount::default(),\n                    &mut SolanaAccount::default(),\n                    &mut self.pool_mint_account,\n                    pool_account,\n                    &mut self.token_a_account,\n                    &mut self.token_b_account,\n                    destination_account,\n                    &mut self.pool_fee_account,\n                    &mut destination_mint_account,\n                    &mut SolanaAccount::default(),\n                    &mut SolanaAccount::default(),\n                ],\n            )\n        }",
    "pub fn pack(src: Self, dst: &mut [u8]) -> Result<(), ProgramError> {\n        match src {\n            Self::SwapV1(swap_info) => {\n                dst[0] = 1;\n                SwapV1::pack(swap_info, &mut dst[1..])\n            }",
    "pub fn unpack(input: &[u8]) -> Result<Arc<dyn SwapState>, ProgramError> {\n        let (&version, rest) = input\n            .split_first()\n            .ok_or(ProgramError::InvalidAccountData)?;\n        match version {\n            1 => Ok(Arc::new(SwapV1::unpack(rest)?)),\n            _ => Err(ProgramError::UninitializedAccount),\n        }\n    }\n\n    /// Special check to be done before any instruction processing, works for\n    /// all versions\n    pub fn is_initialized(input: &[u8]) -> bool {\n        match Self::unpack(input) {\n            Ok(swap) => swap.is_initialized(),\n            Err(_) => false,\n        }\n    }\n}\n\n/// Program states.\n#[repr(C)]\n#[derive(Debug, Default, PartialEq)]\npub struct SwapV1 {\n    /// Initialized state.\n    pub is_initialized: bool,\n    /// Bump seed used in program address.\n    /// The program address is created deterministically with the bump seed,\n    /// swap program id, and swap account pubkey.  This program address has\n    /// authority over the swap's token A account, token B account, and pool\n    /// token mint.\n    pub bump_seed: u8,\n\n    /// Program ID of the tokens being exchanged.\n    pub token_program_id: Pubkey,\n\n    /// Token A\n    pub token_a: Pubkey,\n    /// Token B\n    pub token_b: Pubkey,\n\n    /// Pool tokens are issued when A or B tokens are deposited.\n    /// Pool tokens can be withdrawn back to the original A or B token.\n    pub pool_mint: Pubkey,\n\n    /// Mint information for token A\n    pub token_a_mint: Pubkey,\n    /// Mint information for token B\n    pub token_b_mint: Pubkey,\n\n    /// Pool token account to receive trading and / or withdrawal fees\n    pub pool_fee_account: Pubkey,\n\n    /// All fee information\n    pub fees: Fees,\n\n    /// Swap curve parameters, to be unpacked and used by the SwapCurve, which\n    /// calculates swaps, deposits, and withdrawals\n    pub swap_curve: SwapCurve,\n}\n\nimpl SwapState for SwapV1 {\n    fn is_initialized(&self) -> bool {\n        self.is_initialized\n    }\n\n    fn bump_seed(&self) -> u8 {\n        self.bump_seed\n    }\n\n    fn token_program_id(&self) -> &Pubkey {\n        &self.token_program_id\n    }\n\n    fn token_a_account(&self) -> &Pubkey {\n        &self.token_a\n    }\n\n    fn token_b_account(&self) -> &Pubkey {\n        &self.token_b\n    }\n\n    fn pool_mint(&self) -> &Pubkey {\n        &self.pool_mint\n    }\n\n    fn token_a_mint(&self) -> &Pubkey {\n        &self.token_a_mint\n    }\n\n    fn token_b_mint(&self) -> &Pubkey {\n        &self.token_b_mint\n    }\n\n    fn pool_fee_account(&self) -> &Pubkey {\n        &self.pool_fee_account\n    }\n\n    fn check_pool_fee_info(&self, pool_fee_info: &AccountInfo) -> Result<(), ProgramError> {\n        let data = &pool_fee_info.data.borrow();\n        let token_account =\n            StateWithExtensions::<Account>::unpack(data).map_err(|err| match err {\n                ProgramError::InvalidAccountData | ProgramError::UninitializedAccount => {\n                    SwapError::InvalidFeeAccount.into()\n                }",
    "pub fn swap(\n        &self,\n        source_amount: u128,\n        swap_source_amount: u128,\n        swap_destination_amount: u128,\n        trade_direction: TradeDirection,\n        fees: &Fees,\n    ) -> Option<SwapResult> {\n        // debit the fee to calculate the amount swapped\n        let trade_fee = fees.trading_fee(source_amount)?;\n        let owner_fee = fees.owner_trading_fee(source_amount)?;\n\n        let total_fees = trade_fee.checked_add(owner_fee)?;\n        let source_amount_less_fees = source_amount.checked_sub(total_fees)?;\n\n        let SwapWithoutFeesResult {\n            source_amount_swapped,\n            destination_amount_swapped,\n        } = self.calculator.swap_without_fees(\n            source_amount_less_fees,\n            swap_source_amount,\n            swap_destination_amount,\n            trade_direction,\n        )?;\n\n        let source_amount_swapped = source_amount_swapped.checked_add(total_fees)?;\n        Some(SwapResult {\n            new_swap_source_amount: swap_source_amount.checked_add(source_amount_swapped)?,\n            new_swap_destination_amount: swap_destination_amount\n                .checked_sub(destination_amount_swapped)?,\n            source_amount_swapped,\n            destination_amount_swapped,\n            trade_fee,\n            owner_fee,\n        })\n    }",
    "pub fn deposit_single_token_type(\n        &self,\n        source_amount: u128,\n        swap_token_a_amount: u128,\n        swap_token_b_amount: u128,\n        pool_supply: u128,\n        trade_direction: TradeDirection,\n        fees: &Fees,\n    ) -> Option<u128> {\n        if source_amount == 0 {\n            return Some(0);\n        }\n        // Get the trading fee incurred if *half* the source amount is swapped\n        // for the other side. Reference at:\n        // https://github.com/balancer-labs/balancer-core/blob/f4ed5d65362a8d6cec21662fb6eae233b0babc1f/contracts/BMath.sol#L117\n        let half_source_amount = std::cmp::max(1, source_amount.checked_div(2)?);\n        let trade_fee = fees.trading_fee(half_source_amount)?;\n        let owner_fee = fees.owner_trading_fee(half_source_amount)?;\n        let total_fees = trade_fee.checked_add(owner_fee)?;\n        let source_amount = source_amount.checked_sub(total_fees)?;\n        self.calculator.deposit_single_token_type(\n            source_amount,\n            swap_token_a_amount,\n            swap_token_b_amount,\n            pool_supply,\n            trade_direction,\n        )\n    }",
    "pub fn withdraw_single_token_type_exact_out(\n        &self,\n        source_amount: u128,\n        swap_token_a_amount: u128,\n        swap_token_b_amount: u128,\n        pool_supply: u128,\n        trade_direction: TradeDirection,\n        fees: &Fees,\n    ) -> Option<u128> {\n        if source_amount == 0 {\n            return Some(0);\n        }\n        // Since we want to get the amount required to get the exact amount out,\n        // we need the inverse trading fee incurred if *half* the source amount\n        // is swapped for the other side. Reference at:\n        // https://github.com/balancer-labs/balancer-core/blob/f4ed5d65362a8d6cec21662fb6eae233b0babc1f/contracts/BMath.sol#L117\n        let half_source_amount = source_amount.checked_add(1)?.checked_div(2)?; // round up\n        let pre_fee_source_amount = fees.pre_trading_fee_amount(half_source_amount)?;\n        let source_amount = source_amount\n            .checked_sub(half_source_amount)?\n            .checked_add(pre_fee_source_amount)?;\n        self.calculator.withdraw_single_token_type_exact_out(\n            source_amount,\n            swap_token_a_amount,\n            swap_token_b_amount,\n            pool_supply,\n            trade_direction,\n            RoundDirection::Ceiling,\n        )\n    }",
    "pub fn map_zero_to_none(x: u128) -> Option<u128> {\n    if x == 0 {\n        None\n    } else {\n        Some(x)\n    }",
    "pub fn opposite(&self) -> TradeDirection {\n        match self {\n            TradeDirection::AtoB => TradeDirection::BtoA,\n            TradeDirection::BtoA => TradeDirection::AtoB,\n        }\n    }\n}\n\n/// Encodes all results of swapping from a source token to a destination token\n#[derive(Debug, PartialEq)]\npub struct SwapWithoutFeesResult {\n    /// Amount of source token swapped\n    pub source_amount_swapped: u128,\n    /// Amount of destination token swapped\n    pub destination_amount_swapped: u128,\n}\n\n/// Encodes results of depositing both sides at once\n#[derive(Debug, PartialEq)]\npub struct TradingTokenResult {\n    /// Amount of token A\n    pub token_a_amount: u128,\n    /// Amount of token B\n    pub token_b_amount: u128,\n}\n\n/// Trait for packing of trait objects, required because structs that implement\n/// `Pack` cannot be used as trait objects (as `dyn Pack`).\npub trait DynPack {\n    /// Only required function is to pack given a trait object\n    fn pack_into_slice(&self, dst: &mut [u8]);\n}\n\n/// Trait representing operations required on a swap curve\npub trait CurveCalculator: Debug + DynPack {\n    /// Calculate how much destination token will be provided given an amount\n    /// of source token.\n    fn swap_without_fees(\n        &self,\n        source_amount: u128,\n        swap_source_amount: u128,\n        swap_destination_amount: u128,\n        trade_direction: TradeDirection,\n    ) -> Option<SwapWithoutFeesResult>;\n\n    /// Get the supply for a new pool\n    /// The default implementation is a Balancer-style fixed initial supply\n    fn new_pool_supply(&self) -> u128 {\n        INITIAL_SWAP_POOL_AMOUNT\n    }\n\n    /// Get the amount of trading tokens for the given amount of pool tokens,\n    /// provided the total trading tokens and supply of pool tokens.\n    fn pool_tokens_to_trading_tokens(\n        &self,\n        pool_tokens: u128,\n        pool_token_supply: u128,\n        swap_token_a_amount: u128,\n        swap_token_b_amount: u128,\n        round_direction: RoundDirection,\n    ) -> Option<TradingTokenResult>;\n\n    /// Get the amount of pool tokens for the deposited amount of token A or B.\n    ///\n    /// This is used for single-sided deposits.  It essentially performs a swap\n    /// followed by a deposit.  Because a swap is implicitly performed, this\n    /// will change the spot price of the pool.\n    ///\n    /// See more background for the calculation at:\n    ///\n    /// <https://balancer.finance/whitepaper/#single-asset-deposit-withdrawal>\n    fn deposit_single_token_type(\n        &self,\n        source_amount: u128,\n        swap_token_a_amount: u128,\n        swap_token_b_amount: u128,\n        pool_supply: u128,\n        trade_direction: TradeDirection,\n    ) -> Option<u128>;\n\n    /// Get the amount of pool tokens for the withdrawn amount of token A or B.\n    ///\n    /// This is used for single-sided withdrawals and owner trade fee\n    /// calculation. It essentially performs a withdrawal followed by a swap.\n    /// Because a swap is implicitly performed, this will change the spot price\n    /// of the pool.\n    ///\n    /// See more background for the calculation at:\n    ///\n    /// <https://balancer.finance/whitepaper/#single-asset-deposit-withdrawal>\n    fn withdraw_single_token_type_exact_out(\n        &self,\n        source_amount: u128,\n        swap_token_a_amount: u128,\n        swap_token_b_amount: u128,\n        pool_supply: u128,\n        trade_direction: TradeDirection,\n        round_direction: RoundDirection,\n    ) -> Option<u128>;\n\n    /// Validate that the given curve has no invalid parameters\n    fn validate(&self) -> Result<(), SwapError>;\n\n    /// Validate the given supply on initialization. This is useful for curves\n    /// that allow zero supply on one or both sides, since the standard constant\n    /// product curve must have a non-zero supply on both sides.\n    fn validate_supply(&self, token_a_amount: u64, token_b_amount: u64) -> Result<(), SwapError> {\n        if token_a_amount == 0 {\n            return Err(SwapError::EmptySupply);\n        }\n        if token_b_amount == 0 {\n            return Err(SwapError::EmptySupply);\n        }\n        Ok(())\n    }",
    "pub fn check_deposit_token_conversion(\n        curve: &dyn CurveCalculator,\n        source_token_amount: u128,\n        swap_source_amount: u128,\n        swap_destination_amount: u128,\n        trade_direction: TradeDirection,\n        pool_supply: u128,\n        epsilon_in_basis_points: u128,\n    ) {\n        let amount_to_swap = source_token_amount / 2;\n        let results = curve\n            .swap_without_fees(\n                amount_to_swap,\n                swap_source_amount,\n                swap_destination_amount,\n                trade_direction,\n            )\n            .unwrap();\n        let opposite_direction = trade_direction.opposite();\n        let (swap_token_a_amount, swap_token_b_amount) = match trade_direction {\n            TradeDirection::AtoB => (swap_source_amount, swap_destination_amount),\n            TradeDirection::BtoA => (swap_destination_amount, swap_source_amount),\n        };\n\n        // base amount\n        let pool_tokens_from_one_side = curve\n            .deposit_single_token_type(\n                source_token_amount,\n                swap_token_a_amount,\n                swap_token_b_amount,\n                pool_supply,\n                trade_direction,\n            )\n            .unwrap();\n\n        // perform both separately, updating amounts accordingly\n        let (swap_token_a_amount, swap_token_b_amount) = match trade_direction {\n            TradeDirection::AtoB => (\n                swap_source_amount + results.source_amount_swapped,\n                swap_destination_amount - results.destination_amount_swapped,\n            ),\n            TradeDirection::BtoA => (\n                swap_destination_amount - results.destination_amount_swapped,\n                swap_source_amount + results.source_amount_swapped,\n            ),\n        };\n        let pool_tokens_from_source = curve\n            .deposit_single_token_type(\n                source_token_amount - results.source_amount_swapped,\n                swap_token_a_amount,\n                swap_token_b_amount,\n                pool_supply,\n                trade_direction,\n            )\n            .unwrap();\n        let pool_tokens_from_destination = curve\n            .deposit_single_token_type(\n                results.destination_amount_swapped,\n                swap_token_a_amount,\n                swap_token_b_amount,\n                pool_supply + pool_tokens_from_source,\n                opposite_direction,\n            )\n            .unwrap();\n\n        let pool_tokens_total_separate = pool_tokens_from_source + pool_tokens_from_destination;\n\n        // slippage due to rounding or truncation errors\n        let epsilon = std::cmp::max(\n            1,\n            pool_tokens_total_separate * epsilon_in_basis_points / 10000,\n        );\n        let difference = if pool_tokens_from_one_side >= pool_tokens_total_separate {\n            pool_tokens_from_one_side - pool_tokens_total_separate\n        } else {\n            pool_tokens_total_separate - pool_tokens_from_one_side\n        };\n        assert!(\n            difference <= epsilon,\n            \"difference expected to be less than {}, actually {}\",\n            epsilon,\n            difference\n        );\n    }\n\n    /// Test function to check that withdrawing token A is the same as\n    /// withdrawing both and swapping one side.\n    /// Since calculations use unsigned integers, there will be truncation at\n    /// some point, meaning we can't have perfect equality.\n    /// We guarantee that the relative error between withdrawing one side and\n    /// performing a withdraw plus a swap will be at most some epsilon provided\n    /// by the curve. Most curves guarantee accuracy within 0.5%.\n    pub fn check_withdraw_token_conversion(\n        curve: &dyn CurveCalculator,\n        pool_token_amount: u128,\n        pool_token_supply: u128,\n        swap_token_a_amount: u128,\n        swap_token_b_amount: u128,\n        trade_direction: TradeDirection,\n        epsilon_in_basis_points: u128,\n    ) {\n        // withdraw the pool tokens\n        let withdraw_result = curve\n            .pool_tokens_to_trading_tokens(\n                pool_token_amount,\n                pool_token_supply,\n                swap_token_a_amount,\n                swap_token_b_amount,\n                RoundDirection::Floor,\n            )\n            .unwrap();\n\n        let new_swap_token_a_amount = swap_token_a_amount - withdraw_result.token_a_amount;\n        let new_swap_token_b_amount = swap_token_b_amount - withdraw_result.token_b_amount;\n\n        // swap one side of them\n        let source_token_amount = match trade_direction {\n            TradeDirection::AtoB => {\n                let results = curve\n                    .swap_without_fees(\n                        withdraw_result.token_a_amount,\n                        new_swap_token_a_amount,\n                        new_swap_token_b_amount,\n                        trade_direction,\n                    )\n                    .unwrap();\n                withdraw_result.token_b_amount + results.destination_amount_swapped\n            }\n            TradeDirection::BtoA => {\n                let results = curve\n                    .swap_without_fees(\n                        withdraw_result.token_b_amount,\n                        new_swap_token_b_amount,\n                        new_swap_token_a_amount,\n                        trade_direction,\n                    )\n                    .unwrap();\n                withdraw_result.token_a_amount + results.destination_amount_swapped\n            }\n        };\n\n        // see how many pool tokens it would cost to withdraw one side for the\n        // total amount of tokens, should be close!\n        let opposite_direction = trade_direction.opposite();\n        let pool_token_amount_from_single_side_withdraw = curve\n            .withdraw_single_token_type_exact_out(\n                source_token_amount,\n                swap_token_a_amount,\n                swap_token_b_amount,\n                pool_token_supply,\n                opposite_direction,\n                RoundDirection::Ceiling,\n            )\n            .unwrap();\n\n        // slippage due to rounding or truncation errors\n        let epsilon = std::cmp::max(1, pool_token_amount * epsilon_in_basis_points / 10000);\n        let difference = if pool_token_amount >= pool_token_amount_from_single_side_withdraw {\n            pool_token_amount - pool_token_amount_from_single_side_withdraw\n        } else {\n            pool_token_amount_from_single_side_withdraw - pool_token_amount\n        };\n        assert!(\n            difference <= epsilon,\n            \"difference expected to be less than {}, actually {}\",\n            epsilon,\n            difference\n        );\n    }\n\n    /// Test function checking that a swap never reduces the overall value of\n    /// the pool.\n    ///\n    /// Since curve calculations use unsigned integers, there is potential for\n    /// truncation at some point, meaning a potential for value to be lost in\n    /// either direction if too much is given to the swapper.\n    ///\n    /// This test guarantees that the relative change in value will be at most\n    /// 1 normalized token, and that the value will never decrease from a trade.\n    pub fn check_curve_value_from_swap(\n        curve: &dyn CurveCalculator,\n        source_token_amount: u128,\n        swap_source_amount: u128,\n        swap_destination_amount: u128,\n        trade_direction: TradeDirection,\n    ) {\n        let results = curve\n            .swap_without_fees(\n                source_token_amount,\n                swap_source_amount,\n                swap_destination_amount,\n                trade_direction,\n            )\n            .unwrap();\n\n        let (swap_token_a_amount, swap_token_b_amount) = match trade_direction {\n            TradeDirection::AtoB => (swap_source_amount, swap_destination_amount),\n            TradeDirection::BtoA => (swap_destination_amount, swap_source_amount),\n        };\n        let previous_value = curve\n            .normalized_value(swap_token_a_amount, swap_token_b_amount)\n            .unwrap();\n\n        let new_swap_source_amount = swap_source_amount\n            .checked_add(results.source_amount_swapped)\n            .unwrap();\n        let new_swap_destination_amount = swap_destination_amount\n            .checked_sub(results.destination_amount_swapped)\n            .unwrap();\n        let (swap_token_a_amount, swap_token_b_amount) = match trade_direction {\n            TradeDirection::AtoB => (new_swap_source_amount, new_swap_destination_amount),\n            TradeDirection::BtoA => (new_swap_destination_amount, new_swap_source_amount),\n        };\n\n        let new_value = curve\n            .normalized_value(swap_token_a_amount, swap_token_b_amount)\n            .unwrap();\n        assert!(new_value.greater_than_or_equal(&previous_value));\n\n        let epsilon = 1; // Extremely close!\n        let difference = new_value\n            .checked_sub(&previous_value)\n            .unwrap()\n            .to_imprecise()\n            .unwrap();\n        assert!(difference <= epsilon);\n    }\n\n    /// Test function checking that a deposit never reduces the value of pool\n    /// tokens.\n    ///\n    /// Since curve calculations use unsigned integers, there is potential for\n    /// truncation at some point, meaning a potential for value to be lost if\n    /// too much is given to the depositor.\n    pub fn check_pool_value_from_deposit(\n        curve: &dyn CurveCalculator,\n        pool_token_amount: u128,\n        pool_token_supply: u128,\n        swap_token_a_amount: u128,\n        swap_token_b_amount: u128,\n    ) {\n        let deposit_result = curve\n            .pool_tokens_to_trading_tokens(\n                pool_token_amount,\n                pool_token_supply,\n                swap_token_a_amount,\n                swap_token_b_amount,\n                RoundDirection::Ceiling,\n            )\n            .unwrap();\n        let new_swap_token_a_amount = swap_token_a_amount + deposit_result.token_a_amount;\n        let new_swap_token_b_amount = swap_token_b_amount + deposit_result.token_b_amount;\n        let new_pool_token_supply = pool_token_supply + pool_token_amount;\n\n        // the following inequality must hold:\n        // new_token_a / new_pool_token_supply >= token_a / pool_token_supply\n        // which reduces to:\n        // new_token_a * pool_token_supply >= token_a * new_pool_token_supply\n\n        // These numbers can be just slightly above u64 after the deposit, which\n        // means that their multiplication can be just above the range of u128.\n        // For ease of testing, we bump these up to U256.\n        let pool_token_supply = U256::from(pool_token_supply);\n        let new_pool_token_supply = U256::from(new_pool_token_supply);\n        let swap_token_a_amount = U256::from(swap_token_a_amount);\n        let new_swap_token_a_amount = U256::from(new_swap_token_a_amount);\n        let swap_token_b_amount = U256::from(swap_token_b_amount);\n        let new_swap_token_b_amount = U256::from(new_swap_token_b_amount);\n\n        assert!(\n            new_swap_token_a_amount * pool_token_supply\n                >= swap_token_a_amount * new_pool_token_supply\n        );\n        assert!(\n            new_swap_token_b_amount * pool_token_supply\n                >= swap_token_b_amount * new_pool_token_supply\n        );\n    }\n\n    /// Test function checking that a withdraw never reduces the value of pool\n    /// tokens.\n    ///\n    /// Since curve calculations use unsigned integers, there is potential for\n    /// truncation at some point, meaning a potential for value to be lost if\n    /// too much is given to the depositor.\n    pub fn check_pool_value_from_withdraw(\n        curve: &dyn CurveCalculator,\n        pool_token_amount: u128,\n        pool_token_supply: u128,\n        swap_token_a_amount: u128,\n        swap_token_b_amount: u128,\n    ) {\n        let withdraw_result = curve\n            .pool_tokens_to_trading_tokens(\n                pool_token_amount,\n                pool_token_supply,\n                swap_token_a_amount,\n                swap_token_b_amount,\n                RoundDirection::Floor,\n            )\n            .unwrap();\n        let new_swap_token_a_amount = swap_token_a_amount - withdraw_result.token_a_amount;\n        let new_swap_token_b_amount = swap_token_b_amount - withdraw_result.token_b_amount;\n        let new_pool_token_supply = pool_token_supply - pool_token_amount;\n\n        let value = curve\n            .normalized_value(swap_token_a_amount, swap_token_b_amount)\n            .unwrap();\n        // since we can get rounding issues on the pool value which make it seem that\n        // the value per token has gone down, we bump it up by an epsilon of 1\n        // to cover all cases\n        let new_value = curve\n            .normalized_value(new_swap_token_a_amount, new_swap_token_b_amount)\n            .unwrap();\n\n        // the following inequality must hold:\n        // new_pool_value / new_pool_token_supply >= pool_value / pool_token_supply\n        // which can also be written:\n        // new_pool_value * pool_token_supply >= pool_value * new_pool_token_supply\n\n        let pool_token_supply = PreciseNumber::new(pool_token_supply).unwrap();\n        let new_pool_token_supply = PreciseNumber::new(new_pool_token_supply).unwrap();\n        assert!(new_value\n            .checked_mul(&pool_token_supply)\n            .unwrap()\n            .greater_than_or_equal(&value.checked_mul(&new_pool_token_supply).unwrap()));\n    }\n\n    prop_compose! {\n        pub fn total_and_intermediate(max_value: u64)(total in 1..max_value)\n                        (intermediate in 1..total, total in Just(total))\n                        -> (u64, u64) {\n           (total, intermediate)\n       }",
    "pub fn trading_tokens_to_pool_tokens(\n    token_b_price: u64,\n    source_amount: u128,\n    swap_token_a_amount: u128,\n    swap_token_b_amount: u128,\n    pool_supply: u128,\n    trade_direction: TradeDirection,\n    round_direction: RoundDirection,\n) -> Option<u128> {\n    let token_b_price = U256::from(token_b_price);\n    let given_value = match trade_direction {\n        TradeDirection::AtoB => U256::from(source_amount),\n        TradeDirection::BtoA => U256::from(source_amount).checked_mul(token_b_price)?,\n    };\n    let total_value = U256::from(swap_token_b_amount)\n        .checked_mul(token_b_price)?\n        .checked_add(U256::from(swap_token_a_amount))?;\n    let pool_supply = U256::from(pool_supply);\n    match round_direction {\n        RoundDirection::Floor => Some(\n            pool_supply\n                .checked_mul(given_value)?\n                .checked_div(total_value)?\n                .as_u128(),\n        ),\n        RoundDirection::Ceiling => Some(\n            pool_supply\n                .checked_mul(given_value)?\n                .checked_ceil_div(total_value)?\n                .0\n                .as_u128(),\n        ),\n    }\n}\n\n/// ConstantPriceCurve struct implementing CurveCalculator\n#[derive(Clone, Debug, Default, PartialEq)]\npub struct ConstantPriceCurve {\n    /// Amount of token A required to get 1 token B\n    pub token_b_price: u64,\n}\n\nimpl CurveCalculator for ConstantPriceCurve {\n    /// Constant price curve always returns 1:1\n    fn swap_without_fees(\n        &self,\n        source_amount: u128,\n        _swap_source_amount: u128,\n        _swap_destination_amount: u128,\n        trade_direction: TradeDirection,\n    ) -> Option<SwapWithoutFeesResult> {\n        let token_b_price = self.token_b_price as u128;\n\n        let (source_amount_swapped, destination_amount_swapped) = match trade_direction {\n            TradeDirection::BtoA => (source_amount, source_amount.checked_mul(token_b_price)?),\n            TradeDirection::AtoB => {\n                let destination_amount_swapped = source_amount.checked_div(token_b_price)?;\n                let mut source_amount_swapped = source_amount;\n\n                // if there is a remainder from buying token B, floor\n                // token_a_amount to avoid taking too many tokens, but\n                // don't recalculate the fees\n                let remainder = source_amount_swapped.checked_rem(token_b_price)?;\n                if remainder > 0 {\n                    source_amount_swapped = source_amount.checked_sub(remainder)?;\n                }\n\n                (source_amount_swapped, destination_amount_swapped)\n            }",
    "pub fn swap(\n    source_amount: u128,\n    swap_source_amount: u128,\n    swap_destination_amount: u128,\n) -> Option<SwapWithoutFeesResult> {\n    let invariant = swap_source_amount.checked_mul(swap_destination_amount)?;\n\n    let new_swap_source_amount = swap_source_amount.checked_add(source_amount)?;\n    let (new_swap_destination_amount, new_swap_source_amount) =\n        invariant.checked_ceil_div(new_swap_source_amount)?;\n\n    let source_amount_swapped = new_swap_source_amount.checked_sub(swap_source_amount)?;\n    let destination_amount_swapped =\n        map_zero_to_none(swap_destination_amount.checked_sub(new_swap_destination_amount)?)?;\n\n    Some(SwapWithoutFeesResult {\n        source_amount_swapped,\n        destination_amount_swapped,\n    })\n}",
    "pub fn pool_tokens_to_trading_tokens(\n    pool_tokens: u128,\n    pool_token_supply: u128,\n    swap_token_a_amount: u128,\n    swap_token_b_amount: u128,\n    round_direction: RoundDirection,\n) -> Option<TradingTokenResult> {\n    let mut token_a_amount = pool_tokens\n        .checked_mul(swap_token_a_amount)?\n        .checked_div(pool_token_supply)?;\n    let mut token_b_amount = pool_tokens\n        .checked_mul(swap_token_b_amount)?\n        .checked_div(pool_token_supply)?;\n    let (token_a_amount, token_b_amount) = match round_direction {\n        RoundDirection::Floor => (token_a_amount, token_b_amount),\n        RoundDirection::Ceiling => {\n            let token_a_remainder = pool_tokens\n                .checked_mul(swap_token_a_amount)?\n                .checked_rem(pool_token_supply)?;\n            // Also check for 0 token A and B amount to avoid taking too much\n            // for tiny amounts of pool tokens.  For example, if someone asks\n            // for 1 pool token, which is worth 0.01 token A, we avoid the\n            // ceiling of taking 1 token A and instead return 0, for it to be\n            // rejected later in processing.\n            if token_a_remainder > 0 && token_a_amount > 0 {\n                token_a_amount += 1;\n            }\n            let token_b_remainder = pool_tokens\n                .checked_mul(swap_token_b_amount)?\n                .checked_rem(pool_token_supply)?;\n            if token_b_remainder > 0 && token_b_amount > 0 {\n                token_b_amount += 1;\n            }\n            (token_a_amount, token_b_amount)\n        }",
    "pub fn deposit_single_token_type(\n    source_amount: u128,\n    swap_token_a_amount: u128,\n    swap_token_b_amount: u128,\n    pool_supply: u128,\n    trade_direction: TradeDirection,\n    round_direction: RoundDirection,\n) -> Option<u128> {\n    let swap_source_amount = match trade_direction {\n        TradeDirection::AtoB => swap_token_a_amount,\n        TradeDirection::BtoA => swap_token_b_amount,\n    };\n    let swap_source_amount = PreciseNumber::new(swap_source_amount)?;\n    let source_amount = PreciseNumber::new(source_amount)?;\n    let ratio = source_amount.checked_div(&swap_source_amount)?;\n    let one = PreciseNumber::new(1)?;\n    let base = one.checked_add(&ratio)?;\n    let root = base.sqrt()?.checked_sub(&one)?;\n    let pool_supply = PreciseNumber::new(pool_supply)?;\n    let pool_tokens = pool_supply.checked_mul(&root)?;\n    match round_direction {\n        RoundDirection::Floor => pool_tokens.floor()?.to_imprecise(),\n        RoundDirection::Ceiling => pool_tokens.ceiling()?.to_imprecise(),\n    }\n}\n\n/// Get the amount of pool tokens for the withdrawn amount of token A or B.\n///\n/// The constant product implementation uses the Balancer formulas found at\n/// <https://balancer.finance/whitepaper/#single-asset-withdrawal>, specifically\n/// in the case for 2 tokens, each weighted at 1/2.\npub fn withdraw_single_token_type_exact_out(\n    source_amount: u128,\n    swap_token_a_amount: u128,\n    swap_token_b_amount: u128,\n    pool_supply: u128,\n    trade_direction: TradeDirection,\n    round_direction: RoundDirection,\n) -> Option<u128> {\n    let swap_source_amount = match trade_direction {\n        TradeDirection::AtoB => swap_token_a_amount,\n        TradeDirection::BtoA => swap_token_b_amount,\n    };\n    let swap_source_amount = PreciseNumber::new(swap_source_amount)?;\n    let source_amount = PreciseNumber::new(source_amount)?;\n    let ratio = source_amount.checked_div(&swap_source_amount)?;\n    let one = PreciseNumber::new(1)?;\n    let base = one\n        .checked_sub(&ratio)\n        .unwrap_or_else(|| PreciseNumber::new(0).unwrap());\n    let root = one.checked_sub(&base.sqrt()?)?;\n    let pool_supply = PreciseNumber::new(pool_supply)?;\n    let pool_tokens = pool_supply.checked_mul(&root)?;\n    match round_direction {\n        RoundDirection::Floor => pool_tokens.floor()?.to_imprecise(),\n        RoundDirection::Ceiling => pool_tokens.ceiling()?.to_imprecise(),\n    }\n}\n\n/// Calculates the total normalized value of the curve given the liquidity\n/// parameters.\n///\n/// The constant product implementation for this function gives the square root\n/// of the Uniswap invariant.\npub fn normalized_value(\n    swap_token_a_amount: u128,\n    swap_token_b_amount: u128,\n) -> Option<PreciseNumber> {\n    let swap_token_a_amount = PreciseNumber::new(swap_token_a_amount)?;\n    let swap_token_b_amount = PreciseNumber::new(swap_token_b_amount)?;\n    swap_token_a_amount\n        .checked_mul(&swap_token_b_amount)?\n        .sqrt()\n}",
    "pub fn calculate_fee(\n    token_amount: u128,\n    fee_numerator: u128,\n    fee_denominator: u128,\n) -> Option<u128> {\n    if fee_numerator == 0 || token_amount == 0 {\n        Some(0)\n    }",
    "pub fn owner_withdraw_fee(&self, pool_tokens: u128) -> Option<u128> {\n        calculate_fee(\n            pool_tokens,\n            u128::from(self.owner_withdraw_fee_numerator),\n            u128::from(self.owner_withdraw_fee_denominator),\n        )\n    }",
    "pub fn trading_fee(&self, trading_tokens: u128) -> Option<u128> {\n        calculate_fee(\n            trading_tokens,\n            u128::from(self.trade_fee_numerator),\n            u128::from(self.trade_fee_denominator),\n        )\n    }",
    "pub fn owner_trading_fee(&self, trading_tokens: u128) -> Option<u128> {\n        calculate_fee(\n            trading_tokens,\n            u128::from(self.owner_trade_fee_numerator),\n            u128::from(self.owner_trade_fee_denominator),\n        )\n    }",
    "pub fn pre_trading_fee_amount(&self, post_fee_amount: u128) -> Option<u128> {\n        if self.trade_fee_numerator == 0 || self.trade_fee_denominator == 0 {\n            pre_fee_amount(\n                post_fee_amount,\n                self.owner_trade_fee_numerator as u128,\n                self.owner_trade_fee_denominator as u128,\n            )\n        }",
    "pub fn host_fee(&self, owner_fee: u128) -> Option<u128> {\n        calculate_fee(\n            owner_fee,\n            u128::from(self.host_fee_numerator),\n            u128::from(self.host_fee_denominator),\n        )\n    }",
    "pub fn validate(&self) -> Result<(), SwapError> {\n        validate_fraction(self.trade_fee_numerator, self.trade_fee_denominator)?;\n        validate_fraction(\n            self.owner_trade_fee_numerator,\n            self.owner_trade_fee_denominator,\n        )?;\n        validate_fraction(\n            self.owner_withdraw_fee_numerator,\n            self.owner_withdraw_fee_denominator,\n        )?;\n        validate_fraction(self.host_fee_numerator, self.host_fee_denominator)?;\n        Ok(())\n    }",
    "pub fn values_sum_within_u64()(total in 1..u64::MAX)\n                        (amount in 1..total, total in Just(total))\n                        -> (u64, u64) {\n           (total - amount, amount)\n       }",
    "pub fn get_token_upgrade_authority_address(\n    original_mint: &Pubkey,\n    new_mint: &Pubkey,\n    program_id: &Pubkey,\n) -> Pubkey {\n    get_token_upgrade_authority_address_and_bump_seed(original_mint, new_mint, program_id).0\n}\n\npub(crate) fn get_token_upgrade_authority_address_and_bump_seed(\n    original_mint: &Pubkey,\n    new_mint: &Pubkey,\n    program_id: &Pubkey,\n) -> (Pubkey, u8) {\n    Pubkey::find_program_address(\n        &collect_token_upgrade_authority_seeds(original_mint, new_mint),\n        program_id,\n    )\n}",
    "pub fn get_wrapped_mint_address(\n    unwrapped_mint: &Pubkey,\n    wrapped_token_program_id: &Pubkey,\n) -> Pubkey {\n    get_wrapped_mint_address_with_seed(unwrapped_mint, wrapped_token_program_id).0\n}\n\nconst WRAPPED_MINT_AUTHORITY_SEED: &[u8] = br\"authority\";\n\npub(crate) fn get_wrapped_mint_authority_seeds(wrapped_mint: &Pubkey) -> [&[u8]; 2] {\n    [WRAPPED_MINT_AUTHORITY_SEED, wrapped_mint.as_ref()]\n}\n\npub(crate) fn _get_wrapped_mint_authority_signer_seeds<'a>(\n    wrapped_mint: &'a Pubkey,\n    bump_seed: &'a [u8],\n) -> [&'a [u8]; 3] {\n    [\n        WRAPPED_MINT_AUTHORITY_SEED,\n        wrapped_mint.as_ref(),\n        bump_seed,\n    ]\n}\n\npub(crate) fn get_wrapped_mint_authority_with_seed(wrapped_mint: &Pubkey) -> (Pubkey, u8) {\n    Pubkey::find_program_address(&get_wrapped_mint_authority_seeds(wrapped_mint), &id())\n}",
    "pub fn get_wrapped_mint_authority(wrapped_mint: &Pubkey) -> Pubkey {\n    get_wrapped_mint_authority_with_seed(wrapped_mint).0\n}\n\nconst WRAPPED_MINT_BACKPOINTER_SEED: &[u8] = br\"backpointer\";\n\npub(crate) fn get_wrapped_mint_backpointer_address_seeds(wrapped_mint: &Pubkey) -> [&[u8]; 2] {\n    [WRAPPED_MINT_BACKPOINTER_SEED, wrapped_mint.as_ref()]\n}\n\npub(crate) fn _get_wrapped_mint_backpointer_address_signer_seeds<'a>(\n    wrapped_mint: &'a Pubkey,\n    bump_seed: &'a [u8],\n) -> [&'a [u8]; 3] {\n    [\n        WRAPPED_MINT_BACKPOINTER_SEED,\n        wrapped_mint.as_ref(),\n        bump_seed,\n    ]\n}\n\npub(crate) fn get_wrapped_mint_backpointer_address_with_seed(\n    wrapped_mint: &Pubkey,\n) -> (Pubkey, u8) {\n    Pubkey::find_program_address(\n        &get_wrapped_mint_backpointer_address_seeds(wrapped_mint),\n        &id(),\n    )\n}"
  ],
  "cookbook": [
    "import { createSolanaClient } from \"gill\";\n\nconst { rpc, rpcSubscriptions } = createSolanaClient({\n  urlOrMoniker: \"devnet\", // or `mainnet`, `localnet`, etc\n});",
    "import { createSolanaRpc, createSolanaRpcSubscriptions, devnet } from \"gill\";\n\nconst rpc = createSolanaRpc(devnet(\"https://api.devnet.solana.com\"));\n\nconst rpcSubscriptions = createSolanaRpcSubscriptions(\n  devnet(\"wss://api.devnet.solana.com\"),\n);",
    "import {\n  address,\n  lamports,\n  airdropFactory,\n  createSolanaClient,\n  LAMPORTS_PER_SOL,\n} from \"gill\";\n\nconst { rpc, rpcSubscriptions, sendAndConfirmTransaction } = createSolanaClient(\n  {\n    urlOrMoniker: \"devnet\", // or `localnet`, etc\n  },\n);\n\nconst wallet = address(\"nick6zJc6HpW3kfBm4xS2dmbuVRyb5F3AnUvj5ymzR5\");\n\nconst { value: initialBalance } = await rpc.getBalance(wallet).send();\nconsole.log(\"Initial balance:\", initialBalance);\n\n/**\n * Note: the `devnet` and `testnet` clusters are subject to rate limits.\n * it is strongly recommended to use `localnet` and the local test validator\n */\nawait airdropFactory({ rpc, rpcSubscriptions })({\n  commitment: \"confirmed\",\n  lamports: lamports(LAMPORTS_PER_SOL), // request 1 SOL airdrop\n  recipientAddress: wallet,\n});\n\nconst { value: newBalance } = await rpc.getBalance(wallet).send();\nconsole.log(\"New balance:\", newBalance);",
    "import { clusterApiUrl, Connection, Keypair } from \"@solana/web3.js\";\n\n(async () => {\n  // Establish new connect to devnet - websocket client connected to devnet will also be registered here\n  const connection = new Connection(clusterApiUrl(\"devnet\"), \"confirmed\");\n\n  // Create a test wallet to listen to\n  const wallet = Keypair.generate();\n\n  // Register a callback to listen to the wallet (ws subscription)\n  connection.onAccountChange(\n    wallet.publicKey,\n    (updatedAccountInfo, context) =>\n      console.log(\"Updated account info: \", updatedAccountInfo),\n    \"confirmed\",\n  );\n})();",
    "import { generateKeyPairSigner } from \"gill\";\n\n// non-extractable and more secure keypair\nconst signer = await generateKeyPairSigner();\nconsole.log(\"address: \", signer.address);",
    "import { generateExtractableKeyPairSigner } from \"gill\";\n\n// extractable and less secure keypair\nconst extractableSigner = await generateExtractableKeyPairSigner();\nconsole.log(\"address: \", extractableSigner.address);",
    "import { createKeyPairSignerFromBytes } from \"gill\";\n\nconst keypairBytes = new Uint8Array([\n  174, 47, 154, 16, 202, 193, 206, 113, 199, 190, 53, 133, 169, 175, 31, 56,\n  222, 53, 138, 189, 224, 216, 117, 173, 10, 149, 53, 45, 73, 251, 237, 246, 15,\n  185, 186, 82, 177, 240, 148, 69, 241, 227, 167, 80, 141, 89, 240, 121, 121,\n  35, 172, 247, 68, 251, 226, 218, 48, 63, 176, 109, 168, 89, 238, 135,\n]);\n\nconst signer = await createKeyPairSignerFromBytes(keypairBytes);",
    "import { createKeypairSignerFromBase58 } from \"gill\";\n\nconst keypairBase58 =\n  \"5MaiiCavjCmn9Hs1o3eznqDEhRwxo7pXiAYez7keQUviUkauRiTMD8DrESdrNjN8zd9mTmVhRvBJeg5vhyvgrAhG\";\nconst signer = await createKeypairSignerFromBase58(keypairBase58);\nconsole.log(signer.address);\n// output: 5pVyoAeURQHNMVU7DmfMHvCDNmTEYXWfEwc136GYhTKG",
    "import { createKeyPairSignerFromBytes, address } from \"gill\";\n\nconst publicKey = address(\"24PNhTaNtomHhoy3fTRaMhAFCRj4uHqhZEEoWrKDbR5p\");\n\nconst keypairBytes = new Uint8Array([\n  174, 47, 154, 16, 202, 193, 206, 113, 199, 190, 53, 133, 169, 175, 31, 56,\n  222, 53, 138, 189, 224, 216, 117, 173, 10, 149, 53, 45, 73, 251, 237, 246, 15,\n  185, 186, 82, 177, 240, 148, 69, 241, 227, 167, 80, 141, 89, 240, 121, 121,\n  35, 172, 247, 68, 251, 226, 218, 48, 63, 176, 109, 168, 89, 238, 135,\n]);\n\nconst signer = await createKeyPairSignerFromBytes(keypairBytes);\n\nconsole.log(signer.address === publicKey);\n// output: true",
    "import { isAddress } from \"gill\";\n\n// Note that generateKeyPair() will always give a public key that is valid for users\n\n// Valid public key\nconst key = \"5oNDL3swdJJF1g9DzJiZ4ynHXgszjAEpUkxVYejchzrY\";\n\n// Lies on the ed25519 curve and is suitable for users\nconsole.log(\"Valid Address: \", isAddress(key));\n\n// Valid public key\nconst offCurveAddress = \"4BJXYkfvg37zEmBbsacZjeQDpTNx91KppxFJxRqrz48e\";\n\n// Not on the ed25519 curve, therefore not suitable for users\nconsole.log(\"Valid Off Curve Address: \", isAddress(offCurveAddress));\n\n// Not a valid public key\nconst errorPubkey = \"testPubkey\";\nconsole.log(\"Invalid Address: \", isAddress(errorPubkey));",
    "import * as bip39 from \"bip39\";\n\nconst mnemonic = bip39.generateMnemonic();",
    "import { Keypair } from \"@solana/web3.js\";\nimport * as bip39 from \"bip39\";\n\nconst mnemonic =\n  \"pill tomorrow foster begin walnut borrow virtual kick shift mutual shoe scatter\";\n\n// arguments: (mnemonic, password)\nconst seed = bip39.mnemonicToSeedSync(mnemonic, \"\");\nconst keypair = Keypair.fromSeed(seed.slice(0, 32));\n\nconsole.log(`${keypair.publicKey.toBase58()}`);\n\n// output: 5ZWj7a1f8tWkjBESHKgrLmXshuXxqeY9SYcfbshpAqPG",
    "import { Keypair } from \"@solana/web3.js\";\nimport { HDKey } from \"micro-ed25519-hdkey\";\nimport * as bip39 from \"bip39\";\n\nconst mnemonic =\n  \"neither lonely flavor argue grass remind eye tag avocado spot unusual intact\";\n\n// arguments: (mnemonic, password)\nconst seed = bip39.mnemonicToSeedSync(mnemonic, \"\");\nconst hd = HDKey.fromMasterSeed(seed.toString(\"hex\"));\n\nfor (let i = 0; i < 10; i++) {\n  const path = `m/44'/501'/${i}'/0'`;\n  const keypair = Keypair.fromSeed(hd.derive(path).privateKey);\n  console.log(`${path} => ${keypair.publicKey.toBase58()}`);\n}",
    "import {\n  generateKeyPair,\n  signBytes,\n  verifySignature,\n  getUtf8Encoder,\n  getBase58Decoder,\n} from \"@solana/kit\";\n\nconst keys = await generateKeyPair();\nconst message = getUtf8Encoder().encode(\"Hello, World!\");\nconst signedBytes = await signBytes(keys.privateKey, message);\n\nconst decoded = getBase58Decoder().decode(signedBytes);\nconsole.log(\"Signature:\", decoded);\n\nconst verified = await verifySignature(keys.publicKey, signedBytes, message);\nconsole.log(\"Verified:\", verified);",
    "npx create-solana-dapp <app-name>",
    "npm install --save \\\n    @solana/wallet-adapter-base \\\n    @solana/wallet-adapter-react \\\n    @solana/wallet-adapter-react-ui \\\n    @solana/wallet-adapter-wallets \\\n    @solana/web3.js@1 \\\n    react",
    "import React, { FC, useMemo } from 'react';\nimport { ConnectionProvider, WalletProvider } from '@solana/wallet-adapter-react';\nimport { WalletAdapterNetwork } from '@solana/wallet-adapter-base';\nimport { UnsafeBurnerWalletAdapter } from '@solana/wallet-adapter-wallets';\nimport {\n    WalletModalProvider,\n    WalletDisconnectButton,\n    WalletMultiButton\n} from '@solana/wallet-adapter-react-ui';\nimport { clusterApiUrl } from '@solana/web3.js';\n\n// Default styles that can be overridden by your app\nrequire('@solana/wallet-adapter-react-ui/styles.css');\n\nexport const Wallet: FC = () => {\n    // The network can be set to 'devnet', 'testnet', or 'mainnet-beta'.\n    const network = WalletAdapterNetwork.Devnet;\n\n    // You can also provide a custom RPC endpoint.\n    const endpoint = useMemo(() => clusterApiUrl(network), [network]);\n\n    const wallets = useMemo(\n        () => [\n            new UnsafeBurnerWalletAdapter(),\n        ],\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        [network]\n    );\n\n    return (\n        <ConnectionProvider endpoint={endpoint}>\n            <WalletProvider wallets={wallets} autoConnect>\n                <WalletModalProvider>\n                    <WalletMultiButton />\n                    <WalletDisconnectButton />\n                    { /* Your app's components go here, nested within the context providers. */ }\n                </WalletModalProvider>\n            </WalletProvider>\n        </ConnectionProvider>\n    );\n};",
    "import {\n  address,\n  lamports,\n  createTransaction,\n  createSolanaClient,\n  signTransactionMessageWithSigners,\n} from \"gill\";\nimport { loadKeypairSignerFromFile } from \"gill/node\";\nimport { getTransferSolInstruction } from \"gill/programs\";\n\nconst { rpc, sendAndConfirmTransaction } = createSolanaClient({\n  urlOrMoniker: \"devnet\",\n});\n\n// loads Signer from the default Solana CLI keypair path: `~/.config/solana/id.json`\nconst signer = await loadKeypairSignerFromFile();\n\nconst destination = address(\"nick6zJc6HpW3kfBm4xS2dmbuVRyb5F3AnUvj5ymzR5\");\n\nconst { value: latestBlockhash } = await rpc.getLatestBlockhash().send();\n\nconst tx = createTransaction({\n  version: \"legacy\",\n  feePayer: signer,\n  instructions: [\n    getTransferSolInstruction({\n      source: signer,\n      destination,\n      amount: lamports(1_000_000n),\n    }),\n  ],\n  latestBlockhash,\n});\n\nconst signedTransaction = await signTransactionMessageWithSigners(tx);\nawait sendAndConfirmTransaction(signedTransaction);",
    "import {\n  airdropFactory,\n  appendTransactionMessageInstructions,\n  compileTransactionMessage,\n  createSignerFromKeyPair,\n  createSolanaRpc,\n  createSolanaRpcSubscriptions,\n  createTransactionMessage,\n  devnet,\n  generateKeyPairSigner,\n  getBase64Decoder,\n  getCompiledTransactionMessageEncoder,\n  getComputeUnitEstimateForTransactionMessageFactory,\n  getSignatureFromTransaction,\n  lamports,\n  pipe,\n  prependTransactionMessageInstructions,\n  sendAndConfirmTransactionFactory,\n  setTransactionMessageFeePayerSigner,\n  setTransactionMessageLifetimeUsingBlockhash,\n  signTransactionMessageWithSigners,\n  type TransactionMessageBytesBase64,\n} from \"@solana/web3.js\";\nimport {\n  getSetComputeUnitLimitInstruction,\n  getSetComputeUnitPriceInstruction,\n} from \"@solana-program/compute-budget\";\nimport { getAddMemoInstruction } from \"@solana-program/memo\";\nimport { loadDefaultKeypairWithAirdrop } from \"./CreateKeypair\";\n\nasync function calculateCost(message: string) {\n  // Create an RPC.\n  const CLUSTER = \"devnet\";\n  const rpc = createSolanaRpc(devnet(`https://api.${CLUSTER}.solana.com`));\n  const rpcSubscriptions = createSolanaRpcSubscriptions(\n    devnet(`wss://api.${CLUSTER}.solana.com`),\n  );\n\n  // Create a utility that estimates a transaction message's compute consumption.\n  const getComputeUnitEstimate =\n    getComputeUnitEstimateForTransactionMessageFactory({ rpc });\n\n  // Create a transaction sending function.\n  const sendAndConfirmTransaction = sendAndConfirmTransactionFactory({\n    rpc,\n    rpcSubscriptions,\n  });\n\n  // Create an airdrop function.\n  const airdrop = airdropFactory({ rpc, rpcSubscriptions });\n\n  // Create and fund an account.\n  const signer = await generateKeyPairSigner();\n  console.log(\"Created an account with address\", signer.address);\n  console.log(\"Requesting airdrop\");\n  await airdrop({\n    commitment: \"confirmed\",\n    lamports: lamports(1000_000n),\n    recipientAddress: signer.address,\n  });\n  console.log(\"Airdrop confirmed\");\n\n  // Create a memo transaction.\n  console.log(\"Creating a memo transaction\");\n  const { value: latestBlockhash } = await rpc.getLatestBlockhash().send();\n  const transactionMessage = pipe(\n    createTransactionMessage({ version: \"legacy\" }),\n    m => setTransactionMessageFeePayerSigner(signer, m),\n    m => setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, m),\n    m =>\n      appendTransactionMessageInstructions(\n        [\n          getSetComputeUnitPriceInstruction({ microLamports: 5000n }),\n          getAddMemoInstruction({ memo: message }),\n        ],\n        m,\n      ),\n  );\n\n  // Figure out how many compute units to budget for this transaction\n  // so that you can right-size the compute budget to maximize the\n  // chance that it will be selected for inclusion into a block.\n  console.log(\"Estimating the compute consumption of the transaction\");\n  const estimatedComputeUnits =\n    await getComputeUnitEstimate(transactionMessage);\n  console.log(\n    `Transaction is estimated to consume ${estimatedComputeUnits} compute units`,\n  );\n\n  const budgetedTransactionMessage = prependTransactionMessageInstructions(\n    [getSetComputeUnitLimitInstruction({ units: estimatedComputeUnits })],\n    transactionMessage,\n  );\n\n  const base64EncodedMessage = pipe(\n    // Start with the message you want the fee for.\n    budgetedTransactionMessage,\n\n    // Compile it.\n    compileTransactionMessage,\n\n    // Convert the compiled message into a byte array.\n    getCompiledTransactionMessageEncoder().encode,\n\n    // Encode that byte array as a base64 string.\n    getBase64Decoder().decode,\n  ) as TransactionMessageBytesBase64;\n\n  const transactionCost = await rpc\n    .getFeeForMessage(base64EncodedMessage)\n    .send();\n\n  console.log(\n    \"Transaction is estimated to cost \" + transactionCost.value + \" lamports\",\n  );\n\n  // Sign and send the transaction.\n  console.log(\"Signing and sending the transaction\");\n  const signedTx = await signTransactionMessageWithSigners(\n    budgetedTransactionMessage,\n  );\n  const signature = getSignatureFromTransaction(signedTx);\n  console.log(\n    \"Sending transaction https://explorer.solana.com/tx/\" +\n      signature +\n      \"/?cluster=\" +\n      CLUSTER,\n  );\n  await sendAndConfirmTransaction(signedTx, { commitment: \"confirmed\" });\n  console.log(\"Transaction confirmed\");\n  // Transaction is estimated to consume 6236 compute units\n  // Transaction is estimated to cost 5032 lamports\n}\n\ncalculateCost(\"Hello, Fees!\");",
    "import {\n  getExplorerLink,\n  createTransaction,\n  createSolanaClient,\n  getSignatureFromTransaction,\n  signTransactionMessageWithSigners,\n} from \"gill\";\nimport { loadKeypairSignerFromFile } from \"gill/node\";\nimport { getAddMemoInstruction } from \"gill/programs\";\n\nconst { rpc, sendAndConfirmTransaction } = createSolanaClient({\n  urlOrMoniker: \"devnet\", // or `mainnet`, `localnet`, etc\n});\n\nconst { value: latestBlockhash } = await rpc.getLatestBlockhash().send();\n\n// load a Signer from the default Solana CLI keypair file\nconst signer = await loadKeypairSignerFromFile();\n\nconst transaction = createTransaction({\n  version: \"legacy\",\n  feePayer: signer,\n  instructions: [\n    getAddMemoInstruction({\n      memo: \"Memo message to send in this transaction\",\n    }),\n  ],\n  latestBlockhash,\n});\n\nconst signedTransaction = await signTransactionMessageWithSigners(transaction);\n\nconsole.log(\n  \"Sending transaction:\",\n  getExplorerLink({\n    cluster: \"devnet\",\n    transaction: getSignatureFromTransaction(signedTransaction),\n  }),\n);\n\nawait sendAndConfirmTransaction(signedTransaction);",
    "import {\n  getExplorerLink,\n  createTransaction,\n  createSolanaClient,\n  getSignatureFromTransaction,\n  signTransactionMessageWithSigners,\n} from \"gill\";\nimport { loadKeypairSignerFromFile } from \"gill/node\";\nimport {\n  getAddMemoInstruction,\n  getSetComputeUnitPriceInstruction,\n} from \"gill/programs\";\n\nconst { rpc, sendAndConfirmTransaction } = createSolanaClient({\n  urlOrMoniker: \"devnet\", // or `mainnet`, `localnet`, etc\n});\n\nconst { value: latestBlockhash } = await rpc.getLatestBlockhash().send();\n\n// load a Signer from the default Solana CLI keypair file\nconst signer = await loadKeypairSignerFromFile();\n\n// provide the `computeUnitPrice` value to set a priority fee\nconst transaction = createTransaction({\n  version: \"legacy\",\n  feePayer: signer,\n  instructions: [\n    getAddMemoInstruction({ memo: \"Memo message to send in this transaction\" }),\n  ],\n  latestBlockhash,\n  computeUnitPrice: 10_000, // set compute unit price of 10k micro-lamports per CU\n});\n\n// or you can manually add the compute unit price instruction to set a priority fee\nconst transaction2 = createTransaction({\n  version: \"legacy\",\n  feePayer: signer,\n  instructions: [\n    getAddMemoInstruction({ memo: \"Memo message to send in this transaction\" }),\n    getSetComputeUnitPriceInstruction({ microLamports: 10_000 }), // set compute unit price of 10k micro-lamports per CU\n  ],\n  latestBlockhash,\n});\n\nconst signedTransaction = await signTransactionMessageWithSigners(transaction);\n\nconsole.log(\n  \"Sending transaction:\",\n  getExplorerLink({\n    cluster: \"devnet\",\n    transaction: getSignatureFromTransaction(signedTransaction),\n  }),\n);\n\nawait sendAndConfirmTransaction(signedTransaction);",
    "// import { ... } from \"@solana/web3.js\"\n\nasync function buildOptimalTransaction(\n  connection: Connection,\n  instructions: Array<TransactionInstruction>,\n  signer: Signer,\n  lookupTables: Array<AddressLookupTableAccount>,\n) {\n  const [microLamports, units, recentBlockhash] = await Promise.all([\n    100 /* Get optimal priority fees - https://solana.com/developers/guides/advanced/how-to-use-priority-fees*/,\n    getSimulationComputeUnits(\n      connection,\n      instructions,\n      signer.publicKey,\n      lookupTables,\n    ),\n    connection.getLatestBlockhash(),\n  ]);\n\n  instructions.unshift(\n    ComputeBudgetProgram.setComputeUnitPrice({ microLamports }),\n  );\n  if (units) {\n    // probably should add some margin of error to units\n    instructions.unshift(ComputeBudgetProgram.setComputeUnitLimit({ units }));\n  }\n  return {\n    transaction: new VersionedTransaction(\n      new TransactionMessage({\n        instructions,\n        recentBlockhash: recentBlockhash.blockhash,\n        payerKey: signer.publicKey,\n      }).compileToV0Message(lookupTables),\n    ),\n    recentBlockhash,\n  };\n}",
    "import {\n  clusterApiUrl,\n  Connection,\n  Keypair,\n  Transaction,\n  SystemProgram,\n  LAMPORTS_PER_SOL,\n  Message,\n} from \"@solana/web3.js\";\nimport * as nacl from \"tweetnacl\";\nimport * as bs58 from \"bs58\";\n\n// To complete an offline transaction, I will separate them into four steps\n// 1. Create Transaction\n// 2. Sign Transaction\n// 3. Recover Transaction\n// 4. Send Transaction\n\n(async () => {\n  // create connection\n  const connection = new Connection(clusterApiUrl(\"devnet\"), \"confirmed\");\n\n  // create an example tx, alice transfer to bob and feePayer is `feePayer`\n  // alice and feePayer are signer in this tx\n  const feePayer = Keypair.generate();\n  await connection.confirmTransaction(\n    await connection.requestAirdrop(feePayer.publicKey, LAMPORTS_PER_SOL),\n  );\n  const alice = Keypair.generate();\n  await connection.confirmTransaction(\n    await connection.requestAirdrop(alice.publicKey, LAMPORTS_PER_SOL),\n  );\n  const bob = Keypair.generate();\n\n  // 1. Create Transaction\n  let tx = new Transaction().add(\n    SystemProgram.transfer({\n      fromPubkey: alice.publicKey,\n      toPubkey: bob.publicKey,\n      lamports: 0.1 * LAMPORTS_PER_SOL,\n    }),\n  );\n  tx.recentBlockhash = (await connection.getRecentBlockhash()).blockhash;\n  tx.feePayer = feePayer.publicKey;\n  let realDataNeedToSign = tx.serializeMessage(); // the real data singer need to sign.\n\n  // 2. Sign Transaction\n  // use any lib you like, the main idea is to use ed25519 to sign it.\n  // the return signature should be 64 bytes.\n  let feePayerSignature = nacl.sign.detached(\n    realDataNeedToSign,\n    feePayer.secretKey,\n  );\n  let aliceSignature = nacl.sign.detached(realDataNeedToSign, alice.secretKey);\n\n  // 3. Recover Transaction\n\n  // you can verify signatures before you recovering the transaction\n  let verifyFeePayerSignatureResult = nacl.sign.detached.verify(\n    realDataNeedToSign,\n    feePayerSignature,\n    feePayer.publicKey.toBytes(), // you should use the raw pubkey (32 bytes) to verify\n  );\n  console.log(`verify feePayer signature: ${verifyFeePayerSignatureResult}`);\n\n  let verifyAliceSignatureResult = nacl.sign.detached.verify(\n    realDataNeedToSign,\n    aliceSignature,\n    alice.publicKey.toBytes(),\n  );\n  console.log(`verify alice signature: ${verifyAliceSignatureResult}`);\n\n  // there are two ways you can recover the tx\n  // 3.a Recover Transaction (use populate then addSignature)\n  {\n    let recoverTx = Transaction.populate(Message.from(realDataNeedToSign));\n    recoverTx.addSignature(feePayer.publicKey, Buffer.from(feePayerSignature));\n    recoverTx.addSignature(alice.publicKey, Buffer.from(aliceSignature));\n\n    // 4. Send transaction\n    console.log(\n      `txhash: ${await connection.sendRawTransaction(recoverTx.serialize())}`,\n    );\n  }\n\n  // or\n\n  // 3.b. Recover Transaction (use populate with signature)\n  {\n    let recoverTx = Transaction.populate(Message.from(realDataNeedToSign), [\n      bs58.encode(feePayerSignature),\n      bs58.encode(aliceSignature),\n    ]);\n\n    // 4. Send transaction\n    console.log(\n      `txhash: ${await connection.sendRawTransaction(recoverTx.serialize())}`,\n    );\n  }\n\n  // if this process takes too long, your recent blockhash will expire (after 150 blocks).\n  // you can use `durable nonce` to get rid of it.\n})();",
    "import {\n  createTransferCheckedInstruction,\n  getAssociatedTokenAddress,\n  getMint,\n  getOrCreateAssociatedTokenAccount,\n} from \"@solana/spl-token\";\nimport {\n  clusterApiUrl,\n  Connection,\n  Keypair,\n  LAMPORTS_PER_SOL,\n  PublicKey,\n  SystemProgram,\n  Transaction,\n} from \"@solana/web3.js\";\nimport base58 from \"bs58\";\n\n/* The transaction:\n * - sends 0.01 SOL from Alice to Bob\n * - sends 1 token from Bob to Alice\n * - is partially signed by Bob, so Alice can approve + send it\n */\n\n(async () => {\n  const connection = new Connection(clusterApiUrl(\"devnet\"), \"confirmed\");\n\n  const alicePublicKey = new PublicKey(\n    \"5YNmS1R9nNSCDzb5a7mMJ1dwK9uHeAAF4CmPEwKgVWr8\",\n  );\n  const bobKeypair = Keypair.fromSecretKey(\n    base58.decode(\n      \"4NMwxzmYj2uvHuq8xoqhY8RXg63KSVJM1DXkpbmkUY7YQWuoyQgFnnzn6yo3CMnqZasnNPNuAT2TLwQsCaKkUddp\",\n    ),\n  );\n  const tokenAddress = new PublicKey(\n    \"Gh9ZwEmdLJ8DscKNTkTqPbNwLNNBjuSzaG9Vp2KGtKJr\",\n  );\n  const bobTokenAddress = await getAssociatedTokenAddress(\n    tokenAddress,\n    bobKeypair.publicKey,\n  );\n\n  // Alice may not have a token account, so Bob creates one if not\n  const aliceTokenAccount = await getOrCreateAssociatedTokenAccount(\n    connection,\n    bobKeypair, // Bob pays the fee to create it\n    tokenAddress, // which token the account is for\n    alicePublicKey, // who the token account is for\n  );\n\n  // Get the details about the token mint\n  const tokenMint = await getMint(connection, tokenAddress);\n\n  // Get a recent blockhash to include in the transaction\n  const { blockhash } = await connection.getLatestBlockhash(\"finalized\");\n\n  const transaction = new Transaction({\n    recentBlockhash: blockhash,\n    // Alice pays the transaction fee\n    feePayer: alicePublicKey,\n  });\n\n  // Transfer 0.01 SOL from Alice -> Bob\n  transaction.add(\n    SystemProgram.transfer({\n      fromPubkey: alicePublicKey,\n      toPubkey: bobKeypair.publicKey,\n      lamports: 0.01 * LAMPORTS_PER_SOL,\n    }),\n  );\n\n  // Transfer 1 token from Bob -> Alice\n  transaction.add(\n    createTransferCheckedInstruction(\n      bobTokenAddress, // source\n      tokenAddress, // mint\n      aliceTokenAccount.address, // destination\n      bobKeypair.publicKey, // owner of source account\n      1 * 10 ** tokenMint.decimals, // amount to transfer\n      tokenMint.decimals, // decimals of token\n    ),\n  );\n\n  // Partial sign as Bob\n  transaction.partialSign(bobKeypair);\n\n  // Serialize the transaction and convert to base64 to return it\n  const serializedTransaction = transaction.serialize({\n    // We will need Alice to deserialize and sign the transaction\n    requireAllSignatures: false,\n  });\n  const transactionBase64 = serializedTransaction.toString(\"base64\");\n  return transactionBase64;\n\n  // The caller of this can convert it back to a transaction object:\n  const recoveredTransaction = Transaction.from(\n    Buffer.from(transactionBase64, \"base64\"),\n  );\n})();",
    "import {\n  clusterApiUrl,\n  Connection,\n  Keypair,\n  Transaction,\n  NONCE_ACCOUNT_LENGTH,\n  SystemProgram,\n  LAMPORTS_PER_SOL,\n} from \"@solana/web3.js\";\n\n(async () => {\n  // Setup our connection and wallet\n  const connection = new Connection(clusterApiUrl(\"devnet\"), \"confirmed\");\n  const feePayer = Keypair.generate();\n\n  // Fund our wallet with 1 SOL\n  const airdropSignature = await connection.requestAirdrop(\n    feePayer.publicKey,\n    LAMPORTS_PER_SOL,\n  );\n  await connection.confirmTransaction(airdropSignature);\n\n  // you can use any keypair as nonce account authority,\n  // this uses the default Solana keypair file (id.json) as the nonce account authority\n  const nonceAccountAuth = await getKeypairFromFile();\n\n  let nonceAccount = Keypair.generate();\n  console.log(`nonce account: ${nonceAccount.publicKey.toBase58()}`);\n\n  let tx = new Transaction().add(\n    // create nonce account\n    SystemProgram.createAccount({\n      fromPubkey: feePayer.publicKey,\n      newAccountPubkey: nonceAccount.publicKey,\n      lamports:\n        await connection.getMinimumBalanceForRentExemption(\n          NONCE_ACCOUNT_LENGTH,\n        ),\n      space: NONCE_ACCOUNT_LENGTH,\n      programId: SystemProgram.programId,\n    }),\n    // init nonce account\n    SystemProgram.nonceInitialize({\n      noncePubkey: nonceAccount.publicKey, // nonce account pubkey\n      authorizedPubkey: nonceAccountAuth.publicKey, // nonce account authority (for advance and close)\n    }),\n  );\n\n  console.log(\n    `txhash: ${await sendAndConfirmTransaction(connection, tx, [feePayer, nonceAccount])}`,\n  );\n})();",
    "import {\n  clusterApiUrl,\n  Connection,\n  PublicKey,\n  Keypair,\n  NonceAccount,\n} from \"@solana/web3.js\";\n\n(async () => {\n  const connection = new Connection(clusterApiUrl(\"devnet\"), \"confirmed\");\n\n  const nonceAccountPubkey = new PublicKey(\n    \"7H18z3v3rZEoKiwY3kh8DLn9eFT6nFCQ2m4kiC7RZ3a4\",\n  );\n\n  let accountInfo = await connection.getAccountInfo(nonceAccountPubkey);\n  let nonceAccount = NonceAccount.fromAccountData(accountInfo.data);\n  console.log(`nonce: ${nonceAccount.nonce}`);\n  console.log(`authority: ${nonceAccount.authorizedPubkey.toBase58()}`);\n  console.log(`fee calculator: ${JSON.stringify(nonceAccount.feeCalculator)}`);\n})();",
    "import {\n  clusterApiUrl,\n  Connection,\n  PublicKey,\n  Keypair,\n  Transaction,\n  SystemProgram,\n  NonceAccount,\n  LAMPORTS_PER_SOL,\n} from \"@solana/web3.js\";\nimport * as bs58 from \"bs58\";\nimport { getKeypairFromFile } from \"@solana-developers/helpers\";\n\n(async () => {\n  // Setup our connection and wallet\n  const connection = new Connection(clusterApiUrl(\"devnet\"), \"confirmed\");\n  const feePayer = Keypair.generate();\n\n  // Fund our wallet with 1 SOL\n  const airdropSignature = await connection.requestAirdrop(\n    feePayer.publicKey,\n    LAMPORTS_PER_SOL,\n  );\n  await connection.confirmTransaction(airdropSignature);\n\n  // you can use any keypair as nonce account authority,\n  // but nonceAccountAuth must be the same as the one used in nonce account creation\n  // load default solana keypair for nonce account authority\n  const nonceAccountAuth = await getKeypairFromFile();\n\n  const nonceAccountPubkey = new PublicKey(\n    \"7H18z3v3rZEoKiwY3kh8DLn9eFT6nFCQ2m4kiC7RZ3a4\",\n  );\n  let nonceAccountInfo = await connection.getAccountInfo(nonceAccountPubkey);\n  let nonceAccount = NonceAccount.fromAccountData(nonceAccountInfo.data);\n\n  let tx = new Transaction().add(\n    // nonce advance must be the first instruction\n    SystemProgram.nonceAdvance({\n      noncePubkey: nonceAccountPubkey,\n      authorizedPubkey: nonceAccountAuth.publicKey,\n    }),\n    // after that, you do what you really want to do, here we append a transfer instruction as an example.\n    SystemProgram.transfer({\n      fromPubkey: feePayer.publicKey,\n      toPubkey: nonceAccountAuth.publicKey,\n      lamports: 1,\n    }),\n  );\n  // assign `nonce` as recentBlockhash\n  tx.recentBlockhash = nonceAccount.nonce;\n  tx.feePayer = feePayer.publicKey;\n  tx.sign(\n    feePayer,\n    nonceAccountAuth,\n  ); /* fee payer + nonce account authority + ... */\n\n  console.log(`txhash: ${await connection.sendRawTransaction(tx.serialize())}`);\n})();",
    "import {\n  createTransaction,\n  createSolanaClient,\n  signTransactionMessageWithSigners,\n  getMinimumBalanceForRentExemption,\n  generateKeyPairSigner,\n} from \"gill\";\nimport { loadKeypairSignerFromFile } from \"gill/node\";\nimport {\n  getCreateAccountInstruction,\n  SYSTEM_PROGRAM_ADDRESS,\n} from \"gill/programs\";\n\nconst { rpc, sendAndConfirmTransaction } = createSolanaClient({\n  urlOrMoniker: \"devnet\",\n});\n\nconst { value: latestBlockhash } = await rpc.getLatestBlockhash().send();\n\nconst signer = await loadKeypairSignerFromFile();\n\nconst newAccount = await generateKeyPairSigner();\n\nconst space = 0n; // any extra space in the account\n\nconst rentLamports = getMinimumBalanceForRentExemption(space);\n// const rentLamports = await rpc.getMinimumBalanceForRentExemption(space).send();\n\nconst tx = createTransaction({\n  version: \"legacy\",\n  feePayer: signer,\n  instructions: [\n    getCreateAccountInstruction({\n      lamports: rentLamports,\n      newAccount: newAccount,\n      payer: signer,\n      space: space,\n      // \"wallet\" accounts are owned by the system program\n      programAddress: SYSTEM_PROGRAM_ADDRESS,\n    }),\n  ],\n  latestBlockhash,\n});\n\nconst signedTransaction = await signTransactionMessageWithSigners(tx);\nawait sendAndConfirmTransaction(signedTransaction);",
    "import { getMinimumBalanceForRentExemption } from \"gill\";\n\n// allocate 1.5k bytes of extra space in the account for data\nconst space = 1500n;\n\nconst lamports = getMinimumBalanceForRentExemption(space);\nconsole.log(\"Minimum balance for rent exemption:\", lamports);",
    "import { createSolanaClient } from \"gill\";\n\nconst { rpc } = createSolanaClient({\n  urlOrMoniker: \"devnet\", // or `mainnet`, `localnet`, etc\n});\n\n// allocate 1.5k bytes of extra space in the account for data\nconst space = 1500n;\n\nconst lamports = await rpc.getMinimumBalanceForRentExemption(space).send();\nconsole.log(\"Minimum balance for rent exemption:\", lamports);",
    "import { PublicKey } from \"@solana/web3.js\";\n\nconst programId = new PublicKey(\"G1DCNUQTSGHehwdLCAmRyAG8hf51eCHrLNUqkgGKYASj\");\n\nlet [pda, bump] = PublicKey.findProgramAddressSync(\n  [Buffer.from(\"test\")],\n  programId,\n);\nconsole.log(`bump: ${bump}, pubkey: ${pda.toBase58()}`);\n// you will find the result is different from `createProgramAddress`.\n// It is expected because the real seed we used to calculate is [\"test\" + bump]",
    "use solana_program::{\n    account_info::next_account_info, account_info::AccountInfo, entrypoint,\n    entrypoint::ProgramResult, program::invoke_signed, pubkey::Pubkey, system_instruction, sysvar::{rent::Rent, Sysvar}\n};\n\nentrypoint!(process_instruction);\n\nfn process_instruction(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    instruction_data: &[u8],\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n\n    let payer_account_info = next_account_info(account_info_iter)?;\n    let pda_account_info = next_account_info(account_info_iter)?;\n    let rent_sysvar_account_info = &Rent::from_account_info(next_account_info(account_info_iter)?)?;\n\n    // find space and minimum rent required for account\n    let space = instruction_data[0];\n    let bump = instruction_data[1];\n    let rent_lamports = rent_sysvar_account_info.minimum_balance(space.into());\n\n    invoke_signed(\n        &system_instruction::create_account(\n            &payer_account_info.key,\n            &pda_account_info.key,\n            rent_lamports,\n            space.into(),\n            program_id\n        ),\n        &[\n            payer_account_info.clone(),\n            pda_account_info.clone()\n        ],\n        &[&[&payer_account_info.key.as_ref(), &[bump]]]\n    )?;\n\n    Ok(())\n}",
    "import {\n  clusterApiUrl,\n  Connection,\n  Keypair,\n  Transaction,\n  SystemProgram,\n  PublicKey,\n  TransactionInstruction,\n  LAMPORTS_PER_SOL,\n  SYSVAR_RENT_PUBKEY,\n} from \"@solana/web3.js\";\n\n(async () => {\n  // program id\n  const programId = new PublicKey(\n    \"7ZP42kRwUQ2zgbqXoaXzAFaiQnDyp6swNktTSv8mNQGN\",\n  );\n\n  // connection\n  const connection = new Connection(clusterApiUrl(\"devnet\"), \"confirmed\");\n\n  // setup fee payer\n  const feePayer = Keypair.generate();\n  const feePayerAirdropSignature = await connection.requestAirdrop(\n    feePayer.publicKey,\n    LAMPORTS_PER_SOL,\n  );\n  await connection.confirmTransaction(feePayerAirdropSignature);\n\n  // setup pda\n  let [pda, bump] = await PublicKey.findProgramAddress(\n    [feePayer.publicKey.toBuffer()],\n    programId,\n  );\n  console.log(`bump: ${bump}, pubkey: ${pda.toBase58()}`);\n\n  const data_size = 0;\n\n  let tx = new Transaction().add(\n    new TransactionInstruction({\n      keys: [\n        {\n          pubkey: feePayer.publicKey,\n          isSigner: true,\n          isWritable: true,\n        },\n        {\n          pubkey: pda,\n          isSigner: false,\n          isWritable: true,\n        },\n        {\n          pubkey: SYSVAR_RENT_PUBKEY,\n          isSigner: false,\n          isWritable: false,\n        },\n        {\n          pubkey: SystemProgram.programId,\n          isSigner: false,\n          isWritable: false,\n        },\n      ],\n      data: Buffer.from(new Uint8Array([data_size, bump])),\n      programId: programId,\n    }),\n  );\n\n  console.log(`txhash: ${await connection.sendTransaction(tx, [feePayer])}`);\n})();",
    "use solana_program::{\n    account_info::next_account_info, account_info::AccountInfo, entrypoint,\n    entrypoint::ProgramResult, program::invoke_signed, pubkey::Pubkey, system_instruction,\n};\n\nentrypoint!(process_instruction);\n\nfn process_instruction(\n    _program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    instruction_data: &[u8],\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n\n    let pda_account_info = next_account_info(account_info_iter)?;\n    let to_account_info = next_account_info(account_info_iter)?;\n    let system_program_account_info = next_account_info(account_info_iter)?;\n\n    // pass bump seed for saving compute budget\n    let bump_seed = instruction_data[0];\n\n    invoke_signed(\n        &system_instruction::transfer(\n            &pda_account_info.key,\n            &to_account_info.key,\n            100_000_000, // 0.1 SOL\n        ),\n        &[\n            pda_account_info.clone(),\n            to_account_info.clone(),\n            system_program_account_info.clone(),\n        ],\n        &[&[b\"escrow\", &[bump_seed]]],\n    )?;\n\n    Ok(())\n}\n",
    "use solana_program::{\n    account_info::next_account_info, account_info::AccountInfo, entrypoint,\n    entrypoint::ProgramResult, pubkey::Pubkey,\n};\n\nentrypoint!(process_instruction);\n\nfn process_instruction(\n    _program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    _instruction_data: &[u8],\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n\n    let source_account_info = next_account_info(account_info_iter)?;\n    let dest_account_info = next_account_info(account_info_iter)?;\n\n    let dest_starting_lamports = dest_account_info.lamports();\n    **dest_account_info.lamports.borrow_mut() = dest_starting_lamports\n        .checked_add(source_account_info.lamports())\n        .unwrap();\n    **source_account_info.lamports.borrow_mut() = 0;\n\n    source_account_info.assign(&system_program::ID);\n    source_account_info.realloc(0, false).map_err(Into::into)\n\n    Ok(())\n}",
    "import { createSolanaClient, LAMPORTS_PER_SOL, address } from \"gill\";\n\nconst { rpc } = createSolanaClient({\n  urlOrMoniker: \"devnet\", // or `mainnet`, `localnet`, etc\n});\n\nconst wallet = address(\"nicktrLHhYzLmoVbuZQzHUTicd2sfP571orwo9jfc8c\");\nconst { value: balance } = await rpc.getBalance(wallet).send();\nconsole.log(`Balance: ${Number(balance) / LAMPORTS_PER_SOL} SOL`);",
    "/// Transfers lamports from one account (must be program owned)\n/// to another account. The recipient can be any account\nfn transfer_service_fee_lamports(\n    from_account: &AccountInfo,\n    to_account: &AccountInfo,\n    amount_of_lamports: u64,\n) -> ProgramResult {\n    // Does the from account have enough lamports to transfer?\n    if **from_account.try_borrow_lamports()? < amount_of_lamports {\n        return Err(CustomError::InsufficientFundsForTransaction.into());\n    }\n    // Debit from_account and credit to_account\n    **from_account.try_borrow_mut_lamports()? -= amount_of_lamports;\n    **to_account.try_borrow_mut_lamports()? += amount_of_lamports;\n    Ok(())\n}\n\n/// Primary function handler associated with instruction sent\n/// to your program\nfn instruction_handler(accounts: &[AccountInfo]) -> ProgramResult {\n    // Get the 'from' and 'to' accounts\n    let account_info_iter = &mut accounts.iter();\n    let from_account = next_account_info(account_info_iter)?;\n    let to_service_account = next_account_info(account_info_iter)?;\n\n    // Extract a service 'fee' of 5 lamports for performing this instruction\n    transfer_service_fee_lamports(from_account, to_service_account, 5u64)?;\n\n    // Perform the primary instruction\n    // ... etc.\n\n    Ok(())\n}",
    "use borsh::{BorshDeserialize, BorshSerialize};\nuse solana_program::{\n    account_info::{next_account_info, AccountInfo},\n    clock::Clock,\n    entrypoint,\n    entrypoint::ProgramResult,\n    msg,\n    pubkey::Pubkey,\n    sysvar::Sysvar,\n};\n\nentrypoint!(process_instruction);\n\n#[derive(BorshSerialize, BorshDeserialize, Debug)]\npub struct HelloState {\n    is_initialized: bool,\n}\n\n// Accounts required\n/// 1. [signer, writable] Payer\n/// 2. [writable] Hello state account\n/// 3. [] Clock sys var\npub fn process_instruction(\n    _program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    _instruction_data: &[u8],\n) -> ProgramResult {\n    let accounts_iter = &mut accounts.iter();\n    // Payer account\n    let _payer_account = next_account_info(accounts_iter)?;\n    // Hello state account\n    let hello_state_account = next_account_info(accounts_iter)?;\n    // Clock sysvar\n    let sysvar_clock_pubkey = next_account_info(accounts_iter)?;\n\n    let mut hello_state = HelloState::try_from_slice(&hello_state_account.data.borrow())?;\n    hello_state.is_initialized = true;\n    hello_state.serialize(&mut &mut hello_state_account.data.borrow_mut()[..])?;\n    msg!(\"Account initialized :)\");\n\n    // Type casting [AccountInfo] to [Clock]\n    let clock = Clock::from_account_info(&sysvar_clock_pubkey)?;\n    // Getting timestamp\n    let current_timestamp = clock.unix_timestamp;\n    msg!(\"Current Timestamp: {}\", current_timestamp);\n\n    Ok(())\n}",
    "import {\n  clusterApiUrl,\n  Connection,\n  Keypair,\n  LAMPORTS_PER_SOL,\n  PublicKey,\n  SystemProgram,\n  SYSVAR_CLOCK_PUBKEY,\n  Transaction,\n  TransactionInstruction,\n  sendAndConfirmTransaction,\n} from \"@solana/web3.js\";\n\n(async () => {\n  const programId = new PublicKey(\n    \"77ezihTV6mTh2Uf3ggwbYF2NyGJJ5HHah1GrdowWJVD3\",\n  );\n\n  const connection = new Connection(clusterApiUrl(\"devnet\"), \"confirmed\");\n  const latestBlockHash = await connection.getLatestBlockhash();\n\n  // Airdropping 1 SOL\n  const feePayer = Keypair.generate();\n  await connection.confirmTransaction(\n    {\n      blockhash: latestBlockHash.blockhash,\n      lastValidBlockHeight: latestBlockHash.lastValidBlockHeight,\n      signature: await connection.requestAirdrop(\n        feePayer.publicKey,\n        LAMPORTS_PER_SOL,\n      ),\n    },\n    \"confirmed\",\n  );\n\n  // Hello state account\n  const helloAccount = Keypair.generate();\n\n  const accountSpace = 1; // because there exists just one boolean variable\n  const rentRequired =\n    await connection.getMinimumBalanceForRentExemption(accountSpace);\n\n  // Allocating space for hello state account\n  const allocateHelloAccountIx = SystemProgram.createAccount({\n    fromPubkey: feePayer.publicKey,\n    lamports: rentRequired,\n    newAccountPubkey: helloAccount.publicKey,\n    programId: programId,\n    space: accountSpace,\n  });\n\n  // Passing Clock Sys Var\n  const passClockIx = new TransactionInstruction({\n    programId: programId,\n    keys: [\n      {\n        isSigner: true,\n        isWritable: true,\n        pubkey: feePayer.publicKey,\n      },\n      {\n        isSigner: false,\n        isWritable: true,\n        pubkey: helloAccount.publicKey,\n      },\n      {\n        isSigner: false,\n        isWritable: false,\n        pubkey: SYSVAR_CLOCK_PUBKEY,\n      },\n    ],\n  });\n\n  const transaction = new Transaction();\n  transaction.add(allocateHelloAccountIx, passClockIx);\n\n  const txHash = await sendAndConfirmTransaction(connection, transaction, [\n    feePayer,\n    helloAccount,\n  ]);\n\n  console.log(`Transaction succeeded. TxHash: ${txHash}`);\n})();",
    "use borsh::{BorshDeserialize, BorshSerialize};\nuse solana_program::{\n    account_info::{next_account_info, AccountInfo},\n    clock::Clock,\n    entrypoint,\n    entrypoint::ProgramResult,\n    msg,\n    pubkey::Pubkey,\n    sysvar::Sysvar,\n};\n\nentrypoint!(process_instruction);\n\n#[derive(BorshSerialize, BorshDeserialize, Debug)]\npub struct HelloState {\n    is_initialized: bool,\n}\n\n// Accounts required\n/// 1. [signer, writable] Payer\n/// 2. [writable] Hello state account\npub fn process_instruction(\n    _program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    _instruction_data: &[u8],\n) -> ProgramResult {\n    let accounts_iter = &mut accounts.iter();\n    // Payer account\n    let _payer_account = next_account_info(accounts_iter)?;\n    // Hello state account\n    let hello_state_account = next_account_info(accounts_iter)?;\n\n    // Getting clock directly\n    let clock = Clock::get()?;\n\n    let mut hello_state = HelloState::try_from_slice(&hello_state_account.data.borrow())?;\n    hello_state.is_initialized = true;\n    hello_state.serialize(&mut &mut hello_state_account.data.borrow_mut()[..])?;\n    msg!(\"Account initialized :)\");\n\n    // Getting timestamp\n    let current_timestamp = clock.unix_timestamp;\n    msg!(\"Current Timestamp: {}\", current_timestamp);\n\n    Ok(())\n}",
    "import {\n  clusterApiUrl,\n  Connection,\n  Keypair,\n  LAMPORTS_PER_SOL,\n  PublicKey,\n  SystemProgram,\n  Transaction,\n  TransactionInstruction,\n} from \"@solana/web3.js\";\n\n(async () => {\n  const programId = new PublicKey(\n    \"4ZEdbCtb5UyCSiAMHV5eSHfyjq3QwbG3yXb6oHD7RYjk\",\n  );\n\n  const connection = new Connection(clusterApiUrl(\"devnet\"), \"confirmed\");\n  const latestBlockHash = await connection.getLatestBlockhash();\n\n  // Airdropping 1 SOL\n  const feePayer = Keypair.generate();\n  await connection.confirmTransaction(\n    {\n      blockhash: latestBlockHash.blockhash,\n      lastValidBlockHeight: latestBlockHash.lastValidBlockHeight,\n      signature: await connection.requestAirdrop(\n        feePayer.publicKey,\n        LAMPORTS_PER_SOL,\n      ),\n    },\n    \"confirmed\",\n  );\n\n  // Hello state account\n  const helloAccount = Keypair.generate();\n\n  const accountSpace = 1; // because there exists just one boolean variable\n  const rentRequired =\n    await connection.getMinimumBalanceForRentExemption(accountSpace);\n\n  // Allocating space for hello state account\n  const allocateHelloAccountIx = SystemProgram.createAccount({\n    fromPubkey: feePayer.publicKey,\n    lamports: rentRequired,\n    newAccountPubkey: helloAccount.publicKey,\n    programId: programId,\n    space: accountSpace,\n  });\n\n  const initIx = new TransactionInstruction({\n    programId: programId,\n    keys: [\n      {\n        isSigner: true,\n        isWritable: true,\n        pubkey: feePayer.publicKey,\n      },\n      {\n        isSigner: false,\n        isWritable: true,\n        pubkey: helloAccount.publicKey,\n      },\n    ],\n  });\n\n  const transaction = new Transaction();\n  transaction.add(allocateHelloAccountIx, initIx);\n\n  const txHash = await sendAndConfirmTransaction(connection, transaction, [\n    feePayer,\n    helloAccount,\n  ]);\n\n  console.log(`Transaction succeeded. TxHash: ${txHash}`);\n})();",
    "use {\n  crate::{\n      instruction::WhitelistInstruction,\n      state::WhiteListData,\n  },\n  borsh::{BorshDeserialize, BorshSerialize},\n  solana_program::{\n      account_info::{next_account_info, AccountInfo},\n      entrypoint::ProgramResult,\n      msg,\n      program::invoke_signed,\n      program::invoke,\n      program_error::ProgramError,\n      pubkey::Pubkey,\n      sysvar::Sysvar,\n      sysvar::rent::Rent,\n      system_instruction,\n  },\n  std::convert::TryInto,\n};\n\npub fn process_instruction(\n  _program_id: &Pubkey,\n  accounts: &[AccountInfo],\n  input: &[u8],\n) -> ProgramResult {\n  // Length = BOOL + VEC + Pubkey * n (n = number of keys)\n  const INITIAL_ACCOUNT_LEN: usize = 1 + 4 + 0 ;\n  msg!(\"input: {:?}\", input);\n\n  let instruction = WhitelistInstruction::try_from_slice(input)?;\n\n  let accounts_iter = &mut accounts.iter();\n\n  let funding_account = next_account_info(accounts_iter)?;\n  let pda_account = next_account_info(accounts_iter)?;\n  let system_program = next_account_info(accounts_iter)?;\n\n  match instruction {\n    WhitelistInstruction::Initialize => {\n      msg!(\"Initialize\");\n\n      let (pda, pda_bump) = Pubkey::find_program_address(\n          &[\n            b\"customaddress\",\n            &funding_account.key.to_bytes(),\n          ],\n          _program_id,\n      );\n\n      let signers_seeds: &[&[u8]; 3] = &[\n          b\"customaddress\",\n          &funding_account.key.to_bytes(),\n          &[pda_bump],\n      ];\n\n      if pda.ne(&pda_account.key) {\n          return Err(ProgramError::InvalidAccountData);\n      }\n\n      let lamports_required = Rent::get()?.minimum_balance(INITIAL_ACCOUNT_LEN);\n      let create_pda_account_ix = system_instruction::create_account(\n          &funding_account.key,\n          &pda_account.key,\n          lamports_required,\n          INITIAL_ACCOUNT_LEN.try_into().unwrap(),\n          &_program_id,\n      );\n\n      invoke_signed(\n          &create_pda_account_ix,\n          &[\n              funding_account.clone(),\n              pda_account.clone(),\n              system_program.clone(),\n          ],\n          &[signers_seeds],\n      )?;\n\n      let mut pda_account_state = WhiteListData::try_from_slice(&pda_account.data.borrow())?;\n\n      pda_account_state.is_initialized = true;\n      pda_account_state.white_list = Vec::new();\n      pda_account_state.serialize(&mut &mut pda_account.data.borrow_mut()[..])?;\n      Ok(())\n    }\n    WhitelistInstruction::AddKey { key } => {\n      msg!(\"AddKey\");\n\n      let mut pda_account_state = WhiteListData::try_from_slice(&pda_account.data.borrow())?;\n\n      if !pda_account_state.is_initialized {\n          return Err(ProgramError::InvalidAccountData);\n      }\n\n      let new_size = pda_account.data.borrow().len() + 32;\n\n      let rent = Rent::get()?;\n      let new_minimum_balance = rent.minimum_balance(new_size);\n\n      let lamports_diff = new_minimum_balance.saturating_sub(pda_account.lamports());\n      invoke(\n          &system_instruction::transfer(funding_account.key, pda_account.key, lamports_diff),\n          &[\n              funding_account.clone(),\n              pda_account.clone(),\n              system_program.clone(),\n          ],\n      )?;\n\n      pda_account.realloc(new_size, false)?;\n\n      pda_account_state.white_list.push(key);\n      pda_account_state.serialize(&mut &mut pda_account.data.borrow_mut()[..])?;\n\n      Ok(())\n    }\n  }\n}",
    "use solana_program::{\n    account_info::{next_account_info, AccountInfo},\n    entrypoint,\n    entrypoint::ProgramResult,\n    msg,\n    program::invoke,\n    program_error::ProgramError,\n    pubkey::Pubkey,\n};\nuse spl_token::instruction::transfer;\n\nentrypoint!(process_instruction);\n\n// Accounts required\n/// 1. [writable] Source Token Account\n/// 2. [writable] Destination Token Account\n/// 3. [signer] Source Token Account holder's PubKey\n/// 4. [] Token Program\npub fn process_instruction(\n    _program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    instruction_data: &[u8],\n) -> ProgramResult {\n    let accounts_iter = &mut accounts.iter();\n\n    // Accounts required for token transfer\n\n    // 1. Token account we hold\n    let source_token_account = next_account_info(accounts_iter)?;\n    // 2. Token account to send to\n    let destination_token_account = next_account_info(accounts_iter)?;\n    // 3. Our wallet address\n    let source_token_account_holder = next_account_info(accounts_iter)?;\n    // 4. Token Program\n    let token_program = next_account_info(accounts_iter)?;\n\n    // Parsing the token transfer amount from instruction data\n    // a. Getting the 0th to 8th index of the u8 byte array\n    // b. Converting the obtained non zero u8 to a proper u8 (as little endian integers)\n    // c. Converting the little endian integers to a u64 number\n    let token_transfer_amount = instruction_data\n        .get(..8)\n        .and_then(|slice| slice.try_into().ok())\n        .map(u64::from_le_bytes)\n        .ok_or(ProgramError::InvalidAccountData)?;\n\n    msg!(\n        \"Transferring {} tokens from {} to {}\",\n        token_transfer_amount,\n        source_token_account.key.to_string(),\n        destination_token_account.key.to_string()\n    );\n\n    // Creating a new TransactionInstruction\n    /*\n        Internal representation of the instruction's return value (Result<Instruction, ProgramError>)\n\n        Ok(Instruction {\n            program_id: *token_program_id, // PASSED FROM USER\n            accounts,\n            data,\n        })\n    */\n\n    let transfer_tokens_instruction = transfer(\n        &token_program.key,\n        &source_token_account.key,\n        &destination_token_account.key,\n        &source_token_account_holder.key,\n        &[&source_token_account_holder.key],\n        token_transfer_amount,\n    )?;\n\n    let required_accounts_for_transfer = [\n        source_token_account.clone(),\n        destination_token_account.clone(),\n        source_token_account_holder.clone(),\n    ];\n\n    // Passing the TransactionInstruction to send\n    invoke(\n        &transfer_tokens_instruction,\n        &required_accounts_for_transfer,\n    )?;\n\n    msg!(\"Transfer successful\");\n\n    Ok(())\n}",
    "import {\n  clusterApiUrl,\n  Connection,\n  Keypair,\n  LAMPORTS_PER_SOL,\n  PublicKey,\n  SystemProgram,\n  sendAndConfirmTransaction\n  Transaction,\n  TransactionInstruction,\n} from \"@solana/web3.js\";\nimport {\n  AccountLayout,\n  MintLayout,\n  Token,\n  TOKEN_PROGRAM_ID,\n  u64,\n} from \"@solana/spl-token\";\n\nimport * as BN from \"bn.js\";\n\n// Users\nconst PAYER_KEYPAIR = Keypair.generate();\nconst RECEIVER_KEYPAIR = Keypair.generate().publicKey;\n\n// Mint and token accounts\nconst TOKEN_MINT_ACCOUNT = Keypair.generate();\nconst SOURCE_TOKEN_ACCOUNT = Keypair.generate();\nconst DESTINATION_TOKEN_ACCOUNT = Keypair.generate();\n\n// Numbers\nconst DEFAULT_DECIMALS_COUNT = 9;\nconst TOKEN_TRANSFER_AMOUNT = 50 * 10 ** DEFAULT_DECIMALS_COUNT;\nconst TOKEN_TRANSFER_AMOUNT_BUFFER = Buffer.from(\n  Uint8Array.of(...new BN(TOKEN_TRANSFER_AMOUNT).toArray(\"le\", 8))\n);\n\n(async () => {\n  const connection = new Connection(clusterApiUrl(\"devnet\"), \"confirmed\");\n  const programId = new PublicKey(\n    \"EfYK91eN3AqTwY1C34W6a33qGAtQ8HJYVhNv7cV4uMZj\"\n  );\n\n  const mintDataSpace = MintLayout.span;\n  const mintRentRequired = await connection.getMinimumBalanceForRentExemption(\n    mintDataSpace\n  );\n\n  const tokenDataSpace = AccountLayout.span;\n  const tokenRentRequired = await connection.getMinimumBalanceForRentExemption(\n    tokenDataSpace\n  );\n\n  // Airdropping 1 SOL\n  const feePayer = Keypair.generate();\n  await connection.confirmTransaction({\n      blockhash: latestBlockHash.blockhash,\n      lastValidBlockHeight: latestBlockHash.lastValidBlockHeight,\n      signature: await connection.requestAirdrop(feePayer.publicKey, LAMPORTS_PER_SOL),\n    },\n    'confirmed',\n  );\n\n\n  // Allocating space and rent for mint account\n  const createMintAccountIx = SystemProgram.createAccount({\n    fromPubkey: PAYER_KEYPAIR.publicKey,\n    lamports: mintRentRequired,\n    newAccountPubkey: TOKEN_MINT_ACCOUNT.publicKey,\n    programId: TOKEN_PROGRAM_ID,\n    space: mintDataSpace,\n  });\n\n  // Initializing mint with decimals and authority\n  const initializeMintIx = Token.createInitMintInstruction(\n    TOKEN_PROGRAM_ID,\n    TOKEN_MINT_ACCOUNT.publicKey,\n    DEFAULT_DECIMALS_COUNT,\n    PAYER_KEYPAIR.publicKey, // mintAuthority\n    PAYER_KEYPAIR.publicKey // freezeAuthority\n  );\n\n  // Allocating space and rent for source token account\n  const createSourceTokenAccountIx = SystemProgram.createAccount({\n    fromPubkey: PAYER_KEYPAIR.publicKey,\n    newAccountPubkey: SOURCE_TOKEN_ACCOUNT.publicKey,\n    lamports: tokenRentRequired,\n    programId: TOKEN_PROGRAM_ID,\n    space: tokenDataSpace,\n  });\n\n  // Initializing token account with mint and owner\n  const initializeSourceTokenAccountIx = Token.createInitAccountInstruction(\n    TOKEN_PROGRAM_ID,\n    TOKEN_MINT_ACCOUNT.publicKey,\n    SOURCE_TOKEN_ACCOUNT.publicKey,\n    PAYER_KEYPAIR.publicKey\n  );\n\n  // Minting tokens to the source token account for transferring later to destination account\n  const mintTokensIx = Token.createMintToInstruction(\n    TOKEN_PROGRAM_ID,\n    TOKEN_MINT_ACCOUNT.publicKey,\n    SOURCE_TOKEN_ACCOUNT.publicKey,\n    PAYER_KEYPAIR.publicKey,\n    [PAYER_KEYPAIR],\n    TOKEN_TRANSFER_AMOUNT\n  );\n\n  // Allocating space and rent for destination token account\n  const createDestinationTokenAccountIx = SystemProgram.createAccount({\n    fromPubkey: PAYER_KEYPAIR.publicKey,\n    newAccountPubkey: DESTINATION_TOKEN_ACCOUNT.publicKey,\n    lamports: tokenRentRequired,\n    programId: TOKEN_PROGRAM_ID,\n    space: tokenDataSpace,\n  });\n\n  // Initializing token account with mint and owner\n  const initializeDestinationTokenAccountIx =\n    Token.createInitAccountInstruction(\n      TOKEN_PROGRAM_ID,\n      TOKEN_MINT_ACCOUNT.publicKey,\n      DESTINATION_TOKEN_ACCOUNT.publicKey,\n      RECEIVER_KEYPAIR\n    );\n\n  // Our program's CPI instruction (transfer)\n  const transferTokensIx = new TransactionInstruction({\n    programId: programId,\n    data: TOKEN_TRANSFER_AMOUNT_BUFFER,\n    keys: [\n      {\n        isSigner: false,\n        isWritable: true,\n        pubkey: SOURCE_TOKEN_ACCOUNT.publicKey,\n      },\n      {\n        isSigner: false,\n        isWritable: true,\n        pubkey: DESTINATION_TOKEN_ACCOUNT.publicKey,\n      },\n      {\n        isSigner: true,\n        isWritable: true,\n        pubkey: PAYER_KEYPAIR.publicKey,\n      },\n      {\n        isSigner: false,\n        isWritable: false,\n        pubkey: TOKEN_PROGRAM_ID,\n      },\n    ],\n  });\n\n  const transaction = new Transaction();\n  // Adding up all the above instructions\n  transaction.add(\n    createMintAccountIx,\n    initializeMintIx,\n    createSourceTokenAccountIx,\n    initializeSourceTokenAccountIx,\n    mintTokensIx,\n    createDestinationTokenAccountIx,\n    initializeDestinationTokenAccountIx,\n    transferTokensIx\n  );\n\n  const txHash = await sendAndConfirmTransaction(connection, transaction, [\n    PAYER_KEYPAIR,\n    TOKEN_MINT_ACCOUNT,\n    SOURCE_TOKEN_ACCOUNT,\n    DESTINATION_TOKEN_ACCOUNT,\n  ]);\n\n  console.log(`Token transfer CPI success: ${txHash}`);\n})();",
    "use solana_program::{\n    account_info::{next_account_info, AccountInfo},\n    entrypoint,\n    entrypoint::ProgramResult,\n    msg,\n    program::invoke,\n    program_error::ProgramError,\n    pubkey::Pubkey,\n    rent::Rent,\n    system_instruction::create_account,\n    sysvar::Sysvar,\n};\n\nentrypoint!(process_instruction);\n\n// Accounts required\n/// 1. [signer, writable] Payer Account\n/// 2. [signer, writable] General State Account\n/// 3. [] System Program\npub fn process_instruction(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    instruction_data: &[u8],\n) -> ProgramResult {\n    let accounts_iter = &mut accounts.iter();\n\n    // Accounts required for token transfer\n\n    // 1. Payer account for the state account creation\n    let payer_account = next_account_info(accounts_iter)?;\n    // 2. Token account we hold\n    let general_state_account = next_account_info(accounts_iter)?;\n    // 3. System Program\n    let system_program = next_account_info(accounts_iter)?;\n\n    msg!(\n        \"Creating account for {}\",\n        general_state_account.key.to_string()\n    );\n\n    // Parsing the token transfer amount from instruction data\n    // a. Getting the 0th to 8th index of the u8 byte array\n    // b. Converting the obtained non zero u8 to a proper u8 (as little endian integers)\n    // c. Converting the little endian integers to a u64 number\n    let account_span = instruction_data\n        .get(..8)\n        .and_then(|slice| slice.try_into().ok())\n        .map(u64::from_le_bytes)\n        .ok_or(ProgramError::InvalidAccountData)?;\n\n    let lamports_required = (Rent::get()?).minimum_balance(account_span as usize);\n\n    // Creating a new TransactionInstruction\n    /*\n        Internal representation of the instruction's return value (Instruction)\n\n        Instruction::new_with_bincode(\n            system_program::id(), // NOT PASSED FROM USER\n            &SystemInstruction::CreateAccount {\n                lamports,\n                space,\n                owner: *owner,\n            },\n            account_metas,\n        )\n    */\n\n    let create_account_instruction = create_account(\n        &payer_account.key,\n        &general_state_account.key,\n        lamports_required,\n        account_span,\n        program_id,\n    );\n\n    let required_accounts_for_create = [\n        payer_account.clone(),\n        general_state_account.clone(),\n        system_program.clone(),\n    ];\n\n    // Passing the TransactionInstruction to send (with the issued program_id)\n    invoke(&create_account_instruction, &required_accounts_for_create)?;\n\n    msg!(\"Transfer successful\");\n\n    Ok(())\n}",
    "import { clusterApiUrl, Connection, Keypair } from \"@solana/web3.js\";\nimport { LAMPORTS_PER_SOL, PublicKey, SystemProgram } from \"@solana/web3.js\";\nimport {\n  Transaction,\n  TransactionInstruction,\n  sendAndConfirmTransaction,\n} from \"@solana/web3.js\";\n\nimport * as BN from \"bn.js\";\n\n// Users\nconst PAYER_KEYPAIR = Keypair.generate();\nconst GENERAL_STATE_KEYPAIR = Keypair.generate();\n\nconst ACCOUNT_SPACE_BUFFER = Buffer.from(\n  Uint8Array.of(...new BN(100).toArray(\"le\", 8)),\n);\n\n(async () => {\n  const connection = new Connection(clusterApiUrl(\"devnet\"), \"confirmed\");\n  const latestBlockHash = await connection.getLatestBlockhash();\n  const programId = new PublicKey(\n    \"DkuQ5wsndkzXfgqDB6Lgf4sDjBi4gkLSak1dM5Mn2RuQ\",\n  );\n\n  // Airdropping 1 SOL\n  const feePayer = Keypair.generate();\n  await connection.confirmTransaction(\n    {\n      blockhash: latestBlockHash.blockhash,\n      lastValidBlockHeight: latestBlockHash.lastValidBlockHeight,\n      signature: await connection.requestAirdrop(\n        feePayer.publicKey,\n        LAMPORTS_PER_SOL,\n      ),\n    },\n    \"confirmed\",\n  );\n\n  // Our program's CPI instruction (create_account)\n  const createAccountIx = new TransactionInstruction({\n    programId: programId,\n    data: ACCOUNT_SPACE_BUFFER,\n    keys: [\n      {\n        isSigner: true,\n        isWritable: true,\n        pubkey: PAYER_KEYPAIR.publicKey,\n      },\n      {\n        isSigner: true,\n        isWritable: true,\n        pubkey: GENERAL_STATE_KEYPAIR.publicKey,\n      },\n      {\n        isSigner: false,\n        isWritable: false,\n        pubkey: SystemProgram.programId,\n      },\n    ],\n  });\n\n  const transaction = new Transaction();\n  // Adding up all the above instructions\n  transaction.add(createAccountIx);\n\n  const txHash = await sendAndConfirmTransaction(connection, transaction, [\n    PAYER_KEYPAIR,\n    GENERAL_STATE_KEYPAIR,\n  ]);\n\n  console.log(`Create Account CPI Success: ${txHash}`);\n})();",
    "use borsh::{BorshDeserialize, BorshSerialize};\nuse solana_program::{\n    account_info::{next_account_info, AccountInfo},\n    entrypoint,\n    entrypoint::ProgramResult,\n    program::invoke_signed,\n    program_error::ProgramError,\n    pubkey::Pubkey,\n    rent::Rent,\n    system_instruction,\n    sysvar::Sysvar,\n};\n\nentrypoint!(process_instruction);\n\n#[derive(BorshSerialize, BorshDeserialize, Debug)]\npub struct HelloState {\n    is_initialized: bool,\n}\n\n// Accounts required\n/// 1. [signer, writable] Funding account\n/// 2. [writable] PDA account\n/// 3. [] System Program\npub fn process_instruction(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    instruction_data: &[u8],\n) -> ProgramResult {\n    const ACCOUNT_DATA_LEN: usize = 1;\n\n    let accounts_iter = &mut accounts.iter();\n    // Getting required accounts\n    let funding_account = next_account_info(accounts_iter)?;\n    let pda_account = next_account_info(accounts_iter)?;\n    let system_program = next_account_info(accounts_iter)?;\n\n    // Getting PDA Bump from instruction data\n    let (pda_bump, _) = instruction_data\n        .split_first()\n        .ok_or(ProgramError::InvalidInstructionData)?;\n\n    // Checking if passed PDA and expected PDA are equal\n    let signers_seeds: &[&[u8]; 3] = &[\n        b\"customaddress\",\n        &funding_account.key.to_bytes(),\n        &[*pda_bump],\n    ];\n    let pda = Pubkey::create_program_address(signers_seeds, program_id)?;\n\n    if pda.ne(&pda_account.key) {\n        return Err(ProgramError::InvalidAccountData);\n    }\n\n    // Assessing required lamports and creating transaction instruction\n    let lamports_required = Rent::get()?.minimum_balance(ACCOUNT_DATA_LEN);\n    let create_pda_account_ix = system_instruction::create_account(\n        &funding_account.key,\n        &pda_account.key,\n        lamports_required,\n        ACCOUNT_DATA_LEN.try_into().unwrap(),\n        &program_id,\n    );\n    // Invoking the instruction but with PDAs as additional signer\n    invoke_signed(\n        &create_pda_account_ix,\n        &[\n            funding_account.clone(),\n            pda_account.clone(),\n            system_program.clone(),\n        ],\n        &[signers_seeds],\n    )?;\n\n    // Setting state for PDA\n    let mut pda_account_state = HelloState::try_from_slice(&pda_account.data.borrow())?;\n    pda_account_state.is_initialized = true;\n    pda_account_state.serialize(&mut &mut pda_account.data.borrow_mut()[..])?;\n\n    Ok(())\n}",
    "import {\n  clusterApiUrl,\n  Connection,\n  Keypair,\n  LAMPORTS_PER_SOL,\n  PublicKey,\n  sendAndConfirmTransaction,\n  SystemProgram,\n  Transaction,\n  TransactionInstruction,\n} from \"@solana/web3.js\";\n\nconst PAYER_KEYPAIR = Keypair.generate();\n\n(async () => {\n  const connection = new Connection(clusterApiUrl(\"devnet\"), \"confirmed\");\n  const latestBlockHash = await connection.getLatestBlockhash();\n  const programId = new PublicKey(\n    \"6eW5nnSosr2LpkUGCdznsjRGDhVb26tLmiM1P8RV1QQp\",\n  );\n\n  // Airdrop to Payer\n  await connection.confirmTransaction(\n    {\n      blockhash: latestBlockHash.blockhash,\n      lastValidBlockHeight: latestBlockHash.lastValidBlockHeight,\n      signature: await connection.requestAirdrop(\n        PAYER_KEYPAIR.publicKey,\n        LAMPORTS_PER_SOL,\n      ),\n    },\n    \"confirmed\",\n  );\n\n  const [pda, bump] = await PublicKey.findProgramAddress(\n    [Buffer.from(\"customaddress\"), PAYER_KEYPAIR.publicKey.toBuffer()],\n    programId,\n  );\n\n  console.log(`PDA Pubkey: ${pda.toString()}`);\n\n  const createPDAIx = new TransactionInstruction({\n    programId: programId,\n    data: Buffer.from(Uint8Array.of(bump)),\n    keys: [\n      {\n        isSigner: true,\n        isWritable: true,\n        pubkey: PAYER_KEYPAIR.publicKey,\n      },\n      {\n        isSigner: false,\n        isWritable: true,\n        pubkey: pda,\n      },\n      {\n        isSigner: false,\n        isWritable: false,\n        pubkey: SystemProgram.programId,\n      },\n    ],\n  });\n\n  const transaction = new Transaction();\n  transaction.add(createPDAIx);\n\n  const txHash = await sendAndConfirmTransaction(connection, transaction, [\n    PAYER_KEYPAIR,\n  ]);\n  console.log(`Created PDA successfully. Tx Hash: ${txHash}`);\n})();",
    "use borsh::{BorshDeserialize, BorshSerialize};\nuse solana_program::{\n    account_info::{next_account_info, AccountInfo},\n    entrypoint,\n    entrypoint::ProgramResult,\n    pubkey::Pubkey,\n};\n\nentrypoint!(process_instruction);\n\n#[derive(BorshSerialize, BorshDeserialize, Debug)]\npub struct HelloState {\n    is_initialized: bool,\n}\n\n// Accounts required\n/// 1. [signer] Payer\n/// 2. [writable] Hello state account\n/// 3. [] Rent account\n/// 4. [] System Program\npub fn process_instruction(\n    _program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    _instruction_data: &[u8],\n) -> ProgramResult {\n    // Fetching all the accounts as a iterator (facilitating for loops and iterations)\n    let accounts_iter = &mut accounts.iter();\n    // Payer account\n    let payer_account = next_account_info(accounts_iter)?;\n    // Hello state account\n    let hello_state_account = next_account_info(accounts_iter)?;\n    // Rent account\n    let rent_account = next_account_info(accounts_iter)?;\n    // System Program\n    let system_program = next_account_info(accounts_iter)?;\n\n    Ok(())\n}",
    "use anchor_lang::{\n    prelude::*,\n    solana_program::{\n        sysvar,\n        serialize_utils::{read_pubkey,read_u16}\n    }\n};\n\ndeclare_id!(\"8DJXJRV8DBFjJDYyU9cTHBVK1F1CTCi6JUBDVfyBxqsT\");\n\n#[program]\npub mod cookbook {\n    use super::*;\n\n    pub fn read_multiple_instruction<'info>(ctx: Context<ReadMultipleInstruction>, creator_bump: u8) -> Result<()> {\n        let instruction_sysvar_account = &ctx.accounts.instruction_sysvar_account;\n\n        let instruction_sysvar_account_info = instruction_sysvar_account.to_account_info();\n\n        let id = \"8DJXJRV8DBFjJDYyU9cTHBVK1F1CTCi6JUBDVfyBxqsT\";\n\n        let instruction_sysvar = instruction_sysvar_account_info.data.borrow();\n\n        let mut idx = 0;\n\n        let num_instructions = read_u16(&mut idx, &instruction_sysvar)\n        .map_err(|_| MyError::NoInstructionFound)?;\n\n        for index in 0..num_instructions {\n            let mut current = 2 + (index * 2) as usize;\n            let start = read_u16(&mut current, &instruction_sysvar).unwrap();\n\n            current = start as usize;\n            let num_accounts = read_u16(&mut current, &instruction_sysvar).unwrap();\n            current += (num_accounts as usize) * (1 + 32);\n            let program_id = read_pubkey(&mut current, &instruction_sysvar).unwrap();\n\n            if program_id != id\n            {\n                msg!(\"Transaction had ix with program id {}\", program_id);\n                return Err(MyError::SuspiciousTransaction.into());\n            }\n        }\n\n        Ok(())\n    }\n\n}\n\n#[derive(Accounts)]\n#[instruction(creator_bump:u8)]\npub struct ReadMultipleInstruction<'info> {\n    #[account(address = sysvar::instructions::id())]\n    instruction_sysvar_account: UncheckedAccount<'info>\n}\n\n#[error_code]\npub enum MyError {\n    #[msg(\"No instructions found\")]\n    NoInstructionFound,\n    #[msg(\"Suspicious transaction detected\")]\n    SuspiciousTransaction\n}",
    "use borsh::{BorshDeserialize, BorshSerialize};\nuse solana_program::{\n    account_info::{next_account_info, AccountInfo},\n    clock::Clock,\n    entrypoint,\n    entrypoint::ProgramResult,\n    msg,\n    program_error::ProgramError,\n    pubkey::Pubkey,\n    rent::Rent,\n    system_program::ID as SYSTEM_PROGRAM_ID,\n    sysvar::Sysvar,\n};\n\nentrypoint!(process_instruction);\n\n#[derive(BorshSerialize, BorshDeserialize, Debug)]\npub struct HelloState {\n    is_initialized: bool,\n}\n\n// Accounts required\n/// 1. [signer] Payer\n/// 2. [writable] Hello state account\n/// 3. [] System Program\npub fn process_instruction(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    _instruction_data: &[u8],\n) -> ProgramResult {\n    let accounts_iter = &mut accounts.iter();\n    // Payer account\n    let payer_account = next_account_info(accounts_iter)?;\n    // Hello state account\n    let hello_state_account = next_account_info(accounts_iter)?;\n    // System Program\n    let system_program = next_account_info(accounts_iter)?;\n\n    let rent = Rent::get()?;\n\n    // Checking if payer account is the signer\n    if !payer_account.is_signer {\n        return Err(ProgramError::MissingRequiredSignature);\n    }\n\n    // Checking if hello state account is rent exempt\n    if !rent.is_exempt(hello_state_account.lamports(), 1) {\n        return Err(ProgramError::AccountNotRentExempt);\n    }\n\n    // Checking if hello state account is writable\n    if !hello_state_account.is_writable {\n        return Err(ProgramError::InvalidAccountData);\n    }\n\n    // Checking if hello state account's owner is the current program\n    if hello_state_account.owner.ne(&program_id) {\n        return Err(ProgramError::IllegalOwner);\n    }\n\n    // Checking if the system program is valid\n    if system_program.key.ne(&SYSTEM_PROGRAM_ID) {\n        return Err(ProgramError::IncorrectProgramId);\n    }\n\n    let mut hello_state = HelloState::try_from_slice(&hello_state_account.data.borrow())?;\n\n    // Checking if the state has already been initialized\n    if hello_state.is_initialized {\n        return Err(ProgramError::AccountAlreadyInitialized);\n    }\n\n    hello_state.is_initialized = true;\n    hello_state.serialize(&mut &mut hello_state_account.data.borrow_mut()[..])?;\n    msg!(\"Account initialized :)\");\n\n    Ok(())\n}"
  ],
  "snippets_from_pdf": [
    "import { Connection, PublicKey } from \"@solana/web3.js\";\nimport { promises as fs } from \"fs\";\nimport path from \"path\";\nimport { URL } from \"url\";\nimport dotenv from \"dotenv\";\nimport axios from \"axios\";",
    "dotenv.config();\nconst __dirname = new URL(\".\", import.meta.url).pathname;",
    "const rpcUrl = process.env.RPC_URL;\nconst heliusEnrichedApiUrl = process.env.HELIUS_ENRICHED_URL;\nconst heliusApiKey = process.env.HELIUS_API_KEY;\nif (!rpcUrl || !heliusEnrichedApiUrl || !heliusApiKey) {\n  throw new Error(\n    \"RPC_URL or HELIUS_ENRICHED_URL or HELIUS_API_KEY is not d\n  );\n}",
    "const connection = new Connection(rpcUrl!);",
    "const getAllTransactionSignaturesForAddress = async (\n  collectionMint: PublicKey\n): Promise<string[]> => {\n  let lastReceivedTransactionSignature = \"\";",
    "const transactionSignatures: string[] = [];",
    "while (true) {\n    const signaturesForAddress = await connection.getSignature\n      collectionMint,",
    "{\n        before: lastReceivedTransactionSignature\n          ? lastReceivedTransactionSignature\n          : undefined,\n        limit: 1000,\n      }\n    );",
    "const signatures = signaturesForAddress.map(\n      (signatureObj) => signatureObj.signature\n    );",
    "transactionSignatures.push(...signatures);",
    "if (signaturesForAddress.length < 1000) {\n      break;\n    }\n  }",
    "return transactionSignatures;\n};",
    "const getParsedTransactions = async (transactionSignatures: s\n  const result = await axios.post(\n    `${heliusEnrichedApiUrl}/v0/transactions/?api-key=${heliu\n    {\n      transactions: transactionSignatures,\n    }\n  );",
    "return result.data;\n};",
    "const getAirdroppedAddresses = async (collectionMint: PublicKe\n  const airdroppedAddresses: string[] = [];",
    "const transactionSignatures = await getAllTransactionSignat\n    collectionMint\n  );",
    "const batchSize = 100; // 100 is the max batch size for Heli\n  for (let i = 0; i < transactionSignatures.length; i += batc\n    const parsedTransactions = await getParsedTransactions(\n      transactionSignatures.slice(i, i + batchSize)\n    );",
    "if (compressedEvents) {\n        for (let j = 0; j < compressedEvents.length; j++) {\n          const compressedEvent = compressedEvents[j];",
    "if (compressedEvent.type === \"COMPRESSED_NFT_MINT\") \n            return compressedEvent.newLeafOwner;\n          }\n        }\n      }\n    });",
    "airdroppedAddresses.push(...addresses);\n  }",
    "return airdroppedAddresses.filter((address) => !!address);\n};",
    "const main = async () => {\n  const collectionMint = new PublicKey(\n    \"AYED8JzJmMzq3rX61q1WsziKHtuUCLPEHK5673bWjnXr\"\n  );",
    "console.log(`Found ${airdroppedAddresses.length} airdropped",
    "await fs.writeFile(\n    `${path.join(\n      __dirname,\n      \"../../output\",\n      `${collectionMint.toBase58()}.csv`\n    )}`,\n    airdroppedAddresses.join(\"\\n\")\n  );\n};",
    "main();",
    "import axios from \"axios\";\nimport * as dotenv from \"dotenv\";\nimport { promises as fs } from \"fs\";\nimport path from \"path\";\nimport { URL } from \"url\";",
    "dotenv.config();\nconst __dirname = new URL(\".\", import.meta.url).pathname;",
    "const rpcUrl = process.env.RPC_URL;\nif (!rpcUrl) {\n  throw new Error(\"RPC_URL is not defined in environment varia\n}",
    "async function fetchCompressedNfts(walletAddress: string): Pro\n  const body = {\n    jsonrpc: '2.0',\n    id: 'fetch-solana-assets',\n    method: 'searchAssets',\n    params: {\n      ownerAddress: walletAddress,\n      tokenType: 'all',\n      displayOptions: {\n        showNativeBalance: true,\n        showInscription: true,\n        showCollectionMetadata: true,\n      },\n    },\n  };",
    "const maxRetries: number = 3;\n  let retryCount: number = 0;\n  let delayTime: number = 1000;",
    "while (retryCount < maxRetries) {\n    try {\n      const response = await axios.post(rpcUrl, body);\n      if (response.data && response.data.result) {\n        const items = response.data.result.items;\n        const compressedNfts = items.filter((item: any) => ite",
    "return compressedNfts;\n      }\n      return [];\n    } catch (error: any) {\n      if (error.response && error.response.status === 429) {\n        console.log(`Rate limit hit, retrying after ${delayTim\n        await delay(delayTime);\n        retryCount++;\n        delayTime *= 2;\n      } else {\n        console.error('Error fetching Solana assets:', error)",
    "throw new Error('Failed to fetch Solana assets');\n      }\n    }\n  }\n  throw new Error('Failed to fetch Solana assets after multipl\n}",
    "function delay(ms: number): Promise<void> {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}",
    "const main = async () => {\n  const walletAddress = 'YourWalletAddressHere';\n  try {\n    const compressedNfts = await fetchCompressedNfts(walletAdd\n    console.log(compressedNfts);\n    await fs.writeFile(\n      `${path.join(__dirname, \"../../output\", \"compressedNfts\n      JSON.stringify(compressedNfts, null, 2)\n    );\n    console.log('Compressed NFTs data saved successfully.');\n  } catch (error) {\n    console.error('Failed to fetch and save compressed NFTs:'\n  }\n};",
    "main();",
    "import { PublicKey } from \"@solana/web3.js\";\nimport axios from \"axios\";\nimport { promises as fs } from \"fs\";\nimport path from \"path\";\nimport { URL } from \"url\";\nimport dotenv from \"dotenv\";",
    "dotenv.config();\nconst __dirname = new URL(\".\", import.meta.url).pathname;",
    "const dasUrl = process.env.DAS_URL;",
    "if (!dasUrl) {\n  throw new Error(\"DAS_URL is not defined in environment varia\n}",
    "const getNftHoldersFromCollectionMint = async (\n  collectionMintAddress: PublicKey\n): Promise<string[]> => {\n  let page = 1;\n  const holderAddresses: string[] = [];",
    "while (true) {\n    const { data } = await axios.post(dasUrl, {\n      jsonrpc: \"2.0\",\n      id: \"my-id\",\n      method: \"getAssetsByGroup\",\n      params: {\n        groupKey: \"collection\",\n        groupValue: collectionMintAddress.toBase58(),\n        page,\n        limit: 1000,\n      },\n    });\n    if (data.result.total === 0) break;",
    "data.result.items.map((asset: any) =>\n      holderAddresses.push(asset.ownership.owner)\n    );\n    page++;\n  }\n  return holderAddresses;\n};",
    "const findMultipleAddresses = (addresses: string[]) => {\n  const visitedAddresses: string[] = [];\n  const multipleAddresses: string[] = [];",
    "for (let address of addresses) {\n    if (\n      visitedAddresses.includes(address) &&\n      !multipleAddresses.includes(address)\n    ) {\n      multipleAddresses.push(address);\n    } else {\n      visitedAddresses.push(address);\n    }\n  }",
    "return multipleAddresses;\n};",
    "const main = async () => {\n  const collectionMintAddress = new PublicKey(\n    \"J1S9H3QjnRtBbbuD4HjPV6RpRhwuk4zKbxsnCHuTgh9w\"\n  );",
    "const holderAddresses = await getNftHoldersFromCollectionMi\n    collectionMintAddress\n  );",
    "console.log(`Found ${multipleHolderAddresses.length} multipl",
    "await fs.writeFile(\n    `${path.join(\n      __dirname,\n      \"../../output\",\n      `multiples_${collectionMintAddress.toBase58()}.csv`\n    )}`,\n    multipleHolderAddresses.join(\"\\n\")",
    ");\n};",
    "main();",
    "import { PublicKey } from \"@solana/web3.js\";\nimport axios from \"axios\";\nimport { promises as fs } from \"fs\";\nimport path from \"path\";\nimport { URL } from \"url\";\nimport dotenv from \"dotenv\";",
    "dotenv.config();\nconst __dirname = new URL(\".\", import.meta.url).pathname;",
    "const dasUrl = process.env.DAS_URL;",
    "if (!dasUrl) {\n  throw new Error(\"DAS_URL is not defined in environment varia\n}",
    "const getNftHoldersFromCollectionMint = async (\n  collectionMintAddress: PublicKey\n): Promise<string[]> => {\n  let page = 1;\n  const holderAddresses: string[] = [];",
    "while (true) {\n    const { data } = await axios.post(dasUrl, {\n      jsonrpc: \"2.0\",\n      id: \"my-id\",\n      method: \"getAssetsByGroup\",\n      params: {\n        groupKey: \"collection\",",
    "groupValue: collectionMintAddress.toBase58(),\n        page,\n        limit: 1000,\n      },\n    });\n    if (data.result.total === 0) break;",
    "data.result.items.map((asset: any) =>\n      holderAddresses.push(asset.ownership.owner)\n    );\n    page++;\n  }\n  return holderAddresses;\n};",
    "const main = async () => {\n  const collectionMintAddress = new PublicKey(\n    \"J1S9H3QjnRtBbbuD4HjPV6RpRhwuk4zKbxsnCHuTgh9w\"\n  );",
    "const holderAddresses = await getNftHoldersFromCollectionMi\n    collectionMintAddress\n  );",
    "console.log(`Found ${holderAddresses.length} holders`);",
    "await fs.writeFile(\n    `${path.join(\n      __dirname,\n      \"../../output\",\n      `${collectionMintAddress.toBase58()}.csv`\n    )}`,\n    holderAddresses.join(\"\\n\")\n  );\n};",
    "main();",
    "import { Connection, PublicKey, type ParsedAccountData } from \nimport { promises as fs } from \"fs\";\nimport path from \"path\";\nimport { URL } from \"url\";\nimport dotenv from \"dotenv\";",
    "dotenv.config();\nconst __dirname = new URL(\".\", import.meta.url).pathname;",
    "const rpcUrl = process.env.RPC_URL;\nif (!rpcUrl) {\n  throw new Error(\"RPC_URL is not defined in environment varia\n}",
    "const main = async () => {\n  const connection = new Connection(rpcUrl!);",
    "const holderAddresses: string[] = [];",
    "const programAccounts = await connection.getParsedProgramAcc\n    new PublicKey(\"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA\n    {\n      filters: [\n        {\n          dataSize: 165,\n        },\n        {\n          memcmp: {\n            offset: 0,\n            bytes: tokenAddress,\n          },\n        },",
    "],\n    }\n  );",
    "for (const programAccount of programAccounts) {\n    const data = programAccount.account.data as ParsedAccountD\n    if (data.parsed.info.tokenAmount.uiAmount > 0) {\n      holderAddresses.push(data.parsed.info.owner);\n      // console.log(data.parsed.info.owner);\n    }\n  }",
    "await fs.writeFile(\n    `${path.join(__dirname, \"../../output\", `${tokenAddress}.c\n    holderAddresses.join(\"\\n\")\n  );\n};",
    "main();",
    "use anchor_lang::prelude::*;\nuse anchor_lang::system_program::{create_account, CreateAccou",
    "declare_id!(\"ARVNCsYKDQsCLHbwUTJLpFXVrJdjhWZStyzvxmKe2xHi\"); /",
    "#[program]\npub mod create_system_account {\n    use super::*;",
    "\"  New public key will be: {}\",\n            &ctx.accounts.new_account.key().to_string()\n        );",
    "// The minimum lamports for rent exemption\n        let lamports = (Rent::get()?).minimum_balance(0);",
    "create_account(\n            CpiContext::new(\n                ctx.accounts.system_program.to_account_info()\n                CreateAccount {\n                    from: ctx.accounts.payer.to_account_info(\n                    to: ctx.accounts.new_account.to_account_i\n                },\n            ),\n            lamports,                           // Lamports\n            0,                                  // Space\n            &ctx.accounts.system_program.key(), // Owner Prog\n        )?;",
    "msg!(\"Account created succesfully.\");\n        Ok(())\n    }\n}",
    "#[derive(Accounts)]\npub struct CreateSystemAccount<'info> {\n    #[account(mut)]\n    pub payer: Signer<'info>,\n    #[account(mut)]\n    pub new_account: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}",
    "#![allow(clippy::result_large_err)]\nuse anchor_lang::prelude::*;\nuse instructions::*;",
    "pub mod instructions;\npub mod state;",
    "declare_id!(\"GpVcgWdgVErgLqsn8VYUch6EqDerMgNqoLSmGyKrd6MR\");//",
    "#[program]\npub mod anchor_program_example {\n    use super::*;",
    "pub fn create_address_info(\n        ctx: Context<CreateAddressInfo>,\n        name: String,\n        house_number: u8,\n        street: String,\n        city: String,\n    ) -> Result<()> {\n        create::create_address_info(ctx, name, house_number, \n    }\n}",
    "use anchor_lang::prelude::*;",
    "declare_id!(\"ECWPhR3rJbaPfyNFgphnjxSEexbTArc7vxD8fnW6tgKw\"); /",
    "#[program]\npub mod anchor_program_example {\n    use super::*;",
    "pub fn check_accounts(_ctx: Context<CheckingAccounts>) -> \n        Ok(())\n    }\n}",
    "// Account validation in Anchor is done using the types and co\n// This is a simple example and does not include all possible \n#[derive(Accounts)]\npub struct CheckingAccounts<'info> {\n    payer: Signer<'info>, // checks account is signer",
    "/// CHECK: No checks performed, example of an unchecked ac\n    #[account(mut)]\n    account_to_create: UncheckedAccount<'info>,\n    /// CHECK: Perform owner check using constraint\n    #[account(\n        mut,\n        owner = id()\n    )]\n    account_to_change: UncheckedAccount<'info>,\n    system_program: Program<'info, System>, // checks account \n}",
    "use anchor_lang::prelude::*;\nmod instructions;\nmod state;\nuse instructions::*;",
    "declare_id!(\"99TQtoDdQ5NS2v5Ppha93aqEmv3vV9VZVfHTP5rGST3c\"); /",
    "pub mod close_account_program {\n    use super::*;",
    "pub fn create_user(ctx: Context<CreateUserContext>, name: \n        create_user::create_user(ctx, name)\n    }",
    "pub fn close_user(ctx: Context<CloseUserContext>) -> Resul\n        close_user::close_user(ctx)\n    }\n}",
    "use anchor_lang::prelude::*;",
    "declare_id!(\"BmDHboaj1kBUoinJKKSRqKfMeRKJqQqEbUj1VgzeQe4A\"); /",
    "#[program]\npub mod counter_anchor {\n    use super::*;",
    "pub fn initialize_counter(_ctx: Context<InitializeCounter>\n        Ok(())\n    }",
    "pub fn increment(ctx: Context<Increment>) -> Result<()> {\n        ctx.accounts.counter.count = ctx.accounts.counter.cou\n        Ok(())\n    }\n}",
    "#[derive(Accounts)]\npub struct InitializeCounter<'info> {",
    "#[account(\n        init,\n        space = 8 + Counter::INIT_SPACE,\n        payer = payer\n    )]\n    pub counter: Account<'info, Counter>,\n    pub system_program: Program<'info, System>,\n}",
    "#[derive(Accounts)]\npub struct Increment<'info> {\n    #[account(mut)]\n    pub counter: Account<'info, Counter>,\n}",
    "#[account]\n#[derive(InitSpace)]\npub struct Counter {\n    count: u64,\n}",
    "use anchor_lang::prelude::*;\nuse lever::cpi::accounts::SetPowerStatus;\nuse lever::program::Lever;\nuse lever::{self, PowerStatus};",
    "declare_id!(\"EJfTLXDCJTVwBgGpz9X2Me4CWHbvg8F8zsM7fiVJLLeR\");//",
    "mod hand {\n    use super::*;\n    pub fn pull_lever(ctx: Context<PullLever>, name: String) \n        // Hitting the switch_power method on the lever progra\n        //\n        lever::cpi::switch_power(\n            CpiContext::new(\n                ctx.accounts.lever_program.to_account_info(),\n                // Using the accounts context struct from the \n                //\n                SetPowerStatus {\n                    power: ctx.accounts.power.to_account_info\n                },\n            ),\n            name,\n        )\n    }\n}",
    "#[derive(Accounts)]\npub struct PullLever<'info> {\n    #[account(mut)]\n    pub power: Account<'info, PowerStatus>,\n    pub lever_program: Program<'info, Lever>,\n}",
    "use anchor_lang::prelude::*;",
    "declare_id!(\"CABVoybzrbAJSv7QhQd6GXNGKxDMRjw9niqFzizhk6uk\");",
    "#[program]\npub mod lever {",
    "use super::*;\n    pub fn initialize(_ctx: Context<InitializeLever>) -> Resul\n        Ok(())\n    }",
    "pub fn switch_power(ctx: Context<SetPowerStatus>, name: S\n        let power = &mut ctx.accounts.power;\n        power.is_on = !power.is_on;",
    "msg!(\"{} is pulling the power switch!\", &name);",
    "match power.is_on {\n            true => msg!(\"The power is now on.\"),\n            false => msg!(\"The power is now off!\"),\n        };",
    "Ok(())\n    }\n}",
    "#[derive(Accounts)]\npub struct InitializeLever<'info> {\n    #[account(init, payer = user, space = 8 + 8)]\n    pub power: Account<'info, PowerStatus>,\n    #[account(mut)]\n    pub user: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}",
    "#[derive(Accounts)]\npub struct SetPowerStatus<'info> {\n    #[account(mut)]\n    pub power: Account<'info, PowerStatus>,\n}",
    "#[account]\npub struct PowerStatus {",
    "pub is_on: bool,\n}",
    "use anchor_lang::prelude::*;",
    "declare_id!(\"2phbC62wekpw95XuBk4i1KX4uA8zBUWmYbiTMhicSuBV\");",
    "#[program]\npub mod hello_solana {\n    use super::*;",
    "pub fn hello(_ctx: Context<Hello>) -> Result<()> {\n        msg!(\"Hello, Solana!\");",
    "msg!(\"Our program's Program ID: {}\", &id());",
    "Ok(())\n    }\n}",
    "#[derive(Accounts)]\npub struct Hello {}",
    "use solana_program::{\n    account_info::AccountInfo, entrypoint, entrypoint::Program\n};",
    "//  is the \"process_instruction\" function.\n//\nentrypoint!(process_instruction);",
    "// Our entrypoint's parameters have to match the\n//  anatomy of a transaction instruction (see README).\n//\nfn process_instruction(\n    program_id: &Pubkey,\n    _accounts: &[AccountInfo],\n    _instruction_data: &[u8],\n) -> ProgramResult {\n    msg!(\"Hello, Solana!\");",
    "msg!(\"Our program's Program ID: {}\", &program_id);",
    "Ok(())\n}",
    "use anchor_lang::prelude::*;\nuse anchor_lang::solana_program;\nuse anchor_spl::token;\nuse std::convert::TryFrom;",
    "declare_id!(\"Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS\");",
    "#[derive(Debug)]\n#[account]\npub struct Counter {\n    authority: Pubkey,\n    value: u8,\n}",
    "let mut authority = &mut ctx.accounts.authority;\n    let mut counter = &mut ctx.accounts.counter;\n    let mut counter = counter;",
    "counter.authority = authority.key();",
    "counter.value = 0;",
    "msg!(\"{}\", \"Hello, Solana from Seahorse!\");",
    "Ok(())\n}",
    "pub fn increment_handler(mut ctx: Context<Increment>) -> Resul\n    let mut authority = &mut ctx.accounts.authority;\n    let mut counter = &mut ctx.accounts.counter;",
    "counter.value += 1;",
    "Ok(())\n}",
    "#[derive(Accounts)]\npub struct Initialize<'info> {\n    #[account(mut)]\n    pub authority: Signer<'info>,\n    #[account(\n        init,\n        payer = authority,\n        seeds = [\"new_delhi_hh\".as_bytes().as_ref(), authority\n        bump,\n        space = 8 + std::mem::size_of::<Counter>()\n    )]\n    pub counter: Box<Account<'info, Counter>>,\n    pub system_program: Program<'info, System>,\n}",
    "pub struct Increment<'info> {\n    #[account(mut)]\n    pub authority: Signer<'info>,\n    #[account(mut)]\n    pub counter: Box<Account<'info, Counter>>,\n}",
    "#[program]\npub mod hello_solana {\n    use super::*;",
    "pub fn initialize(ctx: Context<Initialize>) -> Result<()> \n        initialize_handler(ctx)\n    }",
    "pub fn increment(ctx: Context<Increment>) -> Result<()> {\n        increment_handler(ctx)\n    }\n}",
    "@program_id(\"F1ipperKF9EfD821ZbbYjS319LXYiBmjhzkkf5a26rC\")\ncontract hello_solana {\n    // The constructor is used to create a new account\n    // Here we create a new account that stores no data and o\n    @payer(payer) // The \"payer\" pays for the account creatio\n    constructor() {\n        // We get the program ID by calling 'this';\n        address programId = address(this);",
    "// Print messages to the program logs\n        print(\"Hello, Solana!\");\n        print(\"Our program's Program ID: {:}\".format(programId",
    "}\n}",
    "#![allow(clippy::result_large_err)]\nuse anchor_lang::prelude::*;\nuse instructions::*;\npub mod instructions;",
    "declare_id!(\"7Hm9nsYVuBZ9rf8z9AMUHreZRv8Q4vLhqwdVTCawRZtA\");",
    "#[program]\npub mod pda_rent_payer {\n    use super::*;",
    "pub fn init_rent_vault(ctx: Context<InitRentVault>, fund_l\n        init_rent_vault::init_rent_vault(ctx, fund_lamports)\n    }",
    "pub fn create_new_account(ctx: Context<CreateNewAccount>) \n        create_new_account::create_new_account(ctx)\n    }\n}",
    "use anchor_lang::prelude::*;",
    "declare_id!(\"DgoL5J44aspizyUs9fcnpGEUJjWTLJRCfx8eYtUMYczf\");",
    "#[program]\npub mod processing_instructions {\n    use super::*;",
    "// With Anchor, we just put instruction data in the functi\n    //\n    pub fn go_to_park(_ctx: Context<Park>, name: String, heig\n        msg!(\"Welcome to the park, {}!\", name);\n        if height > 5 {\n            msg!(\"You are tall enough to ride this ride. Cong\n        } else {\n            msg!(\"You are NOT tall enough to ride this ride. S\n        };",
    "Ok(())\n    }\n}",
    "#[derive(Accounts)]\npub struct Park {}",
    "use borsh::{BorshDeserialize, BorshSerialize};\nuse solana_program::{\n    account_info::AccountInfo, entrypoint, entrypoint::Program\n};",
    "entrypoint!(process_instruction);",
    "fn process_instruction(\n    _program_id: &Pubkey,\n    _accounts: &[AccountInfo],\n    instruction_data: &[u8],\n) -> ProgramResult {\n    // Attempt to serialize the BPF format to our struct",
    "msg!(\"Welcome to the park, {}!\", instruction_data_object.\n    if instruction_data_object.height > 5 {\n        msg!(\"You are tall enough to ride this ride. Congratul\n    } else {\n        msg!(\"You are NOT tall enough to ride this ride. Sorry\n    };",
    "Ok(())\n}",
    "#[derive(BorshSerialize, BorshDeserialize, Debug)]\npub struct InstructionData {\n    name: String,\n    height: u32,\n}",
    "use anchor_lang::prelude::*;",
    "use instructions::*;",
    "pub mod instructions;\npub mod state;",
    "declare_id!(\"oCCQRZyAbVxujyd8m57MPmDzZDmy2FoKW4ULS7KofCE\");",
    "#[program]\npub mod anchor_program_example {\n    use super::*;",
    "pub fn create_page_visits(ctx: Context<CreatePageVisits>) \n        create::create_page_visits(ctx)\n    }",
    "pub fn increment_page_visits(ctx: Context<IncrementPageVi\n        increment::increment_page_visits(ctx)\n    }\n}",
    "use anchor_lang::prelude::*;",
    "declare_id!(\"Fod47xKXjdHVQDzkFPBvfdWLm8gEAV4iMSXkfUzCHiSD\");",
    "#[program]\npub mod anchor_realloc {\n    use super::*;",
    "pub fn initialize(ctx: Context<Initialize>, input: String\n        ctx.accounts.message_account.message = input;\n        Ok(())\n    }",
    "pub fn update(ctx: Context<Update>, input: String) -> Res\n        ctx.accounts.message_account.message = input;\n        Ok(())\n    }\n}",
    "#[derive(Accounts)]\n#[instruction(input: String)]\npub struct Initialize<'info> {\n    #[account(mut)]\n    pub payer: Signer<'info>,",
    "#[account(\n        init,\n        payer = payer,\n        space = Message::required_space(input.len()),\n    )]\n    pub message_account: Account<'info, Message>,\n    pub system_program: Program<'info, System>,\n}",
    "#[derive(Accounts)]\n#[instruction(input: String)]\npub struct Update<'info> {\n    #[account(mut)]\n    pub payer: Signer<'info>,",
    "#[account(\n       mut, \n       realloc = Message::required_space(input.len()),\n       realloc::payer = payer,\n       realloc::zero = true,\n    )]\n    pub message_account: Account<'info, Message>,\n    pub system_program: Program<'info, System>,\n}",
    "#[account]\npub struct Message {\n    pub message: String,\n}",
    "impl Message {\n    pub fn required_space(input_len: usize) -> usize {\n        8 + // 8 byte discriminator\n        4 + // 4 byte for length of string\n        input_len\n    }\n}",
    "use anchor_lang::prelude::*;\nuse anchor_lang::system_program;",
    "declare_id!(\"ED6f4gweAE7hWPQPXMt4kWxzDJne8VQEm9zkb1tMpFNB\");",
    "#[program]\npub mod rent_example {\n    use super::*;",
    "pub fn create_system_account(\n        ctx: Context<CreateSystemAccount>,\n        address_data: AddressData,\n    ) -> Result<()> {\n        msg!(\"Program invoked. Creating a system account...\")\n        msg!(\n            \"  New public key will be: {}\",\n            &ctx.accounts.new_account.key().to_string()\n        );",
    "msg!(\"Account span: {}\", &account_span);\n        msg!(\"Lamports required: {}\", &lamports_required);",
    "system_program::create_account(\n            CpiContext::new(\n                ctx.accounts.system_program.to_account_info()\n                system_program::CreateAccount {\n                    from: ctx.accounts.payer.to_account_info(",
    "to: ctx.accounts.new_account.to_account_i\n                },\n            ),\n            lamports_required,\n            account_span as u64,\n            &ctx.accounts.system_program.key(),\n        )?;",
    "msg!(\"Account created succesfully.\");\n        Ok(())\n    }\n}",
    "#[derive(Accounts)]\npub struct CreateSystemAccount<'info> {\n    #[account(mut)]\n    pub payer: Signer<'info>,\n    #[account(mut)]\n    pub new_account: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}",
    "#[derive(AnchorSerialize, AnchorDeserialize, Debug)]\npub struct AddressData {\n    name: String,\n    address: String,\n}",
    "use anchor_lang::prelude::*;",
    "pub mod error;\npub mod instructions;",
    "pub mod state;",
    "use crate::instructions::{eat_food, get_on_ride, play_game};",
    "declare_id!(\"8t94SEJh9jVjDwV7cbiuT6BvEsHo4YHP9x9a5rYH1NpP\");",
    "#[program]\npub mod carnival {\n    use super::*;",
    "pub fn go_on_ride(\n        _ctx: Context<CarnivalContext>,\n        name: String,\n        height: u32,\n        ticket_count: u32,\n        ride_name: String,\n    ) -> Result<()> {\n        get_on_ride::get_on_ride(get_on_ride::GetOnRideInstruc\n            rider_name: name,\n            rider_height: height,\n            rider_ticket_count: ticket_count,\n            ride: ride_name,\n        })\n    }",
    "pub fn play_game(\n        _ctx: Context<CarnivalContext>,\n        name: String,\n        ticket_count: u32,\n        game_name: String,\n    ) -> Result<()> {\n        play_game::play_game(play_game::PlayGameInstructionDa\n            gamer_name: name,\n            gamer_ticket_count: ticket_count,\n            game: game_name,\n        })",
    "}",
    "pub fn eat_food(\n        _ctx: Context<CarnivalContext>,\n        name: String,\n        ticket_count: u32,\n        food_stand_name: String,\n    ) -> Result<()> {\n        eat_food::eat_food(eat_food::EatFoodInstructionData {\n            eater_name: name,\n            eater_ticket_count: ticket_count,\n            food_stand: food_stand_name,\n        })\n    }\n}",
    "#[derive(Accounts)]\npub struct CarnivalContext<'info> {\n    #[account(mut)]\n    pub payer: Signer<'info>,\n}",
    "use anchor_lang::prelude::*;\nuse anchor_lang::system_program;",
    "declare_id!(\"4fQVnLWKKKYxtxgGn7Haw8v2g2Hzbu8K61JvWKvqAi7W\");",
    "#[program]\npub mod transfer_sol {\n    use super::*;",
    "system_program::transfer(\n            CpiContext::new(\n                ctx.accounts.system_program.to_account_info()\n                system_program::Transfer {\n                    from: ctx.accounts.payer.to_account_info(\n                    to: ctx.accounts.recipient.to_account_info\n                },\n            ),\n            amount,\n        )?;",
    "Ok(())\n    }",
    "// Directly modifying lamports is only possible if the pro\n    pub fn transfer_sol_with_program(\n        ctx: Context<TransferSolWithProgram>,\n        amount: u64,\n    ) -> Result<()> {\n        **ctx.accounts.payer.try_borrow_mut_lamports()? -= amo\n        **ctx.accounts.recipient.try_borrow_mut_lamports()? +=\n        Ok(())\n    }\n}",
    "#[derive(Accounts)]\npub struct TransferSolWithCpi<'info> {\n    #[account(mut)]\n    payer: Signer<'info>,\n    #[account(mut)]\n    recipient: SystemAccount<'info>,\n    system_program: Program<'info, System>,\n}",
    "#[derive(Accounts)]\npub struct TransferSolWithProgram<'info> {\n    /// CHECK: Use owner constraint to check account is owned \n    #[account(",
    "mut,\n        owner = id() // value of declare_id!()\n    )]\n    payer: UncheckedAccount<'info>,\n    #[account(mut)]\n    recipient: SystemAccount<'info>,\n}",
    "pub mod dot;",
    "use anchor_lang::prelude::*;\nuse anchor_spl::{\n    associated_token::{self, AssociatedToken},\n    token::{self, Mint, Token, TokenAccount},\n};",
    "use dot::program::*;\nuse std::{cell::RefCell, rc::Rc};",
    "declare_id!(\"2RjL4mpTANyGxz7fLWEbQtmdEDti7c4CqsLR96mgvcaV\");",
    "pub mod seahorse_util {\n    use super::*;",
    "#[cfg(feature = \"pyth-sdk-solana\")]\n    pub use pyth_sdk_solana::{load_price_feed_from_account_inf\n    use std::{collections::HashMap, fmt::Debug, ops::Deref};",
    "pub struct Mutable<T>(Rc<RefCell<T>>);",
    "impl<T> Mutable<T> {",
    "pub fn new(obj: T) -> Self {\n            Self(Rc::new(RefCell::new(obj)))\n        }\n    }",
    "impl<T> Clone for Mutable<T> {\n        fn clone(&self) -> Self {\n            Self(self.0.clone())\n        }\n    }",
    "impl<T> Deref for Mutable<T> {\n        type Target = Rc<RefCell<T>>;",
    "fn deref(&self) -> &Self::Target {\n            &self.0\n        }\n    }",
    "impl<T: Debug> Debug for Mutable<T> {\n        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std\n            write!(f, \"{:?}\", self.0)\n        }\n    }",
    "impl<T: Default> Default for Mutable<T> {\n        fn default() -> Self {\n            Self::new(T::default())\n        }\n    }",
    "impl<T: Clone> Mutable<Vec<T>> {\n        pub fn wrapped_index(&self, mut index: i128) -> usize \n            if index >= 0 {\n                return index.try_into().unwrap();\n            }",
    "index += self.borrow().len() as i128;",
    "return index.try_into().unwrap();\n        }\n    }",
    "impl<T: Clone, const N: usize> Mutable<[T; N]> {\n        pub fn wrapped_index(&self, mut index: i128) -> usize \n            if index >= 0 {\n                return index.try_into().unwrap();\n            }",
    "index += self.borrow().len() as i128;",
    "return index.try_into().unwrap();\n        }\n    }",
    "#[derive(Clone)]\n    pub struct Empty<T: Clone> {\n        pub account: T,\n        pub bump: Option<u8>,\n    }",
    "impl<'info> ProgramsMap<'info> {\n        pub fn get(&self, name: &'static str) -> AccountInfo<\n            self.0.get(name).unwrap().clone()\n        }\n    }",
    "#[derive(Clone, Debug)]\n    pub struct WithPrograms<'info, 'entrypoint, A> {\n        pub account: &'entrypoint A,\n        pub programs: &'entrypoint ProgramsMap<'info>,\n    }",
    "impl<'info, 'entrypoint, A> Deref for WithPrograms<'info, \n        type Target = A;",
    "fn deref(&self) -> &Self::Target {\n            &self.account\n        }\n    }",
    "#[derive(Clone, Debug)]\n    pub struct CpiAccount<'info> {\n        #[doc = \"CHECK: CpiAccounts temporarily store Account\n        pub account_info: AccountInfo<'info>,\n        pub is_writable: bool,\n        pub is_signer: bool,\n        pub seeds: Option<Vec<Vec<u8>>>,\n    }",
    "#[macro_export]\n    macro_rules! seahorse_const {\n        ($ name : ident , $ value : expr) => {\n            macro_rules! $name {\n                () => {\n                    $value\n                };\n            }",
    "pub(crate) use $name;\n        };\n    }",
    "#[macro_export]\n    macro_rules! assign {\n        ($ lval : expr , $ rval : expr) => {{",
    "let temp = $rval;",
    "$lval = temp;\n        }};\n    }",
    "#[macro_export]\n    macro_rules! index_assign {\n        ($ lval : expr , $ idx : expr , $ rval : expr) => {\n            let temp_rval = $rval;\n            let temp_idx = $idx;",
    "$lval[temp_idx] = temp_rval;\n        };\n    }",
    "pub(crate) use assign;",
    "pub(crate) use index_assign;",
    "pub(crate) use seahorse_const;\n}",
    "#[program]\nmod seahorse {\n    use super::*;\n    use seahorse_util::*;\n    use std::collections::HashMap;",
    "#[derive(Accounts)]\n    pub struct InitMockAccount<'info> {\n        #[account(mut)]\n        pub signer: Signer<'info>,\n        # [account (init , space = std :: mem :: size_of :: < \n        pub mock_account: Box<Account<'info, dot::program::Moc\n        pub rent: Sysvar<'info, Rent>,\n        pub system_program: Program<'info, System>,\n    }",
    "pub fn init_mock_account(ctx: Context<InitMockAccount>) ->\n        let mut programs = HashMap::new();",
    "programs.insert(\n            \"system_program\",\n            ctx.accounts.system_program.to_account_info(),\n        );",
    "let programs_map = ProgramsMap(programs);\n        let signer = SeahorseSigner {\n            account: &ctx.accounts.signer,\n            programs: &programs_map,\n        };",
    "let mock_account = Empty {\n            account: dot::program::MockAccount::load(&mut ctx\n            bump: ctx.bumps.get(\"mock_account\").map(|bump| *b\n        };",
    "return Ok(());\n    }",
    "#[derive(Accounts)]\n    # [instruction (amount : u64)]\n    pub struct TransferSolWithCpi<'info> {\n        #[account(mut)]\n        pub sender: Signer<'info>,\n        #[account(mut)]\n        pub recipient: Box<Account<'info, dot::program::MockAc\n        pub system_program: Program<'info, System>,\n    }",
    "let mut programs = HashMap::new();",
    "programs.insert(\n            \"system_program\",\n            ctx.accounts.system_program.to_account_info(),\n        );",
    "let programs_map = ProgramsMap(programs);\n        let sender = SeahorseSigner {\n            account: &ctx.accounts.sender,\n            programs: &programs_map,\n        };",
    "dot::program::MockAccount::store(recipient);",
    "return Ok(());\n    }\n}",
    "use anchor_lang::prelude::*;",
    "declare_id!(\"FbeHkUEevbhKmdk5FE5orcTaJkCYn5drwZoZXaxQXXNn\");",
    "#[derive(Clone)]\npub struct SPLCompression;",
    "impl anchor_lang::Id for SPLCompression {\n    fn id() -> Pubkey {\n        spl_account_compression::id()\n    }",
    "}",
    "#[program]\npub mod cnft_burn {\n    use super::*;",
    "pub fn burn_cnft<'info>(\n        ctx: Context<'_, '_, '_, 'info, BurnCnft<'info>>,\n        root: [u8; 32],\n        data_hash: [u8; 32],\n        creator_hash: [u8; 32],\n        nonce: u64,\n        index: u32,\n    ) -> Result<()> {\n        let tree_config = ctx.accounts.tree_authority.to_acco\n        let leaf_owner = ctx.accounts.leaf_owner.to_account_i\n        let merkle_tree = ctx.accounts.merkle_tree.to_account_\n        let log_wrapper = ctx.accounts.log_wrapper.to_account_\n        let compression_program = ctx.accounts.compression_pro\n        let system_program = ctx.accounts.system_program.to_ac",
    "let cnft_burn_cpi = mpl_bubblegum::instructions::BurnC\n            &ctx.accounts.bubblegum_program,\n            mpl_bubblegum::instructions::BurnCpiAccounts {\n                tree_config: &tree_config,\n                leaf_owner: (&leaf_owner, true),\n                leaf_delegate: (&leaf_owner, false),\n                merkle_tree: &merkle_tree,\n                log_wrapper: &log_wrapper,\n                compression_program: &compression_program,\n                system_program: &system_program,\n            },\n            mpl_bubblegum::instructions::BurnInstructionArgs \n                root,\n                data_hash,\n                creator_hash,\n                nonce,\n                index,",
    "},\n        );",
    "cnft_burn_cpi.invoke_with_remaining_accounts(\n            ctx.remaining_accounts\n                .iter()\n                .map(|account| (account, false, false))\n                .collect::<Vec<_>>()\n                .as_slice(),\n        )?;",
    "Ok(())\n    }\n}",
    "#[derive(Accounts)]\npub struct BurnCnft<'info> {\n    #[account(mut)]\n    pub leaf_owner: Signer<'info>,\n    #[account(mut)]\n    #[account(\n        seeds = [merkle_tree.key().as_ref()],\n        bump,\n        seeds::program = bubblegum_program.key()\n    )]\n    /// CHECK: This account is modified in the downstream prog\n    pub tree_authority: UncheckedAccount<'info>,\n    #[account(mut)]\n    /// CHECK: This account is neither written to nor read fro\n    pub merkle_tree: UncheckedAccount<'info>,\n    /// CHECK: This account is neither written to nor read fro\n    pub log_wrapper: UncheckedAccount<'info>,\n    pub compression_program: Program<'info, SPLCompression>,\n    /// CHECK: This account is neither written to nor read fro\n    pub bubblegum_program: UncheckedAccount<'info>,\n    pub system_program: Program<'info, System>,\n}",
    "import \"solana\";",
    "@program_id(\"BvgEJTPXfriGPopjJr1nLc4vADXm7A7TqjLFVztpd19Q\")\ncontract compressed_nft {",
    "@payer(payer) // payer address\n    @seed(\"seed\") // hardcoded seed\n    constructor(\n        @bump bytes1 bump // bump seed for pda address\n    ) {\n        // Creating a dataAccount for the program, which is re\n        // However, this account is not used in the program\n    }",
    "// Mint a compressed NFT to an existing merkle tree, via a\n    // Reference: https://github.com/metaplex-foundation/meta\n    // Reference: https://github.com/metaplex-foundation/meta\n    @mutableAccount(tree_authority) // authority of the merkle\n    @account(leaf_owner) // owner of the new compressed NFT\n    @account(leaf_delegate) // delegate of the new compressed \n    @mutableAccount(merkle_tree)  // address of the merkle tre\n    @mutableSigner(payer) // payer\n    @mutableSigner(tree_delegate) // delegate of the merkle t\n    @account(noop_address)\n    @account(compression_pid)\n    @account(bubblegum_pid)\n    function mint(\n        string uri // uri of the new compressed NFT (metadata\n    ) external {\n        print(\"Minting Compressed NFT\");",
    "// Create a creator array with a single creator\n        Creator[] memory creators = new Creator[](1);",
    "// Set the creator to the payer\n        creators[0] = Creator({\n            creatorAddress: tx.accounts.payer.key,\n            verified: false,\n            share: 100\n        });",
    "// Create the metadata args, representing the metadata\n        // Solidity does not support optional arguments,\n        // So we have to explicitly declare if the optional a\n        // If not present, we comment them out, otherwise the \n        MetadataArgs memory args = MetadataArgs({\n            name: \"RGB\",\n            symbol: \"RGB\",\n            uri: uri,\n            sellerFeeBasisPoints: 0,\n            primarySaleHappened: false,\n            isMutable: true,\n            editionNoncePresent: false,\n            // editionNonce: 0,\n            tokenStandardPresent: true,\n            tokenStandard: TokenStandard.NonFungible,\n            collectionPresent: false,\n            // collection: Collection({\n            //     verified: false,\n            //     key: address(0)\n            // }),\n            usesPresent: false,\n            // uses: Uses({\n            //     useMethod: UseMethod.Burn,\n            //     remaining: 0,\n            //     total: 0\n            // }),\n            tokenProgramVersion: TokenProgramVersion.Original\n            creators: creators\n        });",
    "AccountMeta({pubkey: tx.accounts.tree_authority.ke\n            AccountMeta({pubkey: tx.accounts.leaf_owner.key, i\n            AccountMeta({pubkey: tx.accounts.leaf_delegate.key\n            AccountMeta({pubkey: tx.accounts.merkle_tree.key, \n            AccountMeta({pubkey: tx.accounts.payer.key, is_wri\n            AccountMeta({pubkey: tx.accounts.tree_delegate.key\n            AccountMeta({pubkey: tx.accounts.noop_address.key\n            AccountMeta({pubkey: tx.accounts.compression_pid.\n            AccountMeta({pubkey: address\"111111111111111111111\n        ];",
    "// Reference: https://github.com/metaplex-foundation/m\n        bytes8 discriminator = 0x9162c076b8937668;\n        bytes instructionData = abi.encode(discriminator, arg",
    "// Invoking the Bubblegum program\n        tx.accounts.bubblegum_pid.key.call{accounts: metas}(i\n    }",
    "// Reference: https://github.com/metaplex-foundation/meta\n    struct MetadataArgs {\n        string name;\n        string symbol;\n        string uri;\n        uint16 sellerFeeBasisPoints;\n        bool primarySaleHappened;\n        bool isMutable;\n        bool editionNoncePresent;\n        // uint8 editionNonce;\n        bool tokenStandardPresent;\n        TokenStandard tokenStandard;\n        bool collectionPresent;\n        // Collection collection;\n        bool usesPresent;\n        // Uses uses;\n        TokenProgramVersion tokenProgramVersion;\n        Creator[] creators;\n    }",
    "enum TokenStandard {\n        NonFungible,\n        FungibleAsset,\n        Fungible,\n        NonFungibleEdition\n    }",
    "enum TokenProgramVersion {\n        Original,\n        Token2022\n    }",
    "struct Creator {\n        address creatorAddress;\n        bool verified;\n        uint8 share;\n    }",
    "struct Collection {\n        bool verified;\n        address key;\n    }",
    "struct Uses {\n        UseMethod useMethod;\n        uint64 remaining;\n        uint64 total;\n    }",
    "enum UseMethod {\n        Burn,\n        Multiple,\n        Single\n    }",
    "}",
    "use anchor_lang::prelude::*;\nuse mpl_bubblegum::state::TreeConfig;\nuse solana_program::pubkey::Pubkey;\nuse spl_account_compression::{program::SplAccountCompression,",
    "declare_id!(\"CNftyK7T8udPwYRzZUMWzbh79rKrz9a5GwV2wv7iEHpk\");",
    "#[derive(Clone)]\npub struct MplBubblegum;",
    "impl anchor_lang::Id for MplBubblegum {\n    fn id() -> Pubkey {\n        mpl_bubblegum::id()\n    }\n}",
    "// first 8 bytes of SHA256(\"global:transfer\")\nconst TRANSFER_DISCRIMINATOR: &[u8; 8] = &[163, 52, 200, 231,",
    "#[program]\npub mod cnft_vault {",
    "use super::*;",
    "pub fn withdraw_cnft<'info>(\n        ctx: Context<'_, '_, '_, 'info, Withdraw<'info>>,\n        root: [u8; 32],\n        data_hash: [u8; 32],\n        creator_hash: [u8; 32],\n        nonce: u64,\n        index: u32,",
    ") -> Result<()> {\n        msg!(\n            \"attempting to send nft {} from tree {}\",\n            index,\n            ctx.accounts.merkle_tree.key()\n        );",
    "let mut accounts: Vec<solana_program::instruction::Acc\n            AccountMeta::new_readonly(ctx.accounts.tree_autho\n            AccountMeta::new_readonly(ctx.accounts.leaf_owner\n            AccountMeta::new_readonly(ctx.accounts.leaf_owner\n            AccountMeta::new_readonly(ctx.accounts.new_leaf_ow\n            AccountMeta::new(ctx.accounts.merkle_tree.key(), f\n            AccountMeta::new_readonly(ctx.accounts.log_wrappe\n            AccountMeta::new_readonly(ctx.accounts.compressio\n            AccountMeta::new_readonly(ctx.accounts.system_prog\n        ];",
    "let mut data: Vec<u8> = vec![];\n        data.extend(TRANSFER_DISCRIMINATOR);\n        data.extend(root);\n        data.extend(data_hash);\n        data.extend(creator_hash);\n        data.extend(nonce.to_le_bytes());\n        data.extend(index.to_le_bytes());",
    "let mut account_infos: Vec<AccountInfo> = vec![\n            ctx.accounts.tree_authority.to_account_info(),\n            ctx.accounts.leaf_owner.to_account_info(),\n            ctx.accounts.leaf_owner.to_account_info(),\n            ctx.accounts.new_leaf_owner.to_account_info(),\n            ctx.accounts.merkle_tree.to_account_info(),\n            ctx.accounts.log_wrapper.to_account_info(),\n            ctx.accounts.compression_program.to_account_info(\n            ctx.accounts.system_program.to_account_info(),\n        ];",
    "for acc in ctx.remaining_accounts.iter() {\n            accounts.push(AccountMeta::new_readonly(acc.key()\n            account_infos.push(acc.to_account_info());\n        }",
    "msg!(\"manual cpi call\");\n        solana_program::program::invoke_signed(\n            &solana_program::instruction::Instruction {\n                program_id: ctx.accounts.bubblegum_program.key\n                accounts,\n                data,\n            },\n            &account_infos[..],\n            &[&[b\"cNFT-vault\", &[*ctx.bumps.get(\"leaf_owner\")\n        )\n        .map_err(Into::into)\n    }",
    "#[allow(clippy::too_many_arguments)]\n    pub fn withdraw_two_cnfts<'info>(\n        ctx: Context<'_, '_, '_, 'info, WithdrawTwo<'info>>,\n        root1: [u8; 32],\n        data_hash1: [u8; 32],\n        creator_hash1: [u8; 32],\n        nonce1: u64,\n        index1: u32,\n        proof_1_length: u8,\n        root2: [u8; 32],\n        data_hash2: [u8; 32],\n        creator_hash2: [u8; 32],\n        nonce2: u64,\n        index2: u32,\n        _proof_2_length: u8, // we don't actually need this (\n    ) -> Result<()> {\n        let merkle_tree1 = ctx.accounts.merkle_tree1.key();\n        let merkle_tree2 = ctx.accounts.merkle_tree2.key();\n        msg!(\n            \"attempting to send nfts from trees {} and {}\",",
    "merkle_tree1,\n            merkle_tree2\n        );",
    "let mut accounts1: Vec<solana_program::instruction::Ac\n            AccountMeta::new_readonly(ctx.accounts.tree_autho\n            AccountMeta::new_readonly(ctx.accounts.leaf_owner\n            AccountMeta::new_readonly(ctx.accounts.leaf_owner\n            AccountMeta::new_readonly(ctx.accounts.new_leaf_ow\n            AccountMeta::new(ctx.accounts.merkle_tree1.key(), \n            AccountMeta::new_readonly(ctx.accounts.log_wrappe\n            AccountMeta::new_readonly(ctx.accounts.compressio\n            AccountMeta::new_readonly(ctx.accounts.system_prog\n        ];",
    "let mut accounts2: Vec<solana_program::instruction::Ac\n            AccountMeta::new_readonly(ctx.accounts.tree_autho\n            AccountMeta::new_readonly(ctx.accounts.leaf_owner\n            AccountMeta::new_readonly(ctx.accounts.leaf_owner\n            AccountMeta::new_readonly(ctx.accounts.new_leaf_ow\n            AccountMeta::new(ctx.accounts.merkle_tree2.key(), \n            AccountMeta::new_readonly(ctx.accounts.log_wrappe\n            AccountMeta::new_readonly(ctx.accounts.compressio\n            AccountMeta::new_readonly(ctx.accounts.system_prog\n        ];",
    "let mut data1: Vec<u8> = vec![];\n        data1.extend(TRANSFER_DISCRIMINATOR);\n        data1.extend(root1);\n        data1.extend(data_hash1);\n        data1.extend(creator_hash1);\n        data1.extend(nonce1.to_le_bytes());\n        data1.extend(index1.to_le_bytes());\n        let mut data2: Vec<u8> = vec![];\n        data2.extend(TRANSFER_DISCRIMINATOR);",
    "data2.extend(root2);\n        data2.extend(data_hash2);\n        data2.extend(creator_hash2);\n        data2.extend(nonce2.to_le_bytes());\n        data2.extend(index2.to_le_bytes());",
    "let mut account_infos1: Vec<AccountInfo> = vec![\n            ctx.accounts.tree_authority1.to_account_info(),\n            ctx.accounts.leaf_owner.to_account_info(),\n            ctx.accounts.leaf_owner.to_account_info(),\n            ctx.accounts.new_leaf_owner1.to_account_info(),\n            ctx.accounts.merkle_tree1.to_account_info(),\n            ctx.accounts.log_wrapper.to_account_info(),\n            ctx.accounts.compression_program.to_account_info(\n            ctx.accounts.system_program.to_account_info(),\n        ];\n        let mut account_infos2: Vec<AccountInfo> = vec![\n            ctx.accounts.tree_authority2.to_account_info(),\n            ctx.accounts.leaf_owner.to_account_info(),\n            ctx.accounts.leaf_owner.to_account_info(),\n            ctx.accounts.new_leaf_owner2.to_account_info(),\n            ctx.accounts.merkle_tree2.to_account_info(),\n            ctx.accounts.log_wrapper.to_account_info(),\n            ctx.accounts.compression_program.to_account_info(\n            ctx.accounts.system_program.to_account_info(),\n        ];",
    "for (i, acc) in ctx.remaining_accounts.iter().enumera\n            if i < proof_1_length as usize {\n                accounts1.push(AccountMeta::new_readonly(acc.\n                account_infos1.push(acc.to_account_info());\n            } else {\n                accounts2.push(AccountMeta::new_readonly(acc.\n                account_infos2.push(acc.to_account_info());\n            }\n        }",
    "msg!(\"withdrawing cNFT#1\");",
    "solana_program::program::invoke_signed(\n            &solana_program::instruction::Instruction {\n                program_id: ctx.accounts.bubblegum_program.key\n                accounts: accounts1,\n                data: data1,\n            },\n            &account_infos1[..],\n            &[&[b\"cNFT-vault\", &[*ctx.bumps.get(\"leaf_owner\")\n        )?;",
    "msg!(\"withdrawing cNFT#2\");\n        solana_program::program::invoke_signed(\n            &solana_program::instruction::Instruction {\n                program_id: ctx.accounts.bubblegum_program.key\n                accounts: accounts2,\n                data: data2,\n            },\n            &account_infos2[..],\n            &[&[b\"cNFT-vault\", &[*ctx.bumps.get(\"leaf_owner\")\n        )?;",
    "msg!(\"successfully sent cNFTs\");\n        Ok(())\n    }\n}",
    "#[derive(Accounts)]\npub struct Withdraw<'info> {\n    #[account(\n        seeds = [merkle_tree.key().as_ref()],\n        bump,\n        seeds::program = bubblegum_program.key()\n    )]\n    /// CHECK: This account is neither written to nor read fro\n    pub tree_authority: Account<'info, TreeConfig>,",
    "bump,\n    )]\n    /// CHECK: This account doesnt even exist (it is just the \n    pub leaf_owner: UncheckedAccount<'info>, // sender (the va\n    /// CHECK: This account is neither written to nor read fro\n    pub new_leaf_owner: UncheckedAccount<'info>, // receiver\n    #[account(mut)]\n    /// CHECK: This account is modified in the downstream prog\n    pub merkle_tree: UncheckedAccount<'info>,\n    pub log_wrapper: Program<'info, Noop>,\n    pub compression_program: Program<'info, SplAccountCompres\n    pub bubblegum_program: Program<'info, MplBubblegum>,\n    pub system_program: Program<'info, System>,\n}",
    "#[derive(Accounts)]\npub struct WithdrawTwo<'info> {\n    #[account(\n        seeds = [merkle_tree1.key().as_ref()],\n        bump,\n        seeds::program = bubblegum_program.key()\n    )]\n    /// CHECK: This account is neither written to nor read fro\n    pub tree_authority1: Account<'info, TreeConfig>,\n    #[account(\n        seeds = [b\"cNFT-vault\"],\n        bump,\n    )]\n    /// CHECK: This account doesnt even exist (it is just the \n    pub leaf_owner: UncheckedAccount<'info>, // you might need\n    /// CHECK: This account is neither written to nor read fro\n    pub new_leaf_owner1: UncheckedAccount<'info>, // receiver\n    #[account(mut)]\n    /// CHECK: This account is modified in the downstream prog\n    pub merkle_tree1: UncheckedAccount<'info>,",
    "pub log_wrapper: Program<'info, Noop>,\n    pub compression_program: Program<'info, SplAccountCompres\n    pub bubblegum_program: Program<'info, MplBubblegum>,\n    pub system_program: Program<'info, System>,\n}",
    "pub mod actions;\npub use actions::*;",
    "pub mod state;\npub use state::*;",
    "use anchor_lang::prelude::*;\nuse solana_program::pubkey::Pubkey;\nuse spl_account_compression::{program::SplAccountCompression,",
    "#[derive(Clone)]\npub struct MplBubblegum;",
    "impl anchor_lang::Id for MplBubblegum {\n    fn id() -> Pubkey {",
    "mpl_bubblegum::id()\n    }\n}",
    "declare_id!(\"burZc1SfqbrAP35XG63YZZ82C9Zd22QUwhCXoEUZWNF\");",
    "#[program]\npub mod cutils {\n    use super::*;",
    "#[access_control(ctx.accounts.validate(&ctx, &params))]\n    pub fn mint<'info>(\n        ctx: Context<'_, '_, '_, 'info, Mint<'info>>,\n        params: MintParams,\n    ) -> Result<()> {\n        Mint::actuate(ctx, params)\n    }",
    "#[access_control(ctx.accounts.validate(&ctx, &params))]\n    pub fn verify<'info>(\n        ctx: Context<'_, '_, '_, 'info, Verify<'info>>,\n        params: VerifyParams,\n    ) -> Result<()> {\n        Verify::actuate(ctx, &params)\n    }\n}",
    "use anchor_lang::prelude::*;\npub mod state;\nuse state::PriceFeed;",
    "pub mod error;",
    "use error::ErrorCode;",
    "declare_id!(\"F6mNuN1xoPdRaZcUX3Xviq7x1EFtoBXygpFggCLd62eU\");",
    "#[program]\npub mod pythexample {\n    use super::*;\n    pub fn read_price(ctx: Context<Pyth>) -> Result<()> {\n        let price_feed = &ctx.accounts.price_feed;\n        let clock = &ctx.accounts.clock;\n        // Get the current timestamp\n        let timestamp: i64 = clock.unix_timestamp;\n        // Load the price from the price feed. Here, the price\n        let price: pyth_sdk::Price = price_feed\n            .get_price_no_older_than(timestamp, 30)\n            .ok_or(ErrorCode::PythError)?;",
    "let confidence_interval: u64 = price.conf;",
    "let asset_price_full: i64 = price.price;",
    "let asset_exponent: i32 = price.expo;",
    "msg!(\"Price: {}\", asset_price);\n        msg!(\"Confidence interval: {}\", confidence_interval);",
    "Ok(())\n    }\n}",
    "#[derive(Accounts)]\npub struct Pyth<'info> {\n    pub price_feed: Account<'info, PriceFeed>,\n    pub system_program: Program<'info, System>,\n    pub clock: Sysvar<'info, Clock>,\n}",
    "import { readFileSync } from 'node:fs'",
    "export function changePackageVersion(file: string, pkgName: s\n  const content = JSON.parse(readFileSync(file).toString('utf\n  if (content.dependencies && content.dependencies[pkgName] &&\n    content.dependencies[pkgName] = pkgVersion\n    return [true, content]\n  }\n  if (content.devDependencies && content.devDependencies[pkgNa\n    content.devDependencies[pkgName] = pkgVersion\n    return [true, content]\n  }\n  return [false, content]\n}",
    "import { basename } from 'node:path'\nimport * as p from 'picocolors'\nimport { getDepsCount } from './get-deps-count'\nimport { getRecursiveFileList } from './get-recursive-file-li",
    "export function commandCheck(path: string = '.') {\n  const files = getRecursiveFileList(path).filter((file) => ba\n  const depsCounter = getDepsCount(files)",
    ".map((pkg) => {\n      const versions = depsCounter[pkg]\n      const versionMap = Object.keys(versions).sort()\n      const versionsLength = versionMap.length",
    "if (versionsLength === 1) {\n        const count = versions[versionMap[0]].length\n        single.push(`${p.green(`\u2714`)} ${pkg}@${versionMap[0]} \n        return\n      }",
    "const versionCount: { version: string; count: number }[\n      for (const version of versionMap) {\n        versionCount.push({ version, count: versions[version]\n      }\n      versionCount.sort((a, b) => b.count - a.count)",
    "multiple.push(`${p.yellow(`\u26a0`)} ${pkg} has ${versionsLe",
    "for (const { count, version } of versionCount) {\n        multiple.push(`  - ${p.bold(version)} (${count})`)\n      }\n    })",
    "for (const string of [...single.sort(), ...multiple]) {\n    console.log(string)\n  }\n}",
    "export function commandHelp() {\n  console.log(`Usage: yarn sync-package-json <command> [optio\n  console.log(``)\n  console.log(`Commands:`)",
    "console.log(`  check  <path>        Check package.json file\n  console.log(`  help                 Show this help`)\n  console.log(`  list   <path>        List package.json files\n  console.log(`  set    [ver] <path>  Set specific version in \n  console.log(`  update <path> <pkgs> Update all versions in \n  console.log(``)\n  console.log(`Arguments:`)\n  console.log(`  path    Path to directory`)\n  console.log(``)\n  console.log(`Examples:`)\n  console.log(`  yarn sync-package-json check`)\n  console.log(`  yarn sync-package-json check basics`)\n  console.log(`  yarn sync-package-json list`)\n  console.log(`  yarn sync-package-json list basics`)\n  console.log(`  yarn sync-package-json help`)\n  console.log(`  yarn sync-package-json set @coral-xyz/anchor@\n  console.log(`  yarn sync-package-json set @coral-xyz/anchor@\n  console.log(`  yarn sync-package-json update`)\n  console.log(`  yarn sync-package-json update basics`)\n  console.log(`  yarn sync-package-json update . @solana/web3\n  process.exit(0)\n}",
    "import { basename } from 'node:path'\nimport { getRecursiveFileList } from './get-recursive-file-li",
    "export function commandList(path: string) {\n  const files = getRecursiveFileList(path).filter((file) => ba\n  for (const file of files) {\n    console.log(file)\n  }\n}",
    "import { writeFileSync } from 'fs'\nimport { basename } from 'node:path'\nimport { changePackageVersion } from './change-package-versio\nimport { getRecursiveFileList } from './get-recursive-file-li",
    "export function commandSet(version: string, path: string = '.\n  if (!version) {\n    console.error(`Version is required`)\n    process.exit(1)\n  }\n  if (\n    !version\n      // Strip first character if it's a `@`\n      .replace(/^@/, '')\n      .includes('@')\n  ) {\n    console.error(`Invalid package version: ${version}. Provid\n    process.exit(1)\n  }\n  // Take anything after the second `@` as the version, the re\n  const [pkg, ...rest] = version.split('@').reverse()\n  const pkgName = rest.reverse().join('@')",
    "// Make sure pkgVersions has a ^ prefix, if not add it\n  const pkgVersion = pkg.startsWith('^') ? pkg : `^${pkg}`",
    "console.log(`Setting package ${pkgName} to ${pkgVersion} in",
    "const files = getRecursiveFileList(path).filter((file) => ba\n  let count = 0\n  for (const file of files) {\n    const [changed, content] = changePackageVersion(file, pkgN\n    if (changed) {\n      writeFileSync(file, JSON.stringify(content, null, 2) +",
    "count++\n    }\n  }\n  if (count === 0) {\n    console.log(`No files updated`)\n  } else {\n    console.log(`Updated ${count} files`)\n  }\n}",
    "import { execSync } from 'child_process'\nimport { writeFileSync } from 'fs'\nimport { basename } from 'node:path'\nimport * as p from 'picocolors'\nimport { changePackageVersion } from './change-package-versio",
    "import { getDepsCount } from './get-deps-count'\nimport { getRecursiveFileList } from './get-recursive-file-li",
    "export function commandUpdate(path: string = '.', packageName\n  const files = getRecursiveFileList(path).filter((file) => ba\n  const depsCounter = getDepsCount(files)\n  const pkgNames = Object.keys(depsCounter).sort()\n  if (packageNames.length > 0) {\n    console.log(`Updating ${packageNames.join(', ')} in ${file\n  }",
    "let total = 0\n  for (const pkgName of pkgNames.filter((pkgName) => packageNa\n    // Get latest version from npm\n    const npmVersion = execSync(`npm view ${pkgName} version`",
    "let count = 0\n    for (const file of files) {",
    "const [changed, content] = changePackageVersion(file, p\n      if (changed) {\n        writeFileSync(file, JSON.stringify(content, null, 2) +\n        count++\n      }\n    }\n    total += count",
    "if (count === 0) {\n      console.log(p.dim(`Package ${pkgName} is up to date ${n\n      continue\n    }\n    console.log(p.green(` -> Updated ${count} files with ${pkg\n  }",
    "if (total === 0) {\n    console.log(`No files updated`)\n  } else {\n    console.log(`Updated ${total} files`)\n  }\n}",
    "import { readFileSync } from 'node:fs'",
    "export function getDepsCount(files: string[] = []): Record<st\n  const map: Record<string, JSON> = {}\n  const depsCounter: Record<string, Record<string, string[]>>",
    "for (const file of files) {\n    const content = JSON.parse(readFileSync(file).toString('u\n    map[file] = content",
    "const deps = content.dependencies ?? {}\n    const devDeps = content.devDependencies ?? {}",
    "const merged = { ...deps, ...devDeps }",
    "Object.keys(merged)\n      .sort()\n      .map((pkg) => {\n        const pkgVersion = merged[pkg]\n        if (!depsCounter[pkg]) {\n          depsCounter[pkg] = { [pkgVersion]: [file] }\n          return\n        }\n        if (!depsCounter[pkg][pkgVersion]) {\n          depsCounter[pkg][pkgVersion] = [file]\n          return\n        }\n        depsCounter[pkg][pkgVersion] = [...depsCounter[pkg][p\n      })\n  }\n  return depsCounter\n}",
    "// Point method at path and return a list of all the files in \nimport { readdirSync, statSync } from 'node:fs'",
    "const items = readdirSync(path)\n  items.forEach((item) => {\n    if (ignore.includes(item)) {\n      return\n    }\n    // Check out if it's a directory or a file",
    "const isDir = statSync(`${path}/${item}`).isDirectory()\n    if (isDir) {\n      // If it's a directory, recursively call the method\n      files.push(...getRecursiveFileList(`${path}/${item}`))\n    } else {\n      // If it's a file, add it to the array of files\n      files.push(`${path}/${item}`)\n    }\n  })",
    "return files.filter((file) => {\n    // Remove package.json from the root directory\n    return path === '.' ? file !== './package.json' : true\n  })\n}",
    "use {\n    anchor_lang::prelude::*,\n    anchor_spl::{\n        metadata::{create_metadata_accounts_v3, CreateMetadata\n        token::{Mint, Token},\n    },\n    mpl_token_metadata::{pda::find_metadata_account, state::Da\n};",
    "declare_id!(\"2B6MrsKB2pVq6W6tY8dJLcnSd3Uv1KE7yRaboBjdQoEX\");",
    "#[program]\npub mod create_token {\n    use super::*;",
    "ctx: Context<CreateTokenMint>,\n        token_name: String,\n        token_symbol: String,\n        token_uri: String,\n        _token_decimals: u8,\n    ) -> Result<()> {\n        msg!(\"Creating metadata account...\");\n        msg!(\n            \"Metadata account address: {}\",\n            &ctx.accounts.metadata_account.key()\n        );",
    "// Cross Program Invocation (CPI)\n        // Invoking the create_metadata_account_v3 instructio\n        create_metadata_accounts_v3(\n            CpiContext::new(\n                ctx.accounts.token_metadata_program.to_accoun\n                CreateMetadataAccountsV3 {\n                    metadata: ctx.accounts.metadata_account.to\n                    mint: ctx.accounts.mint_account.to_accoun\n                    mint_authority: ctx.accounts.payer.to_acco\n                    update_authority: ctx.accounts.payer.to_ac\n                    payer: ctx.accounts.payer.to_account_info\n                    system_program: ctx.accounts.system_progra\n                    rent: ctx.accounts.rent.to_account_info()\n                },\n            ),\n            DataV2 {\n                name: token_name,\n                symbol: token_symbol,\n                uri: token_uri,\n                seller_fee_basis_points: 0,\n                creators: None,\n                collection: None,\n                uses: None,\n            },\n            false, // Is mutable\n            true,  // Update authority is signer",
    "None,  // Collection details\n        )?;",
    "msg!(\"Token mint created successfully.\");",
    "Ok(())\n    }\n}",
    "#[derive(Accounts)]\n#[instruction(_token_decimals: u8)]\npub struct CreateTokenMint<'info> {\n    #[account(mut)]\n    pub payer: Signer<'info>,",
    "pub token_metadata_program: Program<'info, Metadata>,\n    pub token_program: Program<'info, Token>,\n    pub system_program: Program<'info, System>,\n    pub rent: Sysvar<'info, Rent>,\n}",
    "use {\n    anchor_lang::prelude::*,\n    anchor_spl::{\n        associated_token::AssociatedToken,\n        metadata::{\n            create_master_edition_v3, create_metadata_account\n            CreateMetadataAccountsV3, Metadata,\n        },\n        token::{mint_to, Mint, MintTo, Token, TokenAccount},\n    },\n    mpl_token_metadata::{\n        pda::{find_master_edition_account, find_metadata_acco\n        state::DataV2,\n    },\n};",
    "declare_id!(\"3qHNM98iLTaQtwmj2NkViXnHZQjNBS5PTHT2AuPxHXYN\");",
    "#[program]\npub mod nft_minter {\n    use super::*;",
    "pub fn mint_nft(\n        ctx: Context<CreateToken>,\n        nft_name: String,\n        nft_symbol: String,\n        nft_uri: String,\n    ) -> Result<()> {\n        msg!(\"Minting Token\");\n        // Cross Program Invocation (CPI)\n        // Invoking the mint_to instruction on the token prog\n        mint_to(\n            CpiContext::new(",
    "ctx.accounts.token_program.to_account_info(),\n                MintTo {\n                    mint: ctx.accounts.mint_account.to_accoun\n                    to: ctx.accounts.associated_token_account\n                    authority: ctx.accounts.payer.to_account_i\n                },\n            ),\n            1,\n        )?;",
    "msg!(\"Creating metadata account\");\n        // Cross Program Invocation (CPI)\n        // Invoking the create_metadata_account_v3 instructio\n        create_metadata_accounts_v3(\n            CpiContext::new(\n                ctx.accounts.token_metadata_program.to_accoun\n                CreateMetadataAccountsV3 {\n                    metadata: ctx.accounts.metadata_account.to\n                    mint: ctx.accounts.mint_account.to_accoun\n                    mint_authority: ctx.accounts.payer.to_acco\n                    update_authority: ctx.accounts.payer.to_ac\n                    payer: ctx.accounts.payer.to_account_info\n                    system_program: ctx.accounts.system_progra\n                    rent: ctx.accounts.rent.to_account_info()\n                },\n            ),\n            DataV2 {\n                name: nft_name,\n                symbol: nft_symbol,\n                uri: nft_uri,\n                seller_fee_basis_points: 0,\n                creators: None,\n                collection: None,\n                uses: None,\n            },\n            false, // Is mutable\n            true,  // Update authority is signer\n            None,  // Collection details",
    ")?;",
    "msg!(\"Creating master edition account\");\n        // Cross Program Invocation (CPI)\n        // Invoking the create_master_edition_v3 instruction o\n        create_master_edition_v3(\n            CpiContext::new(\n                ctx.accounts.token_metadata_program.to_accoun\n                CreateMasterEditionV3 {\n                    edition: ctx.accounts.edition_account.to_a\n                    mint: ctx.accounts.mint_account.to_accoun\n                    update_authority: ctx.accounts.payer.to_ac\n                    mint_authority: ctx.accounts.payer.to_acco\n                    payer: ctx.accounts.payer.to_account_info\n                    metadata: ctx.accounts.metadata_account.to\n                    token_program: ctx.accounts.token_program\n                    system_program: ctx.accounts.system_progra\n                    rent: ctx.accounts.rent.to_account_info()\n                },\n            ),\n            None, // Max Supply\n        )?;",
    "msg!(\"NFT minted successfully.\");",
    "Ok(())\n    }\n}",
    "#[derive(Accounts)]\npub struct CreateToken<'info> {\n    #[account(mut)]\n    pub payer: Signer<'info>,",
    "pub token_program: Program<'info, Token>,\n    pub token_metadata_program: Program<'info, Metadata>,\n    pub associated_token_program: Program<'info, AssociatedTo\n    pub system_program: Program<'info, System>,\n    pub rent: Sysvar<'info, Rent>,\n}",
    "use anchor_lang::prelude::*;\nuse instructions::*;\npub mod instructions;",
    "declare_id!(\"A5gNtapBvMLD6i7D2t3SSyJeFtBdfb6ibvZu1hoBLzCo\");",
    "#[program]\npub mod token_minter {\n    use super::*;",
    "pub fn create_token(\n        ctx: Context<CreateToken>,\n        token_name: String,\n        token_symbol: String,\n        token_uri: String,\n    ) -> Result<()> {\n        create::create_token(ctx, token_name, token_symbol, to\n    }",
    "pub fn mint_token(ctx: Context<MintToken>, amount: u64) ->\n        mint::mint_token(ctx, amount)\n    }\n}",
    "use anchor_lang::prelude::*;",
    "pub mod instructions;",
    "use instructions::*;",
    "declare_id!(\"77p9WmpzQW29RUEzTEef2ym7AHePBE9yNWJ9acikXfZS\");",
    "#[program]\npub mod spl_token_minter {\n    use super::*;",
    "pub fn create_token(\n        ctx: Context<CreateToken>,\n        token_name: String,\n        token_symbol: String,\n        token_uri: String,\n    ) -> Result<()> {\n        create::create_token(ctx, token_name, token_symbol, to\n    }",
    "pub fn mint_token(ctx: Context<MintToken>, amount: u64) ->\n        mint::mint_token(ctx, amount)\n    }\n}",
    "use anchor_lang::prelude::*;\nuse anchor_spl::associated_token::AssociatedToken;\nuse anchor_spl::token_interface::{\n    self, Mint, MintTo, TokenAccount, TokenInterface, Transfe\n};",
    "declare_id!(\"6qNqxkRF791FXFeQwqYQLEzAbGiqDULC5SSHVsfRoG89\");",
    "#[program]\npub mod anchor {",
    "use super::*;",
    "pub fn create_token(_ctx: Context<CreateToken>, _token_nam\n        msg!(\"Create Token\");\n        Ok(())\n    }\n    pub fn create_token_account(_ctx: Context<CreateTokenAcco\n        msg!(\"Create Token Account\");\n        Ok(())\n    }\n    pub fn create_associated_token_account(\n        _ctx: Context<CreateAssociatedTokenAccount>,\n    ) -> Result<()> {\n        msg!(\"Create Associated Token Account\");\n        Ok(())\n    }\n    pub fn transfer_token(ctx: Context<TransferToken>, amount\n        let cpi_accounts = TransferChecked {\n            from: ctx.accounts.from.to_account_info().clone()\n            mint: ctx.accounts.mint.to_account_info().clone()\n            to: ctx.accounts.to_ata.to_account_info().clone()\n            authority: ctx.accounts.signer.to_account_info(),\n        };\n        let cpi_program = ctx.accounts.token_program.to_accou\n        let cpi_context = CpiContext::new(cpi_program, cpi_acc\n        token_interface::transfer_checked(cpi_context, amount\n        msg!(\"Transfer Token\");\n        Ok(())\n    }\n    pub fn mint_token(ctx: Context<MintToken>, amount: u64) ->\n        let cpi_accounts = MintTo {\n            mint: ctx.accounts.mint.to_account_info().clone()\n            to: ctx.accounts.receiver.to_account_info().clone",
    "authority: ctx.accounts.signer.to_account_info(),\n        };\n        let cpi_program = ctx.accounts.token_program.to_accou\n        let cpi_context = CpiContext::new(cpi_program, cpi_acc\n        token_interface::mint_to(cpi_context, amount)?;\n        msg!(\"Mint Token\");\n        Ok(())\n    }\n}",
    "#[derive(Accounts)]\n#[instruction(token_name: String)]\npub struct CreateToken<'info> {\n    #[account(mut)]\n    pub signer: Signer<'info>,\n    #[account(\n        init,\n        payer = signer,\n        mint::decimals = 6,\n        mint::authority = signer.key(),\n        seeds = [b\"token-2022-token\", signer.key().as_ref(), \n        bump,\n    )]\n    pub mint: InterfaceAccount<'info, Mint>,\n    pub system_program: Program<'info, System>,\n    pub token_program: Interface<'info, TokenInterface>,\n}",
    "#[derive(Accounts)]\npub struct CreateTokenAccount<'info> {\n    #[account(mut)]\n    pub signer: Signer<'info>,\n    pub mint: InterfaceAccount<'info, Mint>,\n    #[account(\n        init,\n        token::mint = mint,\n        token::authority = signer,\n        payer = signer,",
    "seeds = [b\"token-2022-token-account\", signer.key().as_\n        bump,\n    )]\n    pub token_account: InterfaceAccount<'info, TokenAccount>,\n    pub system_program: Program<'info, System>,\n    pub token_program: Interface<'info, TokenInterface>,\n}",
    "#[derive(Accounts)]\npub struct CreateAssociatedTokenAccount<'info> {\n    #[account(mut)]\n    pub signer: Signer<'info>,\n    pub mint: InterfaceAccount<'info, Mint>,\n    #[account(\n        init,\n        associated_token::mint = mint,\n        payer = signer,\n        associated_token::authority = signer,\n    )]\n    pub token_account: InterfaceAccount<'info, TokenAccount>,\n    pub system_program: Program<'info, System>,\n    pub token_program: Interface<'info, TokenInterface>,\n    pub associated_token_program: Program<'info, AssociatedTo\n}",
    "pub struct TransferToken<'info> {\n    #[account(mut)]\n    pub signer: Signer<'info>,\n    #[account(mut)]\n    pub from: InterfaceAccount<'info, TokenAccount>,\n    pub to: SystemAccount<'info>,\n    #[account(\n        init,\n        associated_token::mint = mint,\n        payer = signer,\n        associated_token::authority = to",
    ")]\n    pub to_ata: InterfaceAccount<'info, TokenAccount>,\n    #[account(mut)]\n    pub mint: InterfaceAccount<'info, Mint>,\n    pub token_program: Interface<'info, TokenInterface>,\n    pub system_program: Program<'info, System>,\n    pub associated_token_program: Program<'info, AssociatedTo\n}",
    "#[derive(Accounts)]\npub struct MintToken<'info> {\n    #[account(mut)]\n    pub signer: Signer<'info>,\n    #[account(mut)]\n    pub mint: InterfaceAccount<'info, Mint>,\n    #[account(mut)]\n    pub receiver: InterfaceAccount<'info, TokenAccount>,\n    pub token_program: Interface<'info, TokenInterface>,\n}",
    "use {\n    borsh::{BorshDeserialize, BorshSerialize},\n    solana_program::{\n        account_info::{next_account_info, AccountInfo},\n        entrypoint,\n        entrypoint::ProgramResult,\n        msg,\n        program::invoke,\n        pubkey::Pubkey,\n        rent::Rent,\n        system_instruction,\n        sysvar::Sysvar,\n    },",
    "spl_token_2022::{\n        extension::{\n            default_account_state::instruction::{\n                initialize_default_account_state, update_defa\n            },\n            ExtensionType,\n        },\n        instruction as token_instruction,\n        state::AccountState,\n        state::Mint,\n    },\n};",
    "#[derive(BorshSerialize, BorshDeserialize, Debug)]\npub struct CreateTokenArgs {\n    pub token_decimals: u8,\n}",
    "entrypoint!(process_instruction);",
    "fn process_instruction(\n    _program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    instruction_data: &[u8],\n) -> ProgramResult {\n    let args = CreateTokenArgs::try_from_slice(instruction_da",
    "let accounts_iter = &mut accounts.iter();",
    "let mint_account = next_account_info(accounts_iter)?;\n    let mint_authority = next_account_info(accounts_iter)?;\n    let payer = next_account_info(accounts_iter)?;\n    let rent = next_account_info(accounts_iter)?;\n    let system_program = next_account_info(accounts_iter)?;\n    let token_program = next_account_info(accounts_iter)?;",
    "// Get the required rent exemption amount for the account\n    let rent_required = Rent::get()?.minimum_balance(space);",
    "msg!(\"Mint account address : {}\", mint_account.key);\n    invoke(\n        &system_instruction::create_account(\n            payer.key,\n            mint_account.key,\n            rent_required,\n            space as u64,\n            token_program.key,\n        ),\n        &[\n            mint_account.clone(),\n            payer.clone(),\n            system_program.clone(),\n            token_program.clone(),\n        ],\n    )?;",
    ")?;",
    "// Initialize the Token Mint\n    invoke(\n        &token_instruction::initialize_mint(\n            token_program.key,\n            mint_account.key,\n            mint_authority.key,\n            Some(mint_authority.key),\n            args.token_decimals,\n        )?,\n        &[\n            mint_account.clone(),\n            mint_authority.clone(),\n            token_program.clone(),\n            rent.clone(),\n        ],\n    )?;",
    "// Update the Default Account State to Initialized\n    invoke(\n        &update_default_account_state(\n            token_program.key,\n            mint_account.key,\n            payer.key,\n            &[payer.key],\n            &AccountState::Initialized,\n        )\n        .unwrap(),\n        &[\n            mint_account.clone(),\n            payer.clone(),\n            token_program.clone(),\n            system_program.clone(),\n        ],\n    )?;",
    "msg!(\"Mint created!\");",
    "Ok(())\n}",
    "use {\n    borsh::{BorshDeserialize, BorshSerialize},\n    solana_program::{\n        account_info::{next_account_info, AccountInfo},\n        entrypoint,\n        entrypoint::ProgramResult,\n        msg,\n        program::invoke,\n        pubkey::Pubkey,\n        rent::Rent,\n        system_instruction,\n        sysvar::Sysvar,\n    },\n    spl_token_2022::{extension::ExtensionType, instruction as \n};",
    "#[derive(BorshSerialize, BorshDeserialize, Debug)]\npub struct CreateTokenArgs {\n    pub token_decimals: u8,\n}",
    "entrypoint!(process_instruction);",
    "fn process_instruction(\n    _program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    instruction_data: &[u8],\n) -> ProgramResult {",
    "let accounts_iter = &mut accounts.iter();",
    "let mint_account = next_account_info(accounts_iter)?;\n    let mint_authority = next_account_info(accounts_iter)?;\n    let close_authority = next_account_info(accounts_iter)?;\n    let payer = next_account_info(accounts_iter)?;\n    let rent = next_account_info(accounts_iter)?;\n    let system_program = next_account_info(accounts_iter)?;\n    let token_program = next_account_info(accounts_iter)?;",
    "// Get the required rent exemption amount for the account\n    let rent_required = Rent::get()?.minimum_balance(space);",
    "// Create the account for the Mint and allocate space\n    msg!(\"Mint account address : {}\", mint_account.key);\n    invoke(\n        &system_instruction::create_account(\n            payer.key,\n            mint_account.key,\n            rent_required,\n            space as u64,\n            token_program.key,\n        ),\n        &[\n            mint_account.clone(),\n            payer.clone(),\n            system_program.clone(),\n            token_program.clone(),\n        ],\n    )?;",
    "// Initialize the Mint close authority Extension\n    invoke(\n        &token_instruction::initialize_mint_close_authority(\n            token_program.key,\n            mint_account.key,\n            Some(close_authority.key),\n        )\n        .unwrap(),\n        &[\n            mint_account.clone(),\n            close_authority.clone(),\n            token_program.clone(),\n            system_program.clone(),\n        ],\n    )?;",
    "// Initialize the Token Mint\n    invoke(\n        &token_instruction::initialize_mint(\n            token_program.key,\n            mint_account.key,\n            mint_authority.key,\n            Some(mint_authority.key),\n            args.token_decimals,\n        )?,\n        &[\n            mint_account.clone(),\n            mint_authority.clone(),\n            token_program.clone(),\n            rent.clone(),\n        ],\n    )?;",
    "msg!(\"Mint created!\");",
    "Ok(())\n}",
    "use {\n    borsh::{BorshDeserialize, BorshSerialize},\n    solana_program::{\n        account_info::{next_account_info, AccountInfo},\n        entrypoint,\n        entrypoint::ProgramResult,\n        msg,\n        program::invoke,\n        pubkey::Pubkey,\n        rent::Rent,\n        system_instruction,\n        sysvar::Sysvar,\n    },\n    spl_token_2022::{extension::ExtensionType, instruction as \n};",
    "#[derive(BorshSerialize, BorshDeserialize, Debug)]\npub struct CreateTokenArgs {\n    pub token_decimals: u8,\n}",
    "entrypoint!(process_instruction);",
    "fn process_instruction(\n    _program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    instruction_data: &[u8],\n) -> ProgramResult {\n    let args = CreateTokenArgs::try_from_slice(instruction_da",
    "let accounts_iter = &mut accounts.iter();",
    "let mint_account = next_account_info(accounts_iter)?;\n    let mint_authority = next_account_info(accounts_iter)?;\n    let close_authority = next_account_info(accounts_iter)?;\n    let payer = next_account_info(accounts_iter)?;\n    let rent = next_account_info(accounts_iter)?;\n    let system_program = next_account_info(accounts_iter)?;\n    let token_program = next_account_info(accounts_iter)?;",
    "// Find the size for the Mint account with the the number \n    let space = ExtensionType::get_account_len::<Mint>(&[\n        ExtensionType::MintCloseAuthority,\n        ExtensionType::NonTransferable,\n    ]);",
    "// Get the required rent exemption amount for the account\n    let rent_required = Rent::get()?.minimum_balance(space);",
    "// Create the account for the Mint and allocate space\n    msg!(\"Mint account address : {}\", mint_account.key);\n    invoke(\n        &system_instruction::create_account(\n            payer.key,\n            mint_account.key,\n            rent_required,\n            space as u64,\n            token_program.key,\n        ),\n        &[\n            mint_account.clone(),\n            payer.clone(),\n            system_program.clone(),\n            token_program.clone(),\n        ],\n    )?;",
    "// Initialize the Mint close authority Extension\n    invoke(\n        &token_instruction::initialize_mint_close_authority(\n            token_program.key,\n            mint_account.key,\n            Some(close_authority.key),\n        )\n        .unwrap(),\n        &[\n            mint_account.clone(),\n            close_authority.clone(),\n            token_program.clone(),\n            system_program.clone(),\n        ],\n    )?;",
    "// Initialize the Non Transferable Mint Extension\n    invoke(\n        &token_instruction::initialize_non_transferable_mint(\n            .unwrap(),\n        &[\n            mint_account.clone(),\n            token_program.clone(),\n            system_program.clone(),\n        ],\n    )?;",
    "mint_authority.clone(),\n            token_program.clone(),\n            rent.clone(),\n        ],\n    )?;",
    "msg!(\"Mint created!\");",
    "Ok(())\n}",
    "pub use crate::errors::GameErrorCode;\npub use anchor_lang::prelude::*;\npub use session_keys::{session_auth_or, Session, SessionError\npub mod constants;\npub mod errors;\npub mod instructions;\npub mod state;\nuse instructions::*;",
    "declare_id!(\"H31ofLpWqeAzF2Pg54HSPQGYifJad843tTJg8vCYVoh3\");",
    "#[program]\npub mod extension_nft {",
    "use super::*;",
    "pub fn init_player(ctx: Context<InitPlayer>, _level_seed: \n        init_player::init_player(ctx)\n    }",
    "// lets the player either use their session token or thei\n    // there so that the player can do multiple transactions i\n    // in the same block would result in the same signature a\n    #[session_auth_or(\n        ctx.accounts.player.authority.key() == ctx.accounts.si\n        GameErrorCode::WrongAuthority\n    )]\n    pub fn chop_tree(ctx: Context<ChopTree>, _level_seed: Stri\n        chop_tree::chop_tree(ctx, counter, 1)\n    }",
    "pub fn mint_nft(ctx: Context<MintNft>) -> Result<()> {\n        mint_nft::mint_nft(ctx)\n    }\n}",
    "use {\n    borsh::{BorshDeserialize, BorshSerialize},\n    solana_program::{\n        account_info::{next_account_info, AccountInfo},\n        entrypoint,\n        entrypoint::ProgramResult,\n        msg,\n        program::invoke,\n        pubkey::Pubkey,\n        rent::Rent,\n        system_instruction,\n        sysvar::Sysvar,\n    },\n    spl_token_2022::{extension::ExtensionType, instruction as \n};",
    "#[derive(BorshSerialize, BorshDeserialize, Debug)]\npub struct CreateTokenArgs {\n    pub token_decimals: u8,\n}",
    "entrypoint!(process_instruction);",
    "fn process_instruction(\n    _program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    instruction_data: &[u8],\n) -> ProgramResult {\n    let args = CreateTokenArgs::try_from_slice(instruction_da",
    "let accounts_iter = &mut accounts.iter();",
    "let mint_account = next_account_info(accounts_iter)?;\n    let mint_authority = next_account_info(accounts_iter)?;\n    let payer = next_account_info(accounts_iter)?;\n    let rent = next_account_info(accounts_iter)?;\n    let system_program = next_account_info(accounts_iter)?;\n    let token_program = next_account_info(accounts_iter)?;",
    "// Get the required rent exemption amount for the account\n    let rent_required = Rent::get()?.minimum_balance(space);",
    "// Create the account for the Mint and allocate space\n    msg!(\"Mint account address : {}\", mint_account.key);\n    invoke(\n        &system_instruction::create_account(\n            payer.key,\n            mint_account.key,\n            rent_required,\n            space as u64,\n            token_program.key,",
    "),\n        &[\n            mint_account.clone(),\n            payer.clone(),\n            system_program.clone(),\n            token_program.clone(),\n        ],\n    )?;",
    "// Initialize the Non Transferable Mint Extension\n    invoke(\n        &token_instruction::initialize_non_transferable_mint(\n            .unwrap(),\n        &[\n            mint_account.clone(),\n            token_program.clone(),\n            system_program.clone(),\n        ],\n    )?;",
    "// Initialize the Token Mint\n    invoke(\n        &token_instruction::initialize_mint(\n            token_program.key,\n            mint_account.key,\n            mint_authority.key,\n            Some(mint_authority.key),\n            args.token_decimals,\n        )?,\n        &[\n            mint_account.clone(),\n            mint_authority.clone(),\n            token_program.clone(),\n            rent.clone(),\n        ],\n    )?;",
    "msg!(\"Mint created!\");",
    "Ok(())\n}",
    "use {\n    borsh::{BorshDeserialize, BorshSerialize},\n    solana_program::{\n        account_info::{next_account_info, AccountInfo},\n        entrypoint,\n        entrypoint::ProgramResult,\n        msg,\n        program::invoke,\n        pubkey::Pubkey,\n        rent::Rent,\n        system_instruction,\n        sysvar::Sysvar,\n    },\n    spl_token_2022::{\n        extension::{\n            transfer_fee::instruction::{initialize_transfer_fe\n            ExtensionType,\n        },\n        instruction as token_instruction,\n        state::Mint,\n    },\n};",
    "#[derive(BorshSerialize, BorshDeserialize, Debug)]\npub struct CreateTokenArgs {",
    "pub token_decimals: u8,\n}",
    "entrypoint!(process_instruction);",
    "fn process_instruction(\n    _program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    instruction_data: &[u8],\n) -> ProgramResult {\n    let args = CreateTokenArgs::try_from_slice(instruction_da",
    "let accounts_iter = &mut accounts.iter();",
    "let mint_account = next_account_info(accounts_iter)?;\n    let mint_authority = next_account_info(accounts_iter)?;\n    let payer = next_account_info(accounts_iter)?;\n    let rent = next_account_info(accounts_iter)?;\n    let system_program = next_account_info(accounts_iter)?;\n    let token_program = next_account_info(accounts_iter)?;",
    "// Get the required rent exemption amount for the account\n    let rent_required = Rent::get()?.minimum_balance(space);",
    "// Create the account for the Mint and allocate space\n    msg!(\"Mint account address : {}\", mint_account.key);\n    invoke(\n        &system_instruction::create_account(\n            payer.key,\n            mint_account.key,\n            rent_required,\n            space as u64,\n            token_program.key,\n        ),\n        &[",
    "mint_account.clone(),\n            payer.clone(),\n            system_program.clone(),\n            token_program.clone(),\n        ],\n    )?;",
    "// The max fee will be 5 tokens, here we adjust it with t\n    let max_fee = 5 * 10u64.pow(args.token_decimals as u32);",
    "// This needs to be done before the Mint is initialized\n    // Initialize the Transfer Fee config\n    invoke(\n        &initialize_transfer_fee_config(\n            token_program.key,\n            mint_account.key,\n            Some(payer.key),\n            Some(payer.key),\n            // 1% fee on transfers\n            100,\n            max_fee,\n        )\n        .unwrap(),\n        &[\n            mint_account.clone(),\n            token_program.clone(),\n            payer.clone(),\n            system_program.clone(),\n        ],\n    )?;",
    "args.token_decimals,\n        )?,\n        &[\n            mint_account.clone(),\n            mint_authority.clone(),\n            token_program.clone(),\n            rent.clone(),\n        ],\n    )?;",
    "// Initialize the Transfer Fee config\n    invoke(\n        &set_transfer_fee(\n            token_program.key,\n            mint_account.key,\n            payer.key,\n            &[payer.key],\n            // 10% fee on transfers\n            1000,\n            max_fee,\n        )\n        .unwrap(),\n        &[\n            mint_account.clone(),\n            token_program.clone(),\n            payer.clone(),\n            system_program.clone(),\n        ],\n    )?;",
    "msg!(\"Mint created!\");",
    "Ok(())\n}",
    "use anchor_lang::{\n    prelude::*,\n    system_program::{create_account, CreateAccount},\n};\nuse anchor_spl::{\n    associated_token::AssociatedToken,\n    token_interface::{Mint, TokenAccount, TokenInterface},\n};\nuse spl_tlv_account_resolution::{\n    account::ExtraAccountMeta, seeds::Seed, state::ExtraAccou\n};\nuse spl_transfer_hook_interface::instruction::{ExecuteInstruc",
    "declare_id!(\"DrWbQtYJGtsoRwzKqAbHKHKsCJJfpysudF39GBVFSxub\");",
    "#[error_code]\npub enum MyError {\n    #[msg(\"The amount is too big\")]\n    AmountTooBig,\n}",
    "#[program]\npub mod transfer_hook {\n    use super::*;",
    "pub fn initialize_extra_account_meta_list(\n        ctx: Context<InitializeExtraAccountMetaList>,\n    ) -> Result<()> {",
    "let account_metas = vec![\n            ExtraAccountMeta::new_with_seeds(\n                &[Seed::Literal {\n                    bytes: \"counter\".as_bytes().to_vec(),",
    "}],\n                false, // is_signer\n                true,  // is_writable\n            )?,\n        ];",
    "let mint = ctx.accounts.mint.key();\n        let signer_seeds: &[&[&[u8]]] = &[&[\n            b\"extra-account-metas\",\n            &mint.as_ref(),\n            &[ctx.bumps.extra_account_meta_list],\n        ]];",
    "// create ExtraAccountMetaList account\n        create_account(\n            CpiContext::new(\n                ctx.accounts.system_program.to_account_info()\n                CreateAccount {\n                    from: ctx.accounts.payer.to_account_info(\n                    to: ctx.accounts.extra_account_meta_list.\n                },\n            )\n            .with_signer(signer_seeds),\n            lamports,\n            account_size,\n            ctx.program_id,\n        )?;",
    "// initialize ExtraAccountMetaList account with extra \n        ExtraAccountMetaList::init::<ExecuteInstruction>(\n            &mut ctx.accounts.extra_account_meta_list.try_bor\n            &account_metas,\n        )?;",
    "Ok(())\n    }",
    "if amount > 50 {\n            msg!(\"The amount is too big {0}\", amount);\n            //return err!(MyError::AmountTooBig);\n        }",
    "msg!(\"This token has been transferred {0} times\", ctx\n       \n        Ok(())\n    }",
    "// fallback instruction handler as workaround to anchor i\n    pub fn fallback<'info>(\n        program_id: &Pubkey,\n        accounts: &'info [AccountInfo<'info>],\n        data: &[u8],\n    ) -> Result<()> {\n        let instruction = TransferHookInstruction::unpack(data",
    "// match instruction discriminator to transfer hook i\n        // token2022 program CPIs this instruction on token t\n        match instruction {\n            TransferHookInstruction::Execute { amount } => {\n                let amount_bytes = amount.to_le_bytes();",
    "// invoke custom transfer hook instruction on \n                __private::__global::transfer_hook(program_id\n            }\n            _ => return Err(ProgramError::InvalidInstructionDa\n        }\n    }",
    "}",
    "#[derive(Accounts)]\npub struct InitializeExtraAccountMetaList<'info> {\n    #[account(mut)]\n    payer: Signer<'info>,",
    "/// CHECK: ExtraAccountMetaList Account, must use these se\n    #[account(\n        mut,\n        seeds = [b\"extra-account-metas\", mint.key().as_ref()]\n        bump\n    )]\n    pub extra_account_meta_list: AccountInfo<'info>,\n    pub mint: InterfaceAccount<'info, Mint>,\n    #[account(\n        init_if_needed,\n        seeds = [b\"counter\"], \n        bump,\n        payer = payer,\n        space = 16\n    )]\n    pub counter_account: Account<'info, CounterAccount>,\n    pub token_program: Interface<'info, TokenInterface>,\n    pub associated_token_program: Program<'info, AssociatedTo\n    pub system_program: Program<'info, System>,\n}",
    "// Order of accounts matters for this struct.\n// The first 4 accounts are the accounts required for token t\n// Remaining accounts are the extra accounts required from the\n// These accounts are provided via CPI to this program from t\n#[derive(Accounts)]\npub struct TransferHook<'info> {\n    #[account(\n        token::mint = mint, \n        token::authority = owner,\n    )]",
    "pub source_token: InterfaceAccount<'info, TokenAccount>,\n    pub mint: InterfaceAccount<'info, Mint>,\n    #[account(\n        token::mint = mint,\n    )]\n    pub destination_token: InterfaceAccount<'info, TokenAccou\n    /// CHECK: source token account owner, can be SystemAccou\n    pub owner: UncheckedAccount<'info>,\n    /// CHECK: ExtraAccountMetaList Account,\n    #[account(\n        seeds = [b\"extra-account-metas\", mint.key().as_ref()]\n        bump\n    )]\n    pub extra_account_meta_list: UncheckedAccount<'info>,\n    #[account(\n        seeds = [b\"counter\"],\n        bump\n    )]\n    pub counter_account: Account<'info, CounterAccount>,\n}",
    "#[account]\npub struct CounterAccount {\n    counter: u64,\n}",
    "use anchor_lang::{\n    prelude::*,",
    "system_program::{create_account, CreateAccount},\n};\nuse anchor_spl::{\n    associated_token::AssociatedToken,\n    token_interface::{Mint, TokenAccount, TokenInterface},\n};\nuse spl_tlv_account_resolution::{\n    state::ExtraAccountMetaList,\n};\nuse spl_transfer_hook_interface::instruction::{ExecuteInstruc",
    "declare_id!(\"DrWbQtYJGtsoRwzKqAbHKHKsCJJfpysudF39GBVFSxub\");",
    "#[program]\npub mod transfer_hook {\n    use super::*;",
    "pub fn initialize_extra_account_meta_list(\n        ctx: Context<InitializeExtraAccountMetaList>,\n    ) -> Result<()> {",
    "let account_metas = vec![];",
    "let mint = ctx.accounts.mint.key();\n        let signer_seeds: &[&[&[u8]]] = &[&[\n            b\"extra-account-metas\",\n            &mint.as_ref(),\n            &[ctx.bumps.extra_account_meta_list],\n        ]];",
    "ctx.accounts.system_program.to_account_info()\n                CreateAccount {\n                    from: ctx.accounts.payer.to_account_info(\n                    to: ctx.accounts.extra_account_meta_list.\n                },\n            )\n            .with_signer(signer_seeds),\n            lamports,\n            account_size,\n            ctx.program_id,\n        )?;",
    "// initialize ExtraAccountMetaList account with extra \n        ExtraAccountMetaList::init::<ExecuteInstruction>(\n            &mut ctx.accounts.extra_account_meta_list.try_bor\n            &account_metas,\n        )?;",
    "Ok(())\n    }",
    "msg!(\"Hello Transfer Hook!\");",
    "Ok(())\n    }",
    "// fallback instruction handler as workaround to anchor i\n    pub fn fallback<'info>(\n        program_id: &Pubkey,\n        accounts: &'info [AccountInfo<'info>],\n        data: &[u8],\n    ) -> Result<()> {\n        let instruction = TransferHookInstruction::unpack(data",
    "match instruction {\n            TransferHookInstruction::Execute { amount } => {\n                let amount_bytes = amount.to_le_bytes();",
    "// invoke custom transfer hook instruction on \n                __private::__global::transfer_hook(program_id\n            }\n            _ => return Err(ProgramError::InvalidInstructionDa\n        }\n    }\n}",
    "#[derive(Accounts)]\npub struct InitializeExtraAccountMetaList<'info> {\n    #[account(mut)]\n    payer: Signer<'info>,",
    "/// CHECK: ExtraAccountMetaList Account, must use these se\n    #[account(\n        mut,\n        seeds = [b\"extra-account-metas\", mint.key().as_ref()]\n        bump\n    )]\n    pub extra_account_meta_list: AccountInfo<'info>,\n    pub mint: InterfaceAccount<'info, Mint>,\n    pub token_program: Interface<'info, TokenInterface>,\n    pub associated_token_program: Program<'info, AssociatedTo\n    pub system_program: Program<'info, System>,\n}",
    "// Order of accounts matters for this struct.\n// The first 4 accounts are the accounts required for token t\n// Remaining accounts are the extra accounts required from the\n// These accounts are provided via CPI to this program from t\n#[derive(Accounts)]\npub struct TransferHook<'info> {\n    #[account(\n        token::mint = mint,",
    "token::authority = owner,\n    )]\n    pub source_token: InterfaceAccount<'info, TokenAccount>,\n    pub mint: InterfaceAccount<'info, Mint>,\n    #[account(\n        token::mint = mint,\n    )]\n    pub destination_token: InterfaceAccount<'info, TokenAccou\n    /// CHECK: source token account owner, can be SystemAccou\n    pub owner: UncheckedAccount<'info>,\n    /// CHECK: ExtraAccountMetaList Account,\n    #[account(\n        seeds = [b\"extra-account-metas\", mint.key().as_ref()]\n        bump\n    )]\n    pub extra_account_meta_list: UncheckedAccount<'info>,\n}",
    "use anchor_lang::{\n    prelude::*,\n    system_program::{create_account, CreateAccount},\n};\nuse anchor_spl::{\n    associated_token::AssociatedToken,\n    token_interface::{transfer_checked, Mint, TokenAccount, To\n};\nuse spl_tlv_account_resolution::{\n    account::ExtraAccountMeta, seeds::Seed, state::ExtraAccou\n};",
    "use spl_transfer_hook_interface::instruction::{ExecuteInstruc",
    "declare_id!(\"DrWbQtYJGtsoRwzKqAbHKHKsCJJfpysudF39GBVFSxub\");",
    "#[error_code]\npub enum MyError {\n   #[msg(\"Amount Too big\")]\n   AmountTooBig,\n}",
    "#[program]\npub mod transfer_hook {\n    use super::*;",
    "pub fn initialize_extra_account_meta_list(\n        ctx: Context<InitializeExtraAccountMetaList>,\n    ) -> Result<()> {\n        // index 0-3 are the accounts required for token tran\n        // index 4 is address of ExtraAccountMetaList account\n        let account_metas = vec![\n            // index 5, wrapped SOL mint\n            ExtraAccountMeta::new_with_pubkey(&ctx.accounts.w\n            // index 6, token program\n            ExtraAccountMeta::new_with_pubkey(&ctx.accounts.to\n            // index 7, associated token program\n            ExtraAccountMeta::new_with_pubkey(\n                &ctx.accounts.associated_token_program.key(),\n                false,\n                false,\n            )?,\n            // index 8, delegate PDA\n            ExtraAccountMeta::new_with_seeds(\n                &[Seed::Literal {\n                    bytes: \"delegate\".as_bytes().to_vec(),\n                }],",
    "false, // is_signer\n                true,  // is_writable\n            )?,\n            // index 9, delegate wrapped SOL token account\n            ExtraAccountMeta::new_external_pda_with_seeds(\n                7, // associated token program index\n                &[\n                    Seed::AccountKey { index: 8 }, // owner i\n                    Seed::AccountKey { index: 6 }, // token p\n                    Seed::AccountKey { index: 5 }, // wsol mi\n                ],\n                false, // is_signer\n                true,  // is_writable\n            )?,\n            // index 10, sender wrapped SOL token account\n            ExtraAccountMeta::new_external_pda_with_seeds(\n                7, // associated token program index\n                &[\n                    Seed::AccountKey { index: 3 }, // owner i\n                    Seed::AccountKey { index: 6 }, // token p\n                    Seed::AccountKey { index: 5 }, // wsol mi\n                ],\n                false, // is_signer\n                true,  // is_writable\n            )?,\n            ExtraAccountMeta::new_with_seeds(\n                &[Seed::Literal {\n                    bytes: \"counter\".as_bytes().to_vec(),\n                }],\n                false, // is_signer\n                true,  // is_writable\n            )?,\n        ];",
    "let mint = ctx.accounts.mint.key();\n        let signer_seeds: &[&[&[u8]]] = &[&[\n            b\"extra-account-metas\",\n            &mint.as_ref(),\n            &[ctx.bumps.extra_account_meta_list],\n        ]];",
    "// create ExtraAccountMetaList account\n        create_account(\n            CpiContext::new(\n                ctx.accounts.system_program.to_account_info()\n                CreateAccount {\n                    from: ctx.accounts.payer.to_account_info(\n                    to: ctx.accounts.extra_account_meta_list.\n                },\n            )\n            .with_signer(signer_seeds),\n            lamports,\n            account_size,\n            ctx.program_id,\n        )?;",
    "// initialize ExtraAccountMetaList account with extra \n        ExtraAccountMetaList::init::<ExecuteInstruction>(\n            &mut ctx.accounts.extra_account_meta_list.try_bor\n            &account_metas,\n        )?;",
    "Ok(())\n    }",
    "if amount > 50 {\n            //msg!(\"The amount is too big {0}\", amount);\n            //return err!(MyError::AmountTooBig);\n        }",
    "ctx.accounts.counter_account.counter += 1;",
    "msg!(\"This token has been transferred {0} times\", ctx",
    "// All accounts are non writable so you can not burn a\n        msg!(\"Is writable mint {0}\", ctx.accounts.mint.to_acco\n        msg!(\"Is destination mint {0}\", ctx.accounts.destinati\n        msg!(\"Is source mint {0}\", ctx.accounts.source_token.",
    "// Transfer WSOL from sender to delegate token accoun\n        transfer_checked(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                TransferChecked {\n                    from: ctx.accounts.sender_wsol_token_acco\n                    mint: ctx.accounts.wsol_mint.to_account_i\n                    to: ctx.accounts.delegate_wsol_token_acco\n                    authority: ctx.accounts.delegate.to_accou\n                },\n            )\n            .with_signer(signer_seeds),\n            amount / 2,\n            ctx.accounts.wsol_mint.decimals,\n        )?;\n        Ok(())\n    }",
    "// fallback instruction handler as workaround to anchor i\n    pub fn fallback<'info>(\n        program_id: &Pubkey,\n        accounts: &'info [AccountInfo<'info>],\n        data: &[u8],\n    ) -> Result<()> {\n        let instruction = TransferHookInstruction::unpack(data",
    "// match instruction discriminator to transfer hook i\n        // token2022 program CPIs this instruction on token t\n        match instruction {\n            TransferHookInstruction::Execute { amount } => {\n                let amount_bytes = amount.to_le_bytes();",
    "// invoke custom transfer hook instruction on \n                __private::__global::transfer_hook(program_id\n            }\n            _ => Err(ProgramError::InvalidInstructionData.into\n        }\n    }\n}",
    "#[derive(Accounts)]\npub struct InitializeExtraAccountMetaList<'info> {\n    #[account(mut)]\n    payer: Signer<'info>,",
    "pub system_program: Program<'info, System>,\n}",
    "// Order of accounts matters for this struct.\n// The first 4 accounts are the accounts required for token t\n// Remaining accounts are the extra accounts required from the\n// These accounts are provided via CPI to this program from t\n#[derive(Accounts)]\npub struct TransferHook<'info> {\n    #[account(\n        token::mint = mint, \n        token::authority = owner,\n    )]\n    pub source_token: InterfaceAccount<'info, TokenAccount>,\n    pub mint: InterfaceAccount<'info, Mint>,\n    #[account(\n        token::mint = mint,\n    )]\n    pub destination_token: InterfaceAccount<'info, TokenAccou\n    /// CHECK: source token account owner, can be SystemAccou\n    pub owner: UncheckedAccount<'info>,\n    /// CHECK: ExtraAccountMetaList Account,\n    #[account(\n        seeds = [b\"extra-account-metas\", mint.key().as_ref()]\n        bump\n    )]\n    pub extra_account_meta_list: UncheckedAccount<'info>,\n    pub wsol_mint: InterfaceAccount<'info, Mint>,\n    pub token_program: Interface<'info, TokenInterface>,\n    pub associated_token_program: Program<'info, AssociatedTo\n    #[account(\n        mut,\n        seeds = [b\"delegate\"], \n        bump\n    )]\n    pub delegate: SystemAccount<'info>,\n    #[account(\n        mut,",
    "token::mint = wsol_mint, \n        token::authority = delegate,\n    )]\n    pub delegate_wsol_token_account: InterfaceAccount<'info, T\n    #[account(\n        mut,\n        token::mint = wsol_mint, \n        token::authority = owner,\n    )]\n    pub sender_wsol_token_account: InterfaceAccount<'info, To\n    #[account(\n        seeds = [b\"counter\"],\n        bump\n    )]\n    pub counter_account: Account<'info, CounterAccount>,\n}",
    "#[account]\npub struct CounterAccount {\n    counter: u8\n}",
    "use anchor_lang::{\n    prelude::*,\n    system_program::{create_account, CreateAccount},\n};\nuse anchor_spl::{\n    associated_token::AssociatedToken, token_interface::{Mint",
    "};\nuse spl_tlv_account_resolution::state::ExtraAccountMetaList;\nuse spl_transfer_hook_interface::instruction::{ExecuteInstruc",
    "declare_id!(\"DrWbQtYJGtsoRwzKqAbHKHKsCJJfpysudF39GBVFSxub\");",
    "#[program]\npub mod transfer_hook {",
    "use spl_tlv_account_resolution::{account::ExtraAccountMeta",
    "use super::*;",
    "pub fn initialize_extra_account_meta_list(\n        ctx: Context<InitializeExtraAccountMetaList>,\n    ) -> Result<()> {",
    "let account_metas = vec![\n            ExtraAccountMeta::new_with_seeds(\n                &[Seed::Literal {\n                    bytes: \"white_list\".as_bytes().to_vec(),\n                }], // owner index (delegate PDA)\n                false, // is_signer\n                true,  // is_writable\n            )?,\n        ];",
    "let mint = ctx.accounts.mint.key();\n        let signer_seeds: &[&[&[u8]]] = &[&[\n            b\"extra-account-metas\",\n            &mint.as_ref(),",
    "&[ctx.bumps.extra_account_meta_list],\n        ]];",
    "// create ExtraAccountMetaList account\n        create_account(\n            CpiContext::new(\n                ctx.accounts.system_program.to_account_info()\n                CreateAccount {\n                    from: ctx.accounts.payer.to_account_info(\n                    to: ctx.accounts.extra_account_meta_list.\n                },\n            )\n            .with_signer(signer_seeds),\n            lamports,\n            account_size,\n            ctx.program_id,\n        )?;",
    "// initialize ExtraAccountMetaList account with extra \n        ExtraAccountMetaList::init::<ExecuteInstruction>(\n            &mut ctx.accounts.extra_account_meta_list.try_bor\n            &account_metas,\n        )?;",
    "Ok(())\n    }",
    "if !ctx.accounts.white_list.white_list.contains(&ctx.a\n            panic!(\"Account not in white list!\");\n        }",
    "msg!(\"Account in white list, all good!\");",
    "Ok(())\n    }",
    "if ctx.accounts.white_list.authority != ctx.accounts.\n            panic!(\"Only the authority can add to the white li\n        }",
    "ctx.accounts.white_list.white_list.push(ctx.accounts.\n        msg!(\"New account white listed! {0}\", ctx.accounts.new\n        msg!(\"White list length! {0}\", ctx.accounts.white_lis",
    "Ok(())\n    }",
    "// fallback instruction handler as workaround to anchor i\n    pub fn fallback<'info>(\n        program_id: &Pubkey,\n        accounts: &'info [AccountInfo<'info>],\n        data: &[u8],\n    ) -> Result<()> {\n        let instruction = TransferHookInstruction::unpack(data",
    "// match instruction discriminator to transfer hook i\n        // token2022 program CPIs this instruction on token t\n        match instruction {\n            TransferHookInstruction::Execute { amount } => {\n                let amount_bytes = amount.to_le_bytes();",
    "// invoke custom transfer hook instruction on \n                __private::__global::transfer_hook(program_id\n            }\n            _ => return Err(ProgramError::InvalidInstructionDa\n        }\n    }\n}",
    "#[derive(Accounts)]\npub struct InitializeExtraAccountMetaList<'info> {\n    #[account(mut)]",
    "/// CHECK: ExtraAccountMetaList Account, must use these se\n    #[account(\n        mut,\n        seeds = [b\"extra-account-metas\", mint.key().as_ref()]\n        bump\n    )]\n    pub extra_account_meta_list: AccountInfo<'info>,\n    pub mint: InterfaceAccount<'info, Mint>,\n    pub token_program: Interface<'info, TokenInterface>,\n    pub associated_token_program: Program<'info, AssociatedTo\n    pub system_program: Program<'info, System>,\n    #[account(\n        init_if_needed,\n        seeds = [b\"white_list\"],\n        bump,\n        payer = payer,\n        space = 400\n    )]\n    pub white_list: Account<'info, WhiteList>,\n}",
    "// Order of accounts matters for this struct.\n// The first 4 accounts are the accounts required for token t\n// Remaining accounts are the extra accounts required from the\n// These accounts are provided via CPI to this program from t\n#[derive(Accounts)]\npub struct TransferHook<'info> {\n    #[account(\n        token::mint = mint, \n        token::authority = owner,\n    )]\n    pub source_token: InterfaceAccount<'info, TokenAccount>,\n    pub mint: InterfaceAccount<'info, Mint>,\n    #[account(\n        token::mint = mint,\n    )]",
    "pub destination_token: InterfaceAccount<'info, TokenAccou\n    /// CHECK: source token account owner, can be SystemAccou\n    pub owner: UncheckedAccount<'info>,\n    /// CHECK: ExtraAccountMetaList Account,\n    #[account(\n        seeds = [b\"extra-account-metas\", mint.key().as_ref()]\n        bump\n    )]\n    pub extra_account_meta_list: UncheckedAccount<'info>,\n    #[account(\n        seeds = [b\"white_list\"],\n        bump\n    )]\n    pub white_list: Account<'info, WhiteList>,\n}",
    "#[derive(Accounts)]\npub struct AddToWhiteList<'info> {\n    /// CHECK: New account to add to white list\n    #[account()]\n    pub new_account: AccountInfo<'info>,\n    #[account(\n        mut,\n        seeds = [b\"white_list\"],\n        bump\n    )]\n    pub white_list: Account<'info, WhiteList>,\n    #[account(mut)]\n    pub signer: Signer<'info>,\n}",
    "#[account]\npub struct WhiteList {\n    pub authority: Pubkey,\n    pub white_list: Vec<Pubkey>,\n}",
    "use anchor_lang::prelude::*;",
    "mod constants;\nmod errors;\nmod instructions;\nmod state;",
    "// Set the correct key here\ndeclare_id!(\"C3ti6PFK6PoYShRFx1BNNTQU3qeY1iVwjwCA6SjJhiuW\");",
    "#[program]\npub mod swap_example {\n    pub use super::instructions::*;\n    use super::*;",
    "pub fn create_amm(ctx: Context<CreateAmm>, id: Pubkey, fee\n        instructions::create_amm(ctx, id, fee)\n    }",
    "pub fn create_pool(ctx: Context<CreatePool>) -> Result<()>\n        instructions::create_pool(ctx)\n    }",
    "pub fn deposit_liquidity(\n        ctx: Context<DepositLiquidity>,\n        amount_a: u64,\n        amount_b: u64,\n    ) -> Result<()> {",
    "instructions::deposit_liquidity(ctx, amount_a, amount_\n    }",
    "pub fn withdraw_liquidity(ctx: Context<WithdrawLiquidity>\n        instructions::withdraw_liquidity(ctx, amount)\n    }",
    "pub fn swap_exact_tokens_for_tokens(\n        ctx: Context<SwapExactTokensForTokens>,\n        swap_a: bool,\n        input_amount: u64,\n        min_output_amount: u64,\n    ) -> Result<()> {\n        instructions::swap_exact_tokens_for_tokens(ctx, swap_a\n    }\n}",
    "use anchor_lang::prelude::*;",
    "pub mod instructions;",
    "use instructions::*;",
    "declare_id!(\"2W7B8C5skxyVaAA1LfYAsRHiv26LL5j88GJ9XYyybWqc\");",
    "#[program]\npub mod transfer_tokens {\n    use super::*;",
    "token_uri: String,\n    ) -> Result<()> {\n        create::create_token(ctx, token_title, token_symbol, \n    }",
    "pub fn mint_token(ctx: Context<MintToken>, amount: u64) ->\n        mint::mint_token(ctx, amount)\n    }",
    "pub fn transfer_tokens(ctx: Context<TransferTokens>, amou\n        transfer::transfer_tokens(ctx, amount)\n    }\n}",
    "// import custom helpers for demos\nimport {\n  loadPublicKeysFromFile,\n  printConsoleSeparator,\n  savePublicKeyToFile,\n} from \"@/utils/helpers\";",
    "// imports from other libraries\nimport dotenv from \"dotenv\";\nimport { Metaplex, MetaplexError, ReadApiAssetList } from \"@me\nimport { ReadApiConnection } from \"@metaplex-foundation/js\";",
    "import { PublicKey } from \"@solana/web3.js\";",
    "// load the env variables and store the cluster RPC url\ndotenv.config();\nconst CLUSTER_URL = process.env.RPC_URL ?? \"\";",
    "(async () => {\n  // load the stored PublicKeys for ease of use\n  let keys = loadPublicKeysFromFile();",
    "const treeAddress: PublicKey = keys.treeAddress;\n  const treeAuthority: PublicKey = keys.treeAuthority;\n  const collectionMint: PublicKey = keys.collectionMint;\n  const userAddress: PublicKey = keys.userAddress;\n  const testWallet: PublicKey = keys.testWallet;",
    "console.log(\"==== Local PublicKeys loaded ====\");\n  console.log(\"Tree address:\", treeAddress.toBase58());\n  console.log(\"Tree authority:\", treeAuthority.toBase58());\n  console.log(\"Collection mint:\", collectionMint.toBase58());\n  console.log(\"User address:\", userAddress.toBase58());\n  console.log(\"Test address:\", testWallet.toBase58());",
    "// define the address we are actually going to check (in thi\n  const checkAddress = collectionMint.toBase58();",
    "printConsoleSeparator(`getAssetsByGroup: ${checkAddress}`);",
    "const connection = new ReadApiConnection(CLUSTER_URL);\n  const metaplex = Metaplex.make(connection);",
    "/**\n   * Fetch a listing of NFT assets by an owner's address (via \n   * ---\n   * NOTE: This will return both compressed NFTs AND traditio\n   */\n  const rpcAssets = await metaplex\n    .rpc()\n    .getAssetsByGroup({\n      groupKey: \"collection\",\n      groupValue: checkAddress,\n      sortBy: {\n        sortBy: \"created\",\n        sortDirection: \"asc\",\n      },\n    })\n    .then(res => {\n      if ((res as MetaplexError)?.cause) throw res;\n      else return res as ReadApiAssetList;\n    });",
    "/**\n   * Process the returned `rpcAssets` response\n   */\n  console.log(\"Total assets returned:\", rpcAssets.total);",
    "// loop over each of the asset items in the collection\n  rpcAssets.items.map(asset => {\n    // only show compressed nft assets\n    if (!asset.compression.compressed) return;",
    "// extra useful info\n    console.log(\"assetId:\", asset.id);",
    "// view the ownership info for the given asset\n    console.log(\"ownership:\", asset.ownership);",
    "// metadata json data (auto fetched thanks to the Metaplex\n    // console.log(\"metadata:\", asset.content.metadata);",
    "// view the compression specific data for the given asset\n    console.log(\"compression:\", asset.compression);",
    "if (asset.compression.compressed) {\n      console.log(\"==> This NFT is compressed! <===\");\n      console.log(\"\\tleaf_id:\", asset.compression.leaf_id);\n    } else console.log(\"==> NFT is NOT compressed! <===\");\n  });\n})();",
    "// import custom helpers for demos\nimport {\n  loadPublicKeysFromFile,\n  printConsoleSeparator,\n  savePublicKeyToFile,\n} from \"@/utils/helpers\";",
    "// imports from other libraries\nimport dotenv from \"dotenv\";",
    "import { Metaplex, MetaplexError, ReadApiAssetList } from \"@me\nimport { ReadApiConnection } from \"@metaplex-foundation/js\";\nimport { PublicKey } from \"@solana/web3.js\";",
    "// load the env variables and store the cluster RPC url\ndotenv.config();\nconst CLUSTER_URL = process.env.RPC_URL ?? \"\";",
    "(async () => {\n  // load the stored PublicKeys for ease of use\n  let keys = loadPublicKeysFromFile();",
    "const treeAddress: PublicKey = keys.treeAddress;\n  const treeAuthority: PublicKey = keys.treeAuthority;\n  const collectionMint: PublicKey = keys.collectionMint;\n  const userAddress: PublicKey = keys.userAddress;\n  const testWallet: PublicKey = keys.testWallet;",
    "console.log(\"==== Local PublicKeys loaded ====\");\n  console.log(\"Tree address:\", treeAddress.toBase58());\n  console.log(\"Tree authority:\", treeAuthority.toBase58());\n  console.log(\"Collection mint:\", collectionMint.toBase58());\n  console.log(\"User address:\", userAddress.toBase58());\n  console.log(\"Test address:\", testWallet.toBase58());",
    "// define the address we are actually going to check (in thi\n  // const checkAddress = testWallet.toBase58();\n  const checkAddress = userAddress.toBase58();",
    "printConsoleSeparator(`getAssetsByOwner: ${checkAddress}`);",
    "const connection = new ReadApiConnection(CLUSTER_URL);\n  const metaplex = Metaplex.make(connection);",
    "/**\n   * Fetch a listing of NFT assets by an owner's address (via \n   * ---\n   * NOTE: This will return both compressed NFTs AND traditio\n   */\n  const rpcAssets = await metaplex\n    .rpc()\n    .getAssetsByOwner({\n      ownerAddress: checkAddress,\n    })\n    .then(res => {\n      if ((res as MetaplexError)?.cause) throw res;\n      else return res as ReadApiAssetList;\n    });",
    "/**\n   * Process the returned `rpcAssets` response\n   */\n  console.log(\"Total assets returned:\", rpcAssets.total);",
    "// loop over each of the asset items in the collection\n  rpcAssets.items.map(asset => {\n    // only show compressed nft assets\n    if (!asset.compression.compressed) return;",
    "// extra useful info\n    console.log(\"assetId:\", asset.id);",
    "console.log(\"ownership:\", asset.ownership);",
    "// metadata json data (auto fetched thanks to the Metaplex\n    // console.log(\"metadata:\", asset.content.metadata);",
    "// view the compression specific data for the given asset\n    console.log(\"compression:\", asset.compression);",
    "if (asset.compression.compressed) {\n      console.log(\"==> This NFT is compressed! <===\");\n      console.log(\"\\tleaf_id:\", asset.compression.leaf_id);\n    } else console.log(\"==> NFT is NOT compressed! <===\");\n  });\n})();",
    "// imports from other libraries\nimport dotenv from \"dotenv\";\nimport { Metaplex, ReadApiConnection, keypairIdentity } from \nimport { PublicKey, clusterApiUrl } from \"@solana/web3.js\";",
    "// import custom helpers for demos\nimport {\n  loadPublicKeysFromFile,\n  loadKeypairFromFile,\n  loadOrGenerateKeypair,\n  explorerURL,",
    "printConsoleSeparator,\n  savePublicKeyToFile,\n} from \"@/utils/helpers\";\nimport { getLeafAssetId, metadataArgsBeet } from \"@metaplex-fo\nimport {\n  changeLogEventV1Beet,\n  deserializeApplicationDataEvent,\n  deserializeChangeLogEventV1,\n} from \"@solana/spl-account-compression\";\nimport { bs58 } from \"@project-serum/anchor/dist/cjs/utils/by\nimport { BN } from \"@project-serum/anchor\";",
    "// load the env variables and store the cluster RPC url\ndotenv.config();\nconst CLUSTER_URL = process.env.RPC_URL ?? clusterApiUrl(\"dev",
    "// create a new rpc connection\n// const connection = new Connection(CLUSTER_URL);\nconst connection = new ReadApiConnection(CLUSTER_URL);",
    "(async () => {\n  ////////////////////////////////////////////////////////////\n  ////////////////////////////////////////////////////////////",
    "// generate a new Keypair for testing, named `testWallet`\n  const testWallet = loadOrGenerateKeypair(\"testWallet\");",
    "// generate a new keypair for use in this demo (or load it l\n  const payer = process.env?.LOCAL_PAYER_JSON_ABSPATH\n    ? loadKeypairFromFile(process.env?.LOCAL_PAYER_JSON_ABSPAT\n    : loadOrGenerateKeypair(\"payer\");",
    "console.log(\"Payer address:\", payer.publicKey.toBase58());\n  console.log(\"Test wallet address:\", testWallet.publicKey.to",
    "// load the stored PublicKeys for ease of use\n  let keys = loadPublicKeysFromFile();",
    "const treeAddress: PublicKey = keys.treeAddress;\n  const collectionMint: PublicKey = keys.collectionMint;\n  const collectionAuthority: PublicKey = keys.collectionAutho",
    "console.log(\"==== Local PublicKeys loaded ====\");\n  console.log(\"Tree address:\", treeAddress.toBase58());\n  console.log(\"Collection mint:\", collectionMint.toBase58());\n  console.log(\"User address:\", payer.publicKey.toBase58());\n  console.log(\"Test address:\", testWallet.publicKey.toBase58(",
    "// mint a new compressed NFT into our existing collection\n  const { response, nft } = await metaplex.nfts().create({\n    uri: \"https://supersweetcollection.notarealurl/token.json\n    name: \"compressed with metaplex\",\n    sellerFeeBasisPoints: 500,\n    collection: collectionMint,",
    "// note: this merkle tree must have already been created\n    tree: treeAddress,\n  });",
    "console.log(\"nft minted with metaplex sdk:\", nft);",
    "printConsoleSeparator(\"View on explorer\");",
    "console.log(explorerURL({ txSignature: response.signature }\n})();",
    "// import custom helpers for demos\nimport { loadPublicKeysFromFile, printConsoleSeparator } from",
    "import dotenv from \"dotenv\";\nimport { GetAssetProofRpcResponse, Metaplex, ReadApiConnectio",
    "// imports from other libraries\nimport { PublicKey, clusterApiUrl } from \"@solana/web3.js\";\nimport {\n  ConcurrentMerkleTreeAccount,\n  MerkleTree,\n  MerkleTreeProof,",
    "} from \"@solana/spl-account-compression\";",
    "// load the env variables and store the cluster RPC url\ndotenv.config();\nconst CLUSTER_URL = process.env.RPC_URL ?? clusterApiUrl(\"dev",
    "// create a new rpc connection\n// const connection = new Connection(CLUSTER_URL);\nconst connection = new ReadApiConnection(CLUSTER_URL);",
    "(async () => {\n  ////////////////////////////////////////////////////////////\n  ////////////////////////////////////////////////////////////",
    "// load the stored PublicKeys for ease of use\n  let keys = loadPublicKeysFromFile();",
    "// ensure the primary script was already run\n  if (!keys?.assetIdTestAddress)\n    return console.warn(\n      \"No locally saved `assetIdTestAddress` was found, Please\n    );",
    "console.log(\"==== Local PublicKeys loaded ====\");\n  console.log(\"Test Asset ID:\", assetIdTestAddress.toBase58()\n  console.log(\"User Asset ID:\", assetIdUserAddress.toBase58()",
    "// set the asset to test with\n  const assetId = assetIdTestAddress;\n  // const assetId = assetIdUserAddress;",
    "const metaplex = Metaplex.make(connection);",
    "/**\n   * Fetch an asset from the ReadApi by its `assetId`\n   */\n  const nft = await metaplex.nfts().findByAssetId({ assetId }\n  console.log(nft);",
    "printConsoleSeparator(\"Get the asset proof from the RPC:\");",
    "// fetch an asset's proof from the ReadApi by its `assetId`\n  const assetProof = (await metaplex.rpc().getAssetProof(asse\n  console.log(assetProof);",
    "// construct a valid proof object to check against\n  const merkleTreeProof: MerkleTreeProof = {\n    leafIndex: nft.compression?.leaf_id || 0,\n    leaf: new PublicKey(assetProof.leaf).toBuffer(),\n    root: new PublicKey(assetProof.root).toBuffer(),\n    proof: assetProof.proof.map((node: string) => new PublicKe\n  };",
    "// get the actual merkle tree data from the Solana blockchai\n  const merkleTree = new PublicKey(assetProof.tree_id);\n  const treeAccount = await ConcurrentMerkleTreeAccount.fromAc",
    "const currentRoot = treeAccount.getCurrentRoot();\n  const rootFromRpc = new PublicKey(assetProof.root).toBuffer",
    "/**\n   * note: the current on-chain root hash (`currentRoot`) doe\n   * RPC provided root hash (`rootFromRpc`). This is because a\n   * of valid root hashes are stored on-chain via the trees o\n   * (set by your tree's `maxBufferSize` at tree creation)\n   *\n   * This check is show here purely for demonstration, and is \n   */\n  console.log(\n    \"Does the current on-chain root match RPC provided root:\"\n    new PublicKey(currentRoot).toBase58() === new PublicKey(ro\n  );\n})();",
    "// imports from other libraries\nimport dotenv from \"dotenv\";\nimport { Metaplex, ReadApiConnection, keypairIdentity } from \nimport { PublicKey, clusterApiUrl } from \"@solana/web3.js\";",
    "// import custom helpers for demos\nimport {\n  loadPublicKeysFromFile,\n  loadKeypairFromFile,\n  loadOrGenerateKeypair,\n  explorerURL,\n  printConsoleSeparator,\n} from \"@/utils/helpers\";",
    "// load the env variables and store the cluster RPC url\ndotenv.config();\nconst CLUSTER_URL = process.env.RPC_URL ?? clusterApiUrl(\"dev",
    "// create a new rpc connection\n// const connection = new Connection(CLUSTER_URL);\nconst connection = new ReadApiConnection(CLUSTER_URL);",
    "(async () => {\n  ////////////////////////////////////////////////////////////\n  ////////////////////////////////////////////////////////////",
    "// generate a new Keypair for testing, named `testWallet`\n  const testWallet = loadOrGenerateKeypair(\"testWallet\");",
    "const payer = process.env?.LOCAL_PAYER_JSON_ABSPATH\n    ? loadKeypairFromFile(process.env?.LOCAL_PAYER_JSON_ABSPAT\n    : loadOrGenerateKeypair(\"payer\");",
    "console.log(\"Payer address:\", payer.publicKey.toBase58());\n  console.log(\"Test wallet address:\", testWallet.publicKey.to",
    "// load the stored PublicKeys for ease of use\n  let keys = loadPublicKeysFromFile();",
    "// ensure the primary script was already run\n  if (!keys?.assetIdTestAddress)\n    return console.warn(\n      \"No locally saved `assetIdTestAddress` was found, Please\n    );",
    "console.log(\"==== Local PublicKeys loaded ====\");\n  console.log(\"Test Asset ID:\", assetIdTestAddress.toBase58()\n  console.log(\"User Asset ID:\", assetIdUserAddress.toBase58()",
    "// set the asset to test with\n  const assetId = assetIdTestAddress;\n  // const assetId = assetIdUserAddress;",
    "const nft = await metaplex.nfts().findByAssetId({ assetId }\n  console.log(nft);",
    "printConsoleSeparator(\"Transfer the compressed nft:\");",
    "await metaplex\n    .nfts()\n    .transfer({\n      nftOrSft: nft,\n      toOwner: payer.publicKey,\n    })\n    .then(res => {\n      console.log(\"transfer complete:\", res);",
    "console.log(explorerURL({ txSignature: res.response.sig\n    })\n    .catch(err => {\n      console.log(\"==================\");\n      console.log(\"  Transfer failed!\");\n      console.log(\"==================\");\n      console.error(err);\n    });\n})();",
    "// local import of the connection wrapper, to help with using \nimport { WrapperConnection } from \"@/ReadApi/WrapperConnectio",
    "// import custom helpers for demos\nimport {\n  explorerURL,\n  loadKeypairFromFile,\n  loadOrGenerateKeypair,\n  loadPublicKeysFromFile,\n  printConsoleSeparator,\n} from \"@/utils/helpers\";\nimport {\n  TokenProgramVersion,\n  TokenStandard,\n  computeCreatorHash,\n  computeDataHash,\n  createVerifyCreatorInstruction,\n  getLeafAssetId,\n} from \"@metaplex-foundation/mpl-bubblegum\";",
    "import {\n  SPL_ACCOUNT_COMPRESSION_PROGRAM_ID,\n  SPL_NOOP_PROGRAM_ID,\n  ConcurrentMerkleTreeAccount,\n  getAllChangeLogEventV1FromTransaction,\n} from \"@solana/spl-account-compression\";\nimport {\n  MetadataArgs,\n  Creator,\n  PROGRAM_ID as BUBBLEGUM_PROGRAM_ID,\n} from \"@metaplex-foundation/mpl-bubblegum\";\nimport {\n  AccountMeta,",
    "PublicKey,\n  TransactionMessage,\n  VersionedTransaction,\n  clusterApiUrl,\n} from \"@solana/web3.js\";",
    "import dotenv from \"dotenv\";\nimport { BN } from \"@project-serum/anchor\";\ndotenv.config();",
    "(async () => {\n  // generate a new Keypair for testing, named `wallet`\n  const testWallet = loadOrGenerateKeypair(\"testWallet\");",
    "// generate a new keypair for use in this demo (or load it l\n  const payer = process.env?.LOCAL_PAYER_JSON_ABSPATH\n    ? loadKeypairFromFile(process.env?.LOCAL_PAYER_JSON_ABSPAT\n    : loadOrGenerateKeypair(\"payer\");",
    "console.log(\"Payer address:\", payer.publicKey.toBase58());\n  console.log(\"Test wallet address:\", testWallet.publicKey.to",
    "// create a new rpc connection, using the ReadApi wrapper\n  const connection = new WrapperConnection(CLUSTER_URL);",
    "printConsoleSeparator(\"\");",
    "const tx = await connection.getTransaction(devnetSig, {\n    maxSupportedTransactionVersion: 0,\n  });",
    "if (!tx) throw Error(\"Tx not found\");",
    "printConsoleSeparator(\"Events:\");",
    "const events = getAllChangeLogEventV1FromTransaction(tx);",
    "console.log(events);\n  const leafIndex = events[0].index;",
    "console.log(\"assetId:\", assetId);\n  console.log(\"total events:\", events.length);\n})();",
    "import { Keypair, LAMPORTS_PER_SOL, clusterApiUrl } from \"@sol\nimport { ValidDepthSizePair } from \"@solana/spl-account-compre\nimport {\n  MetadataArgs,\n  TokenProgramVersion,\n  TokenStandard,\n} from \"@metaplex-foundation/mpl-bubblegum\";\nimport { CreateMetadataAccountArgsV3 } from \"@metaplex-founda",
    "// import custom helpers for demos\nimport { loadKeypairFromFile, loadOrGenerateKeypair, numberFo",
    "// import custom helpers to mint compressed NFTs\nimport { createCollection, createTree, mintCompressedNFT } fro",
    "// local import of the connection wrapper, to help with using \nimport { WrapperConnection } from \"@/ReadApi/WrapperConnectio",
    "import dotenv from \"dotenv\";\ndotenv.config();",
    "// define some reusable balance values for tracking\nlet initBalance: number, balance: number;",
    "(async () => {\n  ////////////////////////////////////////////////////////////\n  ////////////////////////////////////////////////////////////",
    "// generate a new Keypair for testing, named `wallet`\n  const testWallet = loadOrGenerateKeypair(\"testWallet\");",
    "? loadKeypairFromFile(process.env?.LOCAL_PAYER_JSON_ABSPAT\n    : loadOrGenerateKeypair(\"payer\");",
    "console.log(\"Payer address:\", payer.publicKey.toBase58());\n  console.log(\"Test wallet address:\", testWallet.publicKey.to",
    "// get the payer's starting balance (only used for demonstra\n  initBalance = await connection.getBalance(payer.publicKey);",
    "/*\n    Define our tree size parameters\n  */\n  const maxDepthSizePair: ValidDepthSizePair = {\n    // max=16,384 nodes\n    maxDepth: 14,\n    maxBufferSize: 64,\n  };\n  const canopyDepth = maxDepthSizePair.maxDepth - 5;",
    "// define the address the tree will live at\n  const treeKeypair = Keypair.generate();",
    "// define the metadata to be used for creating the NFT colle\n  const collectionMetadataV3: CreateMetadataAccountArgsV3 = {\n    data: {\n      name: \"Super Sweet NFT Collection\",\n      symbol: \"SSNC\",\n      // specific json metadata for the collection\n      uri: \"https://supersweetcollection.notarealurl/collectio\n      sellerFeeBasisPoints: 100,\n      creators: [\n        {\n          address: payer.publicKey,\n          verified: false,\n          share: 100,\n        },\n      ],\n      collection: null,\n      uses: null,\n    },\n    isMutable: false,\n    collectionDetails: null,\n  };",
    "const compressedNFTMetadata: MetadataArgs = {",
    "name: \"NFT Name\",\n    symbol: collectionMetadataV3.data.symbol,\n    // specific json metadata for each NFT\n    uri: \"https://supersweetcollection.notarealurl/token.json\n    creators: [\n      {\n        address: payer.publicKey,\n        verified: false,\n        share: 100,\n      },\n      {\n        address: testWallet.publicKey,\n        verified: false,\n        share: 0,\n      },\n    ],\n    editionNonce: 0,\n    uses: null,\n    collection: null,\n    primarySaleHappened: false,\n    sellerFeeBasisPoints: 0,\n    isMutable: false,\n    // these values are taken from the Bubblegum package\n    tokenProgramVersion: TokenProgramVersion.Original,\n    tokenStandard: TokenStandard.NonFungible,\n  };",
    "// fully mint a single compressed NFT to the payer\n  console.log(`Minting a single compressed NFT to ${payer.publ",
    "// mint to this specific wallet (in this case, the tree ow\n    payer.publicKey,\n  );",
    "// fully mint a single compressed NFT\n  console.log(`Minting a single compressed NFT to ${testWalle",
    "await mintCompressedNFT(\n    connection,\n    payer,\n    treeKeypair.publicKey,\n    collection.mint,\n    collection.metadataAccount,\n    collection.masterEditionAccount,\n    compressedNFTMetadata,\n    // mint to this specific wallet (in this case, airdrop to \n    testWallet.publicKey,\n  );",
    "// fetch the payer's final balance\n  balance = await connection.getBalance(payer.publicKey);",
    "console.log(`===============================`);\n  console.log(\n    \"Total cost:\",\n    numberFormatter((initBalance - balance) / LAMPORTS_PER_SO\n    \"SOL\\n\",\n  );\n})();"
  ],

  "anchor": [
    "pub fn version_binary_path(version: &Version) -> PathBuf {\n    get_bin_dir_path().join(format!(\"anchor-{version}\"))\n}",
    "pub fn ensure_paths() {\n    let home_dir = AVM_HOME.to_path_buf();\n    if !home_dir.exists() {\n        fs::create_dir_all(&home_dir).expect(\"Could not create .avm directory\");\n    }\n\n    let bin_dir = get_bin_dir_path();\n    if !bin_dir.exists() {\n        fs::create_dir_all(bin_dir).expect(\"Could not create .avm/bin directory\");\n    }\n\n    if !current_version_file_path().exists() {\n        fs::File::create(current_version_file_path()).expect(\"Could not create .version file\");\n    }\n}\n\n/// Read the current version from the version file\npub fn current_version() -> Result<Version> {\n    fs::read_to_string(current_version_file_path())\n        .map_err(|e| anyhow!(\"Could not read version file: {}\", e))?\n        .trim_end_matches('\\n')\n        .parse::<Version>()\n        .map_err(|e| anyhow!(\"Could not parse version file: {}\", e))\n}",
    "pub fn use_version(opt_version: Option<Version>) -> Result<()> {\n    let version = match opt_version {\n        Some(version) => version,\n        None => read_anchorversion_file()?,\n    };\n\n    // Make sure the requested version is installed\n    let installed_versions = read_installed_versions()?;\n    if !installed_versions.contains(&version) {\n        println!(\"Version {version} is not installed. Would you like to install? [y/n]\");\n        let input = std::io::stdin()\n            .lock()\n            .lines()\n            .next()\n            .expect(\"Expected input\")?;\n        match input.as_str() {\n            \"y\" | \"yes\" => return install_version(InstallTarget::Version(version), false, false),\n            _ => return Err(anyhow!(\"Installation rejected.\")),\n        };\n    }\n\n    let mut current_version_file = fs::File::create(current_version_file_path())?;\n    current_version_file.write_all(version.to_string().as_bytes())?;\n    println!(\"Now using anchor version {}.\", current_version()?);\n    Ok(())\n}",
    "pub fn update() -> Result<()> {\n    let latest_version = get_latest_version()?;\n    install_version(InstallTarget::Version(latest_version), false, false)\n}",
    "pub fn check_and_get_full_commit(commit: &str) -> Result<String> {\n    let client = reqwest::blocking::Client::new();\n    let response = client\n        .get(format!(\n            \"https://api.github.com/repos/coral-xyz/anchor/commits/{commit}\"\n        ))\n        .header(USER_AGENT, \"avm https://github.com/coral-xyz/anchor\")\n        .send()?;\n\n    if response.status() != StatusCode::OK {\n        return Err(anyhow!(\n            \"Error checking commit {commit}: {}\",\n            response.text()?\n        ));\n    };\n\n    #[derive(Deserialize)]\n    struct GetCommitResponse {\n        sha: String,\n    }\n\n    response\n        .json::<GetCommitResponse>()\n        .map(|resp| resp.sha)\n        .map_err(|err| anyhow!(\"Failed to parse the response to JSON: {err:?}\"))\n}",
    "pub fn install_version(\n    install_target: InstallTarget,\n    force: bool,\n    from_source: bool,\n) -> Result<()> {\n    let version = match &install_target {\n        InstallTarget::Version(version) => version.to_owned(),\n        InstallTarget::Commit(commit) => get_anchor_version_from_commit(commit)?,\n    };\n    // Return early if version is already installed\n    if !force && read_installed_versions()?.contains(&version) {\n        eprintln!(\"Version `{version}` is already installed\");\n        return Ok(());\n    }\n\n    let is_commit = matches!(install_target, InstallTarget::Commit(_));\n    let is_older_than_v0_31_0 = version < Version::parse(\"0.31.0\")?;\n    if from_source || is_commit || is_older_than_v0_31_0 {\n        // Build from source using `cargo install --git`\n        let mut args: Vec<String> = vec![\n            \"install\".into(),\n            \"anchor-cli\".into(),\n            \"--git\".into(),\n            \"https://github.com/coral-xyz/anchor\".into(),\n            \"--locked\".into(),\n            \"--root\".into(),\n            AVM_HOME.to_str().unwrap().into(),\n        ];\n        let conditional_args = match install_target {\n            InstallTarget::Version(version) => [\"--tag\".into(), format!(\"v{}\", version)],\n            InstallTarget::Commit(commit) => [\"--rev\".into(), commit],\n        };\n        args.extend_from_slice(&conditional_args);\n\n        // If the version is older than v0.31, install using `rustc 1.79.0` to get around the problem\n        // explained in https://github.com/coral-xyz/anchor/pull/3143\n        if is_older_than_v0_31_0 {\n            const REQUIRED_VERSION: &str = \"1.79.0\";\n            let is_installed = Command::new(\"rustup\")\n                .args([\"toolchain\", \"list\"])\n                .output()\n                .map(|output| String::from_utf8(output.stdout))??\n                .lines()\n                .any(|line| line.starts_with(REQUIRED_VERSION));\n            if !is_installed {\n                let exit_status = Command::new(\"rustup\")\n                    .args([\"toolchain\", \"install\", REQUIRED_VERSION])\n                    .spawn()?\n                    .wait()?;\n                if !exit_status.success() {\n                    return Err(anyhow!(\n                        \"Installation of `rustc {REQUIRED_VERSION}` failed. \\\n                    `rustc <1.80` is required to install Anchor v{version} from source. \\\n                    See https://github.com/coral-xyz/anchor/pull/3143 for more information.\"\n                    ));\n                }\n            }\n\n            // Prepend the toolchain to use with the `cargo install` command\n            args.insert(0, format!(\"+{REQUIRED_VERSION}\"));\n        }\n\n        let output = Command::new(\"cargo\")\n            .args(args)\n            .stdout(Stdio::inherit())\n            .stderr(Stdio::inherit())\n            .output()\n            .map_err(|e| anyhow!(\"`cargo install` for version `{version}` failed: {e}\"))?;\n        if !output.status.success() {\n            return Err(anyhow!(\n                \"Failed to install {version}, is it a valid version?\"\n            ));\n        }\n\n        let bin_dir = get_bin_dir_path();\n        let bin_name = if cfg!(target_os = \"windows\") {\n            \"anchor.exe\"\n        } else {\n            \"anchor\"\n        };\n        fs::rename(bin_dir.join(bin_name), version_binary_path(&version))?;\n    } else {\n        let output = Command::new(\"rustc\").arg(\"-vV\").output()?;\n        let target = core::str::from_utf8(&output.stdout)?\n            .lines()\n            .find(|line| line.starts_with(\"host:\"))\n            .and_then(|line| line.split(':').last())\n            .ok_or_else(|| anyhow!(\"`host` not found from `rustc -vV` output\"))?\n            .trim();\n        let ext = if cfg!(target_os = \"windows\") {\n            \".exe\"\n        } else {\n            \"\"\n        };\n        let res = reqwest::blocking::get(format!(\n            \"https://github.com/coral-xyz/anchor/releases/download/v{version}/anchor-{version}-{target}{ext}\"\n        ))?;\n        if !res.status().is_success() {\n            return Err(anyhow!(\n                \"Failed to download the binary for version `{version}` (status code: {})\",\n                res.status()\n            ));\n        }\n\n        let bin_path = version_binary_path(&version);\n        fs::write(&bin_path, res.bytes()?)?;\n\n        // Set file to executable on UNIX\n        #[cfg(unix)]\n        fs::set_permissions(\n            bin_path,\n            <fs::Permissions as std::os::unix::fs::PermissionsExt>::from_mode(0o775),\n        )?;\n    }\n\n    // If .version file is empty or not parseable, write the newly installed version to it\n    if current_version().is_err() {\n        let mut current_version_file = fs::File::create(current_version_file_path())?;\n        current_version_file.write_all(version.to_string().as_bytes())?;\n    }\n\n    use_version(Some(version))\n}",
    "pub fn uninstall_version(version: &Version) -> Result<()> {\n    let version_path = version_binary_path(version);\n    if !version_path.exists() {\n        return Err(anyhow!(\"anchor-cli {} is not installed\", version));\n    }\n    if version == &current_version()? {\n        return Err(anyhow!(\"anchor-cli {} is currently in use\", version));\n    }\n    fs::remove_file(version_path)?;\n\n    Ok(())\n}",
    "pub fn read_anchorversion_file() -> Result<Version> {\n    fs::read_to_string(\".anchorversion\")\n        .map_err(|e| anyhow!(\".anchorversion file not found: {e}\"))\n        .map(|content| Version::parse(content.trim()))?\n        .map_err(|e| anyhow!(\"Unable to parse version: {e}\"))\n}",
    "pub fn fetch_versions() -> Result<Vec<Version>, Error> {\n    #[derive(Deserialize)]\n    struct Release {\n        #[serde(rename = \"name\", deserialize_with = \"version_deserializer\")]\n        version: Version,\n    }\n\n    fn version_deserializer<'de, D>(deserializer: D) -> Result<Version, D::Error>\n    where\n        D: de::Deserializer<'de>,\n    {\n        let s: &str = de::Deserialize::deserialize(deserializer)?;\n        Version::parse(s.trim_start_matches('v')).map_err(de::Error::custom)\n    }",
    "pub fn list_versions() -> Result<()> {\n    let mut installed_versions = read_installed_versions()?;\n\n    let mut available_versions = fetch_versions()?;\n    // Reverse version list so latest versions are printed last\n    available_versions.reverse();\n\n    let print_versions =\n        |versions: Vec<Version>, installed_versions: &mut Vec<Version>, show_latest: bool| {\n            versions.iter().enumerate().for_each(|(i, v)| {\n                print!(\"{v}\");\n                let mut flags = vec![];\n                if i == versions.len() - 1 && show_latest {\n                    flags.push(\"latest\");\n                }\n                if let Some(position) = installed_versions.iter().position(|iv| iv == v) {\n                    flags.push(\"installed\");\n                    installed_versions.remove(position);\n                }\n                if current_version().map(|cv| &cv == v).unwrap_or_default() {\n                    flags.push(\"current\");\n                }\n\n                if flags.is_empty() {\n                    println!();\n                } else {\n                    println!(\"\\t({})\", flags.join(\", \"));\n                }\n            })\n        }",
    "pub fn get_latest_version() -> Result<Version> {\n    fetch_versions()?\n        .into_iter()\n        .next()\n        .ok_or_else(|| anyhow!(\"First version not found\"))\n}",
    "pub fn read_installed_versions() -> Result<Vec<Version>> {\n    const PREFIX: &str = \"anchor-\";\n    let versions = fs::read_dir(get_bin_dir_path())?\n        .filter_map(|entry_result| entry_result.ok())\n        .filter_map(|entry| entry.file_name().to_str().map(|f| f.to_owned()))\n        .filter(|file_name| file_name.starts_with(PREFIX))\n        .filter_map(|file_name| file_name.trim_start_matches(PREFIX).parse::<Version>().ok())\n        .collect();\n\n    Ok(versions)\n}",
    "pub fn entry(opts: Cli) -> Result<()> {\n    match opts.command {\n        Commands::Use { version } => avm::use_version(version),\n        Commands::Install {\n            version_or_commit,\n            force,\n            from_source,\n        } => avm::install_version(version_or_commit, force, from_source),\n        Commands::Uninstall { version } => avm::uninstall_version(&version),\n        Commands::List {} => avm::list_versions(),\n        Commands::Update {} => avm::update(),\n        Commands::Completions { shell } => {\n            clap_complete::generate(shell, &mut Cli::command(), \"avm\", &mut std::io::stdout());\n            Ok(())\n        }",
    "pub fn check_overflow(cargo_toml_path: impl AsRef<Path>) -> Result<bool> {\n    Manifest::from_path(cargo_toml_path)?\n        .profile\n        .release\n        .as_ref()\n        .and_then(|profile| profile.overflow_checks)\n        .ok_or(anyhow!(\n            \"`overflow-checks` is not enabled. To enable, add:\\n\\n\\\n    [profile.release]\\n\\\n    overflow-checks = true\\n\\n\\\n    in workspace root Cargo.toml\",\n        ))\n}",
    "pub fn check_anchor_version(cfg: &WithPath<Config>) -> Result<()> {\n    let cli_version = Version::parse(VERSION)?;\n\n    // Check lang crate\n    let mismatched_lang_version = cfg\n        .get_rust_program_list()?\n        .into_iter()\n        .map(|path| path.join(\"Cargo.toml\"))\n        .map(cargo_toml::Manifest::from_path)\n        .filter_map(|man| man.ok())\n        .filter_map(|man| man.dependencies.get(\"anchor-lang\").map(|d| d.to_owned()))\n        .filter_map(|dep| Version::parse(dep.req()).ok())\n        .find(|ver| ver != &cli_version); // Only log the warning once\n\n    if let Some(ver) = mismatched_lang_version {\n        eprintln!(\n            \"WARNING: `anchor-lang` version({ver}) and the current CLI version({cli_version}) \\\n                 don't match.\\n\\n\\t\\\n                 This can lead to unwanted behavior. To use the same CLI version, add:\\n\\n\\t\\\n                 [toolchain]\\n\\t\\\n                 anchor_version = \\\"{ver}\\\"\\n\\n\\t\\\n                 to Anchor.toml\\n\"\n        );\n    }\n\n    // Check TS package\n    let package_json = {\n        let package_json_path = cfg.path().parent().unwrap().join(\"package.json\");\n        let package_json_content = fs::read_to_string(package_json_path)?;\n        serde_json::from_str::<serde_json::Value>(&package_json_content)?\n    };\n    let mismatched_ts_version = package_json\n        .get(\"dependencies\")\n        .and_then(|deps| deps.get(\"@coral-xyz/anchor\"))\n        .and_then(|ver| ver.as_str())\n        .and_then(|ver| VersionReq::parse(ver).ok())\n        .filter(|ver| !ver.matches(&cli_version));\n\n    if let Some(ver) = mismatched_ts_version {\n        let update_cmd = match cfg.toolchain.package_manager.clone().unwrap_or_default() {\n            PackageManager::NPM => \"npm update\",\n            PackageManager::Yarn => \"yarn upgrade\",\n            PackageManager::PNPM => \"pnpm update\",\n        };\n\n        eprintln!(\n            \"WARNING: `@coral-xyz/anchor` version({ver}) and the current CLI version\\\n                ({cli_version}) don't match.\\n\\n\\t\\\n                This can lead to unwanted behavior. To fix, upgrade the package by running:\\n\\n\\t\\\n                {update_cmd} @coral-xyz/anchor@{cli_version}\\n\"\n        );\n    }\n\n    Ok(())\n}",
    "pub fn check_deps(cfg: &WithPath<Config>) -> Result<()> {\n    // Check `solana-program`\n    cfg.get_rust_program_list()?\n        .into_iter()\n        .map(|path| path.join(\"Cargo.toml\"))\n        .map(cargo_toml::Manifest::from_path)\n        .map(|man| man.map_err(|e| anyhow!(\"Failed to read manifest: {e}\")))\n        .collect::<Result<Vec<_>>>()?\n        .into_iter()\n        .filter(|man| man.dependencies.contains_key(\"solana-program\"))\n        .for_each(|man| {\n            eprintln!(\n                \"WARNING: Adding `solana-program` as a separate dependency might cause conflicts.\\n\\\n                To solve, remove the `solana-program` dependency and use the exported crate from \\\n                `anchor-lang`.\\n\\\n                `use solana_program` becomes `use anchor_lang::solana_program`.\\n\\\n                Program name: `{}`\\n\",\n                man.package().name()\n            )\n        }",
    "pub fn check_idl_build_feature() -> Result<()> {\n    let manifest_path = Path::new(\"Cargo.toml\").canonicalize()?;\n    let manifest = Manifest::from_path(&manifest_path)?;\n\n    // Check whether the manifest has `idl-build` feature\n    let has_idl_build_feature = manifest\n        .features\n        .iter()\n        .any(|(feature, _)| feature == \"idl-build\");\n    if !has_idl_build_feature {\n        let anchor_spl_idl_build = manifest\n            .dependencies\n            .iter()\n            .any(|dep| dep.0 == \"anchor-spl\")\n            .then_some(r#\", \"anchor-spl/idl-build\"\"#)\n            .unwrap_or_default();\n\n        return Err(anyhow!(\n            r#\"`idl-build` feature is missing. To solve, add\n\n[features]\nidl-build = [\"anchor-lang/idl-build\"{anchor_spl_idl_build}]\n\nin `{manifest_path:?}`.\"#\n        ));\n    }\n\n    // Check if `idl-build` is enabled by default\n    manifest\n        .dependencies\n        .iter()\n        .filter(|(_, dep)| dep.req_features().contains(&\"idl-build\".into()))\n        .for_each(|(name, _)| {\n            eprintln!(\n                \"WARNING: `idl-build` feature of crate `{name}` is enabled by default. \\\n                    This is not the intended usage.\\n\\n\\t\\\n                    To solve, do not enable the `idl-build` feature and include crates that have \\\n                    `idl-build` feature in the `idl-build` feature list:\\n\\n\\t\\\n                    [features]\\n\\t\\\n                    idl-build = [\\\"{name}/idl-build\\\", ...]\\n\"\n            )\n        }",
    "pub fn new(inner: T, path: PathBuf) -> Self {\n        Self { inner, path }\n    }\n\n    pub fn path(&self) -> &PathBuf {\n        &self.path\n    }\n\n    pub fn into_inner(self) -> T {\n        self.inner\n    }\n}\n\nimpl<T> std::convert::AsRef<T> for WithPath<T> {\n    fn as_ref(&self) -> &T {\n        &self.inner\n    }\n}\n\n#[derive(Debug, Clone, PartialEq)]\npub struct Manifest(cargo_toml::Manifest);\n\nimpl Manifest {\n    pub fn from_path(p: impl AsRef<Path>) -> Result<Self> {\n        cargo_toml::Manifest::from_path(&p)\n            .map(Manifest)\n            .map_err(anyhow::Error::from)\n            .with_context(|| format!(\"Error reading manifest from path: {}\", p.as_ref().display()))\n    }",
    "pub fn lib_name(&self) -> Result<String> {\n        match &self.lib {\n            Some(cargo_toml::Product {\n                name: Some(name), ..\n            }) => Ok(name.to_owned()),\n            _ => self\n                .package\n                .as_ref()\n                .ok_or_else(|| anyhow!(\"package section not provided\"))\n                .map(|pkg| pkg.name.to_snake_case()),\n        }\n    }\n\n    pub fn version(&self) -> String {\n        match &self.package {\n            Some(package) => package.version().to_string(),\n            _ => \"0.0.0\".to_string(),\n        }\n    }\n\n    // Climbs each parent directory from the current dir until we find a Cargo.toml\n    pub fn discover() -> Result<Option<WithPath<Manifest>>> {\n        Manifest::discover_from_path(std::env::current_dir()?)\n    }",
    "pub fn discover_from_path(start_from: PathBuf) -> Result<Option<WithPath<Manifest>>> {\n        let mut cwd_opt = Some(start_from.as_path());\n\n        while let Some(cwd) = cwd_opt {\n            let mut anchor_toml = false;\n\n            for f in fs::read_dir(cwd).with_context(|| {\n                format!(\"Error reading the directory with path: {}\", cwd.display())\n            }",
    "pub fn get_rust_program_list(&self) -> Result<Vec<PathBuf>> {\n        // Canonicalize the workspace filepaths to compare with relative paths.\n        let (members, exclude) = self.canonicalize_workspace()?;\n\n        // Get all candidate programs.\n        //\n        // If [workspace.members] exists, then use that.\n        // Otherwise, default to `programs/*`.\n        let program_paths: Vec<PathBuf> = {\n            if members.is_empty() {\n                let path = self.path().parent().unwrap().join(\"programs\");\n                if let Ok(entries) = fs::read_dir(path) {\n                    entries\n                        .filter(|entry| entry.as_ref().map(|e| e.path().is_dir()).unwrap_or(false))\n                        .map(|dir| dir.map(|d| d.path().canonicalize().unwrap()))\n                        .collect::<Vec<Result<PathBuf, std::io::Error>>>()\n                        .into_iter()\n                        .collect::<Result<Vec<PathBuf>, std::io::Error>>()?\n                } else {\n                    Vec::new()\n                }",
    "pub fn get_solidity_program_list(&self) -> Result<Vec<(String, PathBuf)>> {\n        let path = self.path().parent().unwrap().join(\"solidity\");\n        let mut res = Vec::new();\n\n        if let Ok(entries) = fs::read_dir(path) {\n            for entry in entries {\n                let path = entry?.path();\n\n                if !path.is_file() || path.extension() != Some(OsStr::new(\"sol\")) {\n                    continue;\n                }\n\n                let source = fs::read_to_string(&path)?;\n\n                let tree = match solang_parser::parse(&source, 0) {\n                    Ok((tree, _)) => tree,\n                    Err(diag) => {\n                        // The parser can return multiple errors, however this is exceedingly rare.\n                        // Just use the first one, else the formatting will be a mess.\n                        bail!(\n                            \"{}: {}: {}\",\n                            path.display(),\n                            diag[0].level.to_string(),\n                            diag[0].message\n                        );\n                    }\n                };\n\n                tree.0.iter().for_each(|part| {\n                    if let SourceUnitPart::ContractDefinition(contract) = part {\n                        // Must be a contract, not library/interface/abstract contract\n                        if matches!(&contract.ty, ContractTy::Contract(..)) {\n                            if let Some(name) = &contract.name {\n                                res.push((name.name.clone(), path.clone()));\n                            }\n                        }\n                    }\n                });\n            }\n        }\n\n        Ok(res)\n    }",
    "pub fn read_all_programs(&self) -> Result<Vec<Program>> {\n        let mut r = vec![];\n        for path in self.get_rust_program_list()? {\n            let cargo = Manifest::from_path(path.join(\"Cargo.toml\"))?;\n            let lib_name = cargo.lib_name()?;\n\n            let idl_filepath = Path::new(\"target\")\n                .join(\"idl\")\n                .join(&lib_name)\n                .with_extension(\"json\");\n            let idl = fs::read(idl_filepath)\n                .ok()\n                .map(|bytes| serde_json::from_reader(&*bytes))\n                .transpose()?;\n\n            r.push(Program {\n                lib_name,\n                solidity: false,\n                path,\n                idl,\n            });\n        }\n        for (lib_name, path) in self.get_solidity_program_list()? {\n            let idl_filepath = Path::new(\"target\")\n                .join(\"idl\")\n                .join(&lib_name)\n                .with_extension(\"json\");\n            let idl = fs::read(idl_filepath)\n                .ok()\n                .map(|bytes| serde_json::from_reader(&*bytes))\n                .transpose()?;\n\n            r.push(Program {\n                lib_name,\n                solidity: true,\n                path,\n                idl,\n            });\n        }\n        Ok(r)\n    }",
    "pub fn get_programs(&self, name: Option<String>) -> Result<Vec<Program>> {\n        let programs = self.read_all_programs()?;\n        let programs = match name {\n            Some(name) => vec![programs\n                .into_iter()\n                .find(|program| {\n                    name == program.lib_name\n                        || name == program.path.file_name().unwrap().to_str().unwrap()\n                }",
    "pub fn get_program(&self, name: &str) -> Result<Program> {\n        self.get_programs(Some(name.to_owned()))?\n            .into_iter()\n            .next()\n            .ok_or_else(|| anyhow!(\"Expected a program\"))\n    }",
    "pub fn canonicalize_workspace(&self) -> Result<(Vec<PathBuf>, Vec<PathBuf>)> {\n        let members = self.process_paths(&self.workspace.members)?;\n        let exclude = self.process_paths(&self.workspace.exclude)?;\n        Ok((members, exclude))\n    }",
    "pub fn build_subcommand(&self) -> &str {\n        match self {\n            Self::Bpf => \"build-bpf\",\n            Self::Sbf => \"build-sbf\",\n        }\n    }\n}\n\n#[derive(Debug, Clone)]\npub struct BuildConfig {\n    pub verifiable: bool,\n    pub solana_version: Option<String>,\n    pub docker_image: String,\n    pub bootstrap: BootstrapMode,\n}\n\nimpl Config {\n    pub fn add_test_config(\n        &mut self,\n        root: impl AsRef<Path>,\n        test_paths: Vec<PathBuf>,\n    ) -> Result<()> {\n        self.test_config = TestConfig::discover(root, test_paths)?;\n        Ok(())\n    }",
    "pub fn docker(&self) -> String {\n        let version = self\n            .toolchain\n            .anchor_version\n            .as_deref()\n            .unwrap_or(crate::DOCKER_BUILDER_VERSION);\n        format!(\"solanafoundation/anchor:v{version}\")\n    }",
    "pub fn discover(cfg_override: &ConfigOverride) -> Result<Option<WithPath<Config>>> {\n        Config::_discover().map(|opt| {\n            opt.map(|mut cfg| {\n                if let Some(cluster) = cfg_override.cluster.clone() {\n                    cfg.provider.cluster = cluster;\n                }\n                if let Some(wallet) = cfg_override.wallet.clone() {\n                    cfg.provider.wallet = wallet;\n                }\n                cfg\n            })\n        }",
    "pub fn wallet_kp(&self) -> Result<Keypair> {\n        get_keypair(&self.provider.wallet.to_string())\n    }",
    "pub fn get_solana_cfg_url() -> Result<String, io::Error> {\n    let config_file = CONFIG_FILE.as_ref().ok_or_else(|| {\n        io::Error::new(\n            io::ErrorKind::NotFound,\n            \"Default Solana config was not found\",\n        )\n    }",
    "pub fn discover(root: impl AsRef<Path>, test_paths: Vec<PathBuf>) -> Result<Option<Self>> {\n        let walker = WalkDir::new(root).into_iter();\n        let mut test_suite_configs = HashMap::new();\n        for entry in walker.filter_entry(|e| !is_hidden(e)) {\n            let entry = entry?;\n            if entry.file_name() == \"Test.toml\" {\n                let entry_path = entry.path();\n                let test_toml = TestToml::from_path(entry_path)?;\n                if test_paths.is_empty() || test_paths.iter().any(|p| entry_path.starts_with(p)) {\n                    test_suite_configs.insert(entry.path().into(), test_toml);\n                }\n            }\n        }\n\n        Ok(match test_suite_configs.is_empty() {\n            true => None,\n            false => Some(Self { test_suite_configs }),\n        })\n    }",
    "pub fn from_path(p: impl AsRef<Path>) -> Result<Self> {\n        WithPath::new(_TestToml::from_path(&p)?, p.as_ref().into()).try_into()\n    }",
    "pub fn get_default_ledger_path() -> PathBuf {\n    Path::new(\".anchor\").join(\"test-ledger\")\n}",
    "pub fn pubkey(&self) -> Result<Pubkey> {\n        self.keypair().map(|kp| kp.pubkey())\n    }",
    "pub fn keypair(&self) -> Result<Keypair> {\n        let file = self.keypair_file()?;\n        get_keypair(file.path().to_str().unwrap())\n    }",
    "pub fn keypair_file(&self) -> Result<WithPath<File>> {\n        let deploy_dir_path = Path::new(\"target\").join(\"deploy\");\n        fs::create_dir_all(&deploy_dir_path)\n            .with_context(|| format!(\"Error creating directory with path: {deploy_dir_path:?}\"))?;\n        let path = std::env::current_dir()\n            .expect(\"Must have current dir\")\n            .join(deploy_dir_path.join(format!(\"{}-keypair.json\", self.lib_name)));\n        if path.exists() {\n            return Ok(WithPath::new(\n                File::open(&path)\n                    .with_context(|| format!(\"Error opening file with path: {}\", path.display()))?,\n                path,\n            ));\n        }\n        let program_kp = Keypair::new();\n        let mut file = File::create(&path)\n            .with_context(|| format!(\"Error creating file with path: {}\", path.display()))?;\n        file.write_all(format!(\"{:?}\", &program_kp.to_bytes()).as_bytes())?;\n        Ok(WithPath::new(file, path))\n    }",
    "pub fn binary_path(&self, verifiable: bool) -> PathBuf {\n        let path = Path::new(\"target\")\n            .join(if verifiable { \"verifiable\" } else { \"deploy\" })\n            .join(&self.lib_name)\n            .with_extension(\"so\");\n\n        std::env::current_dir()\n            .expect(\"Must have current dir\")\n            .join(path)\n    }",
    "pub fn from(name: String, cfg: &WithPath<Config>) -> Result<Self> {\n        let cluster = &cfg.provider.cluster;\n        if cluster != &Cluster::Mainnet {\n            return Err(anyhow!(\"Publishing requires the mainnet cluster\"));\n        }\n        let program_details = cfg\n            .programs\n            .get(cluster)\n            .ok_or_else(|| anyhow!(\"Program not provided in Anchor.toml\"))?\n            .get(&name)\n            .ok_or_else(|| anyhow!(\"Program not provided in Anchor.toml\"))?;\n        let idl = program_details.idl.clone();\n        let address = program_details.address.to_string();\n        Ok(Self { name, address, idl })\n    }",
    "pub fn entry(opts: Opts) -> Result<()> {\n    let restore_cbs = override_toolchain(&opts.cfg_override)?;\n    let result = process_command(opts);\n    restore_toolchain(restore_cbs)?;\n\n    result\n}\n\n/// Functions to restore toolchain entries\ntype RestoreToolchainCallbacks = Vec<Box<dyn FnOnce() -> Result<()>>>;\n\n/// Override the toolchain from `Anchor.toml`.\n///\n/// Returns the previous versions to restore back to.\nfn override_toolchain(cfg_override: &ConfigOverride) -> Result<RestoreToolchainCallbacks> {\n    let mut restore_cbs: RestoreToolchainCallbacks = vec![];\n\n    let cfg = Config::discover(cfg_override)?;\n    if let Some(cfg) = cfg {\n        fn parse_version(text: &str) -> Option<String> {\n            Some(\n                Regex::new(r\"(\\d+\\.\\d+\\.\\S+)\")\n                    .unwrap()\n                    .captures_iter(text)\n                    .next()?\n                    .get(0)?\n                    .as_str()\n                    .to_string(),\n            )\n        }",
    "pub fn create_files(files: &Files) -> Result<()> {\n    for (path, content) in files {\n        let path = path\n            .display()\n            .to_string()\n            .replace('/', std::path::MAIN_SEPARATOR_STR);\n        let path = Path::new(&path);\n        if path.exists() {\n            continue;\n        }\n\n        match path.extension() {\n            Some(_) => {\n                fs::create_dir_all(path.parent().unwrap())?;\n                fs::write(path, content)?;\n            }\n            None => fs::create_dir_all(path)?,\n        }\n    }\n\n    Ok(())\n}",
    "pub fn override_or_create_files(files: &Files) -> Result<()> {\n    for (path, content) in files {\n        let path = Path::new(path);\n        if path.exists() {\n            let mut f = fs::OpenOptions::new()\n                .write(true)\n                .truncate(true)\n                .open(path)?;\n            f.write_all(content.as_bytes())?;\n            f.flush()?;\n        } else {\n            fs::create_dir_all(path.parent().unwrap())?;\n            fs::write(path, content)?;\n        }\n    }\n\n    Ok(())\n}",
    "pub fn expand(\n    cfg_override: &ConfigOverride,\n    program_name: Option<String>,\n    cargo_args: &[String],\n) -> Result<()> {\n    // Change to the workspace member directory, if needed.\n    if let Some(program_name) = program_name.as_ref() {\n        cd_member(cfg_override, program_name)?;\n    }\n\n    let workspace_cfg = Config::discover(cfg_override)?.expect(\"Not in workspace.\");\n    let cfg_parent = workspace_cfg.path().parent().expect(\"Invalid Anchor.toml\");\n    let cargo = Manifest::discover()?;\n\n    let expansions_path = cfg_parent.join(\".anchor\").join(\"expanded-macros\");\n    fs::create_dir_all(&expansions_path)?;\n\n    match cargo {\n        // No Cargo.toml found, expand entire workspace\n        None => expand_all(&workspace_cfg, expansions_path, cargo_args),\n        // Cargo.toml is at root of workspace, expand entire workspace\n        Some(cargo) if cargo.path().parent() == workspace_cfg.path().parent() => {\n            expand_all(&workspace_cfg, expansions_path, cargo_args)\n        }",
    "pub fn build(\n    cfg_override: &ConfigOverride,\n    no_idl: bool,\n    idl: Option<String>,\n    idl_ts: Option<String>,\n    verifiable: bool,\n    skip_lint: bool,\n    program_name: Option<String>,\n    solana_version: Option<String>,\n    docker_image: Option<String>,\n    bootstrap: BootstrapMode,\n    stdout: Option<File>, // Used for the package registry server.\n    stderr: Option<File>, // Used for the package registry server.\n    env_vars: Vec<String>,\n    cargo_args: Vec<String>,\n    no_docs: bool,\n    arch: ProgramArch,\n) -> Result<()> {\n    // Change to the workspace member directory, if needed.\n    if let Some(program_name) = program_name.as_ref() {\n        cd_member(cfg_override, program_name)?;\n    }\n    let cfg = Config::discover(cfg_override)?.expect(\"Not in workspace.\");\n    let cfg_parent = cfg.path().parent().expect(\"Invalid Anchor.toml\");\n\n    // Require overflow checks\n    let workspace_cargo_toml_path = cfg_parent.join(\"Cargo.toml\");\n    if workspace_cargo_toml_path.exists() {\n        check_overflow(workspace_cargo_toml_path)?;\n    }\n\n    // Check whether there is a mismatch between CLI and crate/package versions\n    check_anchor_version(&cfg).ok();\n    check_deps(&cfg).ok();\n\n    let idl_out = match idl {\n        Some(idl) => Some(PathBuf::from(idl)),\n        None => Some(cfg_parent.join(\"target\").join(\"idl\")),\n    };\n    fs::create_dir_all(idl_out.as_ref().unwrap())?;\n\n    let idl_ts_out = match idl_ts {\n        Some(idl_ts) => Some(PathBuf::from(idl_ts)),\n        None => Some(cfg_parent.join(\"target\").join(\"types\")),\n    };\n    fs::create_dir_all(idl_ts_out.as_ref().unwrap())?;\n\n    if !cfg.workspace.types.is_empty() {\n        fs::create_dir_all(cfg_parent.join(&cfg.workspace.types))?;\n    };\n\n    let cargo = Manifest::discover()?;\n    let build_config = BuildConfig {\n        verifiable,\n        solana_version: solana_version.or_else(|| cfg.toolchain.solana_version.clone()),\n        docker_image: docker_image.unwrap_or_else(|| cfg.docker()),\n        bootstrap,\n    };\n    match cargo {\n        // No Cargo.toml so build the entire workspace.\n        None => build_all(\n            &cfg,\n            cfg.path(),\n            no_idl,\n            idl_out,\n            idl_ts_out,\n            &build_config,\n            stdout,\n            stderr,\n            env_vars,\n            cargo_args,\n            skip_lint,\n            no_docs,\n            arch,\n        )?,\n        // If the Cargo.toml is at the root, build the entire workspace.\n        Some(cargo) if cargo.path().parent() == cfg.path().parent() => build_all(\n            &cfg,\n            cfg.path(),\n            no_idl,\n            idl_out,\n            idl_ts_out,\n            &build_config,\n            stdout,\n            stderr,\n            env_vars,\n            cargo_args,\n            skip_lint,\n            no_docs,\n            arch,\n        )?,\n        // Cargo.toml represents a single package. Build it.\n        Some(cargo) => build_rust_cwd(\n            &cfg,\n            cargo.path().to_path_buf(),\n            no_idl,\n            idl_out,\n            idl_ts_out,\n            &build_config,\n            stdout,\n            stderr,\n            env_vars,\n            cargo_args,\n            skip_lint,\n            no_docs,\n            &arch,\n        )?,\n    }\n\n    set_workspace_dir_or_exit();\n\n    Ok(())\n}",
    "pub fn verify_bin(program_id: Pubkey, bin_path: &Path, cluster: &str) -> Result<BinVerification> {\n    // Use `finalized` state for verify\n    let client = RpcClient::new_with_commitment(cluster, CommitmentConfig::finalized());\n\n    // Get the deployed build artifacts.\n    let (deployed_bin, state) = {\n        let account = client.get_account(&program_id)?;\n        if account.owner == bpf_loader::id() || account.owner == bpf_loader_deprecated::id() {\n            let bin = account.data.to_vec();\n            let state = BinVerificationState::ProgramData {\n                slot: 0, // Need to look through the transaction history.\n                upgrade_authority_address: None,\n            };\n            (bin, state)\n        }",
    "pub fn create_program(name: &str, template: ProgramTemplate, with_mollusk: bool) -> Result<()> {\n    let program_path = Path::new(\"programs\").join(name);\n    let common_files = vec![\n        (\"Cargo.toml\".into(), workspace_manifest().into()),\n        (\n            program_path.join(\"Cargo.toml\"),\n            cargo_toml(name, with_mollusk),\n        ),\n        (program_path.join(\"Xargo.toml\"), xargo_toml().into()),\n    ];\n\n    let template_files = match template {\n        ProgramTemplate::Single => create_program_template_single(name, &program_path),\n        ProgramTemplate::Multiple => create_program_template_multiple(name, &program_path),\n    };\n\n    create_files(&[common_files, template_files].concat())\n}",
    "pub fn initialize(ctx: Context<Initialize>) -> Result<()> {{\n        msg!(\"Greetings from: {{:?}}\", ctx.program_id);\n        Ok(())\n    }",
    "pub fn initialize(ctx: Context<Initialize>) -> Result<()> {{\n        initialize::handler(ctx)\n    }",
    "pub fn handler(ctx: Context<Initialize>) -> Result<()> {\n    msg!(\"Greetings from: {:?}\", ctx.program_id);\n    Ok(())\n}",
    "pub fn get_or_create_program_id(name: &str) -> Pubkey {\n    let keypair_path = Path::new(\"target\")\n        .join(\"deploy\")\n        .join(format!(\"{}-keypair.json\", name.to_snake_case()));\n\n    read_keypair_file(&keypair_path)\n        .unwrap_or_else(|_| {\n            let keypair = Keypair::new();\n            write_keypair_file(&keypair, keypair_path).expect(\"Unable to create program keypair\");\n            keypair\n        })\n        .pubkey()\n}",
    "pub fn credentials(token: &str) -> String {\n    format!(\n        r#\"[registry]\ntoken = \"{token}\"\n\"#\n    )\n}",
    "pub fn deploy_js_script_host(cluster_url: &str, script_path: &str) -> String {\n    format!(\n        r#\"\nconst anchor = require('@coral-xyz/anchor');\n\n// Deploy script defined by the user.\nconst userScript = require(\"{script_path}\");\n\nasync function main() {{\n    const url = \"{cluster_url}\";\n    const preflightCommitment = 'recent';\n    const connection = new anchor.web3.Connection(url, preflightCommitment);\n    const wallet = anchor.Wallet.local();\n\n    const provider = new anchor.AnchorProvider(connection, wallet, {{\n        preflightCommitment,\n        commitment: 'recent',\n    }});\n\n    // Run the user's deploy script.\n    userScript(provider);\n}}\nmain();\n\"#,\n    )\n}",
    "pub fn deploy_ts_script_host(cluster_url: &str, script_path: &str) -> String {\n    format!(\n        r#\"import * as anchor from '@coral-xyz/anchor';\n\n// Deploy script defined by the user.\nconst userScript = require(\"{script_path}\");\n\nasync function main() {{\n    const url = \"{cluster_url}\";\n    const preflightCommitment = 'recent';\n    const connection = new anchor.web3.Connection(url, preflightCommitment);\n    const wallet = anchor.Wallet.local();\n\n    const provider = new anchor.AnchorProvider(connection, wallet, {{\n        preflightCommitment,\n        commitment: 'recent',\n    }});\n\n    // Run the user's deploy script.\n    userScript(provider);\n}}\nmain();\n\"#,\n    )\n}",
    "pub fn deploy_script() -> &'static str {\n    r#\"// Migrations are an early feature. Currently, they're nothing more than this\n// single deploy script that's invoked from the CLI, injecting a provider\n// configured from the workspace's Anchor.toml.\n\nconst anchor = require(\"@coral-xyz/anchor\");\n\nmodule.exports = async function (provider) {\n  // Configure client to use the provider.\n  anchor.setProvider(provider);\n\n  // Add your deploy script here.\n};\n\"#\n}\n\npub fn ts_deploy_script() -> &'static str {\n    r#\"// Migrations are an early feature. Currently, they're nothing more than this\n// single deploy script that's invoked from the CLI, injecting a provider\n// configured from the workspace's Anchor.toml.\n\nimport * as anchor from \"@coral-xyz/anchor\";\n\nmodule.exports = async function (provider: anchor.AnchorProvider) {\n  // Configure client to use the provider.\n  anchor.setProvider(provider);\n\n  // Add your deploy script here.\n};\n\"#\n}\n\npub fn mocha(name: &str) -> String {\n    format!(\n        r#\"const anchor = require(\"@coral-xyz/anchor\");\n\ndescribe(\"{}\", () => {{\n  // Configure the client to use the local cluster.\n  anchor.setProvider(anchor.AnchorProvider.env());\n\n  it(\"Is initialized!\", async () => {{\n    // Add your test here.\n    const program = anchor.workspace.{};\n    const tx = await program.methods.initialize().rpc();\n    console.log(\"Your transaction signature\", tx);\n  }});\n}});\n\"#,\n        name,\n        name.to_lower_camel_case(),\n    )\n}",
    "pub fn jest(name: &str) -> String {\n    format!(\n        r#\"const anchor = require(\"@coral-xyz/anchor\");\n\ndescribe(\"{}\", () => {{\n  // Configure the client to use the local cluster.\n  anchor.setProvider(anchor.AnchorProvider.env());\n\n  it(\"Is initialized!\", async () => {{\n    // Add your test here.\n    const program = anchor.workspace.{};\n    const tx = await program.methods.initialize().rpc();\n    console.log(\"Your transaction signature\", tx);\n  }});\n}});\n\"#,\n        name,\n        name.to_lower_camel_case(),\n    )\n}",
    "pub fn package_json(jest: bool, license: String) -> String {\n    if jest {\n        format!(\n            r#\"{{\n  \"license\": \"{license}\",\n  \"scripts\": {{\n    \"lint:fix\": \"prettier */*.js \\\"*/**/*{{.js,.ts}}\\\" -w\",\n    \"lint\": \"prettier */*.js \\\"*/**/*{{.js,.ts}}\\\" --check\"\n  }},\n  \"dependencies\": {{\n    \"@coral-xyz/anchor\": \"^{VERSION}\"\n  }},\n  \"devDependencies\": {{\n    \"jest\": \"^29.0.3\",\n    \"prettier\": \"^2.6.2\"\n  }}\n}}\n    \"#\n        )\n    }",
    "pub fn ts_package_json(jest: bool, license: String) -> String {\n    if jest {\n        format!(\n            r#\"{{\n  \"license\": \"{license}\",\n  \"scripts\": {{\n    \"lint:fix\": \"prettier */*.js \\\"*/**/*{{.js,.ts}}\\\" -w\",\n    \"lint\": \"prettier */*.js \\\"*/**/*{{.js,.ts}}\\\" --check\"\n  }},\n  \"dependencies\": {{\n    \"@coral-xyz/anchor\": \"^{VERSION}\"\n  }},\n  \"devDependencies\": {{\n    \"@types/bn.js\": \"^5.1.0\",\n    \"@types/jest\": \"^29.0.3\",\n    \"jest\": \"^29.0.3\",\n    \"prettier\": \"^2.6.2\",\n    \"ts-jest\": \"^29.0.2\",\n    \"typescript\": \"^5.7.3\"\n  }}\n}}\n\"#\n        )\n    }",
    "pub fn ts_mocha(name: &str) -> String {\n    format!(\n        r#\"import * as anchor from \"@coral-xyz/anchor\";\nimport {{ Program }} from \"@coral-xyz/anchor\";\nimport {{ {} }} from \"../target/types/{}\";\n\ndescribe(\"{}\", () => {{\n  // Configure the client to use the local cluster.\n  anchor.setProvider(anchor.AnchorProvider.env());\n\n  const program = anchor.workspace.{} as Program<{}>;\n\n  it(\"Is initialized!\", async () => {{\n    // Add your test here.\n    const tx = await program.methods.initialize().rpc();\n    console.log(\"Your transaction signature\", tx);\n  }});\n}});\n\"#,\n        name.to_pascal_case(),\n        name.to_snake_case(),\n        name,\n        name.to_lower_camel_case(),\n        name.to_pascal_case(),\n    )\n}",
    "pub fn ts_jest(name: &str) -> String {\n    format!(\n        r#\"import * as anchor from \"@coral-xyz/anchor\";\nimport {{ Program }} from \"@coral-xyz/anchor\";\nimport {{ {} }} from \"../target/types/{}\";\n\ndescribe(\"{}\", () => {{\n  // Configure the client to use the local cluster.\n  anchor.setProvider(anchor.AnchorProvider.env());\n\n  const program = anchor.workspace.{} as Program<{}>;\n\n  it(\"Is initialized!\", async () => {{\n    // Add your test here.\n    const tx = await program.methods.initialize().rpc();\n    console.log(\"Your transaction signature\", tx);\n  }});\n}});\n\"#,\n        name.to_pascal_case(),\n        name.to_snake_case(),\n        name,\n        name.to_lower_camel_case(),\n        name.to_pascal_case(),\n    )\n}",
    "pub fn ts_config(jest: bool) -> &'static str {\n    if jest {\n        r#\"{\n  \"compilerOptions\": {\n    \"types\": [\"jest\"],\n    \"typeRoots\": [\"./node_modules/@types\"],\n    \"lib\": [\"es2015\"],\n    \"module\": \"commonjs\",\n    \"target\": \"es6\",\n    \"esModuleInterop\": true\n  }\n}\n\"#\n    } else {\n        r#\"{\n  \"compilerOptions\": {\n    \"types\": [\"mocha\", \"chai\"],\n    \"typeRoots\": [\"./node_modules/@types\"],\n    \"lib\": [\"es2015\"],\n    \"module\": \"commonjs\",\n    \"target\": \"es6\",\n    \"esModuleInterop\": true\n  }\n}\n\"#\n    }\n}\n\npub fn git_ignore() -> &'static str {\n    r#\".anchor\n.DS_Store\ntarget\n**/*.rs.bk\nnode_modules\ntest-ledger\n.yarn\n\"#\n}\n\npub fn prettier_ignore() -> &'static str {\n    r#\".anchor\n.DS_Store\ntarget\nnode_modules\ndist\nbuild\ntest-ledger\n\"#\n}\n\npub fn node_shell(\n    cluster_url: &str,\n    wallet_path: &str,\n    programs: Vec<ProgramWorkspace>,\n) -> Result<String> {\n    let mut eval_string = format!(\n        r#\"\nconst anchor = require('@coral-xyz/anchor');\nconst web3 = anchor.web3;\nconst PublicKey = anchor.web3.PublicKey;\nconst Keypair = anchor.web3.Keypair;\n\nconst __wallet = new anchor.Wallet(\n  Keypair.fromSecretKey(\n    Buffer.from(\n      JSON.parse(\n        require('fs').readFileSync(\n          \"{wallet_path}\",\n          {{\n            encoding: \"utf-8\",\n          }},\n        ),\n      ),\n    ),\n  ),\n);\nconst __connection = new web3.Connection(\"{cluster_url}\", \"processed\");\nconst provider = new anchor.AnchorProvider(__connection, __wallet, {{\n  commitment: \"processed\",\n  preflightcommitment: \"processed\",\n}});\nanchor.setProvider(provider);\n\"#,\n    );\n\n    for program in programs {\n        write!(\n            &mut eval_string,\n            r#\"\nanchor.workspace.{} = new anchor.Program({}, provider);\n\"#,\n            program.name.to_lower_camel_case(),\n            serde_json::to_string(&program.idl)?,\n        )?;\n    }\n\n    Ok(eval_string)\n}",
    "pub fn get_test_script(&self, js: bool, pkg_manager: &PackageManager) -> String {\n        let pkg_manager_exec_cmd = match pkg_manager {\n            PackageManager::Yarn => \"yarn run\",\n            PackageManager::NPM => \"npx\",\n            PackageManager::PNPM => \"pnpm exec\",\n        };\n\n        match &self {\n            Self::Mocha => {\n                if js {\n                    format!(\"{pkg_manager_exec_cmd} mocha -t 1000000 tests/\")\n                }",
    "pub fn create_test_files(\n        &self,\n        project_name: &str,\n        js: bool,\n        solidity: bool,\n        program_id: &str,\n    ) -> Result<()> {\n        match self {\n            Self::Mocha => {\n                // Build the test suite.\n                fs::create_dir_all(\"tests\")?;\n\n                if js {\n                    let mut test = File::create(format!(\"tests/{}.js\", &project_name))?;\n                    if solidity {\n                        test.write_all(solidity_template::mocha(project_name).as_bytes())?;\n                    } else {\n                        test.write_all(mocha(project_name).as_bytes())?;\n                    }\n                } else {\n                    let mut mocha = File::create(format!(\"tests/{}.ts\", &project_name))?;\n                    if solidity {\n                        mocha.write_all(solidity_template::ts_mocha(project_name).as_bytes())?;\n                    } else {\n                        mocha.write_all(ts_mocha(project_name).as_bytes())?;\n                    }\n                }\n            }\n            Self::Jest => {\n                // Build the test suite.\n                fs::create_dir_all(\"tests\")?;\n\n                let mut test = File::create(format!(\"tests/{}.test.js\", &project_name))?;\n                if solidity {\n                    test.write_all(solidity_template::jest(project_name).as_bytes())?;\n                } else {\n                    test.write_all(jest(project_name).as_bytes())?;\n                }\n            }\n            Self::Rust => {\n                // Do not initilize git repo\n                let exit = std::process::Command::new(\"cargo\")\n                    .arg(\"new\")\n                    .arg(\"--vcs\")\n                    .arg(\"none\")\n                    .arg(\"--lib\")\n                    .arg(\"tests\")\n                    .stderr(Stdio::inherit())\n                    .output()\n                    .map_err(|e| anyhow::format_err!(\"{}\", e.to_string()))?;\n                if !exit.status.success() {\n                    eprintln!(\"'cargo new --lib tests' failed\");\n                    std::process::exit(exit.status.code().unwrap_or(1));\n                }\n\n                let mut files = Vec::new();\n                let tests_path = Path::new(\"tests\");\n                files.extend(vec![(\n                    tests_path.join(\"Cargo.toml\"),\n                    tests_cargo_toml(project_name),\n                )]);\n                files.extend(create_program_template_rust_test(\n                    project_name,\n                    tests_path,\n                    program_id,\n                ));\n                override_or_create_files(&files)?;\n            }\n            Self::Mollusk => {\n                // Build the test suite.\n                let tests_path_str = format!(\"programs/{}/tests\", &project_name);\n                let tests_path = Path::new(&tests_path_str);\n                fs::create_dir_all(tests_path)?;\n\n                let mut files = Vec::new();\n                files.extend(create_program_template_mollusk_test(\n                    project_name,\n                    tests_path,\n                ));\n                override_or_create_files(&files)?;\n            }\n        }\n\n        Ok(())\n    }",
    "pub fn tests_cargo_toml(name: &str) -> String {\n    format!(\n        r#\"[package]\nname = \"tests\"\nversion = \"0.1.0\"\ndescription = \"Created with Anchor\"\nedition = \"2021\"\n\n[dependencies]\nanchor-client = \"{0}\"\n{1} = {{ version = \"0.1.0\", path = \"../programs/{1}\" }}\n\"#,\n        VERSION, name,\n    )\n}",
    "pub fn create_program(name: &str) -> Result<()> {\n    let files = vec![(\n        Path::new(\"solidity\").join(name).with_extension(\"sol\"),\n        solidity(name),\n    )];\n    create_files(&files)\n}",
    "pub fn mocha(name: &str) -> String {\n    format!(\n        r#\"const anchor = require(\"@coral-xyz/anchor\");\n\ndescribe(\"{}\", () => {{\n  // Configure the client to use the local cluster.\n  anchor.setProvider(anchor.AnchorProvider.env());\n\n  it(\"Is initialized!\", async () => {{\n    // Add your test here.\n    const program = anchor.workspace.{};\n    const dataAccount = anchor.web3.Keypair.generate();\n\n    const tx = await program.methods\n       .new()\n       .accounts({{ dataAccount: dataAccount.publicKey }})\n       .signers([dataAccount])\n       .rpc();\n\n    console.log(\"Your transaction signature\", tx);\n\n    const val1 = await program.methods\n      .get()\n      .accounts({{ dataAccount: dataAccount.publicKey }})\n      .view();\n\n    console.log(\"state\", val1);\n\n    await program.methods\n      .flip()\n      .accounts({{ dataAccount: dataAccount.publicKey }})\n      .rpc();\n\n    const val2 = await program.methods\n      .get()\n      .accounts({{ dataAccount: dataAccount.publicKey }})\n      .view();\n\n    console.log(\"state\", val2);\n  }});\n}});\n\"#,\n        name,\n        name.to_upper_camel_case(),\n    )\n}",
    "pub fn jest(name: &str) -> String {\n    format!(\n        r#\"const anchor = require(\"@coral-xyz/anchor\");\n\ndescribe(\"{}\", () => {{\n  // Configure the client to use the local cluster.\n  anchor.setProvider(anchor.AnchorProvider.env());\n\n  it(\"Is initialized!\", async () => {{\n    // Add your test here.\n    const program = anchor.workspace.{};\n    const tx = await program.methods.initialize().rpc();\n    console.log(\"Your transaction signature\", tx);\n  }});\n}});\n\"#,\n        name,\n        name.to_upper_camel_case(),\n    )\n}",
    "pub fn ts_mocha(name: &str) -> String {\n    format!(\n        r#\"import * as anchor from \"@coral-xyz/anchor\";\nimport {{ Program }} from \"@coral-xyz/anchor\";\nimport {{ {} }} from \"../target/types/{}\";\n\ndescribe(\"{}\", () => {{\n  // Configure the client to use the local cluster.\n  const provider = anchor.AnchorProvider.env();\n  anchor.setProvider(provider);\n\n  const dataAccount = anchor.web3.Keypair.generate();\n\n  const program = anchor.workspace.{} as Program<{}>;\n\n  it(\"Is initialized!\", async () => {{\n    // Add your test here.\n    const tx = await program.methods\n      .new()\n      .accounts({{ dataAccount: dataAccount.publicKey }})\n      .signers([dataAccount])\n      .rpc();\n    console.log(\"Your transaction signature\", tx);\n\n    const val1 = await program.methods\n      .get()\n      .accounts({{ dataAccount: dataAccount.publicKey }})\n      .view();\n\n    console.log(\"state\", val1);\n\n    await program.methods\n      .flip()\n      .accounts({{ dataAccount: dataAccount.publicKey }})\n      .rpc();\n\n    const val2 = await program.methods\n      .get()\n      .accounts({{ dataAccount: dataAccount.publicKey }})\n      .view();\n\n    console.log(\"state\", val2);  }});\n}});\n\"#,\n        name.to_upper_camel_case(),\n        name.to_snake_case(),\n        name,\n        name.to_upper_camel_case(),\n        name.to_upper_camel_case(),\n    )\n}",
    "pub fn main() -> Result<()> {\n    let opts = Opts::parse();\n\n    // Wallet and cluster params.\n    let payer = read_keypair_file(&*shellexpand::tilde(\"~/.config/solana/id.json\"))\n        .expect(\"Example requires a keypair file\");\n    let url = Cluster::Custom(\n        \"http://localhost:8899\".to_string(),\n        \"ws://127.0.0.1:8900\".to_string(),\n    );\n\n    if !opts.multithreaded {\n        // Client.\n        let payer = Rc::new(payer);\n        let client =\n            Client::new_with_options(url.clone(), payer.clone(), CommitmentConfig::processed());\n\n        // Run tests on single thread with a single client using an Rc\n        println!(\"\\nStarting single thread test...\");\n        composite(&client, opts.composite_pid)?;\n        basic_2(&client, opts.basic_2_pid)?;\n        basic_4(&client, opts.basic_4_pid)?;\n\n        // Can also use references, since they deref to a signer\n        let payer: &Keypair = &payer;\n        let client = Client::new_with_options(url, payer, CommitmentConfig::processed());\n        events(&client, opts.events_pid)?;\n        optional(&client, opts.optional_pid)?;\n    } else {\n        // Client.\n        let payer = Arc::new(payer);\n        let client = Client::new_with_options(url, payer, CommitmentConfig::processed());\n        let client = Arc::new(client);\n\n        // Run tests multithreaded while sharing a client\n        println!(\"\\nStarting multithread test...\");\n        let client = Arc::new(client);\n        let tests: Vec<(TestFn<Arc<Keypair>>, Pubkey)> = vec![\n            (&composite, opts.composite_pid),\n            (&basic_2, opts.basic_2_pid),\n            (&basic_4, opts.basic_4_pid),\n            (&events, opts.events_pid),\n            (&optional, opts.optional_pid),\n        ];\n        let mut handles = vec![];\n        for (test, arg) in tests {\n            let local_client = Arc::clone(&client);\n            handles.push(std::thread::spawn(move || test(&local_client, arg)));\n        }\n        for handle in handles {\n            assert!(handle.join().unwrap().is_ok());\n        }\n    }\n\n    // Success.\n    Ok(())\n}",
    "pub fn unsubscribe(self) {\n        self.runtime_handle.block_on(self.unsubscribe_internal())\n    }",
    "pub fn new(\n        program_id: Pubkey,\n        cfg: Config<C>,\n        #[cfg(feature = \"mock\")] rpc_client: AsyncRpcClient,\n    ) -> Result<Self, ClientError> {\n        let rt: tokio::runtime::Runtime = Builder::new_multi_thread().enable_all().build()?;\n\n        #[cfg(not(feature = \"mock\"))]\n        let rpc_client = {\n            let comm_config = cfg.options.unwrap_or_default();\n            let cluster_url = cfg.cluster.url().to_string();\n            AsyncRpcClient::new_with_commitment(cluster_url.clone(), comm_config)\n        }",
    "pub fn rpc(&self) -> RpcClient {\n        RpcClient::new_with_commitment(\n            self.cfg.cluster.url().to_string(),\n            self.cfg.options.unwrap_or_default(),\n        )\n    }",
    "pub fn request(&self) -> RequestBuilder<'_, C, Box<dyn Signer + '_>> {\n        RequestBuilder::from(\n            self.program_id,\n            self.cfg.cluster.url(),\n            self.cfg.payer.clone(),\n            self.cfg.options,\n            #[cfg(not(feature = \"async\"))]\n            self.rt.handle(),\n            &self.internal_rpc_client,\n        )\n    }",
    "pub fn from(\n        program_id: Pubkey,\n        cluster: &str,\n        payer: C,\n        options: Option<CommitmentConfig>,\n        handle: &'a Handle,\n        rpc_client: &'a AsyncRpcClient,\n    ) -> Self {\n        Self {\n            program_id,\n            payer,\n            cluster: cluster.to_string(),\n            accounts: Vec::new(),\n            options: options.unwrap_or_default(),\n            instructions: Vec::new(),\n            instruction_data: None,\n            signers: Vec::new(),\n            handle,\n            internal_rpc_client: rpc_client,\n            _phantom: PhantomData,\n        }\n    }\n\n    #[must_use]\n    pub fn signer<T: Signer + 'a>(mut self, signer: T) -> Self {\n        self.signers.push(Box::new(signer));\n        self\n    }\n\n    pub fn signed_transaction(&self) -> Result<Transaction, ClientError> {\n        self.handle.block_on(self.signed_transaction_internal())\n    }",
    "pub fn send(&self) -> Result<Signature, ClientError> {\n        self.handle.block_on(self.send_internal())\n    }",
    "pub fn send_with_spinner_and_config(\n        &self,\n        config: RpcSendTransactionConfig,\n    ) -> Result<Signature, ClientError> {\n        self.handle\n            .block_on(self.send_with_spinner_and_config_internal(config))\n    }",
    "pub fn new(cluster: Cluster, payer: C) -> Self {\n        Self {\n            cfg: Config {\n                cluster,\n                payer,\n                options: None,\n            },\n        }\n    }\n\n    pub fn new_with_options(cluster: Cluster, payer: C, options: CommitmentConfig) -> Self {\n        Self {\n            cfg: Config {\n                cluster,\n                payer,\n                options: Some(options),\n            },\n        }\n    }\n\n    pub fn program(\n        &self,\n        program_id: Pubkey,\n        #[cfg(feature = \"mock\")] rpc_client: AsyncRpcClient,\n    ) -> Result<Program<C>, ClientError> {\n        let cfg = Config {\n            cluster: self.cfg.cluster.clone(),\n            options: self.cfg.options,\n            payer: self.cfg.payer.clone(),\n        };\n\n        Program::new(\n            program_id,\n            cfg,\n            #[cfg(feature = \"mock\")]\n            rpc_client,\n        )\n    }",
    "pub fn payer(&self) -> Pubkey {\n        self.cfg.payer.pubkey()\n    }",
    "pub fn id(&self) -> Pubkey {\n        self.program_id\n    }\n\n    #[cfg(feature = \"mock\")]\n    pub fn internal_rpc(&self) -> &AsyncRpcClient {\n        &self.internal_rpc_client\n    }\n\n    async fn account_internal<T: AccountDeserialize>(\n        &self,\n        address: Pubkey,\n    ) -> Result<T, ClientError> {\n        let account = self\n            .internal_rpc_client\n            .get_account_with_commitment(&address, CommitmentConfig::processed())\n            .await?\n            .value\n            .ok_or(ClientError::AccountNotFound)?;\n        let mut data: &[u8] = &account.data;\n        T::try_deserialize(&mut data).map_err(Into::into)\n    }",
    "pub fn handle_system_log(this_program_str: &str, log: &str) -> (Option<String>, bool) {\n    if log.starts_with(&format!(\"Program {this_program_str} log:\")) {\n        (Some(this_program_str.to_string()), false)\n\n        // `Invoke [1]` instructions are pushed to the stack in `parse_logs_response`,\n        // so this ensures we only push CPIs to the stack at this stage\n    } else if log.contains(\"invoke\") && !log.ends_with(\"[1]\") {\n        (Some(\"cpi\".to_string()), false) // Any string will do.\n    } else {\n        let re = Regex::new(r\"^Program (.*) success*$\").unwrap();\n        if re.is_match(log) {\n            (None, true)\n        }",
    "pub fn new(logs: &mut &[String]) -> Result<Self, ClientError> {\n        let l = &logs[0];\n        *logs = &logs[1..];\n\n        let re = Regex::new(r\"^Program (.*) invoke.*$\").unwrap();\n        let c = re\n            .captures(l)\n            .ok_or_else(|| ClientError::LogParseError(l.to_string()))?;\n        let program = c\n            .get(1)\n            .ok_or_else(|| ClientError::LogParseError(l.to_string()))?\n            .as_str()\n            .to_string();\n        Ok(Self {\n            stack: vec![program],\n        })\n    }",
    "pub fn program(&self) -> String {\n        assert!(!self.stack.is_empty());\n        self.stack[self.stack.len() - 1].clone()\n    }",
    "pub fn push(&mut self, new_program: String) {\n        self.stack.push(new_program);\n    }\n\n    pub fn pop(&mut self) {\n        assert!(!self.stack.is_empty());\n        self.stack.pop().unwrap();\n    }\n}\n\n#[derive(Debug)]\npub struct EventContext {\n    pub signature: Signature,\n    pub slot: u64,\n}\n\n#[derive(Debug, Error)]\npub enum ClientError {\n    #[error(\"Account not found\")]\n    AccountNotFound,\n    #[error(\"{0}\")]\n    AnchorError(#[from] anchor_lang::error::Error),\n    #[error(\"{0}\")]\n    ProgramError(#[from] ProgramError),\n    #[error(\"{0}\")]\n    SolanaClientError(#[from] SolanaClientError),\n    #[error(\"{0}\")]\n    SolanaClientPubsubError(#[from] PubsubClientError),\n    #[error(\"Unable to parse log: {0}\")]\n    LogParseError(String),\n    #[error(transparent)]\n    IOError(#[from] std::io::Error),\n}\n\npub trait AsSigner {\n    fn as_signer(&self) -> &dyn Signer;\n}\n\nimpl AsSigner for Box<dyn Signer + '_> {\n    fn as_signer(&self) -> &dyn Signer {\n        self.as_ref()\n    }",
    "pub fn payer(mut self, payer: C) -> Self {\n        self.payer = payer;\n        self\n    }\n\n    #[must_use]\n    pub fn cluster(mut self, url: &str) -> Self {\n        self.cluster = url.to_string();\n        self\n    }\n\n    #[must_use]\n    pub fn instruction(mut self, ix: Instruction) -> Self {\n        self.instructions.push(ix);\n        self\n    }\n\n    #[must_use]\n    pub fn program(mut self, program_id: Pubkey) -> Self {\n        self.program_id = program_id;\n        self\n    }\n\n    /// Set the accounts to pass to the instruction.\n    ///\n    /// `accounts` argument can be:\n    ///\n    /// - Any type that implements [`ToAccountMetas`] trait\n    /// - A vector of [`AccountMeta`]s (for remaining accounts)\n    ///\n    /// Note that the given accounts are appended to the previous list of accounts instead of\n    /// overriding the existing ones (if any).\n    ///\n    /// # Example\n    ///\n    /// ```ignore\n    /// program\n    ///     .request()\n    ///     // Regular accounts\n    ///     .accounts(accounts::Initialize {\n    ///         my_account: my_account_kp.pubkey(),\n    ///         payer: program.payer(),\n    ///         system_program: system_program::ID,\n    ///     })\n    ///     // Remaining accounts\n    ///     .accounts(vec![AccountMeta {\n    ///         pubkey: remaining,\n    ///         is_signer: true,\n    ///         is_writable: true,\n    ///     }])\n    ///     .args(instruction::Initialize { field: 42 })\n    ///     .send()?;\n    /// ```\n    #[must_use]\n    pub fn accounts(mut self, accounts: impl ToAccountMetas) -> Self {\n        let mut metas = accounts.to_account_metas(None);\n        self.accounts.append(&mut metas);\n        self\n    }\n\n    #[must_use]\n    pub fn options(mut self, options: CommitmentConfig) -> Self {\n        self.options = options;\n        self\n    }\n\n    #[must_use]\n    pub fn args(mut self, args: impl InstructionData) -> Self {\n        self.instruction_data = Some(args.data());\n        self\n    }\n\n    pub fn instructions(&self) -> Result<Vec<Instruction>, ClientError> {\n        let mut instructions = self.instructions.clone();\n        if let Some(ix_data) = &self.instruction_data {\n            instructions.push(Instruction {\n                program_id: self.program_id,\n                data: ix_data.clone(),\n                accounts: self.accounts.clone(),\n            });\n        }\n\n        Ok(instructions)\n    }",
    "pub fn transaction(&self) -> Result<Transaction, ClientError> {\n        let instructions = &self.instructions;\n        let tx = Transaction::new_with_payer(instructions, Some(&self.payer.pubkey()));\n        Ok(tx)\n    }",
    "pub fn new(\n        program_id: Pubkey,\n        cfg: Config<C>,\n        #[cfg(feature = \"mock\")] rpc_client: AsyncRpcClient,\n    ) -> Result<Self, ClientError> {\n        #[cfg(not(feature = \"mock\"))]\n        let rpc_client = {\n            let comm_config = cfg.options.unwrap_or_default();\n            let cluster_url = cfg.cluster.url().to_string();\n            AsyncRpcClient::new_with_commitment(cluster_url.clone(), comm_config)\n        }",
    "pub fn rpc(&self) -> AsyncRpcClient {\n        AsyncRpcClient::new_with_commitment(\n            self.cfg.cluster.url().to_string(),\n            self.cfg.options.unwrap_or_default(),\n        )\n    }",
    "pub fn request(&self) -> RequestBuilder<'_, C, Arc<dyn ThreadSafeSigner>> {\n        RequestBuilder::from(\n            self.program_id,\n            self.cfg.cluster.url(),\n            self.cfg.payer.clone(),\n            self.cfg.options,\n            &self.internal_rpc_client,\n        )\n    }",
    "pub fn initialize(_ctx: Context<Initialize>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn initialize(ctx: Context<Initialize>, data: u64) -> Result<()> {\n        let my_account = &mut ctx.accounts.my_account;\n        my_account.data = data;\n        Ok(())\n    }",
    "pub fn update(ctx: Context<Update>, data: u64) -> Result<()> {\n        let my_account = &mut ctx.accounts.my_account;\n        my_account.data = data;\n        Ok(())\n    }",
    "pub fn create(ctx: Context<Create>, authority: Pubkey) -> Result<()> {\n        let counter = &mut ctx.accounts.counter;\n        counter.authority = authority;\n        counter.count = 0;\n        Ok(())\n    }",
    "pub fn increment(ctx: Context<Increment>) -> Result<()> {\n        let counter = &mut ctx.accounts.counter;\n        counter.count += 1;\n        Ok(())\n    }",
    "pub fn initialize(_ctx: Context<Initialize>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn set_data(ctx: Context<SetData>, data: u64) -> Result<()> {\n        let puppet = &mut ctx.accounts.puppet;\n        puppet.data = data;\n        Ok(())\n    }",
    "pub fn pull_strings(ctx: Context<PullStrings>, data: u64) -> anchor_lang::Result<()> {\n        let cpi_program = ctx.accounts.puppet_program.to_account_info();\n        let cpi_accounts = SetData {\n            puppet: ctx.accounts.puppet.to_account_info(),\n        };\n        let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);\n        puppet::cpi::set_data(cpi_ctx, data)\n    }",
    "pub fn initialize(ctx: Context<Initialize>) -> Result<()> {\n        let counter = ctx.accounts.counter.deref_mut();\n        let bump = ctx.bumps.counter;\n\n        *counter = Counter {\n            authority: *ctx.accounts.authority.key,\n            count: 0,\n            bump,\n        };\n\n        Ok(())\n    }",
    "pub fn increment(ctx: Context<Increment>) -> Result<()> {\n        require_keys_eq!(\n            ctx.accounts.authority.key(),\n            ctx.accounts.counter.authority,\n            ErrorCode::Unauthorized\n        );\n\n        ctx.accounts.counter.count += 1;\n        Ok(())\n    }",
    "pub fn create(ctx: Context<Create>) -> Result<()> {\n        let action_state = &mut ctx.accounts.action_state;\n        // * - means dereferencing\n        action_state.user = *ctx.accounts.user.key;\n        // Lets initialize the state\n        action_state.action = 0;\n\n        Ok(())\n    }",
    "pub fn walk(ctx: Context<Walk>) -> Result<()> {\n        let action_state = &mut ctx.accounts.action_state;\n        // Lets change the robot action state to \"walk\"\n        action_state.action = 1;\n\n        Ok(())\n    }",
    "pub fn run(ctx: Context<Run>) -> Result<()> {\n        let action_state = &mut ctx.accounts.action_state;\n        // Lets change the robot action state to \"run\"\n        action_state.action = 2;\n\n        Ok(())\n    }",
    "pub fn jump(ctx: Context<Jump>) -> Result<()> {\n        let action_state = &mut ctx.accounts.action_state;\n        // Lets change the robot action state to \"jump\"\n        action_state.action = 3;\n\n        Ok(())\n    }",
    "pub fn reset(ctx: Context<Reset>) -> Result<()> {\n        let action_state = &mut ctx.accounts.action_state;\n        // Lets reset the robot action states\n        action_state.action = 0;\n\n        Ok(())\n    }",
    "pub fn new() -> Self {\n        Self::default()\n    }",
    "pub fn program_path(mut self, program_path: PathBuf) -> Self {\n        self.program_path.replace(program_path);\n        self\n    }\n\n    /// Set whether to include account resolution information in the IDL (default: true).\n    pub fn resolution(mut self, resolution: bool) -> Self {\n        self.resolution.replace(resolution);\n        self\n    }\n    /// Set whether to skip linting (default: false).\n    pub fn skip_lint(mut self, skip_lint: bool) -> Self {\n        self.skip_lint.replace(skip_lint);\n        self\n    }\n\n    /// Set whether to skip generating docs in the IDL (default: false).\n    pub fn no_docs(mut self, no_docs: bool) -> Self {\n        self.no_docs.replace(no_docs);\n        self\n    }\n\n    /// Set the `cargo` args that will get passed to the underlying `cargo` command when building\n    /// IDLs (default: empty).\n    pub fn cargo_args(mut self, cargo_args: Vec<String>) -> Self {\n        self.cargo_args.replace(cargo_args);\n        self\n    }\n\n    /// Build the IDL with the current configuration.\n    pub fn build(self) -> Result<Idl> {\n        let idl = build(\n            &self\n                .program_path\n                .unwrap_or_else(|| std::env::current_dir().expect(\"Failed to get program path\")),\n            self.resolution.unwrap_or(true),\n            self.skip_lint.unwrap_or_default(),\n            self.no_docs.unwrap_or_default(),\n            &self.cargo_args.unwrap_or_default(),\n        )\n        .map(convert_module_paths)\n        .map(sort)?;\n        verify(&idl)?;\n\n        Ok(idl)\n    }",
    "pub fn build_idl(\n    program_path: impl AsRef<Path>,\n    resolution: bool,\n    skip_lint: bool,\n    no_docs: bool,\n) -> Result<Idl> {\n    IdlBuilder::new()\n        .program_path(program_path.as_ref().into())\n        .resolution(resolution)\n        .skip_lint(skip_lint)\n        .no_docs(no_docs)\n        .build()\n}",
    "pub fn convert_idl(idl: &[u8]) -> Result<Idl> {\n    let value = serde_json::from_slice::<serde_json::Value>(idl)?;\n    let spec = value\n        .get(\"metadata\")\n        .and_then(|m| m.get(\"spec\"))\n        .and_then(|spec| spec.as_str());\n    match spec {\n        // New standard\n        Some(spec) => match spec {\n            \"0.1.0\" => serde_json::from_value(value).map_err(Into::into),\n            _ => Err(anyhow!(\"IDL spec not supported: `{spec}`\")),\n        },\n        // Legacy\n        None => serde_json::from_value::<legacy::Idl>(value).map(TryInto::try_into)?,\n    }\n}\n\n/// Legacy IDL spec (pre Anchor v0.30)\nmod legacy {\n    use crate::types as t;\n    use anyhow::{anyhow, Result};\n    use heck::SnakeCase;\n    use serde::{Deserialize, Serialize};\n\n    #[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\n    pub struct Idl {\n        pub version: String,\n        pub name: String,\n        #[serde(skip_serializing_if = \"Option::is_none\", default)]\n        pub docs: Option<Vec<String>>,\n        #[serde(skip_serializing_if = \"Vec::is_empty\", default)]\n        pub constants: Vec<IdlConst>,\n        pub instructions: Vec<IdlInstruction>,\n        #[serde(skip_serializing_if = \"Vec::is_empty\", default)]\n        pub accounts: Vec<IdlTypeDefinition>,\n        #[serde(skip_serializing_if = \"Vec::is_empty\", default)]\n        pub types: Vec<IdlTypeDefinition>,\n        #[serde(skip_serializing_if = \"Option::is_none\", default)]\n        pub events: Option<Vec<IdlEvent>>,\n        #[serde(skip_serializing_if = \"Option::is_none\", default)]\n        pub errors: Option<Vec<IdlErrorCode>>,\n        #[serde(skip_serializing_if = \"Option::is_none\", default)]\n        pub metadata: Option<serde_json::Value>,\n    }\n\n    #[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\n    pub struct IdlConst {\n        pub name: String,\n        #[serde(rename = \"type\")]\n        pub ty: IdlType,\n        pub value: String,\n    }\n\n    #[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\n    pub struct IdlState {\n        #[serde(rename = \"struct\")]\n        pub strct: IdlTypeDefinition,\n        pub methods: Vec<IdlInstruction>,\n    }\n\n    #[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\n    pub struct IdlInstruction {\n        pub name: String,\n        #[serde(skip_serializing_if = \"Option::is_none\")]\n        pub docs: Option<Vec<String>>,\n        pub accounts: Vec<IdlAccountItem>,\n        pub args: Vec<IdlField>,\n        #[serde(skip_serializing_if = \"Option::is_none\")]\n        pub returns: Option<IdlType>,\n    }\n\n    #[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\n    #[serde(rename_all = \"camelCase\")]\n    pub struct IdlAccounts {\n        pub name: String,\n        pub accounts: Vec<IdlAccountItem>,\n    }\n\n    #[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\n    #[serde(untagged)]\n    pub enum IdlAccountItem {\n        IdlAccount(IdlAccount),\n        IdlAccounts(IdlAccounts),\n    }\n\n    #[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\n    #[serde(rename_all = \"camelCase\")]\n    pub struct IdlAccount {\n        pub name: String,\n        pub is_mut: bool,\n        pub is_signer: bool,\n        #[serde(skip_serializing_if = \"Option::is_none\")]\n        pub is_optional: Option<bool>,\n        #[serde(skip_serializing_if = \"Option::is_none\")]\n        pub docs: Option<Vec<String>>,\n        #[serde(skip_serializing_if = \"Option::is_none\", default)]\n        pub pda: Option<IdlPda>,\n        #[serde(skip_serializing_if = \"Vec::is_empty\", default)]\n        pub relations: Vec<String>,\n    }\n\n    #[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\n    #[serde(rename_all = \"camelCase\")]\n    pub struct IdlPda {\n        pub seeds: Vec<IdlSeed>,\n        #[serde(skip_serializing_if = \"Option::is_none\", default)]\n        pub program_id: Option<IdlSeed>,\n    }\n\n    #[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\n    #[serde(rename_all = \"camelCase\", tag = \"kind\")]\n    pub enum IdlSeed {\n        Const(IdlSeedConst),\n        Arg(IdlSeedArg),\n        Account(IdlSeedAccount),\n    }\n\n    #[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\n    #[serde(rename_all = \"camelCase\")]\n    pub struct IdlSeedAccount {\n        #[serde(rename = \"type\")]\n        pub ty: IdlType,\n        // account_ty points to the entry in the \"accounts\" section.\n        // Some only if the `Account<T>` type is used.\n        #[serde(skip_serializing_if = \"Option::is_none\")]\n        pub account: Option<String>,\n        pub path: String,\n    }\n\n    #[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\n    #[serde(rename_all = \"camelCase\")]\n    pub struct IdlSeedArg {\n        #[serde(rename = \"type\")]\n        pub ty: IdlType,\n        pub path: String,\n    }\n\n    #[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\n    #[serde(rename_all = \"camelCase\")]\n    pub struct IdlSeedConst {\n        #[serde(rename = \"type\")]\n        pub ty: IdlType,\n        pub value: serde_json::Value,\n    }\n\n    #[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\n    pub struct IdlField {\n        pub name: String,\n        #[serde(skip_serializing_if = \"Option::is_none\")]\n        pub docs: Option<Vec<String>>,\n        #[serde(rename = \"type\")]\n        pub ty: IdlType,\n    }\n\n    #[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\n    pub struct IdlEvent {\n        pub name: String,\n        pub fields: Vec<IdlEventField>,\n    }\n\n    #[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\n    pub struct IdlEventField {\n        pub name: String,\n        #[serde(rename = \"type\")]\n        pub ty: IdlType,\n        pub index: bool,\n    }\n\n    #[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\n    pub struct IdlTypeDefinition {\n        /// - `idl-parse`: always the name of the type\n        /// - `idl-build`: full path if there is a name conflict, otherwise the name of the type\n        pub name: String,\n        /// Documentation comments\n        #[serde(skip_serializing_if = \"Option::is_none\")]\n        pub docs: Option<Vec<String>>,\n        /// Generics, only supported with `idl-build`\n        #[serde(skip_serializing_if = \"Option::is_none\")]\n        pub generics: Option<Vec<String>>,\n        /// Type definition, `struct` or `enum`\n        #[serde(rename = \"type\")]\n        pub ty: IdlTypeDefinitionTy,\n    }\n\n    #[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\n    #[serde(rename_all = \"lowercase\", tag = \"kind\")]\n    pub enum IdlTypeDefinitionTy {\n        Struct { fields: Vec<IdlField> },\n        Enum { variants: Vec<IdlEnumVariant> },\n        Alias { value: IdlType },\n    }\n\n    #[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\n    pub struct IdlEnumVariant {\n        pub name: String,\n        #[serde(skip_serializing_if = \"Option::is_none\", default)]\n        pub fields: Option<EnumFields>,\n    }\n\n    #[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\n    #[serde(untagged)]\n    pub enum EnumFields {\n        Named(Vec<IdlField>),\n        Tuple(Vec<IdlType>),\n    }\n\n    #[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\n    #[serde(rename_all = \"camelCase\")]\n    pub enum IdlType {\n        Bool,\n        U8,\n        I8,\n        U16,\n        I16,\n        U32,\n        I32,\n        F32,\n        U64,\n        I64,\n        F64,\n        U128,\n        I128,\n        U256,\n        I256,\n        Bytes,\n        String,\n        PublicKey,\n        Defined(String),\n        Option(Box<IdlType>),\n        Vec(Box<IdlType>),\n        Array(Box<IdlType>, usize),\n        GenericLenArray(Box<IdlType>, String),\n        Generic(String),\n        DefinedWithTypeArgs {\n            name: String,\n            args: Vec<IdlDefinedTypeArg>,\n        },\n    }\n\n    #[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\n    #[serde(rename_all = \"camelCase\")]\n    pub enum IdlDefinedTypeArg {\n        Generic(String),\n        Value(String),\n        Type(IdlType),\n    }\n\n    #[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]\n    pub struct IdlErrorCode {\n        pub code: u32,\n        pub name: String,\n        #[serde(skip_serializing_if = \"Option::is_none\", default)]\n        pub msg: Option<String>,\n    }\n\n    impl TryFrom<Idl> for t::Idl {\n        type Error = anyhow::Error;\n\n        fn try_from(idl: Idl) -> Result<Self> {\n            Ok(Self {\n                address: idl\n                    .metadata\n                    .as_ref()\n                    .and_then(|m| m.get(\"address\"))\n                    .and_then(|a| a.as_str())\n                    .ok_or_else(|| anyhow!(\"Program id missing in `idl.metadata.address` field\"))?\n                    .into(),\n                metadata: t::IdlMetadata {\n                    name: idl.name,\n                    version: idl.version,\n                    spec: t::IDL_SPEC.into(),\n                    description: Default::default(),\n                    repository: Default::default(),\n                    dependencies: Default::default(),\n                    contact: Default::default(),\n                    deployments: Default::default(),\n                },\n                docs: idl.docs.unwrap_or_default(),\n                instructions: idl.instructions.into_iter().map(Into::into).collect(),\n                accounts: idl.accounts.clone().into_iter().map(Into::into).collect(),\n                events: idl\n                    .events\n                    .clone()\n                    .unwrap_or_default()\n                    .into_iter()\n                    .map(Into::into)\n                    .collect(),\n                errors: idl\n                    .errors\n                    .unwrap_or_default()\n                    .into_iter()\n                    .map(Into::into)\n                    .collect(),\n                types: idl\n                    .types\n                    .into_iter()\n                    .map(Into::into)\n                    .chain(idl.accounts.into_iter().map(Into::into))\n                    .chain(idl.events.unwrap_or_default().into_iter().map(Into::into))\n                    .collect(),\n                constants: idl.constants.into_iter().map(Into::into).collect(),\n            })\n        }",
    "pub fn create(ctx: Context<Create>, bump_seed: u8) -> Result<()> {\n///       let my_account = &mut ctx.accounts.my_account;\n///       my_account.bump_seed = bump_seed;\n///     }\n/// }\n///\n/// #[derive(Accounts)]\n/// pub struct Create {\n///   #[account(init)]\n///   my_account: Account<'info, MyAccount>,\n/// }\n///\n/// impl Create {\n///   pub fn accounts(ctx: &Context<Create>, bump_seed: u8) -> Result<()> {\n///     let seeds = &[ctx.accounts.my_account.to_account_info().key.as_ref(), &[bump_seed]];\n///     Pubkey::create_program_address(seeds, ctx.program_id)\n///       .map_err(|_| ErrorCode::InvalidNonce)?;\n///     Ok(())\n///   }\n/// }\n/// ```\n///\n/// This example demonstrates a useful pattern. Not only can you use\n/// `#[access_control]` to ensure any invariants or preconditions hold prior to\n/// executing an instruction, but also it can be used to finish any validation\n/// on the `Accounts` struct, particularly when instruction arguments are\n/// needed. Here, we use the given `bump_seed` to verify it creates a valid\n/// program-derived address.\n#[proc_macro_attribute]\npub fn access_control(\n    args: proc_macro::TokenStream,\n    input: proc_macro::TokenStream,\n) -> proc_macro::TokenStream {\n    let mut args = args.to_string();\n    args.retain(|c| !c.is_whitespace());\n    let access_control: Vec<proc_macro2::TokenStream> = args\n        .split(')')\n        .filter(|ac| !ac.is_empty())\n        .map(|ac| format!(\"{ac})\")) // Put back on the split char.\n        .map(|ac| format!(\"{ac}?;\")) // Add `?;` syntax.\n        .map(|ac| ac.parse().unwrap())\n        .collect();\n\n    let item_fn = parse_macro_input!(input as syn::ItemFn);\n\n    let fn_attrs = item_fn.attrs;\n    let fn_vis = item_fn.vis;\n    let fn_sig = item_fn.sig;\n    let fn_block = item_fn.block;\n\n    let fn_stmts = fn_block.stmts;\n\n    proc_macro::TokenStream::from(quote! {\n        #(#fn_attrs)*\n        #fn_vis #fn_sig {\n\n            #(#access_control)*\n\n            #(#fn_stmts)*\n        }\n    })\n}",
    "pub fn check_id(id: &#pubkey_type) -> bool {\n            id == &ID\n        }\n\n        /// Returns the program ID\n        pub fn id() -> #pubkey_type {\n            ID\n        }\n\n        /// Const version of `ID`\n        pub const fn id_const() -> #pubkey_type {\n            ID_CONST\n        }\n\n        #[cfg(test)]\n        #[test]\n        fn test_id() {\n            assert!(check_id(&id()));\n        }\n    });\n}\n\npub struct Pubkey(proc_macro2::TokenStream);\n\nimpl Parse for Pubkey {\n    fn parse(input: ParseStream) -> Result<Self> {\n        parse_id(\n            input,\n            quote! { anchor_lang::solana_program::pubkey::Pubkey },\n        )\n        .map(Self)\n    }",
    "pub fn gen_lazy(strct: &syn::ItemStruct) -> syn::Result<TokenStream> {\n    let ident = &strct.ident;\n    let lazy_ident = format_ident!(\"Lazy{}\", ident);\n    let load_common_ident = to_private_ident(\"load_common\");\n    let initialize_fields = to_private_ident(\"initialize_fields\");\n    let lazy_acc_ty = quote! { anchor_lang::accounts::lazy_account::LazyAccount };\n    let disc_len = quote! { <#ident as anchor_lang::Discriminator>::DISCRIMINATOR.len() }",
    "pub fn account(\n    args: proc_macro::TokenStream,\n    input: proc_macro::TokenStream,\n) -> proc_macro::TokenStream {\n    let args = parse_macro_input!(args as AccountArgs);\n    let namespace = args.namespace.unwrap_or_default();\n    let is_zero_copy = args.zero_copy.is_some();\n    let unsafe_bytemuck = args.zero_copy.unwrap_or_default();\n\n    let account_strct = parse_macro_input!(input as syn::ItemStruct);\n    let account_name = &account_strct.ident;\n    let account_name_str = account_name.to_string();\n    let (impl_gen, type_gen, where_clause) = account_strct.generics.split_for_impl();\n\n    let discriminator = args\n        .overrides\n        .and_then(|ov| ov.discriminator)\n        .unwrap_or_else(|| {\n            // Namespace the discriminator to prevent collisions.\n            let namespace = if namespace.is_empty() {\n                \"account\"\n            } else {\n                &namespace\n            };\n\n            gen_discriminator(namespace, account_name)\n        }",
    "pub fn derive_zero_copy_accessor(item: proc_macro::TokenStream) -> proc_macro::TokenStream {\n    let account_strct = parse_macro_input!(item as syn::ItemStruct);\n    let account_name = &account_strct.ident;\n    let (impl_gen, ty_gen, where_clause) = account_strct.generics.split_for_impl();\n\n    let fields = match &account_strct.fields {\n        syn::Fields::Named(n) => n,\n        _ => panic!(\"Fields must be named\"),\n    };\n    let methods: Vec<proc_macro2::TokenStream> = fields\n        .named\n        .iter()\n        .filter_map(|field: &syn::Field| {\n            field\n                .attrs\n                .iter()\n                .find(|attr| anchor_syn::parser::tts_to_string(&attr.path) == \"accessor\")\n                .map(|attr| {\n                    let mut tts = attr.tokens.clone().into_iter();\n                    let g_stream = match tts.next().expect(\"Must have a token group\") {\n                        proc_macro2::TokenTree::Group(g) => g.stream(),\n                        _ => panic!(\"Invalid syntax\"),\n                    };\n                    let accessor_ty = match g_stream.into_iter().next() {\n                        Some(token) => token,\n                        _ => panic!(\"Missing accessor type\"),\n                    };\n\n                    let field_name = field.ident.as_ref().unwrap();\n\n                    let get_field: proc_macro2::TokenStream =\n                        format!(\"get_{field_name}\").parse().unwrap();\n                    let set_field: proc_macro2::TokenStream =\n                        format!(\"set_{field_name}\").parse().unwrap();\n\n                    quote! {\n                        pub fn #get_field(&self) -> #accessor_ty {\n                            anchor_lang::__private::ZeroCopyAccessor::get(&self.#field_name)\n                        }",
    "pub fn zero_copy(\n    args: proc_macro::TokenStream,\n    item: proc_macro::TokenStream,\n) -> proc_macro::TokenStream {\n    let mut is_unsafe = false;\n    for arg in args.into_iter() {\n        match arg {\n            proc_macro::TokenTree::Ident(ident) => {\n                if ident.to_string() == \"unsafe\" {\n                    // `#[zero_copy(unsafe)]` maintains the old behaviour\n                    //\n                    // ```ignore\n                    // #[derive(Copy, Clone)]\n                    // #[repr(packed)]\n                    // struct MyStruct {...}\n                    // ```\n                    is_unsafe = true;\n                } else {\n                    // TODO: how to return a compile error with a span (can't return prase error because expected type TokenStream)\n                    panic!(\"expected single ident `unsafe`\");\n                }\n            }\n            _ => {\n                panic!(\"expected single ident `unsafe`\");\n            }\n        }\n    }\n\n    let account_strct = parse_macro_input!(item as syn::ItemStruct);\n\n    // Takes the first repr. It's assumed that more than one are not on the\n    // struct.\n    let attr = account_strct\n        .attrs\n        .iter()\n        .find(|attr| anchor_syn::parser::tts_to_string(&attr.path) == \"repr\");\n\n    let repr = match attr {\n        // Users might want to manually specify repr modifiers e.g. repr(C, packed)\n        Some(_attr) => quote! {},\n        None => {\n            if is_unsafe {\n                quote! {#[repr(Rust, packed)]}\n            } else {\n                quote! {#[repr(C)]}\n            }\n        }\n    };\n\n    let mut has_pod_attr = false;\n    let mut has_zeroable_attr = false;\n    for attr in account_strct.attrs.iter() {\n        let token_string = attr.tokens.to_string();\n        if token_string.contains(\"bytemuck :: Pod\") {\n            has_pod_attr = true;\n        }\n        if token_string.contains(\"bytemuck :: Zeroable\") {\n            has_zeroable_attr = true;\n        }\n    }\n\n    // Once the Pod derive macro is expanded the compiler has to use the local crate's\n    // bytemuck `::bytemuck::Pod` anyway, so we're no longer using the privately\n    // exported anchor bytemuck `__private::bytemuck`, so that there won't be any\n    // possible disparity between the anchor version and the local crate's version.\n    let pod = if has_pod_attr || is_unsafe {\n        quote! {}\n    } else {\n        quote! {#[derive(::bytemuck::Pod)]}\n    };\n    let zeroable = if has_zeroable_attr || is_unsafe {\n        quote! {}\n    } else {\n        quote! {#[derive(::bytemuck::Zeroable)]}\n    };\n\n    let ret = quote! {\n        #[derive(anchor_lang::__private::ZeroCopyAccessor, Copy, Clone)]\n        #repr\n        #pod\n        #zeroable\n        #account_strct\n    };\n\n    #[cfg(feature = \"idl-build\")]\n    {\n        let derive_unsafe = if is_unsafe {\n            // Not a real proc-macro but exists in order to pass the serialization info\n            quote! { #[derive(bytemuck::Unsafe)] }\n        } else {\n            quote! {}\n        };\n        let zc_struct = syn::parse2(quote! {\n            #derive_unsafe\n            #ret\n        })\n        .unwrap();\n        let idl_build_impl = anchor_syn::idl::impl_idl_build_struct(&zc_struct);\n        return proc_macro::TokenStream::from(quote! {\n            #ret\n            #idl_build_impl\n        });\n    }\n\n    #[allow(unreachable_code)]\n    proc_macro::TokenStream::from(ret)\n}",
    "pub fn pubkey(input: proc_macro::TokenStream) -> proc_macro::TokenStream {\n    let pk = parse_macro_input!(input as id::Pubkey);\n    proc_macro::TokenStream::from(quote! {#pk})\n}",
    "pub fn declare_id(input: proc_macro::TokenStream) -> proc_macro::TokenStream {\n    #[cfg(feature = \"idl-build\")]\n    let address = input.clone().to_string();\n\n    let id = parse_macro_input!(input as id::Id);\n    let ret = quote! { #id };\n\n    #[cfg(feature = \"idl-build\")]\n    {\n        let idl_print = anchor_syn::idl::gen_idl_print_fn_address(address);\n        return proc_macro::TokenStream::from(quote! {\n            #ret\n            #idl_print\n        });\n    }\n\n    #[allow(unreachable_code)]\n    proc_macro::TokenStream::from(ret)\n}",
    "pub fn hello(_ctx: Context<Hello>) -> Result<()> {\n///         Err(error!(MyError::Hello))\n///     }\n/// }\n///\n/// #[derive(Accounts)]\n/// pub struct Hello {}\n///\n/// #[error_code]\n/// pub enum MyError {\n///     #[msg(\"This is an error message clients will automatically display\")]\n///     Hello,\n/// }\n/// ```\n///\n/// Note that we generate a new `Error` type so that we can return either the\n/// user defined error enum *or* a\n/// [`ProgramError`](../solana_program/enum.ProgramError.html), which is used\n/// pervasively, throughout solana program crates. The generated `Error` type\n/// should almost never be used directly, as the user defined error is\n/// preferred. In the example above, `error!(MyError::Hello)`.\n///\n/// # Msg\n///\n/// The `#[msg(..)]` attribute is inert, and is used only as a marker so that\n/// parsers  and IDLs can map error codes to error messages.\n#[proc_macro_attribute]\npub fn error_code(\n    args: proc_macro::TokenStream,\n    input: proc_macro::TokenStream,\n) -> proc_macro::TokenStream {\n    let args = match args.is_empty() {\n        true => None,\n        false => Some(parse_macro_input!(args as ErrorArgs)),\n    };\n    let mut error_enum = parse_macro_input!(input as syn::ItemEnum);\n    let error = codegen::error::generate(error_parser::parse(&mut error_enum, args));\n    proc_macro::TokenStream::from(error)\n}",
    "pub fn example(_ctx: Context<Example>) -> Result<()> {\n///         Err(error!(MyError::Hello))\n///     }\n/// }\n///\n/// #[error_code]\n/// pub enum MyError {\n///     #[msg(\"This is an error message clients will automatically display\")]\n///     Hello,\n/// }\n/// ```\n#[proc_macro]\npub fn error(ts: proc_macro::TokenStream) -> TokenStream {\n    let input = parse_macro_input!(ts as ErrorInput);\n    let error_code = input.error_code;\n    create_error(error_code, true, None)\n}",
    "pub fn event(\n    args: proc_macro::TokenStream,\n    input: proc_macro::TokenStream,\n) -> proc_macro::TokenStream {\n    let args = parse_macro_input!(args as Overrides);\n    let event_strct = parse_macro_input!(input as syn::ItemStruct);\n    let event_name = &event_strct.ident;\n\n    let discriminator = args\n        .discriminator\n        .unwrap_or_else(|| gen_discriminator(\"event\", event_name));\n\n    let ret = quote! {\n        #[derive(AnchorSerialize, AnchorDeserialize)]\n        #event_strct\n\n        impl anchor_lang::Event for #event_name {\n            fn data(&self) -> Vec<u8> {\n                let mut data = Vec::with_capacity(256);\n                data.extend_from_slice(#event_name::DISCRIMINATOR);\n                self.serialize(&mut data).unwrap();\n                data\n            }\n        }\n\n        impl anchor_lang::Discriminator for #event_name {\n            const DISCRIMINATOR: &'static [u8] = #discriminator;\n        }\n    };\n\n    #[cfg(feature = \"idl-build\")]\n    {\n        let idl_build = anchor_syn::idl::gen_idl_print_fn_event(&event_strct);\n        return proc_macro::TokenStream::from(quote! {\n            #ret\n            #idl_build\n        });\n    }\n\n    #[allow(unreachable_code)]\n    proc_macro::TokenStream::from(ret)\n}",
    "pub fn initialize(_ctx: Context<Initialize>) -> Result<()> {\n///     emit!(MyEvent {\n///         data: 5,\n///         label: [1,2,3,4,5],\n///     });\n///     Ok(())\n/// }\n///\n/// #[event]\n/// pub struct MyEvent {\n///     pub data: u64,\n///     pub label: [u8; 5],\n/// }\n/// ```\n#[proc_macro]\npub fn emit(input: proc_macro::TokenStream) -> proc_macro::TokenStream {\n    let data: proc_macro2::TokenStream = input.into();\n    proc_macro::TokenStream::from(quote! {\n        {\n            anchor_lang::solana_program::log::sol_log_data(&[&anchor_lang::Event::data(&#data)]);\n        }\n    })\n}",
    "pub fn my_instruction(ctx: Context<MyInstruction>) -> Result<()> {\n///         emit_cpi!(MyEvent { data: 42 });\n///         Ok(())\n///     }\n/// }\n///\n/// #[event_cpi]\n/// #[derive(Accounts)]\n/// pub struct MyInstruction {}\n///\n/// #[event]\n/// pub struct MyEvent {\n///     pub data: u64,\n/// }\n/// ```\n///\n/// **NOTE:** This macro requires `ctx` to be in scope.\n///\n/// *Only available with `event-cpi` feature enabled.*\n#[cfg(feature = \"event-cpi\")]\n#[proc_macro]\npub fn emit_cpi(input: proc_macro::TokenStream) -> proc_macro::TokenStream {\n    let event_struct = parse_macro_input!(input as syn::Expr);\n\n    let authority = EventAuthority::get();\n    let authority_name = authority.name_token_stream();\n    let authority_seeds = authority.seeds;\n\n    proc_macro::TokenStream::from(quote! {\n        {\n            let authority_info = ctx.accounts.#authority_name.to_account_info();\n            let authority_bump = ctx.bumps.#authority_name;\n\n            let disc = anchor_lang::event::EVENT_IX_TAG_LE;\n            let inner_data = anchor_lang::Event::data(&#event_struct);\n            let ix_data: Vec<u8> = disc\n                .into_iter()\n                .map(|b| *b)\n                .chain(inner_data.into_iter())\n                .collect();\n\n            let ix = anchor_lang::solana_program::instruction::Instruction::new_with_bytes(\n                crate::ID,\n                &ix_data,\n                vec![\n                    anchor_lang::solana_program::instruction::AccountMeta::new_readonly(\n                        *authority_info.key,\n                        true,\n                    ),\n                ],\n            );\n            anchor_lang::solana_program::program::invoke_signed(\n                &ix,\n                &[authority_info],\n                &[&[#authority_seeds, &[authority_bump]]],\n            )\n            .map_err(anchor_lang::error::Error::from)?;\n        }\n    })\n}",
    "pub fn event_cpi(\n    _attr: proc_macro::TokenStream,\n    input: proc_macro::TokenStream,\n) -> proc_macro::TokenStream {\n    let accounts_struct = parse_macro_input!(input as syn::ItemStruct);\n    let accounts_struct = add_event_cpi_accounts(&accounts_struct).unwrap();\n    proc_macro::TokenStream::from(quote! {#accounts_struct})\n}",
    "pub fn program(\n    _args: proc_macro::TokenStream,\n    input: proc_macro::TokenStream,\n) -> proc_macro::TokenStream {\n    parse_macro_input!(input as anchor_syn::Program)\n        .to_token_stream()\n        .into()\n}",
    "pub fn declare_program(input: proc_macro::TokenStream) -> proc_macro::TokenStream {\n    parse_macro_input!(input as DeclareProgram)\n        .to_token_stream()\n        .into()\n}",
    "pub fn get_canonical_program_id() -> proc_macro2::TokenStream {\n    quote! { super::__ID }\n}\n\npub fn gen_docs(docs: &[String]) -> proc_macro2::TokenStream {\n    let docs = docs\n        .iter()\n        .map(|doc| format!(\"{}{doc}\", if doc.is_empty() { \"\" } else { \" \" }))\n        .map(|doc| quote! { #[doc = #doc] });\n    quote! { #(#docs)* }\n}\n\npub fn gen_discriminator(disc: &[u8]) -> proc_macro2::TokenStream {\n    quote! { [#(#disc), *] }\n}\n\npub fn gen_accounts_common(idl: &Idl, prefix: &str) -> proc_macro2::TokenStream {\n    let re_exports = idl\n        .instructions\n        .iter()\n        .map(|ix| format_ident!(\"__{}_accounts_{}\", prefix, ix.name))\n        .map(|ident| quote! { pub use super::internal::#ident::*; });\n\n    quote! {\n        pub mod accounts {\n            #(#re_exports)*\n        }\n    }\n}\n\npub fn convert_idl_type_to_syn_type(ty: &IdlType) -> syn::Type {\n    syn::parse_str(&convert_idl_type_to_str(ty)).unwrap()\n}",
    "pub fn convert_idl_type_to_str(ty: &IdlType) -> String {\n    match ty {\n        IdlType::Bool => \"bool\".into(),\n        IdlType::U8 => \"u8\".into(),\n        IdlType::I8 => \"i8\".into(),\n        IdlType::U16 => \"u16\".into(),\n        IdlType::I16 => \"i16\".into(),\n        IdlType::U32 => \"u32\".into(),\n        IdlType::I32 => \"i32\".into(),\n        IdlType::F32 => \"f32\".into(),\n        IdlType::U64 => \"u64\".into(),\n        IdlType::I64 => \"i64\".into(),\n        IdlType::F64 => \"f64\".into(),\n        IdlType::U128 => \"u128\".into(),\n        IdlType::I128 => \"i128\".into(),\n        IdlType::U256 => \"u256\".into(),\n        IdlType::I256 => \"i256\".into(),\n        IdlType::Bytes => \"Vec<u8>\".into(),\n        IdlType::String => \"String\".into(),\n        IdlType::Pubkey => \"Pubkey\".into(),\n        IdlType::Option(ty) => format!(\"Option<{}>\", convert_idl_type_to_str(ty)),\n        IdlType::Vec(ty) => format!(\"Vec<{}>\", convert_idl_type_to_str(ty)),\n        IdlType::Array(ty, len) => format!(\n            \"[{}; {}]\",\n            convert_idl_type_to_str(ty),\n            match len {\n                IdlArrayLen::Generic(len) => len.into(),\n                IdlArrayLen::Value(len) => len.to_string(),\n            }\n        ),\n        IdlType::Defined { name, generics } => generics\n            .iter()\n            .map(|generic| match generic {\n                IdlGenericArg::Type { ty } => convert_idl_type_to_str(ty),\n                IdlGenericArg::Const { value } => value.into(),\n            })\n            .reduce(|mut acc, cur| {\n                if !acc.is_empty() {\n                    acc.push(',');\n                }\n                acc.push_str(&cur);\n                acc\n            })\n            .map(|generics| format!(\"{name}<{generics}>\"))\n            .unwrap_or(name.into()),\n        IdlType::Generic(ty) => ty.into(),\n        _ => unimplemented!(\"{ty:?}\"),\n    }\n}\n\npub fn convert_idl_type_def_to_ts(\n    ty_def: &IdlTypeDef,\n    ty_defs: &[IdlTypeDef],\n) -> proc_macro2::TokenStream {\n    let name = format_ident!(\"{}\", ty_def.name);\n    let docs = gen_docs(&ty_def.docs);\n\n    let generics = {\n        let generics = ty_def\n            .generics\n            .iter()\n            .map(|generic| match generic {\n                IdlTypeDefGeneric::Type { name } => {\n                    let name = format_ident!(\"{}\", name);\n                    quote! { #name }\n                }\n                IdlTypeDefGeneric::Const { name, ty } => {\n                    let name = format_ident!(\"{}\", name);\n                    let ty = format_ident!(\"{}\", ty);\n                    quote! { const #name: #ty }\n                }\n            })\n            .collect::<Vec<_>>();\n        if generics.is_empty() {\n            quote!()\n        }",
    "pub fn gen_accounts_mod(idl: &Idl) -> proc_macro2::TokenStream {\n    let accounts = idl.accounts.iter().map(|acc| {\n        let name = format_ident!(\"{}\", acc.name);\n        let discriminator = gen_discriminator(&acc.discriminator);\n        let disc = quote! { #name::DISCRIMINATOR };\n\n        let ty_def = idl\n            .types\n            .iter()\n            .find(|ty| ty.name == acc.name)\n            .expect(\"Type must exist\");\n\n        let impls = {\n            let try_deserialize = quote! {\n                fn try_deserialize(buf: &mut &[u8]) -> anchor_lang::Result<Self> {\n                    if buf.len() < #disc.len() {\n                        return Err(anchor_lang::error::ErrorCode::AccountDiscriminatorNotFound.into());\n                    }\n\n                    let given_disc = &buf[..#disc.len()];\n                    if #disc != given_disc {\n                        return Err(\n                            anchor_lang::error!(anchor_lang::error::ErrorCode::AccountDiscriminatorMismatch)\n                            .with_account_name(stringify!(#name))\n                        );\n                    }\n\n                    Self::try_deserialize_unchecked(buf)\n                }",
    "pub fn gen_client_mod(idl: &Idl) -> proc_macro2::TokenStream {\n    let client_args_mod = gen_client_args_mod();\n    let client_accounts_mod = gen_client_accounts_mod(idl);\n\n    quote! {\n        /// Off-chain client helpers.\n        pub mod client {\n            use super::*;\n\n            #client_args_mod\n            #client_accounts_mod\n        }\n    }\n}\n\nfn gen_client_args_mod() -> proc_macro2::TokenStream {\n    quote! {\n        /// Client args.\n        pub mod args {\n            pub use super::internal::args::*;\n        }\n    }\n}\n\nfn gen_client_accounts_mod(idl: &Idl) -> proc_macro2::TokenStream {\n    gen_accounts_common(idl, \"client\")\n}",
    "pub fn gen_cpi_mod(idl: &Idl) -> proc_macro2::TokenStream {\n    let cpi_instructions = gen_cpi_instructions(idl);\n    let cpi_return_type = gen_cpi_return_type();\n    let cpi_accounts_mod = gen_cpi_accounts_mod(idl);\n\n    quote! {\n        /// Cross program invocation (CPI) helpers.\n        pub mod cpi {\n            use super::*;\n\n            #cpi_instructions\n            #cpi_return_type\n            #cpi_accounts_mod\n        }\n    }\n}\n\nfn gen_cpi_instructions(idl: &Idl) -> proc_macro2::TokenStream {\n    let ixs = idl.instructions.iter().map(|ix| {\n        let method_name = format_ident!(\"{}\", ix.name);\n        let accounts_ident = format_ident!(\"{}\", ix.name.to_camel_case());\n\n        let accounts_generic = if ix.accounts.is_empty() {\n           quote!()\n        }",
    "pub fn get(&self) -> T {\n                let (_key, data) = anchor_lang::solana_program::program::get_return_data().unwrap();\n                T::try_from_slice(&data).unwrap()\n            }",
    "pub fn gen_internal_mod(idl: &Idl) -> proc_macro2::TokenStream {\n    let internal_args_mod = gen_internal_args_mod(idl);\n    let internal_accounts_mod = gen_internal_accounts(idl);\n\n    quote! {\n        #[doc(hidden)]\n        mod internal {\n            use super::*;\n\n            #internal_args_mod\n            #internal_accounts_mod\n        }\n    }\n}\n\nfn gen_internal_args_mod(idl: &Idl) -> proc_macro2::TokenStream {\n    let ixs = idl.instructions.iter().map(|ix| {\n        let ix_struct_name = format_ident!(\"{}\", ix.name.to_camel_case());\n\n        let fields = ix.args.iter().map(|arg| {\n            let name = format_ident!(\"{}\", arg.name);\n            let ty = convert_idl_type_to_syn_type(&arg.ty);\n            quote! { pub #name: #ty }\n        });\n\n        let ix_struct = if ix.args.is_empty() {\n            quote! {\n                pub struct #ix_struct_name;\n            }\n        } else {\n            quote! {\n                pub struct #ix_struct_name {\n                    #(#fields),*\n                }\n            }\n        };\n\n        let discriminator = gen_discriminator(&ix.discriminator);\n        let impl_discriminator = quote! {\n            impl anchor_lang::Discriminator for #ix_struct_name {\n                const DISCRIMINATOR: &'static [u8] = &#discriminator;\n            }\n        };\n\n        let impl_ix_data = quote! {\n            impl anchor_lang::InstructionData for #ix_struct_name {}\n        };\n\n        let program_id = get_canonical_program_id();\n        let impl_owner = quote! {\n            impl anchor_lang::Owner for #ix_struct_name {\n                fn owner() -> Pubkey {\n                    #program_id\n                }\n            }\n        };\n\n        quote! {\n            /// Instruction argument\n            #[derive(AnchorSerialize, AnchorDeserialize)]\n            #ix_struct\n\n            #impl_discriminator\n            #impl_ix_data\n            #impl_owner\n        }\n    });\n\n    quote! {\n        /// An Anchor generated module containing the program's set of instructions, where each\n        /// method handler in the `#[program]` mod is associated with a struct defining the input\n        /// arguments to the method. These should be used directly, when one wants to serialize\n        /// Anchor instruction data, for example, when specifying instructions instructions on a\n        /// client.\n        pub mod args {\n            use super::*;\n\n            #(#ixs)*\n        }\n    }\n}\n\nfn gen_internal_accounts(idl: &Idl) -> proc_macro2::TokenStream {\n    let cpi_accounts = gen_internal_accounts_common(idl, __cpi_client_accounts::generate);\n    let client_accounts = gen_internal_accounts_common(idl, __client_accounts::generate);\n\n    quote! {\n        #cpi_accounts\n        #client_accounts\n    }\n}\n\nfn gen_internal_accounts_common(\n    idl: &Idl,\n    gen_accounts: impl Fn(&AccountsStruct, proc_macro2::TokenStream) -> proc_macro2::TokenStream,\n) -> proc_macro2::TokenStream {\n    // It's possible to declare an accounts struct and not use it as an instruction, see\n    // https://github.com/coral-xyz/anchor/issues/3274\n    fn get_non_instruction_composite_accounts<'a>(\n        accs: &'a [IdlInstructionAccountItem],\n        idl: &'a Idl,\n    ) -> Vec<&'a IdlInstructionAccounts> {\n        accs.iter()\n            .flat_map(|acc| match acc {\n                IdlInstructionAccountItem::Composite(accs)\n                    if !idl\n                        .instructions\n                        .iter()\n                        .any(|ix| ix.accounts == accs.accounts) =>\n                {\n                    let mut non_ix_composite_accs =\n                        get_non_instruction_composite_accounts(&accs.accounts, idl);\n                    if !non_ix_composite_accs.contains(&accs) {\n                        non_ix_composite_accs.push(accs);\n                    }\n                    non_ix_composite_accs\n                }\n                _ => Default::default(),\n            })\n            .collect()\n    }",
    "pub fn gen_types_mod(idl: &Idl) -> proc_macro2::TokenStream {\n    let types = idl\n        .types\n        .iter()\n        .filter(|ty| {\n            // Skip accounts and events\n            !(idl.accounts.iter().any(|acc| acc.name == ty.name)\n                || idl.events.iter().any(|ev| ev.name == ty.name))\n        }",
    "pub fn gen_utils_mod(idl: &Idl) -> proc_macro2::TokenStream {\n    let account = gen_account(idl);\n    let event = gen_event(idl);\n\n    quote! {\n        /// Program utilities.\n        pub mod utils {\n            use super::*;\n\n            #account\n            #event\n        }\n    }\n}\n\nfn gen_account(idl: &Idl) -> proc_macro2::TokenStream {\n    let variants = idl\n        .accounts\n        .iter()\n        .map(|acc| format_ident!(\"{}\", acc.name))\n        .map(|name| quote! { #name(#name) }",
    "pub fn try_from_bytes(bytes: &[u8]) -> Result<Self> {\n                Self::try_from(bytes)\n            }",
    "pub fn try_from_bytes(bytes: &[u8]) -> Result<Self> {\n                Self::try_from(bytes)\n            }",
    "pub fn initialize(ctx: Context<Create>, bump: u8, authority: Pubkey, data: u64) -> anchor_lang::Result<()> {\n///     ...\n///     Ok(())\n/// }\n/// ...\n/// #[derive(Accounts)]\n/// #[instruction(bump: u8)]\n/// pub struct Initialize<'info> {\n///     ...\n/// }\n/// ```\n///\n/// # Constraints\n///\n/// There are different types of constraints that can be applied with the `#[account(..)]` attribute.\n///\n/// Attributes may reference other data structures. When `<expr>` is used in the tables below, an arbitrary expression\n/// may be passed in as long as it evaluates to a value of the expected type, e.g. `owner = token_program.key()`. If `target_account`\n/// used, the `target_account` must exist in the struct and the `.key()` is implicit, e.g. `payer = authority`.\n///\n/// - [Normal Constraints](#normal-constraints)\n/// - [SPL Constraints](#spl-constraints)\n///\n/// # Normal Constraints\n/// <table>\n///     <thead>\n///         <tr>\n///             <th>Attribute</th>\n///             <th>Description</th>\n///         </tr>\n///     </thead>\n///     <tbody>\n///         <tr>\n///             <td>\n///                 <code>#[account(signer)]</code> <br><br><code>#[account(signer @ &lt;custom_error&gt;)]</code>\n///             </td>\n///             <td>\n///                 Checks the given account signed the transaction.<br>\n///                 Custom errors are supported via <code>@</code>.<br>\n///                 Consider using the <code>Signer</code> type if you would only have this constraint on the account.<br><br>\n///                 Example:\n///                 <pre><code>\n/// #[account(signer)]\n/// pub authority: AccountInfo<'info>,\n/// #[account(signer @ MyError::MyErrorCode)]\n/// pub payer: AccountInfo<'info>\n///                 </code></pre>\n///             </td>\n///         </tr>\n///         <tr>\n///             <td>\n///                 <code>#[account(mut)]</code> <br><br><code>#[account(mut @ &lt;custom_error&gt;)]</code>\n///             </td>\n///             <td>\n///                 Checks the given account is mutable.<br>\n///                 Makes anchor persist any state changes.<br>\n///                 Custom errors are supported via <code>@</code>.<br><br>\n///                 Example:\n///                 <pre><code>\n/// #[account(mut)]\n/// pub data_account: Account<'info, MyData>,\n/// #[account(mut @ MyError::MyErrorCode)]\n/// pub data_account_two: Account<'info, MyData>\n///                 </code></pre>\n///             </td>\n///         </tr>\n///         <tr>\n///             <td>\n///                 <code>#[account(init, payer = &lt;target_account&gt;, space = &lt;num_bytes&gt;)]</code>\n///             </td>\n///             <td>\n///                 Creates the account via a CPI to the system program and\n///                 initializes it (sets its account discriminator). The annotated account is required to sign for this instruction\n///                 unless `seeds` is provided. <br>\n///                 Marks the account as mutable and is mutually exclusive with <code>mut</code>.<br>\n///                 Makes the account rent exempt unless skipped with <code>rent_exempt = skip</code>.<br><br>\n///                 Use <code>#[account(zero)]</code> for accounts larger than 10 Kibibyte.<br><br>\n///                 <code>init</code> has to be used with additional constraints:\n///                 <ul>\n///                     <li>\n///                         Requires the <code>payer</code> constraint to also be on the account.\n///                         The <code>payer</code> account pays for the\n///                         account creation.\n///                     </li>\n///                     <li>\n///                         Requires the system program to exist on the struct\n///                         and be called <code>system_program</code>.\n///                     </li>\n///                     <li>\n///                         Requires that the <code>space</code> constraint is specified.\n///                         When using the <code>space</code> constraint, one must remember to add 8 to it\n///                         which is the size of the account discriminator. This only has to be done\n///                         for accounts owned by anchor programs.<br>\n///                         The given space number is the size of the account in bytes, so accounts that hold\n///                         a variable number of items such as a <code>Vec</code> should allocate sufficient space for all items that may\n///                         be added to the data structure because account size is fixed.\n///                         Check out the <a href = \"https://www.anchor-lang.com/docs/space\" target = \"_blank\" rel = \"noopener noreferrer\">space reference</a>\n///                         and the <a href = \"https://borsh.io/\" target = \"_blank\" rel = \"noopener noreferrer\">borsh library</a>\n///                         (which anchor uses under the hood for serialization) specification to learn how much\n///                         space different data structures require.\n///                     </li>\n///                 <br>\n///                 Example:\n///                 <pre>\n/// #[account]\n/// pub struct MyData {\n/// &nbsp;&nbsp;&nbsp;&nbsp;pub data: u64\n/// }&#10;\n/// #[derive(Accounts)]\n/// pub struct Initialize<'info> {\n/// &nbsp;&nbsp;&nbsp;&nbsp;#[account(init, payer = payer, space = 8 + 8)]\n/// &nbsp;&nbsp;&nbsp;&nbsp;pub data_account_two: Account<'info, MyData>,\n/// &nbsp;&nbsp;&nbsp;&nbsp;#[account(mut)]\n/// &nbsp;&nbsp;&nbsp;&nbsp;pub payer: Signer<'info>,\n/// &nbsp;&nbsp;&nbsp;&nbsp;pub system_program: Program<'info, System>,\n/// }\n///                 </pre>\n///                 </ul>\n///                 <code>init</code> can be combined with other constraints (at the same time):\n///                 <ul>\n///                     <li>\n///                         By default <code>init</code> sets the owner field of the created account to the\n///                         currently executing program. Add the <code>owner</code> constraint to specify a\n///                         different program owner.\n///                     </li>\n///                     <li>\n///                         Use the <code>seeds</code> constraint together with <code>bump</code>to create PDAs.<br>\n///                         <code>init</code> uses <code>find_program_address</code> to calculate the pda so the\n///                         bump value can be left empty.<br>\n///                         However, if you want to use the bump in your instruction,\n///                         you can pass it in as instruction data and set the bump value like shown in the example,\n///                         using the <code>instruction_data</code> attribute.\n///                         Anchor will then check that the bump returned by <code>find_program_address</code> equals\n///                         the bump in the instruction data.<br>\n///                         <code>seeds::program</code> cannot be used together with init because the creation of an\n///                         account requires its signature which for PDAs only the currently executing program can provide.\n///                     </li>\n///                 </ul>\n///                 Example:\n///                 <pre>\n/// #[derive(Accounts)]\n/// #[instruction(bump: u8)]\n/// pub struct Initialize<'info> {\n/// &nbsp;&nbsp;&nbsp;&nbsp;#[account(\n/// &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;init, payer = payer, space = 8 + 8\n/// &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;seeds = [b\"example_seed\"], bump = bump\n/// &nbsp;&nbsp;&nbsp;&nbsp;)]\n/// &nbsp;&nbsp;&nbsp;&nbsp;pub pda_data_account: Account<'info, MyData>,\n/// &nbsp;&nbsp;&nbsp;&nbsp;#[account(\n/// &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;init, payer = payer,\n/// &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;space = 8 + 8, owner = other_program.key()\n/// &nbsp;&nbsp;&nbsp;&nbsp;)]\n/// &nbsp;&nbsp;&nbsp;&nbsp;pub account_for_other_program: AccountInfo<'info>,\n/// &nbsp;&nbsp;&nbsp;&nbsp;#[account(\n/// &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;init, payer = payer, space = 8 + 8,\n/// &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;owner = other_program.key(),\n/// &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;seeds = [b\"other_seed\"], bump\n/// &nbsp;&nbsp;&nbsp;&nbsp;)]\n/// &nbsp;&nbsp;&nbsp;&nbsp;pub pda_for_other_program: AccountInfo<'info>,\n/// &nbsp;&nbsp;&nbsp;&nbsp;#[account(mut)]\n/// &nbsp;&nbsp;&nbsp;&nbsp;pub payer: Signer<'info>,\n/// &nbsp;&nbsp;&nbsp;&nbsp;pub system_program: Program<'info, System>,\n/// &nbsp;&nbsp;&nbsp;&nbsp;pub other_program: Program<'info, OtherProgram>\n/// }\n///                 </pre>\n///             </td>\n///         </tr>\n///         <tr>\n///             <td>\n///                 <code>#[account(init_if_needed, payer = &lt;target_account&gt;)]</code><br><br>\n///                 <code>#[account(init_if_needed, payer = &lt;target_account&gt;, space = &lt;num_bytes&gt;)]</code>\n///             </td>\n///             <td>\n///                 Exact same functionality as the <code>init</code> constraint but only runs if the account does not exist yet.<br>\n///                 If the account does exist, it still checks whether the given init constraints are correct,\n///                 e.g. that the account has the expected amount of space and, if it's a PDA, the correct seeds etc.<br><br>\n///                 This feature should be used with care and is therefore behind a feature flag.\n///                 You can enable it by importing <code>anchor-lang</code> with the <code>init-if-needed</code> cargo feature.<br>\n///                 When using <code>init_if_needed</code>, you need to make sure you properly protect yourself\n///                 against re-initialization attacks. You need to include checks in your code that check\n///                 that the initialized account cannot be reset to its initial settings after the first time it was\n///                 initialized (unless that it what you want).<br>\n///                 Because of the possibility of re-initialization attacks and the general guideline that instructions\n///                 should avoid having multiple execution flows (which is important so they remain easy to understand),\n///                 consider breaking up your instruction into two instructions - one for initializing and one for using\n///                 the account - unless you have a good reason not to do so.\n///                 <br><br>\n///                 Example:\n///                 <pre>\n/// #[account]\n/// #[derive(Default)]\n/// pub struct MyData {\n/// &nbsp;&nbsp;&nbsp;&nbsp;pub data: u64\n/// }&#10;\n/// #[account]\n/// pub struct OtherData {\n/// &nbsp;&nbsp;&nbsp;&nbsp;pub data: u64\n/// }&#10;\n/// #[derive(Accounts)]\n/// pub struct Initialize<'info> {\n/// &nbsp;&nbsp;&nbsp;&nbsp;#[account(init_if_needed, payer = payer)]\n/// &nbsp;&nbsp;&nbsp;&nbsp;pub data_account: Account<'info, MyData>,\n/// &nbsp;&nbsp;&nbsp;&nbsp;#[account(init_if_needed, payer = payer, space = 8 + 8)]\n/// &nbsp;&nbsp;&nbsp;&nbsp;pub data_account_two: Account<'info, OtherData>,\n/// &nbsp;&nbsp;&nbsp;&nbsp;#[account(mut)]\n/// &nbsp;&nbsp;&nbsp;&nbsp;pub payer: Signer<'info>,\n/// &nbsp;&nbsp;&nbsp;&nbsp;pub system_program: Program<'info, System>\n/// }\n///                 </pre>\n///             </td>\n///         </tr>\n///         <tr>\n///             <td>\n///                 <code>#[account(seeds = &lt;seeds&gt;, bump)]</code><br><br>\n///                 <code>#[account(seeds = &lt;seeds&gt;, bump, seeds::program = &lt;expr&gt;)]<br><br>\n///                 <code>#[account(seeds = &lt;seeds&gt;, bump = &lt;expr&gt;)]</code><br><br>\n///                 <code>#[account(seeds = &lt;seeds&gt;, bump = &lt;expr&gt;, seeds::program = &lt;expr&gt;)]</code><br><br>\n///             </td>\n///             <td>\n///                 Checks that given account is a PDA derived from the currently executing program,\n///                 the seeds, and if provided, the bump. If not provided, anchor uses the canonical\n///                 bump. <br>\n///                 Add <code>seeds::program = &lt;expr&gt;</code> to derive the PDA from a different\n///                 program than the currently executing one.<br>\n///                 This constraint behaves slightly differently when used with <code>init</code>.\n///                 See its description.\n///                 <br><br>\n///                 Example:\n///                 <pre><code>\n/// #[derive(Accounts)]\n/// #[instruction(first_bump: u8, second_bump: u8)]\n/// pub struct Example {\n///     #[account(seeds = [b\"example_seed\"], bump)]\n///     pub canonical_pda: AccountInfo<'info>,\n///     #[account(\n///         seeds = [b\"example_seed\"],\n///         bump,\n///         seeds::program = other_program.key()\n///     )]\n///     pub canonical_pda_two: AccountInfo<'info>,\n///     #[account(seeds = [b\"other_seed\"], bump = first_bump)]\n///     pub arbitrary_pda: AccountInfo<'info>\n///     #[account(\n///         seeds = [b\"other_seed\"],\n///         bump = second_bump,\n///         seeds::program = other_program.key()\n///     )]\n///     pub arbitrary_pda_two: AccountInfo<'info>,\n///     pub other_program: Program<'info, OtherProgram>\n/// }\n///                 </code></pre>\n///             </td>\n///         </tr>\n///         <tr>\n///             <td>\n///                 <code>#[account(has_one = &lt;target_account&gt;)]</code><br><br>\n///                 <code>#[account(has_one = &lt;target_account&gt; @ &lt;custom_error&gt;)]</code>\n///             </td>\n///             <td>\n///                 Checks the <code>target_account</code> field on the account matches the\n///                 key of the <code>target_account</code> field in the Accounts struct.<br>\n///                 Custom errors are supported via <code>@</code>.<br><br>\n///                 Example:\n///                 <pre><code>\n/// #[account(mut, has_one = authority)]\n/// pub data: Account<'info, MyData>,\n/// pub authority: Signer<'info>\n///                 </code></pre>\n///                 In this example <code>has_one</code> checks that <code>data.authority = authority.key()</code>\n///             </td>\n///         </tr>\n///         <tr>\n///             <td>\n///                 <code>#[account(address = &lt;expr&gt;)]</code><br><br>\n///                 <code>#[account(address = &lt;expr&gt; @ &lt;custom_error&gt;)]</code>\n///             </td>\n///             <td>\n///                 Checks the account key matches the pubkey.<br>\n///                 Custom errors are supported via <code>@</code>.<br><br>\n///                 Example:\n///                 <pre><code>\n/// #[account(address = crate::ID)]\n/// pub data: Account<'info, MyData>,\n/// #[account(address = crate::ID @ MyError::MyErrorCode)]\n/// pub data_two: Account<'info, MyData>\n///                 </code></pre>\n///             </td>\n///         </tr>\n///         <tr>\n///             <td>\n///                 <code>#[account(owner = &lt;expr&gt;)]</code><br><br>\n///                 <code>#[account(owner = &lt;expr&gt; @ &lt;custom_error&gt;)]</code>\n///             </td>\n///             <td>\n///                 Checks the account owner matches <code>expr</code>.<br>\n///                 Custom errors are supported via <code>@</code>.<br><br>\n///                 Example:\n///                 <pre><code>\n/// #[account(owner = Token::ID @ MyError::MyErrorCode)]\n/// pub data: Account<'info, MyData>,\n/// #[account(owner = token_program.key())]\n/// pub data_two: Account<'info, MyData>,\n/// pub token_program: Program<'info, Token>\n///                 </code></pre>\n///             </td>\n///         </tr>\n///         <tr>\n///             <td>\n///                 <code>#[account(executable)]</code>\n///             </td>\n///             <td>\n///                 Checks the account is executable (i.e. the account is a program).<br>\n///                 You may want to use the <code>Program</code> type instead.<br><br>\n///                 Example:\n///                 <pre><code>\n/// #[account(executable)]\n/// pub my_program: AccountInfo<'info>\n///                 </code></pre>\n///             </td>\n///         </tr>\n///         <tr>\n///             <td>\n///                 <code>#[account(rent_exempt = skip)]</code><br><br>\n///                 <code>#[account(rent_exempt = enforce)]</code>\n///             </td>\n///             <td>\n///                 Enforces rent exemption with <code>= enforce</code>.<br>\n///                 Skips rent exemption check that would normally be done\n///                 through other constraints with <code>= skip</code>,\n///                 e.g. when used with the <code>zero</code> constraint<br><br>\n///                 Example:\n///                 <pre><code>\n/// #[account(zero, rent_exempt = skip)]\n/// pub skipped_account: Account<'info, MyData>,\n/// #[account(rent_exempt = enforce)]\n/// pub enforced_account: AccountInfo<'info>\n///                 </code></pre>\n///             </td>\n///         </tr>\n///         <tr>\n///             <td>\n///                 <code>#[account(zero)]</code>\n///             </td>\n///             <td>\n///                 Checks the account discriminator is zero.<br>\n///                 Enforces rent exemption unless skipped with <code>rent_exempt = skip</code>.<br><br>\n///                 Use this constraint if you want to create an account in a previous instruction\n///                 and then initialize it in your instruction instead of using <code>init</code>.\n///                 This is necessary for accounts that are larger than 10 Kibibyte because those\n///                 accounts cannot be created via a CPI (which is what <code>init</code> would do).<br><br>\n///                 Anchor adds internal data to the account when using <code>zero</code> just like it\n///                 does with <code>init</code> which is why <code>zero</code> implies <code>mut</code>.\n///                 <br><br>\n///                 Example:\n///                 <pre><code>\n/// #[account(zero)]\n/// pub my_account: Account<'info, MyData>\n///                 </code></pre>\n///             </td>\n///         </tr>\n///         <tr>\n///             <td>\n///                 <code>#[account(close = &lt;target_account&gt;)]</code>\n///             </td>\n///             <td>\n///                 Closes the account by:<br>\n///                 &nbsp;&nbsp;&nbsp;&nbsp;- Sending the lamports to the specified account<br>\n///                 &nbsp;&nbsp;&nbsp;&nbsp;- Assigning the owner to the System Program<br>\n///                 &nbsp;&nbsp;&nbsp;&nbsp;- Resetting the data of the account<br><br>\n///                 Requires <code>mut</code> to exist on the account.\n///                 <br><br>\n///                 Example:\n///                 <pre><code>\n/// #[account(mut, close = receiver)]\n/// pub data_account: Account<'info, MyData>,\n/// #[account(mut)]\n/// pub receiver: SystemAccount<'info>\n///                 </code></pre>\n///             </td>\n///         </tr>\n///         <tr>\n///             <td>\n///                 <code>#[account(constraint = &lt;expr&gt;)]</code><br><br><code>#[account(constraint = &lt;expr&gt; @ &lt;custom_error&gt;)]</code>\n///             </td>\n///             <td>\n///                 Constraint that checks whether the given expression evaluates to true.<br>\n///                 Use this when no other constraint fits your use case.\n///                 <br><br>\n///                 Example:\n///                 <pre><code>\n/// #[account(constraint = one.keys[0].age == two.apple.age)]\n/// pub one: Account<'info, MyData>,\n/// pub two: Account<'info, OtherData>\n///                 </code></pre>\n///             </td>\n///         </tr>\n///         <tr>\n///             <td>\n///                 <code>#[account(realloc = &lt;space&gt;, realloc::payer = &lt;target&gt;, realloc::zero = &lt;bool&gt;)]</code>\n///             </td>\n///             <td>\n///                 Used to <a href=\"https://docs.rs/solana-program/latest/solana_program/account_info/struct.AccountInfo.html#method.realloc\" target = \"_blank\" rel = \"noopener noreferrer\">realloc</a>\n///                 program account space at the beginning of an instruction.\n///                 <br><br>\n///                 The account must be marked as <code>mut</code> and applied to either <code>Account</code> or <code>AccountLoader</code> types.\n///                 <br><br>\n///                 If the change in account data length is additive, lamports will be transferred from the <code>realloc::payer</code> into the\n///                 program account in order to maintain rent exemption. Likewise, if the change is subtractive, lamports will be transferred from\n///                 the program account back into the <code>realloc::payer</code>.\n///                 <br><br>\n///                 The <code>realloc::zero</code> constraint is required in order to determine whether the new memory should be zero initialized after\n///                 reallocation. Please read the documentation on the <code>AccountInfo::realloc</code> function linked above to understand the\n///                 caveats regarding compute units when providing <code>true</code or <code>false</code> to this flag.\n///                 <br><br>\n///                 The manual use of `AccountInfo::realloc` is discouraged in favor of the `realloc` constraint group due to the lack of native runtime checks\n///                 to prevent reallocation over the `MAX_PERMITTED_DATA_INCREASE` limit (which can unintentionally cause account data overwrite other accounts).\n///                 The constraint group also ensure account reallocation idempotency but checking and restricting duplicate account reallocation within a single ix.\n///                 <br><br>\n///                 Example:\n///                 <pre>\n/// #[derive(Accounts)]\n/// pub struct Example {\n///     #[account(mut)]\n///     pub payer: Signer<'info>,\n///     #[account(\n///         mut,\n///         seeds = [b\"example\"],\n///         bump,\n///         realloc = 8 + std::mem::size_of::<MyType>() + 100,\n///         realloc::payer = payer,\n///         realloc::zero = false,\n///     )]\n///     pub acc: Account<'info, MyType>,\n///     pub system_program: Program<'info, System>,\n/// }\n///                 </pre>\n///             </td>\n///         </tr>\n///     </tbody>\n/// </table>\n///\n/// # SPL Constraints\n///\n/// Anchor provides constraints that make verifying SPL accounts easier.\n///\n/// <table>\n///     <thead>\n///         <tr>\n///             <th>Attribute</th>\n///             <th>Description</th>\n///         </tr>\n///     </thead>\n///     <tbody>\n///         <tr>\n///             <td>\n///                 <code>#[account(token::mint = &lt;target_account&gt;, token::authority = &lt;target_account&gt;)]</code>\n///             <br><br>\n///                 <code>#[account(token::mint = &lt;target_account&gt;, token::authority = &lt;target_account&gt;, token::token_program = &lt;target_account&gt;)]</code>\n///             </td>\n///             <td>\n///                 Can be used as a check or with <code>init</code> to create a token\n///                 account with the given mint address and authority.<br>\n///                  When used as a check, it's possible to only specify a subset of the constraints.\n///                 <br><br>\n///                 Example:\n///                 <pre>\n/// use anchor_spl::{mint, token::{TokenAccount, Mint, Token}};\n/// ...&#10;\n/// #[account(\n///     init,\n///     payer = payer,\n///     token::mint = mint,\n///     token::authority = payer,\n/// )]\n/// pub token: Account<'info, TokenAccount>,\n/// #[account(address = mint::USDC)]\n/// pub mint: Account<'info, Mint>,\n/// #[account(mut)]\n/// pub payer: Signer<'info>,\n/// pub token_program: Program<'info, Token>,\n/// pub system_program: Program<'info, System>\n///                 </pre>\n///             </td>\n///         </tr>\n///         <tr>\n///             <td>\n///                 <code>#[account(mint::authority = &lt;target_account&gt;, mint::decimals = &lt;expr&gt;)]</code>\n///                 <br><br>\n///                 <code>#[account(mint::authority = &lt;target_account&gt;, mint::decimals = &lt;expr&gt;, mint::freeze_authority = &lt;target_account&gt;)]</code>\n///             </td>\n///             <td>\n///                 Can be used as a check or with <code>init</code> to create a mint\n///                 account with the given mint decimals and mint authority.<br>\n///                 The freeze authority is optional when used with <code>init</code>.<br>\n///                 When used as a check, it's possible to only specify a subset of the constraints.\n///                 <br><br>\n///                 Example:\n///                 <pre>\n/// use anchor_spl::token::{Mint, Token};\n/// ...&#10;\n/// #[account(\n///     init,\n///     payer = payer,\n///     mint::decimals = 9,\n///     mint::authority = payer,\n/// )]\n/// pub mint_one: Account<'info, Mint>,\n/// #[account(\n///     init,\n///     payer = payer,\n///     mint::decimals = 9,\n///     mint::authority = payer,\n///     mint::freeze_authority = payer\n/// )]\n/// pub mint_two: Account<'info, Mint>,\n/// #[account(mut)]\n/// pub payer: Signer<'info>,\n/// pub token_program: Program<'info, Token>,\n/// pub system_program: Program<'info, System>\n///                 </pre>\n///             </td>\n///         </tr>\n///         <tr>\n///             <td>\n///                 <code>#[account(associated_token::mint = &lt;target_account&gt;, associated_token::authority = &lt;target_account&gt;)]</code>\n///                <br><br>\n///                 <code>#[account(associated_token::mint = &lt;target_account&gt;, associated_token::authority = &lt;target_account&gt;, associated_token::token_program = &lt;target_account&gt;)]</code>\n///             </td>\n///             <td>\n///                 Can be used as a standalone as a check or with <code>init</code> to create an associated token\n///                 account with the given mint address and authority.\n///                 <br><br>\n///                 Example:\n///                 <pre>\n/// use anchor_spl::{\n///     associated_token::AssociatedToken,\n///     mint,\n///     token::{TokenAccount, Mint, Token}\n/// };\n/// ...&#10;\n/// #[account(\n///     init,\n///     payer = payer,\n///     associated_token::mint = mint,\n///     associated_token::authority = payer,\n/// )]\n/// pub token: Account<'info, TokenAccount>,\n/// #[account(\n///     associated_token::mint = mint,\n///     associated_token::authority = payer,\n/// )]\n/// pub second_token: Account<'info, TokenAccount>,\n/// #[account(address = mint::USDC)]\n/// pub mint: Account<'info, Mint>,\n/// #[account(mut)]\n/// pub payer: Signer<'info>,\n/// pub token_program: Program<'info, Token>,\n/// pub associated_token_program: Program<'info, AssociatedToken>,\n/// pub system_program: Program<'info, System>\n///                 </pre>\n///             </td>\n///         </tr><tr>\n///             <td>\n///                 <code>#[account(*::token_program = &lt;target_account&gt;)]</code>\n///             </td>\n///             <td>\n///                 The <code>token_program</code> can optionally be overridden.\n///                 <br><br>\n///                 Example:\n///                 <pre>\n/// use anchor_spl::token_interface::{TokenInterface, TokenAccount, Mint};\n/// ...&#10;\n/// #[account(\n///     mint::token_program = token_a_token_program,\n/// )]\n/// pub token_a_mint: InterfaceAccount<'info, Mint>,\n/// #[account(\n///     mint::token_program = token_b_token_program,\n/// )]\n/// pub token_b_mint: InterfaceAccount<'info, Mint>,\n/// #[account(\n///     init,\n///     payer = payer,\n///     token::mint = token_a_mint,\n///     token::authority = payer,\n///     token::token_program = token_a_token_program,\n/// )]\n/// pub token_a_account: InterfaceAccount<'info, TokenAccount>,\n/// #[account(\n///     init,\n///     payer = payer,\n///     token::mint = token_b_mint,\n///     token::authority = payer,\n///     token::token_program = token_b_token_program,\n/// )]\n/// pub token_b_account: InterfaceAccount<'info, TokenAccount>,\n/// pub token_a_token_program: Interface<'info, TokenInterface>,\n/// pub token_b_token_program: Interface<'info, TokenInterface>,\n/// #[account(mut)]\n/// pub payer: Signer<'info>,\n/// pub system_program: Program<'info, System>\n///                 </pre>\n///             </td>\n///         </tr>\n///     <tbody>\n/// </table>\n#[proc_macro_derive(Accounts, attributes(account, instruction))]\npub fn derive_accounts(item: TokenStream) -> TokenStream {\n    parse_macro_input!(item as anchor_syn::AccountsStruct)\n        .to_token_stream()\n        .into()\n}",
    "pub fn gen_lazy(input: proc_macro::TokenStream) -> syn::Result<proc_macro2::TokenStream> {\n    let item = syn::parse::<Item>(input)?;\n    let (name, generics, size, sized) = match &item {\n        Item::Struct(strct) => (\n            &strct.ident,\n            &strct.generics,\n            sum_fields(&strct.fields),\n            strct\n                .fields\n                .iter()\n                .map(|field| &field.ty)\n                .map(|ty| quote! { <#ty as anchor_lang::__private::Lazy>::SIZED })\n                .fold(quote!(true), |acc, sized| quote! { #acc && #sized }),\n        ),\n        Item::Enum(enm) => {\n            let arms = enm\n                .variants\n                .iter()\n                .map(|variant| sum_fields(&variant.fields))\n                .enumerate()\n                .map(|(i, size)| (Literal::usize_unsuffixed(i), size))\n                .map(|(i, size)| quote! { Some(#i) => { #size } });\n\n            (\n                &enm.ident,\n                &enm.generics,\n                quote! {\n                    1 + match buf.first() {\n                        #(#arms,)*\n                        _ => unreachable!(),\n                    }\n                },\n                quote!(false),\n            )\n        }",
    "pub fn anchor_serialize(input: TokenStream) -> TokenStream {\n    #[cfg(not(feature = \"idl-build\"))]\n    let ret = gen_borsh_serialize(input);\n    #[cfg(feature = \"idl-build\")]\n    let ret = gen_borsh_serialize(input.clone());\n\n    #[cfg(feature = \"idl-build\")]\n    {\n        use anchor_syn::idl::*;\n        use quote::quote;\n\n        let idl_build_impl = match syn::parse(input).unwrap() {\n            Item::Struct(item) => impl_idl_build_struct(&item),\n            Item::Enum(item) => impl_idl_build_enum(&item),\n            Item::Union(item) => impl_idl_build_union(&item),\n            // Derive macros can only be defined on structs, enums, and unions.\n            _ => unreachable!(),\n        };\n\n        return TokenStream::from(quote! {\n            #ret\n            #idl_build_impl\n        });\n    };\n\n    #[allow(unreachable_code)]\n    TokenStream::from(ret)\n}",
    "pub fn borsh_deserialize(input: TokenStream) -> TokenStream {\n    #[cfg(feature = \"lazy-account\")]\n    {\n        let deser = gen_borsh_deserialize(input.clone());\n        let lazy = lazy::gen_lazy(input).unwrap_or_else(|e| e.to_compile_error());\n        quote::quote! {\n            #deser\n            #lazy\n        }\n        .into()\n    }",
    "pub fn lazy(input: TokenStream) -> TokenStream {\n    lazy::gen_lazy(input)\n        .unwrap_or_else(|e| e.to_compile_error())\n        .into()\n}",
    "pub fn derive_init_space(item: TokenStream) -> TokenStream {\n    let input = parse_macro_input!(item as DeriveInput);\n    let (impl_generics, ty_generics, where_clause) = input.generics.split_for_impl();\n    let name = input.ident;\n\n    let process_struct_fields = |fields: Punctuated<Field, Comma>| {\n        let recurse = fields.into_iter().map(|f| {\n            let mut max_len_args = get_max_len_args(&f.attrs);\n            len_from_type(f.ty, &mut max_len_args)\n        }",
    "pub fn new(inner: T) -> Self {\n        Self { inner, pos: 0 }\n    }\n}\n\nimpl Write for BpfWriter<&mut [u8]> {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        if self.pos >= self.inner.len() as u64 {\n            return Ok(0);\n        }\n\n        let amt = cmp::min(\n            self.inner.len().saturating_sub(self.pos as usize),\n            buf.len(),\n        );\n        sol_memcpy(&mut self.inner[(self.pos as usize)..], buf, amt);\n        self.pos += amt as u64;\n        Ok(amt)\n    }",
    "pub fn is_closed(info: &AccountInfo) -> bool {\n    info.owner == &System::id() && info.data_is_empty()\n}",
    "pub fn set_data(ctx: Context<SetData>, age: u64, other_data: u32) -> Result<()> {\n///     // Set account data like this\n///     (*ctx.accounts.my_account).age = age;\n///     (*ctx.accounts.my_account).other_data = other_data;\n///     // or like this\n///     let my_account = &mut ctx.account.my_account;\n///     my_account.age = age;\n///     my_account.other_data = other_data;\n///     Ok(())\n/// }\n/// ```\npub struct Context<'a, 'b, 'c, 'info, T: Bumps> {\n    /// Currently executing program id.\n    pub program_id: &'a Pubkey,\n    /// Deserialized accounts.\n    pub accounts: &'b mut T,\n    /// Remaining accounts given but not deserialized or validated.\n    /// Be very careful when using this directly.\n    pub remaining_accounts: &'c [AccountInfo<'info>],\n    /// Bump seeds found during constraint validation. This is provided as a\n    /// convenience so that handlers don't have to recalculate bump seeds or\n    /// pass them in as arguments.\n    /// Type is the bumps struct generated by #[derive(Accounts)]\n    pub bumps: T::Bumps,\n}\n\nimpl<T> fmt::Debug for Context<'_, '_, '_, '_, T>\nwhere\n    T: fmt::Debug + Bumps,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"Context\")\n            .field(\"program_id\", &self.program_id)\n            .field(\"accounts\", &self.accounts)\n            .field(\"remaining_accounts\", &self.remaining_accounts)\n            .field(\"bumps\", &self.bumps)\n            .finish()\n    }",
    "pub fn log(&self) {\n        match self {\n            Error::ProgramError(program_error) => program_error.log(),\n            Error::AnchorError(anchor_error) => anchor_error.log(),\n        }\n    }\n\n    pub fn with_account_name(mut self, account_name: impl ToString) -> Self {\n        match &mut self {\n            Error::AnchorError(ae) => {\n                ae.error_origin = Some(ErrorOrigin::AccountName(account_name.to_string()));\n            }\n            Error::ProgramError(pe) => {\n                pe.error_origin = Some(ErrorOrigin::AccountName(account_name.to_string()));\n            }\n        };\n        self\n    }\n\n    pub fn with_source(mut self, source: Source) -> Self {\n        match &mut self {\n            Error::AnchorError(ae) => {\n                ae.error_origin = Some(ErrorOrigin::Source(source));\n            }\n            Error::ProgramError(pe) => {\n                pe.error_origin = Some(ErrorOrigin::Source(source));\n            }\n        };\n        self\n    }\n\n    pub fn with_pubkeys(mut self, pubkeys: (Pubkey, Pubkey)) -> Self {\n        let pubkeys = Some(ComparedValues::Pubkeys((pubkeys.0, pubkeys.1)));\n        match &mut self {\n            Error::AnchorError(ae) => ae.compared_values = pubkeys,\n            Error::ProgramError(pe) => pe.compared_values = pubkeys,\n        };\n        self\n    }\n\n    pub fn with_values(mut self, values: (impl ToString, impl ToString)) -> Self {\n        match &mut self {\n            Error::AnchorError(ae) => {\n                ae.compared_values = Some(ComparedValues::Values((\n                    values.0.to_string(),\n                    values.1.to_string(),\n                )))\n            }",
    "pub fn log(&self) {\n        match &self.error_origin {\n            None => {\n                anchor_lang::solana_program::msg!(\n                    \"ProgramError occurred. Error Code: {:?}. Error Number: {}. Error Message: {}.\",\n                    self.program_error,\n                    u64::from(self.program_error.clone()),\n                    self.program_error\n                );\n            }\n            Some(ErrorOrigin::Source(source)) => {\n                anchor_lang::solana_program::msg!(\n                    \"ProgramError thrown in {}:{}. Error Code: {:?}. Error Number: {}. Error Message: {}.\",\n                    source.filename,\n                    source.line,\n                    self.program_error,\n                    u64::from(self.program_error.clone()),\n                    self.program_error\n                );\n            }\n            Some(ErrorOrigin::AccountName(account_name)) => {\n                // using sol_log because msg! wrongly interprets 5 inputs as u64\n                anchor_lang::solana_program::log::sol_log(&format!(\n                    \"ProgramError caused by account: {}. Error Code: {:?}. Error Number: {}. Error Message: {}.\",\n                    account_name,\n                    self.program_error,\n                    u64::from(self.program_error.clone()),\n                    self.program_error\n                ));\n            }\n        }\n        match &self.compared_values {\n            Some(ComparedValues::Pubkeys((left, right))) => {\n                anchor_lang::solana_program::msg!(\"Left:\");\n                left.log();\n                anchor_lang::solana_program::msg!(\"Right:\");\n                right.log();\n            }\n            Some(ComparedValues::Values((left, right))) => {\n                anchor_lang::solana_program::msg!(\"Left: {}\", left);\n                anchor_lang::solana_program::msg!(\"Right: {}\", right);\n            }\n            None => (),\n        }\n    }\n\n    pub fn with_source(mut self, source: Source) -> Self {\n        self.error_origin = Some(ErrorOrigin::Source(source));\n        self\n    }\n\n    pub fn with_account_name(mut self, account_name: impl ToString) -> Self {\n        self.error_origin = Some(ErrorOrigin::AccountName(account_name.to_string()));\n        self\n    }\n}\n\nimpl From<ProgramError> for ProgramErrorWithOrigin {\n    fn from(program_error: ProgramError) -> Self {\n        Self {\n            program_error,\n            error_origin: None,\n            compared_values: None,\n        }\n    }\n}\n\n#[derive(Debug)]\npub enum ComparedValues {\n    Values((String, String)),\n    Pubkeys((Pubkey, Pubkey)),\n}\n\n#[derive(Debug)]\npub enum ErrorOrigin {\n    Source(Source),\n    AccountName(String),\n}\n\n#[derive(Debug)]\npub struct AnchorError {\n    pub error_name: String,\n    pub error_code_number: u32,\n    pub error_msg: String,\n    pub error_origin: Option<ErrorOrigin>,\n    pub compared_values: Option<ComparedValues>,\n}\n\nimpl AnchorError {\n    pub fn log(&self) {\n        match &self.error_origin {\n            None => {\n                anchor_lang::solana_program::log::sol_log(&format!(\n                    \"AnchorError occurred. Error Code: {}. Error Number: {}. Error Message: {}.\",\n                    self.error_name, self.error_code_number, self.error_msg\n                ));\n            }\n            Some(ErrorOrigin::Source(source)) => {\n                anchor_lang::solana_program::msg!(\n                    \"AnchorError thrown in {}:{}. Error Code: {}. Error Number: {}. Error Message: {}.\",\n                    source.filename,\n                    source.line,\n                    self.error_name,\n                    self.error_code_number,\n                    self.error_msg\n                );\n            }\n            Some(ErrorOrigin::AccountName(account_name)) => {\n                anchor_lang::solana_program::log::sol_log(&format!(\n                    \"AnchorError caused by account: {}. Error Code: {}. Error Number: {}. Error Message: {}.\",\n                    account_name,\n                    self.error_name,\n                    self.error_code_number,\n                    self.error_msg\n                ));\n            }\n        }\n        match &self.compared_values {\n            Some(ComparedValues::Pubkeys((left, right))) => {\n                anchor_lang::solana_program::msg!(\"Left:\");\n                left.log();\n                anchor_lang::solana_program::msg!(\"Right:\");\n                right.log();\n            }\n            Some(ComparedValues::Values((left, right))) => {\n                anchor_lang::solana_program::msg!(\"Left: {}\", left);\n                anchor_lang::solana_program::msg!(\"Right: {}\", right);\n            }\n            None => (),\n        }\n    }\n\n    pub fn with_source(mut self, source: Source) -> Self {\n        self.error_origin = Some(ErrorOrigin::Source(source));\n        self\n    }\n\n    pub fn with_account_name(mut self, account_name: impl ToString) -> Self {\n        self.error_origin = Some(ErrorOrigin::AccountName(account_name.to_string()));\n        self\n    }\n}\n\nimpl Display for AnchorError {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        Debug::fmt(&self, f)\n    }",
    "pub fn address(program_id: &Pubkey) -> Pubkey {\n        let program_signer = Pubkey::find_program_address(&[], program_id).0;\n        Pubkey::create_with_seed(&program_signer, IdlAccount::seed(), program_id)\n            .expect(\"Seed is always valid\")\n    }",
    "pub fn set_data(ctx: Context<SetData>, data: u64) -> Result<()> {\n///     require!(ctx.accounts.data.mutation_allowed, MyError::MutationForbidden);\n///     ctx.accounts.data.data = data;\n///     Ok(())\n/// }\n///\n/// // An enum for custom error codes\n/// #[error_code]\n/// pub enum MyError {\n///     MutationForbidden\n/// }\n///\n/// // An account definition\n/// #[account]\n/// #[derive(Default)]\n/// pub struct MyData {\n///     mutation_allowed: bool,\n///     data: u64\n/// }\n///\n/// // An account validation struct\n/// #[derive(Accounts)]\n/// pub struct SetData<'info> {\n///     #[account(mut)]\n///     pub data: Account<'info, MyData>\n/// }\n/// ```\n#[macro_export]\nmacro_rules! require {\n    ($invariant:expr, $error:tt $(,)?) => {\n        if !($invariant) {\n            return Err(anchor_lang::error!($crate::ErrorCode::$error));\n        }\n    };\n    ($invariant:expr, $error:expr $(,)?) => {\n        if !($invariant) {\n            return Err(anchor_lang::error!($error));\n        }\n    };\n}\n\n/// Ensures two NON-PUBKEY values are equal.\n///\n/// Use [require_keys_eq](crate::prelude::require_keys_eq)\n/// to compare two pubkeys.\n///\n/// Can be used with or without a custom error code.\n///\n/// # Example\n/// ```rust,ignore\n/// pub fn set_data(ctx: Context<SetData>, data: u64) -> Result<()> {\n///     require_eq!(ctx.accounts.data.data, 0);\n///     ctx.accounts.data.data = data;\n///     Ok(())\n/// }\n/// ```\n#[macro_export]\nmacro_rules! require_eq {\n    ($value1: expr, $value2: expr, $error_code:expr $(,)?) => {\n        if $value1 != $value2 {\n            return Err(error!($error_code).with_values(($value1, $value2)));\n        }\n    };\n    ($value1: expr, $value2: expr $(,)?) => {\n        if $value1 != $value2 {\n            return Err(error!(anchor_lang::error::ErrorCode::RequireEqViolated)\n                .with_values(($value1, $value2)));\n        }\n    };\n}\n\n/// Ensures two NON-PUBKEY values are not equal.\n///\n/// Use [require_keys_neq](crate::prelude::require_keys_neq)\n/// to compare two pubkeys.\n///\n/// Can be used with or without a custom error code.\n///\n/// # Example\n/// ```rust,ignore\n/// pub fn set_data(ctx: Context<SetData>, data: u64) -> Result<()> {\n///     require_neq!(ctx.accounts.data.data, 0);\n///     ctx.accounts.data.data = data;\n///     Ok(());\n/// }\n/// ```\n#[macro_export]\nmacro_rules! require_neq {\n    ($value1: expr, $value2: expr, $error_code: expr $(,)?) => {\n        if $value1 == $value2 {\n            return Err(error!($error_code).with_values(($value1, $value2)));\n        }\n    };\n    ($value1: expr, $value2: expr $(,)?) => {\n        if $value1 == $value2 {\n            return Err(error!(anchor_lang::error::ErrorCode::RequireNeqViolated)\n                .with_values(($value1, $value2)));\n        }\n    };\n}\n\n/// Ensures two pubkeys values are equal.\n///\n/// Use [require_eq](crate::prelude::require_eq)\n/// to compare two non-pubkey values.\n///\n/// Can be used with or without a custom error code.\n///\n/// # Example\n/// ```rust,ignore\n/// pub fn set_data(ctx: Context<SetData>, data: u64) -> Result<()> {\n///     require_keys_eq!(ctx.accounts.data.authority.key(), ctx.accounts.authority.key());\n///     ctx.accounts.data.data = data;\n///     Ok(())\n/// }\n/// ```\n#[macro_export]\nmacro_rules! require_keys_eq {\n    ($value1: expr, $value2: expr, $error_code:expr $(,)?) => {\n        if $value1 != $value2 {\n            return Err(error!($error_code).with_pubkeys(($value1, $value2)));\n        }\n    };\n    ($value1: expr, $value2: expr $(,)?) => {\n        if $value1 != $value2 {\n            return Err(error!(anchor_lang::error::ErrorCode::RequireKeysEqViolated)\n                .with_pubkeys(($value1, $value2)));\n        }\n    };\n}\n\n/// Ensures two pubkeys are not equal.\n///\n/// Use [require_neq](crate::prelude::require_neq)\n/// to compare two non-pubkey values.\n///\n/// Can be used with or without a custom error code.\n///\n/// # Example\n/// ```rust,ignore\n/// pub fn set_data(ctx: Context<SetData>, data: u64) -> Result<()> {\n///     require_keys_neq!(ctx.accounts.data.authority.key(), ctx.accounts.other.key());\n///     ctx.accounts.data.data = data;\n///     Ok(())\n/// }\n/// ```\n#[macro_export]\nmacro_rules! require_keys_neq {\n    ($value1: expr, $value2: expr, $error_code: expr $(,)?) => {\n        if $value1 == $value2 {\n            return Err(error!($error_code).with_pubkeys(($value1, $value2)));\n        }\n    };\n    ($value1: expr, $value2: expr $(,)?) => {\n        if $value1 == $value2 {\n            return Err(\n                error!(anchor_lang::error::ErrorCode::RequireKeysNeqViolated)\n                    .with_pubkeys(($value1, $value2)),\n            );\n        }\n    };\n}\n\n/// Ensures the first NON-PUBKEY value is greater than the second\n/// NON-PUBKEY value.\n///\n/// To include an equality check, use [require_gte](crate::require_gte).\n///\n/// Can be used with or without a custom error code.\n///\n/// # Example\n/// ```rust,ignore\n/// pub fn set_data(ctx: Context<SetData>, data: u64) -> Result<()> {\n///     require_gt!(ctx.accounts.data.data, 0);\n///     ctx.accounts.data.data = data;\n///     Ok(());\n/// }\n/// ```\n#[macro_export]\nmacro_rules! require_gt {\n    ($value1: expr, $value2: expr, $error_code: expr $(,)?) => {\n        if $value1 <= $value2 {\n            return Err(error!($error_code).with_values(($value1, $value2)));\n        }\n    };\n    ($value1: expr, $value2: expr $(,)?) => {\n        if $value1 <= $value2 {\n            return Err(error!(anchor_lang::error::ErrorCode::RequireGtViolated)\n                .with_values(($value1, $value2)));\n        }\n    };\n}\n\n/// Ensures the first NON-PUBKEY value is greater than or equal\n/// to the second NON-PUBKEY value.\n///\n/// Can be used with or without a custom error code.\n///\n/// # Example\n/// ```rust,ignore\n/// pub fn set_data(ctx: Context<SetData>, data: u64) -> Result<()> {\n///     require_gte!(ctx.accounts.data.data, 1);\n///     ctx.accounts.data.data = data;\n///     Ok(());\n/// }\n/// ```\n#[macro_export]\nmacro_rules! require_gte {\n    ($value1: expr, $value2: expr, $error_code: expr $(,)?) => {\n        if $value1 < $value2 {\n            return Err(error!($error_code).with_values(($value1, $value2)));\n        }\n    };\n    ($value1: expr, $value2: expr $(,)?) => {\n        if $value1 < $value2 {\n            return Err(error!(anchor_lang::error::ErrorCode::RequireGteViolated)\n                .with_values(($value1, $value2)));\n        }\n    };\n}\n\n/// Returns with the given error.\n/// Use this with a custom error type.\n///\n/// # Example\n/// ```ignore\n/// // Instruction function\n/// pub fn example(ctx: Context<Example>) -> Result<()> {\n///     err!(MyError::SomeError)\n/// }\n///\n/// // An enum for custom error codes\n/// #[error_code]\n/// pub enum MyError {\n///     SomeError\n/// }\n/// ```\n#[macro_export]\nmacro_rules! err {\n    ($error:tt $(,)?) => {\n        Err(anchor_lang::error!($crate::ErrorCode::$error))\n    }",
    "pub fn set_data(ctx: Context<SetData>, data: u64) -> Result<()> {\n///         if (*ctx.accounts.auth_account).authorized {\n///             (*ctx.accounts.my_account).data = data;\n///         }\n///         Ok(())\n///     }\n/// }\n///\n/// #[account]\n/// #[derive(Default)]\n/// pub struct MyData {\n///     pub data: u64\n/// }\n///\n/// #[derive(Accounts)]\n/// pub struct SetData<'info> {\n///     #[account(mut)]\n///     pub my_account: Account<'info, MyData> // checks that my_account.info.owner == Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS\n///     pub auth_account: Account<'info, Auth> // checks that auth_account.info.owner == FEZGUxNhZWpYPj9MJCrZJvUo1iF9ys34UHx52y4SzVW9\n/// }\n///\n/// // In a different program\n///\n/// ...\n/// declare_id!(\"FEZGUxNhZWpYPj9MJCrZJvUo1iF9ys34UHx52y4SzVW9\");\n/// #[account]\n/// #[derive(Default)]\n/// pub struct Auth {\n///     pub authorized: bool\n/// }\n/// ...\n/// ```\n///\n/// # Using Account with non-anchor programs\n///\n/// Account can also be used with non-anchor programs. The data types from\n/// those programs are not annotated with `#[account]` so you have to\n/// - create a wrapper type around the structs you want to wrap with Account\n/// - implement the functions required by Account yourself\n///\n/// instead of using `#[account]`. You only have to implement a fraction of the\n/// functions `#[account]` generates. See the example below for the code you have\n/// to write.\n///\n/// The mint wrapper type that Anchor provides out of the box for the token program ([source](https://github.com/coral-xyz/anchor/blob/master/spl/src/token.rs))\n/// ```ignore\n/// #[derive(Clone)]\n/// pub struct Mint(spl_token::state::Mint);\n///\n/// // This is necessary so we can use \"anchor_spl::token::Mint::LEN\"\n/// // because rust does not resolve \"anchor_spl::token::Mint::LEN\" to\n/// // \"spl_token::state::Mint::LEN\" automatically\n/// impl Mint {\n///     pub const LEN: usize = spl_token::state::Mint::LEN;\n/// }\n///\n/// // You don't have to implement the \"try_deserialize\" function\n/// // from this trait. It delegates to\n/// // \"try_deserialize_unchecked\" by default which is what we want here\n/// // because non-anchor accounts don't have a discriminator to check\n/// impl anchor_lang::AccountDeserialize for Mint {\n///     fn try_deserialize_unchecked(buf: &mut &[u8]) -> Result<Self> {\n///         spl_token::state::Mint::unpack(buf).map(Mint)\n///     }\n/// }\n/// // AccountSerialize defaults to a no-op which is what we want here\n/// // because it's a foreign program, so our program does not\n/// // have permission to write to the foreign program's accounts anyway\n/// impl anchor_lang::AccountSerialize for Mint {}\n///\n/// impl anchor_lang::Owner for Mint {\n///     fn owner() -> Pubkey {\n///         // pub use spl_token::ID is used at the top of the file\n///         ID\n///     }\n/// }\n///\n/// // Implement the \"std::ops::Deref\" trait for better user experience\n/// impl Deref for Mint {\n///     type Target = spl_token::state::Mint;\n///\n///     fn deref(&self) -> &Self::Target {\n///         &self.0\n///     }\n/// }\n/// ```\n///\n/// ## Out of the box wrapper types\n///\n/// ### Accessing BPFUpgradeableLoader Data\n///\n/// Anchor provides wrapper types to access data stored in programs owned by the BPFUpgradeableLoader\n/// such as the upgrade authority. If you're interested in the data of a program account, you can use\n/// ```ignore\n/// Account<'info, BpfUpgradeableLoaderState>\n/// ```\n/// and then match on its contents inside your instruction function.\n///\n/// Alternatively, you can use\n/// ```ignore\n/// Account<'info, ProgramData>\n/// ```\n/// to let anchor do the matching for you and return the ProgramData variant of BpfUpgradeableLoaderState.\n///\n/// # Example\n/// ```ignore\n/// use anchor_lang::prelude::*;\n/// use crate::program::MyProgram;\n///\n/// declare_id!(\"Cum9tTyj5HwcEiAmhgaS7Bbj4UczCwsucrCkxRECzM4e\");\n///\n/// #[program]\n/// pub mod my_program {\n///     use super::*;\n///\n///     pub fn set_initial_admin(\n///         ctx: Context<SetInitialAdmin>,\n///         admin_key: Pubkey\n///     ) -> Result<()> {\n///         ctx.accounts.admin_settings.admin_key = admin_key;\n///         Ok(())\n///     }\n///\n///     pub fn set_admin(...){...}\n///\n///     pub fn set_settings(...){...}\n/// }\n///\n/// #[account]\n/// #[derive(Default, Debug)]\n/// pub struct AdminSettings {\n///     admin_key: Pubkey\n/// }\n///\n/// #[derive(Accounts)]\n/// pub struct SetInitialAdmin<'info> {\n///     #[account(init, payer = authority, seeds = [b\"admin\"], bump)]\n///     pub admin_settings: Account<'info, AdminSettings>,\n///     #[account(mut)]\n///     pub authority: Signer<'info>,\n///     #[account(constraint = program.programdata_address()? == Some(program_data.key()))]\n///     pub program: Program<'info, MyProgram>,\n///     #[account(constraint = program_data.upgrade_authority_address == Some(authority.key()))]\n///     pub program_data: Account<'info, ProgramData>,\n///     pub system_program: Program<'info, System>,\n/// }\n/// ```\n///\n/// This example solves a problem you may face if your program has admin settings: How do you set the\n/// admin key for restricted functionality after deployment? Setting the admin key itself should\n/// be a restricted action but how do you restrict it without having set an admin key?\n/// You're stuck in a loop.\n/// One solution is to use the upgrade authority of the program as the initial\n/// (or permanent) admin key.\n///\n/// ### SPL Types\n///\n/// Anchor provides wrapper types to access accounts owned by the token program. Use\n/// ```ignore\n/// use anchor_spl::token::TokenAccount;\n///\n/// #[derive(Accounts)]\n/// pub struct Example {\n///     pub my_acc: Account<'info, TokenAccount>\n/// }\n/// ```\n/// to access token accounts and\n/// ```ignore\n/// use anchor_spl::token::Mint;\n///\n/// #[derive(Accounts)]\n/// pub struct Example {\n///     pub my_acc: Account<'info, Mint>\n/// }\n/// ```\n/// to access mint accounts.\n#[derive(Clone)]\npub struct Account<'info, T: AccountSerialize + AccountDeserialize + Clone> {\n    account: T,\n    info: &'info AccountInfo<'info>,\n}\n\nimpl<T: AccountSerialize + AccountDeserialize + Clone + fmt::Debug> fmt::Debug for Account<'_, T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        self.fmt_with_name(\"Account\", f)\n    }",
    "pub fn reload(&mut self) -> Result<()> {\n        let mut data: &[u8] = &self.info.try_borrow_data()?;\n        self.account = T::try_deserialize(&mut data)?;\n        Ok(())\n    }",
    "pub fn into_inner(self) -> T {\n        self.account\n    }\n\n    /// Sets the inner account.\n    ///\n    /// Instead of this:\n    /// ```ignore\n    /// pub fn new_user(ctx: Context<CreateUser>, new_user:User) -> Result<()> {\n    ///     (*ctx.accounts.user_to_create).name = new_user.name;\n    ///     (*ctx.accounts.user_to_create).age = new_user.age;\n    ///     (*ctx.accounts.user_to_create).address = new_user.address;\n    /// }\n    /// ```\n    /// You can do this:\n    /// ```ignore\n    /// pub fn new_user(ctx: Context<CreateUser>, new_user:User) -> Result<()> {\n    ///     ctx.accounts.user_to_create.set_inner(new_user);\n    /// }\n    /// ```\n    pub fn set_inner(&mut self, inner: T) {\n        self.account = inner;\n    }\n}\n\nimpl<'a, T: AccountSerialize + AccountDeserialize + Owner + Clone> Account<'a, T> {\n    /// Deserializes the given `info` into a `Account`.\n    #[inline(never)]\n    pub fn try_from(info: &'a AccountInfo<'a>) -> Result<Account<'a, T>> {\n        if info.owner == &system_program::ID && info.lamports() == 0 {\n            return Err(ErrorCode::AccountNotInitialized.into());\n        }\n        if info.owner != &T::owner() {\n            return Err(Error::from(ErrorCode::AccountOwnedByWrongProgram)\n                .with_pubkeys((*info.owner, T::owner())));\n        }\n        let mut data: &[u8] = &info.try_borrow_data()?;\n        Ok(Account::new(info, T::try_deserialize(&mut data)?))\n    }",
    "pub fn try_from_unchecked(info: &'a AccountInfo<'a>) -> Result<Account<'a, T>> {\n        if info.owner == &system_program::ID && info.lamports() == 0 {\n            return Err(ErrorCode::AccountNotInitialized.into());\n        }\n        if info.owner != &T::owner() {\n            return Err(Error::from(ErrorCode::AccountOwnedByWrongProgram)\n                .with_pubkeys((*info.owner, T::owner())));\n        }\n        let mut data: &[u8] = &info.try_borrow_data()?;\n        Ok(Account::new(info, T::try_deserialize_unchecked(&mut data)?))\n    }",
    "pub fn create_bar(ctx: Context<CreateBar>, data: u64) -> Result<()> {\n///         let bar = &mut ctx.accounts.bar.load_init()?;\n///         bar.authority = ctx.accounts.authority.key();\n///         bar.data = data;\n///         Ok(())\n///     }\n///\n///     pub fn update_bar(ctx: Context<UpdateBar>, data: u64) -> Result<()> {\n///         (*ctx.accounts.bar.load_mut()?).data = data;\n///         Ok(())\n///     }\n/// }\n///\n/// #[account(zero_copy)]\n/// #[derive(Default)]\n/// pub struct Bar {\n///     authority: Pubkey,\n///     data: u64\n/// }\n///\n/// #[derive(Accounts)]\n/// pub struct CreateBar<'info> {\n///     #[account(\n///         init,\n///         payer = authority\n///     )]\n///     bar: AccountLoader<'info, Bar>,\n///     #[account(mut)]\n///     authority: Signer<'info>,\n///     system_program: AccountInfo<'info>,\n/// }\n///\n/// #[derive(Accounts)]\n/// pub struct UpdateBar<'info> {\n///     #[account(\n///         mut,\n///         has_one = authority,\n///     )]\n///     pub bar: AccountLoader<'info, Bar>,\n///     pub authority: Signer<'info>,\n/// }\n/// ```\n#[derive(Clone)]\npub struct AccountLoader<'info, T: ZeroCopy + Owner> {\n    acc_info: &'info AccountInfo<'info>,\n    phantom: PhantomData<&'info T>,\n}\n\nimpl<T: ZeroCopy + Owner + fmt::Debug> fmt::Debug for AccountLoader<'_, T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"AccountLoader\")\n            .field(\"acc_info\", &self.acc_info)\n            .field(\"phantom\", &self.phantom)\n            .finish()\n    }",
    "pub fn try_from(acc_info: &'info AccountInfo<'info>) -> Result<AccountLoader<'info, T>> {\n        if acc_info.owner != &T::owner() {\n            return Err(Error::from(ErrorCode::AccountOwnedByWrongProgram)\n                .with_pubkeys((*acc_info.owner, T::owner())));\n        }\n\n        let data = &acc_info.try_borrow_data()?;\n        let disc = T::DISCRIMINATOR;\n        if data.len() < disc.len() {\n            return Err(ErrorCode::AccountDiscriminatorNotFound.into());\n        }\n\n        let given_disc = &data[..disc.len()];\n        if given_disc != disc {\n            return Err(ErrorCode::AccountDiscriminatorMismatch.into());\n        }\n\n        Ok(AccountLoader::new(acc_info))\n    }",
    "pub fn try_from_unchecked(\n        _program_id: &Pubkey,\n        acc_info: &'info AccountInfo<'info>,\n    ) -> Result<AccountLoader<'info, T>> {\n        if acc_info.owner != &T::owner() {\n            return Err(Error::from(ErrorCode::AccountOwnedByWrongProgram)\n                .with_pubkeys((*acc_info.owner, T::owner())));\n        }\n        Ok(AccountLoader::new(acc_info))\n    }",
    "pub fn load(&self) -> Result<Ref<T>> {\n        let data = self.acc_info.try_borrow_data()?;\n        let disc = T::DISCRIMINATOR;\n        if data.len() < disc.len() {\n            return Err(ErrorCode::AccountDiscriminatorNotFound.into());\n        }\n\n        let given_disc = &data[..disc.len()];\n        if given_disc != disc {\n            return Err(ErrorCode::AccountDiscriminatorMismatch.into());\n        }\n\n        Ok(Ref::map(data, |data| {\n            bytemuck::from_bytes(&data[disc.len()..mem::size_of::<T>() + disc.len()])\n        }",
    "pub fn load_mut(&self) -> Result<RefMut<T>> {\n        // AccountInfo api allows you to borrow mut even if the account isn't\n        // writable, so add this check for a better dev experience.\n        if !self.acc_info.is_writable {\n            return Err(ErrorCode::AccountNotMutable.into());\n        }\n\n        let data = self.acc_info.try_borrow_mut_data()?;\n        let disc = T::DISCRIMINATOR;\n        if data.len() < disc.len() {\n            return Err(ErrorCode::AccountDiscriminatorNotFound.into());\n        }\n\n        let given_disc = &data[..disc.len()];\n        if given_disc != disc {\n            return Err(ErrorCode::AccountDiscriminatorMismatch.into());\n        }\n\n        Ok(RefMut::map(data, |data| {\n            bytemuck::from_bytes_mut(\n                &mut data.deref_mut()[disc.len()..mem::size_of::<T>() + disc.len()],\n            )\n        }",
    "pub fn load_init(&self) -> Result<RefMut<T>> {\n        // AccountInfo api allows you to borrow mut even if the account isn't\n        // writable, so add this check for a better dev experience.\n        if !self.acc_info.is_writable {\n            return Err(ErrorCode::AccountNotMutable.into());\n        }\n\n        let data = self.acc_info.try_borrow_mut_data()?;\n\n        // The discriminator should be zero, since we're initializing.\n        let disc = T::DISCRIMINATOR;\n        let given_disc = &data[..disc.len()];\n        let has_disc = given_disc.iter().any(|b| *b != 0);\n        if has_disc {\n            return Err(ErrorCode::AccountDiscriminatorAlreadySet.into());\n        }\n\n        Ok(RefMut::map(data, |data| {\n            bytemuck::from_bytes_mut(\n                &mut data.deref_mut()[disc.len()..mem::size_of::<T>() + disc.len()],\n            )\n        }",
    "pub fn programdata_address(&self) -> Result<Option<Pubkey>> {\n        self.0.programdata_address()\n    }",
    "pub fn set_data(ctx: Context<SetData>, data: u64) -> Result<()> {\n///         if (*ctx.accounts.auth_account).authorized {\n///             (*ctx.accounts.my_account).data = data;\n///         }\n///         Ok(())\n///     }\n/// }\n///\n/// #[account]\n/// #[derive(Default)]\n/// pub struct MyData {\n///     pub data: u64\n/// }\n///\n/// #[derive(Accounts)]\n/// pub struct SetData<'info> {\n///     #[account(mut)]\n///     pub my_account: InterfaceAccount<'info, MyData> // checks that my_account.info.owner == Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS\n///     pub auth_account: InterfaceAccount<'info, Auth> // checks that auth_account.info.owner == FEZGUxNhZWpYPj9MJCrZJvUo1iF9ys34UHx52y4SzVW9\n/// }\n///\n/// // In a different program\n///\n/// ...\n/// declare_id!(\"FEZGUxNhZWpYPj9MJCrZJvUo1iF9ys34UHx52y4SzVW9\");\n/// #[account]\n/// #[derive(Default)]\n/// pub struct Auth {\n///     pub authorized: bool\n/// }\n/// ...\n/// ```\n///\n/// # Using InterfaceAccount with non-anchor programs\n///\n/// InterfaceAccount can also be used with non-anchor programs. The data types from\n/// those programs are not annotated with `#[account]` so you have to\n/// - create a wrapper type around the structs you want to wrap with InterfaceAccount\n/// - implement the functions required by InterfaceAccount yourself\n///\n/// instead of using `#[account]`. You only have to implement a fraction of the\n/// functions `#[account]` generates. See the example below for the code you have\n/// to write.\n///\n/// The mint wrapper type that Anchor provides out of the box for the token program ([source](https://github.com/coral-xyz/anchor/blob/master/spl/src/token.rs))\n/// ```ignore\n/// #[derive(Clone)]\n/// pub struct Mint(spl_token::state::Mint);\n///\n/// // This is necessary so we can use \"anchor_spl::token::Mint::LEN\"\n/// // because rust does not resolve \"anchor_spl::token::Mint::LEN\" to\n/// // \"spl_token::state::Mint::LEN\" automatically\n/// impl Mint {\n///     pub const LEN: usize = spl_token::state::Mint::LEN;\n/// }\n///\n/// // You don't have to implement the \"try_deserialize\" function\n/// // from this trait. It delegates to\n/// // \"try_deserialize_unchecked\" by default which is what we want here\n/// // because non-anchor accounts don't have a discriminator to check\n/// impl anchor_lang::AccountDeserialize for Mint {\n///     fn try_deserialize_unchecked(buf: &mut &[u8]) -> Result<Self> {\n///         spl_token::state::Mint::unpack(buf).map(Mint)\n///     }\n/// }\n/// // AccountSerialize defaults to a no-op which is what we want here\n/// // because it's a foreign program, so our program does not\n/// // have permission to write to the foreign program's accounts anyway\n/// impl anchor_lang::AccountSerialize for Mint {}\n///\n/// impl anchor_lang::Owner for Mint {\n///     fn owner() -> Pubkey {\n///         // pub use spl_token::ID is used at the top of the file\n///         ID\n///     }\n/// }\n///\n/// // Implement the \"std::ops::Deref\" trait for better user experience\n/// impl Deref for Mint {\n///     type Target = spl_token::state::Mint;\n///\n///     fn deref(&self) -> &Self::Target {\n///         &self.0\n///     }\n/// }\n/// ```\n///\n/// ## Out of the box wrapper types\n///\n/// ### SPL Types\n///\n/// Anchor provides wrapper types to access accounts owned by the token programs. Use\n/// ```ignore\n/// use anchor_spl::token_interface::TokenAccount;\n///\n/// #[derive(Accounts)]\n/// pub struct Example {\n///     pub my_acc: InterfaceAccount<'info, TokenAccount>\n/// }\n/// ```\n/// to access token accounts and\n/// ```ignore\n/// use anchor_spl::token_interface::Mint;\n///\n/// #[derive(Accounts)]\n/// pub struct Example {\n///     pub my_acc: InterfaceAccount<'info, Mint>\n/// }\n/// ```\n/// to access mint accounts.\n#[derive(Clone)]\npub struct InterfaceAccount<'info, T: AccountSerialize + AccountDeserialize + Clone> {\n    account: Account<'info, T>,\n    // The owner here is used to make sure that changes aren't incorrectly propagated\n    // to an account with a modified owner\n    owner: Pubkey,\n}\n\nimpl<T: AccountSerialize + AccountDeserialize + Clone + fmt::Debug> fmt::Debug\n    for InterfaceAccount<'_, T>\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        self.account.fmt_with_name(\"InterfaceAccount\", f)\n    }",
    "pub fn reload(&mut self) -> Result<()> {\n        self.account.reload()\n    }",
    "pub fn into_inner(self) -> T {\n        self.account.into_inner()\n    }",
    "pub fn new_user(ctx: Context<CreateUser>, new_user:User) -> Result<()> {\n    ///     (*ctx.accounts.user_to_create).name = new_user.name;\n    ///     (*ctx.accounts.user_to_create).age = new_user.age;\n    ///     (*ctx.accounts.user_to_create).address = new_user.address;\n    /// }\n    /// ```\n    /// You can do this:\n    /// ```ignore\n    /// pub fn new_user(ctx: Context<CreateUser>, new_user:User) -> Result<()> {\n    ///     ctx.accounts.user_to_create.set_inner(new_user);\n    /// }\n    /// ```\n    pub fn set_inner(&mut self, inner: T) {\n        self.account.set_inner(inner);\n    }\n}\n\nimpl<'a, T: AccountSerialize + AccountDeserialize + CheckOwner + Clone> InterfaceAccount<'a, T> {\n    /// Deserializes the given `info` into a `InterfaceAccount`.\n    #[inline(never)]\n    pub fn try_from(info: &'a AccountInfo<'a>) -> Result<Self> {\n        if info.owner == &system_program::ID && info.lamports() == 0 {\n            return Err(ErrorCode::AccountNotInitialized.into());\n        }\n        T::check_owner(info.owner)?;\n        let mut data: &[u8] = &info.try_borrow_data()?;\n        Ok(Self::new(info, T::try_deserialize(&mut data)?))\n    }",
    "pub fn try_from_unchecked(info: &'a AccountInfo<'a>) -> Result<Self> {\n        if info.owner == &system_program::ID && info.lamports() == 0 {\n            return Err(ErrorCode::AccountNotInitialized.into());\n        }\n        T::check_owner(info.owner)?;\n        let mut data: &[u8] = &info.try_borrow_data()?;\n        Ok(Self::new(info, T::try_deserialize_unchecked(&mut data)?))\n    }",
    "pub fn init(ctx: Context<Init>) -> Result<()> {\n///         let mut my_account = ctx.accounts.my_account.load_mut()?;\n///         my_account.authority = ctx.accounts.authority.key();\n///\n///         // Fill the dynamic data\n///         for _ in 0..MAX_DATA_LEN {\n///             my_account.dynamic.push(ctx.accounts.authority.key());\n///         }\n///\n///         Ok(())\n///     }\n///\n///     pub fn read(ctx: Context<Read>) -> Result<()> {\n///         // Cached load due to the `has_one` constraint\n///         let authority = ctx.accounts.my_account.load_authority()?;\n///         msg!(\"Authority: {}\", authority);\n///         Ok(())\n///     }\n///\n///     pub fn write(ctx: Context<Write>, new_authority: Pubkey) -> Result<()> {\n///         // Cached load due to the `has_one` constraint\n///         *ctx.accounts.my_account.load_mut_authority()? = new_authority;\n///         Ok(())\n///     }\n/// }\n///\n/// #[derive(Accounts)]\n/// pub struct Init<'info> {\n///     #[account(mut)]\n///     pub authority: Signer<'info>,\n///     #[account(\n///         init,\n///         payer = authority,\n///         space = MyAccount::DISCRIMINATOR.len() + MyAccount::INIT_SPACE\n///     )]\n///     pub my_account: LazyAccount<'info, MyAccount>,\n///     pub system_program: Program<'info, System>,\n/// }\n///\n/// #[derive(Accounts)]\n/// pub struct Read<'info> {\n///     pub authority: Signer<'info>,\n///     #[account(has_one = authority)]\n///     pub my_account: LazyAccount<'info, MyAccount>,\n/// }\n///\n/// #[derive(Accounts)]\n/// pub struct Write<'info> {\n///     pub authority: Signer<'info>,\n///     #[account(mut, has_one = authority)]\n///     pub my_account: LazyAccount<'info, MyAccount>,\n/// }\n///\n/// const MAX_DATA_LEN: usize = 256;\n///\n/// #[account]\n/// #[derive(InitSpace)]\n/// pub struct MyAccount {\n///     pub authority: Pubkey,\n///     pub fixed: [Pubkey; 8],\n///     // Dynamic sized data also works, unlike `AccountLoader`\n///     #[max_len(MAX_DATA_LEN)]\n///     pub dynamic: Vec<Pubkey>,\n/// }\n/// ```\n///\n/// # Safety\n///\n/// The safety checks are done using the account's discriminator and the account's owner (similar\n/// to [`Account`]). However, you should be extra careful when deserializing individual fields if,\n/// for example, the account needs to be migrated. Make sure the previously serialized data always\n/// matches the account's type identically.\n///\n/// # Performance\n///\n/// ## Memory\n///\n/// All fields (including the inner account type) are heap allocated. It only uses 24 bytes (3x\n/// pointer size) of stack memory in total.\n///\n/// It's worth noting that where the account is being deserialized matters. For example, the main\n/// place where Anchor programs are likely to hit stack violation errors is a generated function\n/// called `try_accounts` (you might be familiar with it from the mangled build logs). This is\n/// where the instruction is deserialized and constraints are run. Although having everything at the\n/// same place is convenient for using constraints, this also makes it very easy to use the fixed\n/// amount of stack space (4096 bytes) SVM allocates just by increasing the number of accounts the\n/// instruction has. In SVM, each function has its own stack frame, meaning that it's possible to\n/// deserialize more accounts simply by deserializing them inside other functions (rather than in\n/// `try_accounts` which is already quite heavy).\n///\n/// The mentioned stack limitation can be solved using dynamic stack frames, see [SIMD-0166].\n///\n/// ## Compute units\n///\n/// Compute is harder to formulate, as it varies based on the inner account's type. That being said,\n/// there are a few things you can do to optimize compute units usage when using [`LazyAccount`]:\n///\n/// - Order account fields from fixed-size data (e.g. `u8`, `Pubkey`) to dynamic data (e.g. `Vec`).\n/// - Order account fields based on how frequently the field is accessed (starting with the most\n///   frequent).\n/// - Reduce or limit dynamic fields.\n///\n/// [`borsh`]: crate::prelude::borsh\n/// [`Account`]: crate::prelude::Account\n/// [SIMD-0166]: https://github.com/solana-foundation/solana-improvement-documents/pull/166\npub struct LazyAccount<'info, T>\nwhere\n    T: AccountSerialize + Discriminator + Owner + Clone,\n{\n    /// **INTERNAL FIELD DO NOT USE!**\n    #[doc(hidden)]\n    pub __info: &'info AccountInfo<'info>,\n    /// **INTERNAL FIELD DO NOT USE!**\n    #[doc(hidden)]\n    pub __account: Rc<RefCell<MaybeUninit<T>>>,\n    /// **INTERNAL FIELD DO NOT USE!**\n    #[doc(hidden)]\n    pub __fields: Rc<RefCell<Option<Vec<bool>>>>,\n}\n\nimpl<T> fmt::Debug for LazyAccount<'_, T>\nwhere\n    T: AccountSerialize + Discriminator + Owner + Clone + fmt::Debug,\n{\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.debug_struct(\"LazyAccount\")\n            .field(\"info\", &self.__info)\n            .field(\"account\", &self.__account)\n            .field(\"fields\", &self.__fields)\n            .finish()\n    }",
    "pub fn try_from(info: &'info AccountInfo<'info>) -> Result<LazyAccount<'info, T>> {\n        let data = &info.try_borrow_data()?;\n        let disc = T::DISCRIMINATOR;\n        if data.len() < disc.len() {\n            return Err(ErrorCode::AccountDiscriminatorNotFound.into());\n        }\n\n        let given_disc = &data[..disc.len()];\n        if given_disc != disc {\n            return Err(ErrorCode::AccountDiscriminatorMismatch.into());\n        }\n\n        Self::try_from_unchecked(info)\n    }",
    "pub fn try_from_unchecked(info: &'info AccountInfo<'info>) -> Result<LazyAccount<'info, T>> {\n        if info.owner != &T::owner() {\n            return Err(Error::from(ErrorCode::AccountOwnedByWrongProgram)\n                .with_pubkeys((*info.owner, T::owner())));\n        }\n\n        Ok(LazyAccount::new(info))\n    }",
    "pub fn unload(&self) -> Result<&Self> {\n        // TODO: Should we drop the initialized fields manually?\n        *self.__account.borrow_mut() = MaybeUninit::uninit();\n        *self.__fields.borrow_mut() = None;\n        Ok(self)\n    }",
    "pub fn programdata_address(&self) -> Result<Option<Pubkey>> {\n        if *self.info.owner == bpf_loader_upgradeable::ID {\n            let mut data: &[u8] = &self.info.try_borrow_data()?;\n            let upgradable_loader_state =\n                UpgradeableLoaderState::try_deserialize_unchecked(&mut data)?;\n\n            match upgradable_loader_state {\n                UpgradeableLoaderState::Uninitialized\n                | UpgradeableLoaderState::Buffer {\n                    authority_address: _,\n                }\n                | UpgradeableLoaderState::ProgramData {\n                    slot: _,\n                    upgrade_authority_address: _,\n                } => {\n                    // Unreachable because check in try_from\n                    // ensures that program is executable\n                    // and therefore a program account.\n                    unreachable!()\n                }",
    "pub fn try_from(info: &'info AccountInfo<'info>) -> Result<Signer<'info>> {\n        if !info.is_signer {\n            return Err(ErrorCode::AccountNotSigner.into());\n        }\n        Ok(Signer::new(info))\n    }",
    "pub fn try_from(info: &'info AccountInfo<'info>) -> Result<SystemAccount<'info>> {\n        if *info.owner != system_program::ID {\n            return Err(ErrorCode::AccountNotSystemOwned.into());\n        }\n        Ok(SystemAccount::new(info))\n    }",
    "pub fn from_account_info(acc_info: &'info AccountInfo<'info>) -> Result<Sysvar<'info, T>> {\n        match T::from_account_info(acc_info) {\n            Ok(val) => Ok(Sysvar {\n                info: acc_info,\n                account: val,\n            }),\n            Err(_) => Err(ErrorCode::AccountSysvarMismatch.into()),\n        }\n    }\n}\n\nimpl<T: solana_program::sysvar::Sysvar> Clone for Sysvar<'_, T> {\n    fn clone(&self) -> Self {\n        Self {\n            info: self.info,\n            account: T::from_account_info(self.info).unwrap(),\n        }\n    }\n}\n\nimpl<'info, B, T: solana_program::sysvar::Sysvar> Accounts<'info, B> for Sysvar<'info, T> {\n    fn try_accounts(\n        _program_id: &Pubkey,\n        accounts: &mut &'info [AccountInfo<'info>],\n        _ix_data: &[u8],\n        _bumps: &mut B,\n        _reallocs: &mut BTreeSet<Pubkey>,\n    ) -> Result<Self> {\n        if accounts.is_empty() {\n            return Err(ErrorCode::AccountNotEnoughKeys.into());\n        }\n        let account = &accounts[0];\n        *accounts = &accounts[1..];\n        Sysvar::from_account_info(account)\n    }",
    "pub fn try_from(acc_info: &'info AccountInfo<'info>) -> Self {\n        Self(acc_info)\n    }",
    "pub fn hash(&mut self, val: &[u8]) {\n        self.hasher.update(val);\n    }\n    pub fn hashv(&mut self, vals: &[&[u8]]) {\n        for val in vals {\n            self.hash(val);\n        }\n    }\n    pub fn result(self) -> Hash {\n        // At the time of this writing, the sha2 library is stuck on an old version\n        // of generic_array (0.9.0). Decouple ourselves with a clone to our version.\n        Hash(<[u8; HASH_BYTES]>::try_from(self.hasher.finalize().as_slice()).unwrap())\n    }",
    "pub fn new(hash_slice: &[u8]) -> Self {\n        Hash(<[u8; HASH_BYTES]>::try_from(hash_slice).unwrap())\n    }",
    "pub fn to_bytes(self) -> [u8; HASH_BYTES] {\n        self.0\n    }\n}\n\n/// Return a Sha256 hash for the given data.\npub fn hashv(vals: &[&[u8]]) -> Hash {\n    // Perform the calculation inline, calling this from within a program is\n    // not supported\n    let mut hasher = Hasher::default();\n    hasher.hashv(vals);\n    hasher.result()\n}",
    "pub fn hash(val: &[u8]) -> Hash {\n    hashv(&[val])\n}",
    "pub fn new(\n        strct: ItemStruct,\n        fields: Vec<AccountField>,\n        instruction_api: Option<Punctuated<Expr, Comma>>,\n    ) -> Self {\n        let ident = strct.ident.clone();\n        let generics = strct.generics;\n        Self {\n            ident,\n            generics,\n            fields,\n            instruction_api,\n        }\n    }\n\n    // Return value maps instruction name to type.\n    // E.g. if we have `#[instruction(data: u64)]` then returns\n    // { \"data\": \"u64\"}.\n    pub fn instruction_args(&self) -> Option<HashMap<String, String>> {\n        self.instruction_api.as_ref().map(|instruction_api| {\n            instruction_api\n                .iter()\n                .map(|expr| {\n                    let arg = parser::tts_to_string(expr);\n                    let components: Vec<&str> = arg.split(\" : \").collect();\n                    assert!(components.len() == 2);\n                    (components[0].to_string(), components[1].to_string())\n                }",
    "pub fn field_names(&self) -> Vec<String> {\n        self.fields\n            .iter()\n            .map(|field| field.ident().to_string())\n            .collect()\n    }",
    "pub fn has_optional(&self) -> bool {\n        for field in &self.fields {\n            if let AccountField::Field(field) = field {\n                if field.is_optional {\n                    return true;\n                }\n            }\n        }\n        false\n    }\n\n    pub fn is_field_optional<T: quote::ToTokens>(&self, field: &T) -> bool {\n        let matching_field = self\n            .fields\n            .iter()\n            .find(|f| *f.ident() == parser::tts_to_string(field));\n        if let Some(matching_field) = matching_field {\n            matching_field.is_optional()\n        }",
    "pub fn ty_name(&self) -> Option<String> {\n        let qualified_ty_name = match self {\n            AccountField::Field(field) => match &field.ty {\n                Ty::Account(account) => Some(parser::tts_to_string(&account.account_type_path)),\n                Ty::LazyAccount(account) => Some(parser::tts_to_string(&account.account_type_path)),\n                _ => None,\n            },\n            AccountField::CompositeField(field) => Some(field.symbol.clone()),\n        };\n\n        qualified_ty_name.map(|name| match name.rsplit_once(\" :: \") {\n            Some((_prefix, suffix)) => suffix.to_string(),\n            None => name,\n        })\n    }",
    "pub fn typed_ident(&self) -> proc_macro2::TokenStream {\n        let name = &self.ident;\n        let ty_decl = self.ty_decl(false);\n        quote! {\n            #name: #ty_decl\n        }\n    }\n\n    pub fn ty_decl(&self, ignore_option: bool) -> proc_macro2::TokenStream {\n        let account_ty = self.account_ty();\n        let container_ty = self.container_ty();\n        let inner_ty = match &self.ty {\n            Ty::AccountInfo => quote! {\n                AccountInfo\n            },\n            Ty::UncheckedAccount => quote! {\n                UncheckedAccount\n            },\n            Ty::Signer => quote! {\n                Signer\n            },\n            Ty::ProgramData => quote! {\n                ProgramData\n            },\n            Ty::SystemAccount => quote! {\n                SystemAccount\n            },\n            Ty::Account(AccountTy { boxed, .. })\n            | Ty::InterfaceAccount(InterfaceAccountTy { boxed, .. }) => {\n                if *boxed {\n                    quote! {\n                        Box<#container_ty<#account_ty>>\n                    }\n                } else {\n                    quote! {\n                        #container_ty<#account_ty>\n                    }\n                }\n            }\n            Ty::Sysvar(ty) => {\n                let account = match ty {\n                    SysvarTy::Clock => quote! {Clock},\n                    SysvarTy::Rent => quote! {Rent},\n                    SysvarTy::EpochSchedule => quote! {EpochSchedule},\n                    SysvarTy::Fees => quote! {Fees},\n                    SysvarTy::RecentBlockhashes => quote! {RecentBlockhashes},\n                    SysvarTy::SlotHashes => quote! {SlotHashes},\n                    SysvarTy::SlotHistory => quote! {SlotHistory},\n                    SysvarTy::StakeHistory => quote! {StakeHistory},\n                    SysvarTy::Instructions => quote! {Instructions},\n                    SysvarTy::Rewards => quote! {Rewards},\n                };\n                quote! {\n                    Sysvar<#account>\n                }\n            }\n            _ => quote! {\n                #container_ty<#account_ty>\n            },\n        };\n        if self.is_optional && !ignore_option {\n            quote! {\n                Option<#inner_ty>\n            }\n        } else {\n            quote! {\n                #inner_ty\n            }\n        }\n    }\n\n    // Ignores optional accounts. Optional account checks and handing should be done prior to this\n    // function being called.\n    pub fn from_account_info(\n        &self,\n        kind: Option<&InitKind>,\n        checked: bool,\n    ) -> proc_macro2::TokenStream {\n        let field = &self.ident;\n        let field_str = field.to_string();\n        let container_ty = self.container_ty();\n        let owner_addr = match &kind {\n            None => quote! { __program_id },\n            Some(InitKind::Program { .. }) => quote! {\n                __program_id\n            },\n            _ => quote! {\n                &anchor_spl::token::ID\n            },\n        };\n        match &self.ty {\n            Ty::AccountInfo => quote! { #field.to_account_info() }",
    "pub fn container_ty(&self) -> proc_macro2::TokenStream {\n        match &self.ty {\n            Ty::Account(_) => quote! {\n                anchor_lang::accounts::account::Account\n            },\n            Ty::LazyAccount(_) => quote! {\n                anchor_lang::accounts::lazy_account::LazyAccount\n            },\n            Ty::AccountLoader(_) => quote! {\n                anchor_lang::accounts::account_loader::AccountLoader\n            },\n            Ty::Sysvar(_) => quote! { anchor_lang::accounts::sysvar::Sysvar },\n            Ty::Program(_) => quote! { anchor_lang::accounts::program::Program },\n            Ty::Interface(_) => quote! { anchor_lang::accounts::interface::Interface },\n            Ty::InterfaceAccount(_) => {\n                quote! { anchor_lang::accounts::interface_account::InterfaceAccount }\n            }\n            Ty::AccountInfo => quote! {},\n            Ty::UncheckedAccount => quote! {},\n            Ty::Signer => quote! {},\n            Ty::SystemAccount => quote! {},\n            Ty::ProgramData => quote! {},\n        }\n    }\n\n    // Returns the inner account struct type.\n    pub fn account_ty(&self) -> proc_macro2::TokenStream {\n        match &self.ty {\n            Ty::AccountInfo => quote! {\n                AccountInfo\n            },\n            Ty::UncheckedAccount => quote! {\n                UncheckedAccount\n            },\n            Ty::Signer => quote! {\n                Signer\n            },\n            Ty::SystemAccount => quote! {\n                SystemAccount\n            },\n            Ty::ProgramData => quote! {\n                ProgramData\n            },\n            Ty::Account(ty) => {\n                let ident = &ty.account_type_path;\n                quote! {\n                    #ident\n                }\n            }\n            Ty::LazyAccount(ty) => {\n                let ident = &ty.account_type_path;\n                quote! {\n                    #ident\n                }\n            }\n            Ty::InterfaceAccount(ty) => {\n                let ident = &ty.account_type_path;\n                quote! {\n                    #ident\n                }\n            }\n            Ty::AccountLoader(ty) => {\n                let ident = &ty.account_type_path;\n                quote! {\n                    #ident\n                }\n            }\n            Ty::Sysvar(ty) => match ty {\n                SysvarTy::Clock => quote! {Clock},\n                SysvarTy::Rent => quote! {Rent},\n                SysvarTy::EpochSchedule => quote! {EpochSchedule},\n                SysvarTy::Fees => quote! {Fees},\n                SysvarTy::RecentBlockhashes => quote! {RecentBlockhashes},\n                SysvarTy::SlotHashes => quote! {SlotHashes},\n                SysvarTy::SlotHistory => quote! {SlotHistory},\n                SysvarTy::StakeHistory => quote! {StakeHistory},\n                SysvarTy::Instructions => quote! {Instructions},\n                SysvarTy::Rewards => quote! {Rewards},\n            },\n            Ty::Program(ty) => {\n                let program = &ty.account_type_path;\n                quote! {\n                    #program\n                }\n            }\n            Ty::Interface(ty) => {\n                let program = &ty.account_type_path;\n                quote! {\n                    #program\n                }\n            }\n        }\n    }\n}\n\n#[derive(Debug)]\npub struct CompositeField {\n    pub ident: Ident,\n    pub constraints: ConstraintGroup,\n    pub symbol: String,\n    pub raw_field: syn::Field,\n    /// IDL Doc comment\n    pub docs: Option<Vec<String>>,\n}\n\n// A type of an account field.\n#[derive(Debug, PartialEq, Eq)]\npub enum Ty {\n    AccountInfo,\n    UncheckedAccount,\n    AccountLoader(AccountLoaderTy),\n    Sysvar(SysvarTy),\n    Account(AccountTy),\n    LazyAccount(LazyAccountTy),\n    Program(ProgramTy),\n    Interface(InterfaceTy),\n    InterfaceAccount(InterfaceAccountTy),\n    Signer,\n    SystemAccount,\n    ProgramData,\n}\n\n#[derive(Debug, PartialEq, Eq)]\npub enum SysvarTy {\n    Clock,\n    Rent,\n    EpochSchedule,\n    Fees,\n    RecentBlockhashes,\n    SlotHashes,\n    SlotHistory,\n    StakeHistory,\n    Instructions,\n    Rewards,\n}\n\n#[derive(Debug, PartialEq, Eq)]\npub struct AccountLoaderTy {\n    // The struct type of the account.\n    pub account_type_path: TypePath,\n}\n\n#[derive(Debug, PartialEq, Eq)]\npub struct AccountTy {\n    // The struct type of the account.\n    pub account_type_path: TypePath,\n    // True if the account has been boxed via `Box<T>`.\n    pub boxed: bool,\n}\n\n#[derive(Debug, PartialEq, Eq)]\npub struct LazyAccountTy {\n    // The struct type of the account.\n    pub account_type_path: TypePath,\n}\n\n#[derive(Debug, PartialEq, Eq)]\npub struct InterfaceAccountTy {\n    // The struct type of the account.\n    pub account_type_path: TypePath,\n    // True if the account has been boxed via `Box<T>`.\n    pub boxed: bool,\n}\n\n#[derive(Debug, PartialEq, Eq)]\npub struct ProgramTy {\n    // The struct type of the account.\n    pub account_type_path: TypePath,\n}\n\n#[derive(Debug, PartialEq, Eq)]\npub struct InterfaceTy {\n    // The struct type of the account.\n    pub account_type_path: TypePath,\n}\n\n#[derive(Debug)]\npub struct Error {\n    pub name: String,\n    pub raw_enum: ItemEnum,\n    pub ident: Ident,\n    pub codes: Vec<ErrorCode>,\n    pub args: Option<ErrorArgs>,\n}\n\n#[derive(Debug)]\npub struct ErrorArgs {\n    pub offset: LitInt,\n}\n\nimpl Parse for ErrorArgs {\n    fn parse(stream: ParseStream) -> ParseResult<Self> {\n        let offset_span = stream.span();\n        let offset = stream.call(Ident::parse_any)?;\n        if offset.to_string().as_str() != \"offset\" {\n            return Err(ParseError::new(offset_span, \"expected keyword offset\"));\n        }\n        stream.parse::<Token![=]>()?;\n        Ok(ErrorArgs {\n            offset: stream.parse()?,\n        })\n    }",
    "pub fn is_zeroed(&self) -> bool {\n        self.zeroed.is_some()\n    }",
    "pub fn is_mutable(&self) -> bool {\n        self.mutable.is_some()\n    }",
    "pub fn is_signer(&self) -> bool {\n        self.signer.is_some()\n    }",
    "pub fn is_close(&self) -> bool {\n        self.close.is_some()\n    }",
    "pub fn generate(error: Error) -> proc_macro2::TokenStream {\n    let error_enum = &error.raw_enum;\n    let enum_name = &error.ident;\n    // Each arm of the `match` statement for implementing `std::fmt::Display`\n    // on the user defined error code.\n    let display_variant_dispatch: Vec<proc_macro2::TokenStream> = error\n        .raw_enum\n        .variants\n        .iter()\n        .enumerate()\n        .map(|(idx, variant)| {\n            let ident = &variant.ident;\n            let error_code = &error.codes[idx];\n            let display_msg = match &error_code.msg {\n                None => {\n                    quote! {\n                        <Self as std::fmt::Debug>::fmt(self, fmt)\n                    }",
    "pub fn name(&self) -> String {\n                match self {\n                    #(#name_variant_dispatch),*\n                }\n            }\n        }\n\n        impl From<#enum_name> for u32 {\n            fn from(e: #enum_name) -> u32 {\n                e as u32 + #offset\n            }\n        }\n\n        impl From<#enum_name> for anchor_lang::error::Error {\n            fn from(error_code: #enum_name) -> anchor_lang::error::Error {\n                anchor_lang::error::Error::from(\n                    anchor_lang::error::AnchorError {\n                        error_name: error_code.name(),\n                        error_code_number: error_code.into(),\n                        error_msg: error_code.to_string(),\n                        error_origin: None,\n                        compared_values: None\n                    }\n                )\n            }",
    "pub fn generate(accs: &AccountsStruct) -> proc_macro2::TokenStream {\n    let name = &accs.ident;\n    let bumps_name = generate_bumps_name(name);\n    let ParsedGenerics {\n        combined_generics,\n        trait_generics: _,\n        struct_generics,\n        where_clause,\n    } = generics(accs);\n\n    let (bump_fields, bump_default_fields): (\n        Vec<proc_macro2::TokenStream>,\n        Vec<proc_macro2::TokenStream>,\n    ) = accs\n        .fields\n        .iter()\n        .filter_map(|af| {\n            let ident = af.ident();\n\n            match af {\n                AccountField::Field(f) => {\n                    let constraints = constraints::linearize(&f.constraints);\n                    let (bump_field, bump_default_field) = if f.is_optional {\n                        (quote!(pub #ident: Option<u8>), quote!(#ident: None))\n                    }",
    "pub fn generate(f: &Field, accs: &AccountsStruct) -> proc_macro2::TokenStream {\n    let constraints = linearize(&f.constraints);\n\n    let rent = constraints\n        .iter()\n        .any(|c| matches!(c, Constraint::RentExempt(ConstraintRentExempt::Enforce)))\n        .then(|| quote! { let __anchor_rent = Rent::get()?; })\n        .unwrap_or_else(|| quote! {});\n\n    let checks: Vec<proc_macro2::TokenStream> = constraints\n        .iter()\n        .map(|c| generate_constraint(f, c, accs))\n        .collect();\n\n    let mut all_checks = quote! {#(#checks)*};\n\n    // If the field is optional we do all the inner checks as if the account\n    // wasn't optional. If the account is init we also need to return an Option\n    // by wrapping the resulting value with Some or returning None if it doesn't exist.\n    if f.is_optional && !constraints.is_empty() {\n        let ident = &f.ident;\n        let ty_decl = f.ty_decl(false);\n        all_checks = match &constraints[0] {\n            Constraint::Init(_) | Constraint::Zeroed(_) => {\n                quote! {\n                    let #ident: #ty_decl = if let Some(#ident) = #ident {\n                        #all_checks\n                        Some(#ident)\n                    }",
    "pub fn generate_composite(f: &CompositeField) -> proc_macro2::TokenStream {\n    let checks: Vec<proc_macro2::TokenStream> = linearize(&f.constraints)\n        .iter()\n        .map(|c| match c {\n            Constraint::Raw(_) => c,\n            _ => panic!(\"Invariant violation: composite constraints can only be raw or literals\"),\n        })\n        .map(|c| generate_constraint_composite(f, c))\n        .collect();\n    quote! {\n        #(#checks)*\n    }\n}\n\n// Linearizes the constraint group so that constraints with dependencies\n// run after those without.\npub fn linearize(c_group: &ConstraintGroup) -> Vec<Constraint> {\n    let ConstraintGroup {\n        init,\n        zeroed,\n        mutable,\n        signer,\n        has_one,\n        raw,\n        owner,\n        rent_exempt,\n        seeds,\n        executable,\n        close,\n        address,\n        associated_token,\n        token_account,\n        mint,\n        realloc,\n    } = c_group.clone();\n\n    let mut constraints = Vec::new();\n\n    if let Some(c) = zeroed {\n        constraints.push(Constraint::Zeroed(c));\n    }\n    if let Some(c) = init {\n        constraints.push(Constraint::Init(c));\n    }\n    if let Some(c) = realloc {\n        constraints.push(Constraint::Realloc(c));\n    }\n    if let Some(c) = seeds {\n        constraints.push(Constraint::Seeds(c));\n    }\n    if let Some(c) = associated_token {\n        constraints.push(Constraint::AssociatedToken(c));\n    }\n    if let Some(c) = mutable {\n        constraints.push(Constraint::Mut(c));\n    }\n    if let Some(c) = signer {\n        constraints.push(Constraint::Signer(c));\n    }\n    constraints.append(&mut has_one.into_iter().map(Constraint::HasOne).collect());\n    constraints.append(&mut raw.into_iter().map(Constraint::Raw).collect());\n    if let Some(c) = owner {\n        constraints.push(Constraint::Owner(c));\n    }\n    if let Some(c) = rent_exempt {\n        constraints.push(Constraint::RentExempt(c));\n    }\n    if let Some(c) = executable {\n        constraints.push(Constraint::Executable(c));\n    }\n    if let Some(c) = close {\n        constraints.push(Constraint::Close(c));\n    }\n    if let Some(c) = address {\n        constraints.push(Constraint::Address(c));\n    }\n    if let Some(c) = token_account {\n        constraints.push(Constraint::TokenAccount(c));\n    }\n    if let Some(c) = mint {\n        constraints.push(Constraint::Mint(c));\n    }\n    constraints\n}\n\nfn generate_constraint(\n    f: &Field,\n    c: &Constraint,\n    accs: &AccountsStruct,\n) -> proc_macro2::TokenStream {\n    match c {\n        Constraint::Init(c) => generate_constraint_init(f, c, accs),\n        Constraint::Zeroed(c) => generate_constraint_zeroed(f, c, accs),\n        Constraint::Mut(c) => generate_constraint_mut(f, c),\n        Constraint::HasOne(c) => generate_constraint_has_one(f, c, accs),\n        Constraint::Signer(c) => generate_constraint_signer(f, c),\n        Constraint::Raw(c) => generate_constraint_raw(&f.ident, c),\n        Constraint::Owner(c) => generate_constraint_owner(f, c),\n        Constraint::RentExempt(c) => generate_constraint_rent_exempt(f, c),\n        Constraint::Seeds(c) => generate_constraint_seeds(f, c),\n        Constraint::Executable(c) => generate_constraint_executable(f, c),\n        Constraint::Close(c) => generate_constraint_close(f, c, accs),\n        Constraint::Address(c) => generate_constraint_address(f, c),\n        Constraint::AssociatedToken(c) => generate_constraint_associated_token(f, c, accs),\n        Constraint::TokenAccount(c) => generate_constraint_token_account(f, c, accs),\n        Constraint::Mint(c) => generate_constraint_mint(f, c, accs),\n        Constraint::Realloc(c) => generate_constraint_realloc(f, c, accs),\n    }\n}\n\nfn generate_constraint_composite(f: &CompositeField, c: &Constraint) -> proc_macro2::TokenStream {\n    match c {\n        Constraint::Raw(c) => generate_constraint_raw(&f.ident, c),\n        _ => panic!(\"Invariant violation\"),\n    }\n}\n\nfn generate_constraint_address(f: &Field, c: &ConstraintAddress) -> proc_macro2::TokenStream {\n    let field = &f.ident;\n    let addr = &c.address;\n    let error = generate_custom_error(\n        field,\n        &c.error,\n        quote! { ConstraintAddress },\n        &Some(&(quote! { actual }, quote! { expected })),\n    );\n    quote! {\n        {\n            let actual = #field.key();\n            let expected = #addr;\n            if actual != expected {\n                return #error;\n            }\n        }\n    }\n}\n\npub fn generate_constraint_init(\n    f: &Field,\n    c: &ConstraintInitGroup,\n    accs: &AccountsStruct,\n) -> proc_macro2::TokenStream {\n    generate_constraint_init_group(f, c, accs)\n}",
    "pub fn generate_constraint_zeroed(\n    f: &Field,\n    _c: &ConstraintZeroed,\n    accs: &AccountsStruct,\n) -> proc_macro2::TokenStream {\n    let account_ty = f.account_ty();\n    let discriminator = quote! { #account_ty::DISCRIMINATOR };\n\n    let field = &f.ident;\n    let name_str = field.to_string();\n    let ty_decl = f.ty_decl(true);\n    let from_account_info = f.from_account_info(None, false);\n\n    // Require `zero` constraint accounts to be unique by:\n    //\n    // 1. Getting the names of all accounts that have the `zero` or the `init` constraints and are\n    //    declared before the current field (in order to avoid checking the same field).\n    // 2. Comparing the key of the current field with all the previous fields' keys.\n    // 3. Returning an error if a match is found.\n    let unique_account_checks = accs\n        .fields\n        .iter()\n        .filter_map(|af| match af {\n            AccountField::Field(field) => Some(field),\n            _ => None,\n        })\n        .take_while(|field| field.ident != f.ident)\n        .filter(|field| field.constraints.is_zeroed() || field.constraints.init.is_some())\n        .map(|other_field| {\n            let other = &other_field.ident;\n            let err = quote! {\n                Err(\n                    anchor_lang::error::Error::from(\n                        anchor_lang::error::ErrorCode::ConstraintZero\n                    ).with_account_name(#name_str)\n                )\n            }",
    "pub fn generate_constraint_close(\n    f: &Field,\n    c: &ConstraintClose,\n    accs: &AccountsStruct,\n) -> proc_macro2::TokenStream {\n    let field = &f.ident;\n    let name_str = field.to_string();\n    let target = &c.sol_dest;\n    let target_optional_check =\n        OptionalCheckScope::new_with_field(accs, field).generate_check(target);\n    quote! {\n        {\n            #target_optional_check\n            if #field.key() == #target.key() {\n                return Err(anchor_lang::error::Error::from(anchor_lang::error::ErrorCode::ConstraintClose).with_account_name(#name_str));\n            }\n        }\n    }\n}\n\npub fn generate_constraint_mut(f: &Field, c: &ConstraintMut) -> proc_macro2::TokenStream {\n    let ident = &f.ident;\n    let account_ref = generate_account_ref(f);\n    let error = generate_custom_error(ident, &c.error, quote! { ConstraintMut }, &None);\n    quote! {\n        if !#account_ref.is_writable {\n            return #error;\n        }\n    }\n}\n\npub fn generate_constraint_has_one(\n    f: &Field,\n    c: &ConstraintHasOne,\n    accs: &AccountsStruct,\n) -> proc_macro2::TokenStream {\n    let target = &c.join_target;\n    let ident = &f.ident;\n    let field = match &f.ty {\n        Ty::AccountLoader(_) => quote! {#ident.load()?},\n        _ => quote! {#ident},\n    };\n    let my_key = match &f.ty {\n        Ty::LazyAccount(_) => {\n            let load_ident = format_ident!(\"load_{}\", target.to_token_stream().to_string());\n            quote! { *#field.#load_ident()? }\n        }\n        _ => quote! { #field.#target },\n    };\n    let error = generate_custom_error(\n        ident,\n        &c.error,\n        quote! { ConstraintHasOne },\n        &Some(&(quote! { my_key }, quote! { target_key })),\n    );\n    let target_optional_check =\n        OptionalCheckScope::new_with_field(accs, &field).generate_check(target);\n\n    quote! {\n        {\n            #target_optional_check\n            let my_key = #my_key;\n            let target_key = #target.key();\n            if my_key != target_key {\n                return #error;\n            }\n        }\n    }\n}\n\npub fn generate_constraint_signer(f: &Field, c: &ConstraintSigner) -> proc_macro2::TokenStream {\n    let ident = &f.ident;\n    let account_ref = generate_account_ref(f);\n\n    let error = generate_custom_error(ident, &c.error, quote! { ConstraintSigner }, &None);\n    quote! {\n        if !#account_ref.is_signer {\n            return #error;\n        }\n    }\n}\n\npub fn generate_constraint_raw(ident: &Ident, c: &ConstraintRaw) -> proc_macro2::TokenStream {\n    let raw = &c.raw;\n    let error = generate_custom_error(ident, &c.error, quote! { ConstraintRaw }, &None);\n    quote! {\n        if !(#raw) {\n            return #error;\n        }\n    }\n}\n\npub fn generate_constraint_owner(f: &Field, c: &ConstraintOwner) -> proc_macro2::TokenStream {\n    let ident = &f.ident;\n    let maybe_deref = match &f.ty {\n        Ty::Account(AccountTy { boxed, .. })\n        | Ty::InterfaceAccount(InterfaceAccountTy { boxed, .. }) => *boxed,\n        _ => false,\n    }\n    .then(|| quote!(*))\n    .unwrap_or_default();\n    let owner_address = &c.owner_address;\n    let error = generate_custom_error(\n        ident,\n        &c.error,\n        quote! { ConstraintOwner },\n        &Some(&(quote! { *my_owner }, quote! { owner_address })),\n    );\n\n    quote! {\n        {\n            let my_owner = AsRef::<AccountInfo>::as_ref(& #maybe_deref #ident).owner;\n            let owner_address = #owner_address;\n            if my_owner != &owner_address {\n                return #error;\n            }\n        }\n    }\n}\n\npub fn generate_constraint_rent_exempt(\n    f: &Field,\n    c: &ConstraintRentExempt,\n) -> proc_macro2::TokenStream {\n    let ident = &f.ident;\n    let name_str = ident.to_string();\n    let info = quote! {\n        #ident.to_account_info()\n    }",
    "pub fn new(accounts: &'a AccountsStruct) -> Self {\n        Self {\n            seen: HashSet::new(),\n            accounts,\n        }\n    }\n    pub fn new_with_field(accounts: &'a AccountsStruct, field: impl ToString) -> Self {\n        let mut check_scope = Self::new(accounts);\n        check_scope.seen.insert(field.to_string());\n        check_scope\n    }\n    pub fn generate_check(&mut self, field: impl ToTokens) -> TokenStream {\n        let field_name = parser::tts_to_string(&field);\n        if self.seen.contains(&field_name) {\n            quote! {}\n        } else {\n            self.seen.insert(field_name.clone());\n            if self.accounts.is_field_optional(&field) {\n                quote! {\n                    let #field = if let Some(ref account) = #field {\n                        account\n                    } else {\n                        return Err(anchor_lang::error::Error::from(anchor_lang::error::ErrorCode::ConstraintAccountIsNone).with_account_name(#field_name));\n                    };\n                }\n            } else {\n                quote! {}\n            }\n        }\n    }\n}\n\nfn generate_get_token_account_space(mint: &Expr) -> proc_macro2::TokenStream {\n    quote! {\n        {\n            let mint_info = #mint.to_account_info();\n            if *mint_info.owner == ::anchor_spl::token_2022::Token2022::id() {\n                use ::anchor_spl::token_2022::spl_token_2022::extension::{BaseStateWithExtensions, ExtensionType, StateWithExtensions};\n                use ::anchor_spl::token_2022::spl_token_2022::state::{Account, Mint};\n                let mint_data = mint_info.try_borrow_data()?;\n                let mint_state = StateWithExtensions::<Mint>::unpack(&mint_data)?;\n                let mint_extensions = mint_state.get_extension_types()?;\n                let required_extensions = ExtensionType::get_required_init_account_extensions(&mint_extensions);\n                ExtensionType::try_calculate_account_len::<Account>(&required_extensions)?\n            } else {\n                ::anchor_spl::token::TokenAccount::LEN\n            }\n        }\n    }\n}\n\n// Generated code to create an account with with system program with the\n// given `space` amount of data, owned by `owner`.\n//\n// `seeds_with_nonce` should be given for creating PDAs. Otherwise it's an\n// empty stream.\n//\n// This should only be run within scopes where `system_program` is not Optional\nfn generate_create_account(\n    field: &Ident,\n    space: proc_macro2::TokenStream,\n    owner: proc_macro2::TokenStream,\n    payer: proc_macro2::TokenStream,\n    seeds_with_nonce: proc_macro2::TokenStream,\n) -> proc_macro2::TokenStream {\n    // Field, payer, and system program are already validated to not be an Option at this point\n    quote! {\n        // If the account being initialized already has lamports, then\n        // return them all back to the payer so that the account has\n        // zero lamports when the system program's create instruction\n        // is eventually called.\n        let __current_lamports = #field.lamports();\n        if __current_lamports == 0 {\n            // Create the token account with right amount of lamports and space, and the correct owner.\n            let space = #space;\n            let lamports = __anchor_rent.minimum_balance(space);\n            let cpi_accounts = anchor_lang::system_program::CreateAccount {\n                from: #payer.to_account_info(),\n                to: #field.to_account_info()\n            }",
    "pub fn generate_constraint_executable(\n    f: &Field,\n    _c: &ConstraintExecutable,\n) -> proc_macro2::TokenStream {\n    let name_str = f.ident.to_string();\n    let account_ref = generate_account_ref(f);\n\n    // because we are only acting on the field, we know it isnt optional at this point\n    // as it was unwrapped in `generate_constraint`\n    quote! {\n        if !#account_ref.executable {\n            return Err(anchor_lang::error::Error::from(anchor_lang::error::ErrorCode::ConstraintExecutable).with_account_name(#name_str));\n        }\n    }\n}\n\nfn generate_custom_error(\n    account_name: &Ident,\n    custom_error: &Option<Expr>,\n    error: proc_macro2::TokenStream,\n    compared_values: &Option<&(proc_macro2::TokenStream, proc_macro2::TokenStream)>,\n) -> proc_macro2::TokenStream {\n    let account_name = account_name.to_string();\n    let mut error = match custom_error {\n        Some(error) => {\n            quote! { anchor_lang::error::Error::from(#error).with_account_name(#account_name) }",
    "pub fn generate(accs: &AccountsStruct) -> proc_macro2::TokenStream {\n    let name = &accs.ident;\n    let ParsedGenerics {\n        combined_generics,\n        trait_generics,\n        struct_generics,\n        where_clause,\n    } = generics(accs);\n\n    let on_save: Vec<proc_macro2::TokenStream> = accs\n        .fields\n        .iter()\n        .map(|af: &AccountField| match af {\n            AccountField::CompositeField(s) => {\n                let name = &s.ident;\n                let name_str = name.to_string();\n                quote! {\n                    anchor_lang::AccountsExit::exit(&self.#name, program_id)\n                        .map_err(|e| e.with_account_name(#name_str))?;\n                }\n            }\n            AccountField::Field(f) => {\n                let ident = &f.ident;\n                let name_str = ident.to_string();\n                if f.constraints.is_close() {\n                    let close_target = &f.constraints.close.as_ref().unwrap().sol_dest;\n                    let close_target_optional_check =\n                        OptionalCheckScope::new(accs).generate_check(close_target);\n\n                    quote! {\n                        {\n                            let #close_target = &self.#close_target;\n                            #close_target_optional_check\n                            anchor_lang::AccountsClose::close(\n                                &self.#ident,\n                                #close_target.to_account_info(),\n                            ).map_err(|e| e.with_account_name(#name_str))?;\n                        }\n                    }\n                } else {\n                    match f.constraints.is_mutable() {\n                        false => quote! {},\n                        true => match &f.ty {\n                            // `LazyAccount` is special because it has a custom `exit` method.\n                            Ty::LazyAccount(_) => quote! {\n                                self.#ident.exit(program_id)\n                                    .map_err(|e| e.with_account_name(#name_str))?;\n                            },\n                            _ => quote! {\n                                anchor_lang::AccountsExit::exit(&self.#ident, program_id)\n                                    .map_err(|e| e.with_account_name(#name_str))?;\n                            },\n                        },\n                    }\n                }\n            }\n        })\n        .collect();\n    quote! {\n        #[automatically_derived]\n        impl<#combined_generics> anchor_lang::AccountsExit<#trait_generics> for #name<#struct_generics> #where_clause{\n            fn exit(&self, program_id: &anchor_lang::solana_program::pubkey::Pubkey) -> anchor_lang::Result<()> {\n                #(#on_save)*\n                Ok(())\n            }",
    "pub fn generate(accs: &AccountsStruct) -> proc_macro2::TokenStream {\n    let impl_try_accounts = try_accounts::generate(accs);\n    let impl_to_account_infos = to_account_infos::generate(accs);\n    let impl_to_account_metas = to_account_metas::generate(accs);\n    let impl_exit = exit::generate(accs);\n    let bumps_struct = bumps::generate(accs);\n\n    let __client_accounts_mod = __client_accounts::generate(accs, quote!(crate::ID));\n    let __cpi_client_accounts_mod = __cpi_client_accounts::generate(accs, quote!(crate::ID));\n\n    let ret = quote! {\n        #impl_try_accounts\n        #impl_to_account_infos\n        #impl_to_account_metas\n        #impl_exit\n        #bumps_struct\n\n        #__client_accounts_mod\n        #__cpi_client_accounts_mod\n    };\n\n    #[cfg(feature = \"idl-build\")]\n    {\n        let idl_build_impl = crate::idl::gen_idl_build_impl_accounts_struct(accs);\n        return quote! {\n            #ret\n            #idl_build_impl\n        };\n    }\n\n    #[allow(unreachable_code)]\n    ret\n}\n\nfn generics(accs: &AccountsStruct) -> ParsedGenerics {\n    let trait_lifetime = accs\n        .generics\n        .lifetimes()\n        .next()\n        .cloned()\n        .unwrap_or_else(|| syn::parse_str(\"'info\").expect(\"Could not parse lifetime\"));\n\n    let mut where_clause = accs.generics.where_clause.clone().unwrap_or(WhereClause {\n        where_token: Default::default(),\n        predicates: Default::default(),\n    });\n    for lifetime in accs.generics.lifetimes().map(|def| &def.lifetime) {\n        where_clause\n            .predicates\n            .push(WherePredicate::Lifetime(PredicateLifetime {\n                lifetime: lifetime.clone(),\n                colon_token: Default::default(),\n                bounds: iter::once(trait_lifetime.lifetime.clone()).collect(),\n            }))\n    }",
    "pub fn generate(accs: &AccountsStruct) -> proc_macro2::TokenStream {\n    let name = &accs.ident;\n\n    let to_acc_metas: Vec<proc_macro2::TokenStream> = accs\n        .fields\n        .iter()\n        .map(|f: &AccountField| {\n            let (name, is_signer, is_optional) = match f {\n                AccountField::CompositeField(s) => (&s.ident, quote! {None}, false),\n                AccountField::Field(f) => {\n                    let is_signer = match f.constraints.is_signer() {\n                        false => quote! {None},\n                        true => quote! {Some(true)}",
    "pub fn generate(accs: &AccountsStruct) -> proc_macro2::TokenStream {\n    let name = &accs.ident;\n    let ParsedGenerics {\n        combined_generics,\n        trait_generics,\n        struct_generics,\n        where_clause,\n    } = generics(accs);\n\n    // Deserialization for each field\n    let deser_fields: Vec<proc_macro2::TokenStream> = accs\n        .fields\n        .iter()\n        .map(|af: &AccountField| {\n            match af {\n                AccountField::CompositeField(s) => {\n                    let name = &s.ident;\n                    let ty = &s.raw_field.ty;\n                    quote! {\n                        #[cfg(feature = \"anchor-debug\")]\n                        ::solana_program::log::sol_log(stringify!(#name));\n                        let #name: #ty = anchor_lang::Accounts::try_accounts(__program_id, __accounts, __ix_data, &mut __bumps.#name, __reallocs)?;\n                    }\n                }\n                AccountField::Field(f) => {\n                    // `init` and `zero` accounts are special cased as they are\n                    // deserialized by constraints. Here, we just take out the\n                    // AccountInfo for later use at constraint validation time.\n                    if is_init(af) || f.constraints.zeroed.is_some()  {\n                        let name = &f.ident;\n                        // Optional accounts have slightly different behavior here and\n                        // we can't leverage the try_accounts implementation for zero and init.\n                        if f.is_optional {\n                            // Thus, this block essentially reimplements the try_accounts \n                            // behavior with optional accounts minus the deserialziation.\n                            let empty_behavior = if cfg!(feature = \"allow-missing-optionals\") {\n                                quote!{ None }\n                            } else {\n                                quote!{ return Err(anchor_lang::error::ErrorCode::AccountNotEnoughKeys.into()); }\n                            };\n                            quote! {\n                                let #name = if __accounts.is_empty() {\n                                    #empty_behavior\n                                } else if __accounts[0].key == __program_id {\n                                    *__accounts = &__accounts[1..];\n                                    None\n                                } else {\n                                    let account = &__accounts[0];\n                                    *__accounts = &__accounts[1..];\n                                    Some(account)\n                                }",
    "pub fn generate(\n    accs: &AccountsStruct,\n    program_id: proc_macro2::TokenStream,\n) -> proc_macro2::TokenStream {\n    let name = &accs.ident;\n    let account_mod_name: proc_macro2::TokenStream = format!(\n        \"__client_accounts_{}\",\n        accs.ident.to_string().to_snake_case()\n    )\n    .parse()\n    .unwrap();\n\n    let account_struct_fields: Vec<proc_macro2::TokenStream> = accs\n        .fields\n        .iter()\n        .map(|f: &AccountField| match f {\n            AccountField::CompositeField(s) => {\n                let name = &s.ident;\n                let docs = if let Some(ref docs) = s.docs {\n                    docs.iter()\n                        .map(|docs_line| {\n                            proc_macro2::TokenStream::from_str(&format!(\n                                \"#[doc = r#\\\"{docs_line}\\\"#]\"\n                            ))\n                            .unwrap()\n                        }",
    "pub fn generate(\n    accs: &AccountsStruct,\n    program_id: proc_macro2::TokenStream,\n) -> proc_macro2::TokenStream {\n    let name = &accs.ident;\n    let account_mod_name: proc_macro2::TokenStream = format!(\n        \"__cpi_client_accounts_{}\",\n        accs.ident.to_string().to_snake_case()\n    )\n    .parse()\n    .unwrap();\n\n    let account_struct_fields: Vec<proc_macro2::TokenStream> = accs\n        .fields\n        .iter()\n        .map(|f: &AccountField| match f {\n            AccountField::CompositeField(s) => {\n                let name = &s.ident;\n                let docs = if let Some(ref docs) = s.docs {\n                    docs.iter()\n                        .map(|docs_line| {\n                            proc_macro2::TokenStream::from_str(&format!(\n                                \"#[doc = r#\\\"{docs_line}\\\"#]\"\n                            ))\n                            .unwrap()\n                        }",
    "pub fn sighash(namespace: &str, name: &str) -> [u8; 8] {\n    let preimage = format!(\"{namespace}:{name}\");\n\n    let mut sighash = [0u8; 8];\n    sighash.copy_from_slice(&crate::hash::hash(preimage.as_bytes()).to_bytes()[..8]);\n    sighash\n}\n\npub fn gen_discriminator(namespace: &str, name: impl ToString) -> proc_macro2::TokenStream {\n    let discriminator = sighash(namespace, name.to_string().as_str());\n    format!(\"&{:?}\", discriminator).parse().unwrap()\n}",
    "pub fn generate_ix_variant(name: &str, args: &[IxArg]) -> proc_macro2::TokenStream {\n    let ix_arg_names: Vec<&syn::Ident> = args.iter().map(|arg| &arg.name).collect();\n    let ix_name_camel = generate_ix_variant_name(name);\n\n    if args.is_empty() {\n        quote! {\n            #ix_name_camel\n        }\n    } else {\n        quote! {\n            #ix_name_camel {\n                #(#ix_arg_names),*\n            }\n        }\n    }\n}\n\npub fn generate_ix_variant_name(name: &str) -> proc_macro2::TokenStream {\n    let n = name.to_camel_case();\n    n.parse().unwrap()\n}",
    "pub fn generate(program: &Program) -> proc_macro2::TokenStream {\n    // Generate cpi methods for global methods.\n    let global_cpi_methods: Vec<proc_macro2::TokenStream> = program\n        .ixs\n        .iter()\n        .map(|ix| {\n            let accounts_ident: proc_macro2::TokenStream = format!(\"crate::cpi::accounts::{}\", &ix.anchor_ident.to_string()).parse().unwrap();\n            let cpi_method = {\n                let name = &ix.raw_method.sig.ident;\n                let name_str = name.to_string();\n                let ix_variant = generate_ix_variant(&name_str, &ix.args);\n                let method_name = &ix.ident;\n                let args: Vec<&syn::PatType> = ix.args.iter().map(|arg| &arg.raw_arg).collect();\n                let discriminator = {\n                    let name = generate_ix_variant_name(&name_str);\n                    quote! { <instruction::#name as anchor_lang::Discriminator>::DISCRIMINATOR }\n                };\n                let ret_type = &ix.returns.ty.to_token_stream();\n                let ix_cfgs = &ix.cfgs;\n                let (method_ret, maybe_return) = match ret_type.to_string().as_str() {\n                    \"()\" => (quote! {anchor_lang::Result<()> }, quote! { Ok(()) }",
    "pub fn get(&self) -> T {\n                    let (_key, data) = anchor_lang::solana_program::program::get_return_data().unwrap();\n                    T::try_from_slice(&data).unwrap()\n                }",
    "pub fn generate(program: &Program) -> proc_macro2::TokenStream {\n    // Dispatch all global instructions.\n    let global_ixs = program.ixs.iter().map(|ix| {\n        let ix_method_name = &ix.raw_method.sig.ident;\n        let ix_name_camel: proc_macro2::TokenStream = ix_method_name\n            .to_string()\n            .to_camel_case()\n            .parse()\n            .expect(\"Failed to parse ix method name in camel as `TokenStream`\");\n        let discriminator = quote! { instruction::#ix_name_camel::DISCRIMINATOR };\n        let ix_cfgs = &ix.cfgs;\n\n        quote! {\n            #(#ix_cfgs)*\n            if data.starts_with(#discriminator) {\n                return __private::__global::#ix_method_name(\n                    program_id,\n                    accounts,\n                    &data[#discriminator.len()..],\n                )\n            }",
    "pub fn generate(program: &Program) -> proc_macro2::TokenStream {\n    let name: proc_macro2::TokenStream = program.name.to_string().to_camel_case().parse().unwrap();\n    quote! {\n        #[cfg(not(feature = \"no-entrypoint\"))]\n        anchor_lang::solana_program::entrypoint!(entry);\n        /// The Anchor codegen exposes a programming model where a user defines\n        /// a set of methods inside of a `#[program]` module in a way similar\n        /// to writing RPC request handlers. The macro then generates a bunch of\n        /// code wrapping these user defined methods into something that can be\n        /// executed on Solana.\n        ///\n        /// These methods fall into one category for now.\n        ///\n        /// Global methods - regular methods inside of the `#[program]`.\n        ///\n        /// Care must be taken by the codegen to prevent collisions between\n        /// methods in these different namespaces. For this reason, Anchor uses\n        /// a variant of sighash to perform method dispatch, rather than\n        /// something like a simple enum variant discriminator.\n        ///\n        /// The execution flow of the generated code can be roughly outlined:\n        ///\n        /// * Start program via the entrypoint.\n        /// * Check whether the declared program id matches the input program\n        ///   id. If it's not, return an error.\n        /// * Find and invoke the method based on whether the instruction data\n        ///   starts with the method's discriminator.\n        /// * Run the method handler wrapper. This wraps the code the user\n        ///   actually wrote, deserializing the accounts, constructing the\n        ///   context, invoking the user's code, and finally running the exit\n        ///   routine, which typically persists account changes.\n        ///\n        /// The `entry` function here, defines the standard entry to a Solana\n        /// program, where execution begins.\n        pub fn entry<'info>(program_id: &Pubkey, accounts: &'info [AccountInfo<'info>], data: &[u8]) -> anchor_lang::solana_program::entrypoint::ProgramResult {\n            try_entry(program_id, accounts, data).map_err(|e| {\n                e.log();\n                e.into()\n            }",
    "pub fn generate(program: &Program) -> proc_macro2::TokenStream {\n    let program_name = &program.name;\n    // A constant token stream that stores the accounts and functions, required to live\n    // inside the target program in order to get the program ID.\n    let idl_accounts_and_functions = idl_accounts_and_functions();\n    let non_inlined_idl: proc_macro2::TokenStream = {\n        quote! {\n            // Entry for all IDL related instructions. Use the \"no-idl\" feature\n            // to eliminate this code, for example, if one wants to make the\n            // IDL no longer mutable or if one doesn't want to store the IDL\n            // on chain.\n            #[inline(never)]\n            #[cfg(not(feature = \"no-idl\"))]\n            pub fn __idl_dispatch<'info>(program_id: &Pubkey, accounts: &'info [AccountInfo<'info>], idl_ix_data: &[u8]) -> anchor_lang::Result<()> {\n                let mut accounts = accounts;\n                let mut data: &[u8] = idl_ix_data;\n\n                let ix = anchor_lang::idl::IdlInstruction::deserialize(&mut data)\n                    .map_err(|_| anchor_lang::error::ErrorCode::InstructionDidNotDeserialize)?;\n\n                match ix {\n                    anchor_lang::idl::IdlInstruction::Create { data_len } => {\n                        let mut bumps = <IdlCreateAccounts as anchor_lang::Bumps>::Bumps::default();\n                        let mut reallocs = std::collections::BTreeSet::new();\n                        let mut accounts =\n                            IdlCreateAccounts::try_accounts(program_id, &mut accounts, &[], &mut bumps, &mut reallocs)?;\n                        __idl_create_account(program_id, &mut accounts, data_len)?;\n                        accounts.exit(program_id)?;\n                    },\n                    anchor_lang::idl::IdlInstruction::Resize { data_len } => {\n                        let mut bumps = <IdlResizeAccount as anchor_lang::Bumps>::Bumps::default();\n                        let mut reallocs = std::collections::BTreeSet::new();\n                        let mut accounts =\n                            IdlResizeAccount::try_accounts(program_id, &mut accounts, &[], &mut bumps, &mut reallocs)?;\n                        __idl_resize_account(program_id, &mut accounts, data_len)?;\n                        accounts.exit(program_id)?;\n                    },\n                    anchor_lang::idl::IdlInstruction::Close => {\n                        let mut bumps = <IdlCloseAccount as anchor_lang::Bumps>::Bumps::default();\n                        let mut reallocs = std::collections::BTreeSet::new();\n                        let mut accounts =\n                            IdlCloseAccount::try_accounts(program_id, &mut accounts, &[], &mut bumps, &mut reallocs)?;\n                        __idl_close_account(program_id, &mut accounts)?;\n                        accounts.exit(program_id)?;\n                    },\n                    anchor_lang::idl::IdlInstruction::CreateBuffer => {\n                        let mut bumps = <IdlCreateBuffer as anchor_lang::Bumps>::Bumps::default();\n                        let mut reallocs = std::collections::BTreeSet::new();\n                        let mut accounts =\n                            IdlCreateBuffer::try_accounts(program_id, &mut accounts, &[], &mut bumps, &mut reallocs)?;\n                        __idl_create_buffer(program_id, &mut accounts)?;\n                        accounts.exit(program_id)?;\n                    },\n                    anchor_lang::idl::IdlInstruction::Write { data } => {\n                        let mut bumps = <IdlAccounts as anchor_lang::Bumps>::Bumps::default();\n                        let mut reallocs = std::collections::BTreeSet::new();\n                        let mut accounts =\n                            IdlAccounts::try_accounts(program_id, &mut accounts, &[], &mut bumps, &mut reallocs)?;\n                        __idl_write(program_id, &mut accounts, data)?;\n                        accounts.exit(program_id)?;\n                    },\n                    anchor_lang::idl::IdlInstruction::SetAuthority { new_authority } => {\n                        let mut bumps = <IdlAccounts as anchor_lang::Bumps>::Bumps::default();\n                        let mut reallocs = std::collections::BTreeSet::new();\n                        let mut accounts =\n                            IdlAccounts::try_accounts(program_id, &mut accounts, &[], &mut bumps, &mut reallocs)?;\n                        __idl_set_authority(program_id, &mut accounts, new_authority)?;\n                        accounts.exit(program_id)?;\n                    },\n                    anchor_lang::idl::IdlInstruction::SetBuffer => {\n                        let mut bumps = <IdlSetBuffer as anchor_lang::Bumps>::Bumps::default();\n                        let mut reallocs = std::collections::BTreeSet::new();\n                        let mut accounts =\n                            IdlSetBuffer::try_accounts(program_id, &mut accounts, &[], &mut bumps, &mut reallocs)?;\n                        __idl_set_buffer(program_id, &mut accounts)?;\n                        accounts.exit(program_id)?;\n                    },\n                }\n                Ok(())\n            }",
    "pub fn __event_dispatch(\n                    program_id: &Pubkey,\n                    accounts: &[AccountInfo],\n                    event_data: &[u8],\n                ) -> anchor_lang::Result<()> {\n                    let given_event_authority = next_account_info(&mut accounts.iter())?;\n                    if !given_event_authority.is_signer {\n                        return Err(anchor_lang::error::Error::from(\n                            anchor_lang::error::ErrorCode::ConstraintSigner,\n                        )\n                        .with_account_name(#authority_name));\n                    }\n\n                    let (expected_event_authority, _) =\n                        Pubkey::find_program_address(&[#authority_seeds], &program_id);\n                    if given_event_authority.key() != expected_event_authority {\n                        return Err(anchor_lang::error::Error::from(\n                            anchor_lang::error::ErrorCode::ConstraintSeeds,\n                        )\n                        .with_account_name(#authority_name)\n                        .with_pubkeys((given_event_authority.key(), expected_event_authority)));\n                    }\n\n                    Ok(())\n                }",
    "pub fn idl_accounts_and_functions() -> proc_macro2::TokenStream {\n    quote! {\n        use anchor_lang::idl::ERASED_AUTHORITY;\n\n        #[account(\"internal\")]\n        #[derive(Debug)]\n        pub struct IdlAccount {\n            // Address that can modify the IDL.\n            pub authority: Pubkey,\n            // Length of compressed idl bytes.\n            pub data_len: u32,\n            // Followed by compressed idl bytes.\n        }\n\n        impl IdlAccount {\n            pub fn address(program_id: &Pubkey) -> Pubkey {\n                let program_signer = Pubkey::find_program_address(&[], program_id).0;\n                Pubkey::create_with_seed(&program_signer, IdlAccount::seed(), program_id)\n                    .expect(\"Seed is always valid\")\n            }",
    "pub fn seed() -> &'static str {\n                \"anchor:idl\"\n            }\n        }\n\n        // Hacky workaround because of some internals to how account attribute\n        // works. Namespaces are the root of most of the problem.\n        impl anchor_lang::Owner for IdlAccount {\n            fn owner() -> Pubkey {\n                crate::ID\n            }\n        }\n\n        // Accounts for the Create instruction.\n        #[derive(Accounts)]\n        pub struct IdlCreateAccounts<'info> {\n            // Payer of the transaction.\n            #[account(signer)]\n            pub from: AccountInfo<'info>,\n            // The deterministically defined \"state\" account being created via\n            // `create_account_with_seed`.\n            #[account(mut)]\n            pub to: AccountInfo<'info>,\n            // The program-derived-address signing off on the account creation.\n            // Seeds = &[] + bump seed.\n            #[account(seeds = [], bump)]\n            pub base: AccountInfo<'info>,\n            // The system program.\n            pub system_program: Program<'info, System>,\n            // The program whose state is being constructed.\n            #[account(executable)]\n            pub program: AccountInfo<'info>,\n        }\n\n        // Accounts for Idl instructions.\n        #[derive(Accounts)]\n        pub struct IdlAccounts<'info> {\n            #[account(mut, has_one = authority)]\n            pub idl: Account<'info, IdlAccount>,\n            #[account(constraint = authority.key != &ERASED_AUTHORITY)]\n            pub authority: Signer<'info>,\n        }\n\n        // Accounts for resize account instruction\n        #[derive(Accounts)]\n        pub struct IdlResizeAccount<'info> {\n            #[account(mut, has_one = authority)]\n            pub idl: Account<'info, IdlAccount>,\n            #[account(mut, constraint = authority.key != &ERASED_AUTHORITY)]\n            pub authority: Signer<'info>,\n            pub system_program: Program<'info, System>,\n        }\n\n        // Accounts for creating an idl buffer.\n        #[derive(Accounts)]\n        pub struct IdlCreateBuffer<'info> {\n            #[account(zero)]\n            pub buffer: Account<'info, IdlAccount>,\n            #[account(constraint = authority.key != &ERASED_AUTHORITY)]\n            pub authority: Signer<'info>,\n        }\n\n        // Accounts for upgrading the canonical IdlAccount with the buffer.\n        #[derive(Accounts)]\n        pub struct IdlSetBuffer<'info> {\n            // The buffer with the new idl data.\n            #[account(mut, constraint = buffer.authority == idl.authority)]\n            pub buffer: Account<'info, IdlAccount>,\n            // The idl account to be updated with the buffer's data.\n            #[account(mut, has_one = authority)]\n            pub idl: Account<'info, IdlAccount>,\n            #[account(constraint = authority.key != &ERASED_AUTHORITY)]\n            pub authority: Signer<'info>,\n        }\n\n        // Accounts for closing the canonical Idl buffer.\n        #[derive(Accounts)]\n        pub struct IdlCloseAccount<'info> {\n            #[account(mut, has_one = authority, close = sol_destination)]\n            pub account: Account<'info, IdlAccount>,\n            #[account(constraint = authority.key != &ERASED_AUTHORITY)]\n            pub authority: Signer<'info>,\n            #[account(mut)]\n            pub sol_destination: AccountInfo<'info>,\n        }\n\n\n        use std::cell::{Ref, RefMut};\n\n        pub trait IdlTrailingData<'info> {\n            fn trailing_data(self) -> Ref<'info, [u8]>;\n            fn trailing_data_mut(self) -> RefMut<'info, [u8]>;\n        }\n\n        impl<'a, 'info: 'a> IdlTrailingData<'a> for &'a Account<'info, IdlAccount> {\n            fn trailing_data(self) -> Ref<'a, [u8]> {\n                let info: &AccountInfo<'info> = self.as_ref();\n                Ref::map(info.try_borrow_data().unwrap(), |d| &d[44..])\n            }",
    "pub fn __idl_create_account(\n            program_id: &Pubkey,\n            accounts: &mut IdlCreateAccounts,\n            data_len: u64,\n        ) -> anchor_lang::Result<()> {\n            #[cfg(not(feature = \"no-log-ix-name\"))]\n            anchor_lang::prelude::msg!(\"Instruction: IdlCreateAccount\");\n\n            if program_id != accounts.program.key {\n                return Err(anchor_lang::error::ErrorCode::IdlInstructionInvalidProgram.into());\n            }\n            // Create the IDL's account.\n            let from = accounts.from.key;\n            let (base, nonce) = Pubkey::find_program_address(&[], program_id);\n            let seed = IdlAccount::seed();\n            let owner = accounts.program.key;\n            let to = Pubkey::create_with_seed(&base, seed, owner).unwrap();\n            // Space: account discriminator || authority pubkey || vec len || vec data\n            let space = std::cmp::min(\n                IdlAccount::DISCRIMINATOR.len() + 32 + 4 + data_len as usize,\n                10_000\n            );\n            let rent = Rent::get()?;\n            let lamports = rent.minimum_balance(space);\n            let seeds = &[&[nonce][..]];\n            let ix = anchor_lang::solana_program::system_instruction::create_account_with_seed(\n                from,\n                &to,\n                &base,\n                seed,\n                lamports,\n                space as u64,\n                owner,\n            );\n            anchor_lang::solana_program::program::invoke_signed(\n                &ix,\n                &[\n                    accounts.from.clone(),\n                    accounts.to.clone(),\n                    accounts.base.clone(),\n                    accounts.system_program.to_account_info(),\n                ],\n                &[seeds],\n            )?;\n\n            // Deserialize the newly created account.\n            let mut idl_account = {\n                let mut account_data =  accounts.to.try_borrow_data()?;\n                let mut account_data_slice: &[u8] = &account_data;\n                IdlAccount::try_deserialize_unchecked(\n                    &mut account_data_slice,\n                )?\n            };\n\n            // Set the authority.\n            idl_account.authority = *accounts.from.key;\n\n            // Store the new account data.\n            let mut data = accounts.to.try_borrow_mut_data()?;\n            let dst: &mut [u8] = &mut data;\n            let mut cursor = std::io::Cursor::new(dst);\n            idl_account.try_serialize(&mut cursor)?;\n\n            Ok(())\n        }",
    "pub fn __idl_resize_account(\n            program_id: &Pubkey,\n            accounts: &mut IdlResizeAccount,\n            data_len: u64,\n        ) -> anchor_lang::Result<()> {\n            #[cfg(not(feature = \"no-log-ix-name\"))]\n            anchor_lang::prelude::msg!(\"Instruction: IdlResizeAccount\");\n\n            let data_len: usize = data_len as usize;\n\n            // We're not going to support increasing the size of accounts that already contain data\n            // because that would be messy and possibly dangerous\n            if accounts.idl.data_len != 0 {\n                return Err(anchor_lang::error::ErrorCode::IdlAccountNotEmpty.into());\n            }\n\n            let idl_ref = AsRef::<AccountInfo>::as_ref(&accounts.idl);\n            let new_account_space = idl_ref.data_len().checked_add(std::cmp::min(\n                data_len\n                    .checked_sub(idl_ref.data_len())\n                    .expect(\"data_len should always be >= the current account space\"),\n                10_000,\n            ))\n            .unwrap();\n\n            if new_account_space > idl_ref.data_len() {\n                let sysvar_rent = Rent::get()?;\n                let new_rent_minimum = sysvar_rent.minimum_balance(new_account_space);\n                anchor_lang::system_program::transfer(\n                    anchor_lang::context::CpiContext::new(\n                        accounts.system_program.to_account_info(),\n                        anchor_lang::system_program::Transfer {\n                            from: accounts.authority.to_account_info(),\n                            to: accounts.idl.to_account_info(),\n                        },\n                    ),\n                    new_rent_minimum\n                        .checked_sub(idl_ref.lamports())\n                        .unwrap(),\n                )?;\n                idl_ref.realloc(new_account_space, false)?;\n            }\n\n            Ok(())\n\n        }",
    "pub fn __idl_close_account(\n            program_id: &Pubkey,\n            accounts: &mut IdlCloseAccount,\n        ) -> anchor_lang::Result<()> {\n            #[cfg(not(feature = \"no-log-ix-name\"))]\n            anchor_lang::prelude::msg!(\"Instruction: IdlCloseAccount\");\n\n            Ok(())\n        }",
    "pub fn __idl_create_buffer(\n            program_id: &Pubkey,\n            accounts: &mut IdlCreateBuffer,\n        ) -> anchor_lang::Result<()> {\n            #[cfg(not(feature = \"no-log-ix-name\"))]\n            anchor_lang::prelude::msg!(\"Instruction: IdlCreateBuffer\");\n\n            let mut buffer = &mut accounts.buffer;\n            buffer.authority = *accounts.authority.key;\n            Ok(())\n        }",
    "pub fn __idl_write(\n            program_id: &Pubkey,\n            accounts: &mut IdlAccounts,\n            idl_data: Vec<u8>,\n        ) -> anchor_lang::Result<()> {\n            #[cfg(not(feature = \"no-log-ix-name\"))]\n            anchor_lang::prelude::msg!(\"Instruction: IdlWrite\");\n\n            let prev_len: usize = ::std::convert::TryInto::<usize>::try_into(accounts.idl.data_len).unwrap();\n            let new_len: usize = prev_len.checked_add(idl_data.len()).unwrap() as usize;\n            accounts.idl.data_len = accounts.idl.data_len.checked_add(::std::convert::TryInto::<u32>::try_into(idl_data.len()).unwrap()).unwrap();\n\n            use IdlTrailingData;\n            let mut idl_bytes = accounts.idl.trailing_data_mut();\n            let idl_expansion = &mut idl_bytes[prev_len..new_len];\n            require_eq!(idl_expansion.len(), idl_data.len());\n            idl_expansion.copy_from_slice(&idl_data[..]);\n\n            Ok(())\n        }",
    "pub fn __idl_set_authority(\n            program_id: &Pubkey,\n            accounts: &mut IdlAccounts,\n            new_authority: Pubkey,\n        ) -> anchor_lang::Result<()> {\n            #[cfg(not(feature = \"no-log-ix-name\"))]\n            anchor_lang::prelude::msg!(\"Instruction: IdlSetAuthority\");\n\n            accounts.idl.authority = new_authority;\n            Ok(())\n        }",
    "pub fn __idl_set_buffer(\n            program_id: &Pubkey,\n            accounts: &mut IdlSetBuffer,\n        ) -> anchor_lang::Result<()> {\n            #[cfg(not(feature = \"no-log-ix-name\"))]\n            anchor_lang::prelude::msg!(\"Instruction: IdlSetBuffer\");\n\n            accounts.idl.data_len = accounts.buffer.data_len;\n\n            use IdlTrailingData;\n            let buffer_len = ::std::convert::TryInto::<usize>::try_into(accounts.buffer.data_len).unwrap();\n            let mut target = accounts.idl.trailing_data_mut();\n            let source = &accounts.buffer.trailing_data()[..buffer_len];\n            require_gte!(target.len(), buffer_len);\n            target[..buffer_len].copy_from_slice(source);\n            // zero the remainder of target?\n\n            Ok(())\n        }",
    "pub fn generate(program: &Program) -> proc_macro2::TokenStream {\n    let variants: Vec<proc_macro2::TokenStream> = program\n        .ixs\n        .iter()\n        .map(|ix| {\n            let name = &ix.raw_method.sig.ident.to_string();\n            let ix_cfgs = &ix.cfgs;\n            let ix_name_camel =\n                proc_macro2::Ident::new(&name.to_camel_case(), ix.raw_method.sig.ident.span());\n            let raw_args: Vec<proc_macro2::TokenStream> = ix\n                .args\n                .iter()\n                .map(|arg| {\n                    format!(\"pub {}\", parser::tts_to_string(&arg.raw_arg))\n                        .parse()\n                        .unwrap()\n                }",
    "pub fn gen_idl_build_impl_accounts_struct(accounts: &AccountsStruct) -> TokenStream {\n    let resolution = option_env!(\"ANCHOR_IDL_BUILD_RESOLUTION\")\n        .map(|val| val == \"TRUE\")\n        .unwrap_or_default();\n    let no_docs = get_no_docs();\n    let idl = get_idl_module_path();\n\n    let ident = &accounts.ident;\n    let (impl_generics, ty_generics, where_clause) = accounts.generics.split_for_impl();\n\n    let (accounts, defined) = accounts\n        .fields\n        .iter()\n        .map(|acc| match acc {\n            AccountField::Field(acc) => {\n                let name = acc.ident.to_string();\n                let writable = acc.constraints.is_mutable();\n                let signer = match acc.ty {\n                    Ty::Signer => true,\n                    _ => acc.constraints.is_signer(),\n                };\n                let optional = acc.is_optional;\n                let docs = match &acc.docs {\n                    Some(docs) if !no_docs => quote! { vec![#(#docs.into()),*] },\n                    _ => quote! { vec![] },\n                };\n\n                let (address, pda, relations) = if resolution {\n                    (\n                        get_address(acc),\n                        get_pda(acc, accounts),\n                        get_relations(acc, accounts),\n                    )\n                }",
    "pub fn __anchor_private_gen_idl_accounts(\n                accounts: &mut std::collections::BTreeMap<String, #idl::IdlAccount>,\n                types: &mut std::collections::BTreeMap<String, #idl::IdlTypeDef>,\n            ) -> Vec<#idl::IdlInstructionAccountItem> {\n                #(\n                    if let Some(ty) = <#defined>::create_type() {\n                        let account = #idl::IdlAccount {\n                            name: ty.name.clone(),\n                            discriminator: #defined::DISCRIMINATOR.into(),\n                        };\n                        accounts.insert(account.name.clone(), account);\n                        types.insert(ty.name.clone(), ty);\n                        <#defined>::insert_types(types);\n                    }\n                );*\n\n                vec![#(#accounts),*]\n            }\n        }\n    }\n}\n\nfn get_address(acc: &Field) -> TokenStream {\n    match &acc.ty {\n        Ty::Program(_) | Ty::Sysvar(_) => {\n            let ty = acc.account_ty();\n            let id_trait = matches!(acc.ty, Ty::Program(_))\n                .then(|| quote!(anchor_lang::Id))\n                .unwrap_or_else(|| quote!(anchor_lang::solana_program::sysvar::SysvarId));\n            quote! { Some(<#ty as #id_trait>::id().to_string()) }",
    "pub fn find_path(name: &str, path: impl AsRef<Path>) -> Result<PathBuf> {\n    let path = path.as_ref();\n    for ancestor in path.ancestors() {\n        let file_path = ancestor.join(name);\n        if file_path.exists() {\n            return file_path.canonicalize().map_err(Into::into);\n        }\n    }\n\n    Err(anyhow!(\"Path ({path:?}) not found\"))\n}",
    "pub fn get_no_docs() -> bool {\n    option_env!(\"ANCHOR_IDL_BUILD_NO_DOCS\")\n        .map(|val| val == \"TRUE\")\n        .unwrap_or_default()\n}",
    "pub fn get_program_path() -> Result<PathBuf> {\n    std::env::var(\"ANCHOR_IDL_BUILD_PROGRAM_PATH\")\n        .map(PathBuf::from)\n        .map_err(|_| anyhow!(\"Failed to get program path\"))\n}",
    "pub fn get_idl_module_path() -> TokenStream {\n    quote!(anchor_lang::idl::types)\n}",
    "pub fn get_serde_json_module_path() -> TokenStream {\n    quote!(anchor_lang::idl::serde_json)\n}",
    "pub fn impl_idl_build_struct(item: &syn::ItemStruct) -> TokenStream {\n    impl_idl_build(&item.ident, &item.generics, gen_idl_type_def_struct(item))\n}",
    "pub fn impl_idl_build_enum(item: &syn::ItemEnum) -> TokenStream {\n    impl_idl_build(&item.ident, &item.generics, gen_idl_type_def_enum(item))\n}",
    "pub fn impl_idl_build_union(item: &syn::ItemUnion) -> TokenStream {\n    impl_idl_build(\n        &item.ident,\n        &item.generics,\n        Err(anyhow!(\"Unions are not supported\")),\n    )\n}",
    "pub fn gen_idl_type_def_struct(\n    strct: &syn::ItemStruct,\n) -> Result<(TokenStream, Vec<syn::TypePath>)> {\n    gen_idl_type_def(&strct.attrs, &strct.generics, |generic_params| {\n        let no_docs = get_no_docs();\n        let idl = get_idl_module_path();\n\n        let (fields, defined) = match &strct.fields {\n            syn::Fields::Unit => (quote! { None }, vec![]),\n            syn::Fields::Named(fields) => {\n                let (fields, defined) = fields\n                    .named\n                    .iter()\n                    .map(|f| gen_idl_field(f, generic_params, no_docs))\n                    .collect::<Result<Vec<_>>>()?\n                    .into_iter()\n                    .unzip::<_, _, Vec<_>, Vec<_>>();\n\n                (\n                    quote! { Some(#idl::IdlDefinedFields::Named(vec![#(#fields),*])) }",
    "pub fn gen_idl_type(\n    ty: &syn::Type,\n    generic_params: &[syn::Ident],\n) -> Result<(TokenStream, Vec<syn::TypePath>)> {\n    let idl = get_idl_module_path();\n\n    fn the_only_segment_is(path: &syn::TypePath, cmp: &str) -> bool {\n        if path.path.segments.len() != 1 {\n            return false;\n        };\n        return get_first_segment(path).ident == cmp;\n    }\n\n    fn get_angle_bracketed_type_args(seg: &syn::PathSegment) -> Vec<&syn::Type> {\n        match &seg.arguments {\n            syn::PathArguments::AngleBracketed(ab) => ab\n                .args\n                .iter()\n                .filter_map(|arg| match arg {\n                    syn::GenericArgument::Type(ty) => Some(ty),\n                    _ => None,\n                })\n                .collect(),\n            _ => panic!(\"No angle bracket for {seg:#?}\"),\n        }\n    }\n\n    match ty {\n        syn::Type::Path(path) if the_only_segment_is(path, \"bool\") => {\n            Ok((quote! { #idl::IdlType::Bool }, vec![]))\n        }",
    "pub fn gen_idl_print_fn_error(error: &Error) -> TokenStream {\n    let idl = get_idl_module_path();\n\n    let fn_name = format_ident!(\n        \"__anchor_private_print_idl_error_{}\",\n        error.ident.to_string().to_snake_case()\n    );\n\n    let error_codes = error\n        .codes\n        .iter()\n        .map(|code| {\n            let id = code.id;\n            let name = code.ident.to_string();\n            let msg = match &code.msg {\n                Some(msg) => quote! { Some(#msg.into()) }",
    "pub fn gen_idl_print_fn_event(event_struct: &syn::ItemStruct) -> TokenStream {\n    let idl = get_idl_module_path();\n    let serde_json = get_serde_json_module_path();\n\n    let ident = &event_struct.ident;\n    let fn_name = format_ident!(\n        \"__anchor_private_print_idl_event_{}\",\n        ident.to_string().to_snake_case()\n    );\n    let idl_build_impl = impl_idl_build_event(event_struct);\n\n    let print_ts = gen_print_section(\n        \"event\",\n        quote! {\n            #serde_json::json!({\n                \"event\": event,\n                \"types\": types.into_values().collect::<Vec<_>>()\n            }",
    "pub fn get_external_type(name: &str, path: impl AsRef<Path>) -> Result<Option<syn::Type>> {\n    let use_path = get_uses(path.as_ref())?\n        .into_iter()\n        .find(|u| u.split(\"::\").last().unwrap() == name)\n        .ok_or_else(|| anyhow!(\"`{name}` not found in use statements\"))?;\n\n    // Get crate name and version from lock file\n    let program_path = get_program_path()?;\n    let lock_path = find_path(\"Cargo.lock\", program_path)?;\n    let lock_file = parse_lock_file(lock_path)?;\n    let registry_path = get_registry_path()?;\n\n    recursively_find_type(name, &use_path, &registry_path, &lock_file)\n}",
    "pub fn gen_idl_print_fn_program(program: &Program) -> TokenStream {\n    check_safety_comments().unwrap_or_else(|e| panic!(\"Safety checks failed: {e}\"));\n\n    let idl = get_idl_module_path();\n    let no_docs = get_no_docs();\n\n    let name = program.name.to_string();\n    let docs = match &program.docs {\n        Some(docs) if !no_docs => quote! { vec![#(#docs.into()),*] },\n        _ => quote! { vec![] },\n    };\n\n    let result = program\n        .ixs\n        .iter()\n        .map(|ix| {\n            let name = ix.ident.to_string();\n            let name_pascal = format_ident!(\"{}\", name.to_camel_case());\n            let ctx_ident = &ix.anchor_ident;\n            let cfgs = &ix.cfgs;\n\n            let docs = match &ix.docs {\n                Some(docs) if !no_docs => quote! { vec![#(#docs.into()),*] },\n                _ => quote! { vec![] },\n            };\n\n            let (args, mut defined) = ix\n                .args\n                .iter()\n                .map(|arg| {\n                    let name = arg.name.to_string();\n                    let docs = match docs::parse(&arg.raw_arg.attrs) {\n                        Some(docs) if !no_docs => quote! { vec![#(#docs.into()),*] },\n                        _ => quote! { vec![] },\n                    };\n                    let (ty, defined) = gen_idl_type(&arg.raw_arg.ty, &[])\n                        .map_err(|_| syn::Error::new(arg.raw_arg.ty.span(), \"Unsupported type\"))?;\n\n                    Ok((\n                        quote! {\n                            #idl::IdlField {\n                                name: #name.into(),\n                                docs: #docs,\n                                ty: #ty,\n                            }\n                        },\n                        defined,\n                    ))\n                }",
    "pub fn __anchor_private_print_idl_program() {\n            #fn_body\n        }\n    }\n}\n\n/// Check safety comments.\nfn check_safety_comments() -> Result<()> {\n    let skip_lint = option_env!(\"ANCHOR_IDL_BUILD_SKIP_LINT\")\n        .map(|val| val == \"TRUE\")\n        .unwrap_or_default();\n    if skip_lint {\n        return Ok(());\n    }\n\n    let program_path = get_program_path();\n    if program_path.is_err() {\n        // Getting the program path can fail in the following scenarios:\n        //\n        // - Anchor CLI version is incompatible with the current version\n        // - The error is coming from Rust Analyzer when the user has `idl-build` feature enabled,\n        // likely due to enabling all features (https://github.com/coral-xyz/anchor/issues/3042)\n        //\n        // For the first case, we have a warning when the user is using different versions of the\n        // lang and CLI crate. For the second case, users would either have to disable the\n        // `idl-build` feature, or define the program path environment variable in Rust Analyzer\n        // settings.\n        //\n        // Given this feature is not a critical one, and it works by default with `anchor build`,\n        // we can fail silently in the case of an error rather than panicking.\n        return Ok(());\n    }\n\n    program_path\n        .map(|path| path.join(\"src\").join(\"lib.rs\"))\n        .map(CrateContext::parse)?\n        .map_err(|e| anyhow!(\"Failed to parse crate: {e}\"))?\n        .safety_checks()\n}",
    "pub fn parse(root: impl AsRef<Path>) -> Result<Self> {\n        Ok(CrateContext {\n            modules: ParsedModule::parse_recursive(root.as_ref())?,\n        })\n    }",
    "pub fn consts(&self) -> impl Iterator<Item = &syn::ItemConst> {\n        self.modules.iter().flat_map(|(_, ctx)| ctx.consts())\n    }",
    "pub fn impl_consts(&self) -> impl Iterator<Item = (&Ident, &syn::ImplItemConst)> {\n        self.modules.iter().flat_map(|(_, ctx)| ctx.impl_consts())\n    }",
    "pub fn structs(&self) -> impl Iterator<Item = &syn::ItemStruct> {\n        self.modules.iter().flat_map(|(_, ctx)| ctx.structs())\n    }",
    "pub fn enums(&self) -> impl Iterator<Item = &syn::ItemEnum> {\n        self.modules.iter().flat_map(|(_, ctx)| ctx.enums())\n    }",
    "pub fn type_aliases(&self) -> impl Iterator<Item = &syn::ItemType> {\n        self.modules.iter().flat_map(|(_, ctx)| ctx.type_aliases())\n    }",
    "pub fn modules(&self) -> impl Iterator<Item = ModuleContext> {\n        self.modules.values().map(|detail| ModuleContext { detail })\n    }",
    "pub fn root_module(&self) -> ModuleContext {\n        ModuleContext {\n            detail: self.modules.get(\"crate\").unwrap(),\n        }\n    }\n\n    // Perform Anchor safety checks on the parsed create\n    pub fn safety_checks(&self) -> Result<()> {\n        // Check all structs for unsafe field types, i.e. AccountInfo and UncheckedAccount.\n        for ctx in self.modules.values() {\n            for unsafe_field in ctx.unsafe_struct_fields() {\n                // Check if unsafe field type has been documented with a /// SAFETY: doc string.\n                let is_documented = unsafe_field.attrs.iter().any(|attr| {\n                    attr.tokens.clone().into_iter().any(|token| match token {\n                        // Check for doc comments containing CHECK\n                        proc_macro2::TokenTree::Literal(s) => s.to_string().contains(\"CHECK\"),\n                        _ => false,\n                    })\n                }",
    "pub fn items(&self) -> impl Iterator<Item = &syn::Item> {\n        self.detail.items.iter()\n    }",
    "pub fn parse(attrs: &[syn::Attribute]) -> Option<Vec<String>> {\n    let doc_strings: Vec<String> = attrs\n        .iter()\n        .filter_map(|attr| match attr.parse_meta() {\n            Ok(NameValue(meta)) => {\n                if meta.path.is_ident(\"doc\") {\n                    if let Str(doc) = meta.lit {\n                        let val = doc.value().trim().to_string();\n                        if val.starts_with(\"CHECK:\") {\n                            return None;\n                        }\n                        return Some(val);\n                    }\n                }\n                None\n            }\n            _ => None,\n        })\n        .collect();\n    if doc_strings.is_empty() {\n        None\n    } else {\n        Some(doc_strings)\n    }",
    "pub fn parse(error_enum: &mut syn::ItemEnum, args: Option<ErrorArgs>) -> Error {\n    let ident = error_enum.ident.clone();\n    let mut last_discriminant = 0;\n    let codes: Vec<ErrorCode> = error_enum\n        .variants\n        .iter_mut()\n        .map(|variant: &mut syn::Variant| {\n            let msg = parse_error_attribute(variant);\n            let ident = variant.ident.clone();\n            let id = match &variant.discriminant {\n                None => last_discriminant,\n                Some((_, disc)) => match disc {\n                    syn::Expr::Lit(expr_lit) => match &expr_lit.lit {\n                        syn::Lit::Int(int) => {\n                            int.base10_parse::<u32>().expect(\"Must be a base 10 number\")\n                        }",
    "pub fn parse(_attrs: &[syn::Attribute]) -> Option<[u8; 8]> {\n    None\n}\n\n#[cfg(feature = \"interface-instructions\")]\npub fn parse(attrs: &[syn::Attribute]) -> Option<[u8; 8]> {\n    let interfaces: Vec<[u8; 8]> = attrs\n        .iter()\n        .filter_map(|attr| {\n            if attr.path.is_ident(\"interface\") {\n                if let Ok(Meta::List(meta_list)) = attr.parse_meta() {\n                    if let Some(NestedMeta::Meta(Meta::Path(path))) = meta_list.nested.first() {\n                        return Some(parse_interface_instruction(path));\n                    }\n                }\n                panic!(\n                    \"Failed to parse interface instruction:\\n{}\",\n                    quote::quote!(#attr)\n                );\n            }\n            None\n        })\n        .collect();\n    if interfaces.len() > 1 {\n        panic!(\"An instruction can only implement one interface instruction\");\n    } else if interfaces.is_empty() {\n        None\n    } else {\n        Some(interfaces[0])\n    }",
    "pub fn parse(f: &syn::Field, f_ty: Option<&Ty>) -> ParseResult<ConstraintGroup> {\n    let mut constraints = ConstraintGroupBuilder::new(f_ty);\n    for attr in f.attrs.iter().filter(is_account) {\n        for c in attr.parse_args_with(Punctuated::<ConstraintToken, Comma>::parse_terminated)? {\n            constraints.add(c)?;\n        }\n    }\n    let account_constraints = constraints.build()?;\n\n    Ok(account_constraints)\n}",
    "pub fn is_account(attr: &&syn::Attribute) -> bool {\n    attr.path\n        .get_ident()\n        .is_some_and(|ident| ident == \"account\")\n}",
    "pub fn parse_token(stream: ParseStream) -> ParseResult<ConstraintToken> {\n    let ident = stream.call(Ident::parse_any)?;\n    let kw = ident.to_string();\n\n    let c = match kw.as_str() {\n        \"init\" => ConstraintToken::Init(Context::new(\n            ident.span(),\n            ConstraintInit { if_needed: false },\n        )),\n        \"init_if_needed\" => ConstraintToken::Init(Context::new(\n            ident.span(),\n            ConstraintInit { if_needed: true },\n        )),\n        \"zero\" => ConstraintToken::Zeroed(Context::new(ident.span(), ConstraintZeroed {})),\n        \"mut\" => ConstraintToken::Mut(Context::new(\n            ident.span(),\n            ConstraintMut {\n                error: parse_optional_custom_error(&stream)?,\n            },\n        )),\n        \"signer\" => ConstraintToken::Signer(Context::new(\n            ident.span(),\n            ConstraintSigner {\n                error: parse_optional_custom_error(&stream)?,\n            },\n        )),\n        \"executable\" => {\n            ConstraintToken::Executable(Context::new(ident.span(), ConstraintExecutable {}))\n        }",
    "pub fn new(f_ty: Option<&'ty Ty>) -> Self {\n        Self {\n            f_ty,\n            init: None,\n            zeroed: None,\n            mutable: None,\n            signer: None,\n            has_one: Vec::new(),\n            raw: Vec::new(),\n            owner: None,\n            rent_exempt: None,\n            seeds: None,\n            executable: None,\n            payer: None,\n            space: None,\n            close: None,\n            address: None,\n            token_mint: None,\n            token_authority: None,\n            token_token_program: None,\n            associated_token_mint: None,\n            associated_token_authority: None,\n            associated_token_token_program: None,\n            mint_authority: None,\n            mint_freeze_authority: None,\n            mint_decimals: None,\n            mint_token_program: None,\n            extension_group_pointer_authority: None,\n            extension_group_pointer_group_address: None,\n            extension_group_member_pointer_authority: None,\n            extension_group_member_pointer_member_address: None,\n            extension_metadata_pointer_authority: None,\n            extension_metadata_pointer_metadata_address: None,\n            extension_close_authority: None,\n            extension_transfer_hook_authority: None,\n            extension_transfer_hook_program_id: None,\n            extension_permanent_delegate: None,\n            bump: None,\n            program_seed: None,\n            realloc: None,\n            realloc_payer: None,\n            realloc_zero: None,\n        }\n    }\n\n    pub fn build(mut self) -> ParseResult<ConstraintGroup> {\n        // Init.\n        if let Some(i) = &self.init {\n            if cfg!(not(feature = \"init-if-needed\")) && i.if_needed {\n                return Err(ParseError::new(\n                    i.span(),\n                    \"init_if_needed requires that anchor-lang be imported \\\n                    with the init-if-needed cargo feature enabled. \\\n                    Carefully read the init_if_needed docs before using this feature \\\n                    to make sure you know how to protect yourself against \\\n                    re-initialization attacks.\",\n                ));\n            }\n\n            match self.mutable {\n                Some(m) => {\n                    return Err(ParseError::new(\n                        m.span(),\n                        \"mut cannot be provided with init\",\n                    ))\n                }",
    "pub fn add(&mut self, c: ConstraintToken) -> ParseResult<()> {\n        match c {\n            ConstraintToken::Init(c) => self.add_init(c),\n            ConstraintToken::Zeroed(c) => self.add_zeroed(c),\n            ConstraintToken::Mut(c) => self.add_mut(c),\n            ConstraintToken::Signer(c) => self.add_signer(c),\n            ConstraintToken::HasOne(c) => self.add_has_one(c),\n            ConstraintToken::Raw(c) => self.add_raw(c),\n            ConstraintToken::Owner(c) => self.add_owner(c),\n            ConstraintToken::RentExempt(c) => self.add_rent_exempt(c),\n            ConstraintToken::Seeds(c) => self.add_seeds(c),\n            ConstraintToken::Executable(c) => self.add_executable(c),\n            ConstraintToken::Payer(c) => self.add_payer(c),\n            ConstraintToken::Space(c) => self.add_space(c),\n            ConstraintToken::Close(c) => self.add_close(c),\n            ConstraintToken::Address(c) => self.add_address(c),\n            ConstraintToken::TokenAuthority(c) => self.add_token_authority(c),\n            ConstraintToken::TokenMint(c) => self.add_token_mint(c),\n            ConstraintToken::TokenTokenProgram(c) => self.add_token_token_program(c),\n            ConstraintToken::AssociatedTokenAuthority(c) => self.add_associated_token_authority(c),\n            ConstraintToken::AssociatedTokenMint(c) => self.add_associated_token_mint(c),\n            ConstraintToken::AssociatedTokenTokenProgram(c) => {\n                self.add_associated_token_token_program(c)\n            }",
    "pub fn get() -> Self {\n        Self {\n            name: \"event_authority\",\n            seeds: quote! {b\"__event_authority\"},\n        }\n    }\n\n    /// Returns the name without surrounding quotes.\n    pub fn name_token_stream(&self) -> proc_macro2::TokenStream {\n        let name_token_stream = syn::parse_str::<syn::Expr>(self.name).unwrap();\n        quote! {#name_token_stream}\n    }\n}\n\n/// Add necessary event CPI accounts to the given accounts struct.\npub fn add_event_cpi_accounts(\n    accounts_struct: &syn::ItemStruct,\n) -> syn::parse::Result<syn::ItemStruct> {\n    let syn::ItemStruct {\n        attrs,\n        vis,\n        struct_token,\n        ident,\n        generics,\n        fields,\n        ..\n    } = accounts_struct;\n\n    let fields = fields.into_iter().collect::<Vec<_>>();\n\n    let info_lifetime = generics\n        .lifetimes()\n        .next()\n        .map(|lifetime| quote! {#lifetime})\n        .unwrap_or(quote! {'info});\n    let generics = generics\n        .lt_token\n        .map(|_| quote! {#generics})\n        .unwrap_or(quote! {<'info>});\n\n    let authority = EventAuthority::get();\n    let authority_name = authority.name_token_stream();\n    let authority_seeds = authority.seeds;\n\n    let accounts_struct = quote! {\n        #(#attrs)*\n        #vis #struct_token #ident #generics {\n            #(#fields,)*\n\n            /// CHECK: Only the event authority can invoke self-CPI\n            #[account(seeds = [#authority_seeds], bump)]\n            pub #authority_name: AccountInfo<#info_lifetime>,\n            /// CHECK: Self-CPI will fail if the program is not the current program\n            pub program: AccountInfo<#info_lifetime>,\n        }\n    };\n    syn::parse2(accounts_struct)\n}",
    "pub fn parse(accounts_struct: &syn::ItemStruct) -> ParseResult<AccountsStruct> {\n    let instruction_api: Option<Punctuated<Expr, Comma>> = accounts_struct\n        .attrs\n        .iter()\n        .find(|a| {\n            a.path\n                .get_ident()\n                .is_some_and(|ident| ident == \"instruction\")\n        }",
    "pub fn parse_account_field(f: &syn::Field) -> ParseResult<AccountField> {\n    let ident = f.ident.clone().unwrap();\n    let docs = docs::parse(&f.attrs);\n    let account_field = match is_field_primitive(f)? {\n        true => {\n            let (ty, is_optional) = parse_ty(f)?;\n            let account_constraints = constraints::parse(f, Some(&ty))?;\n            AccountField::Field(Field {\n                ident,\n                ty,\n                is_optional,\n                constraints: account_constraints,\n                docs,\n            })\n        }",
    "pub fn parse(program_mod: &syn::ItemMod) -> ParseResult<(Vec<Ix>, Option<FallbackFn>)> {\n    let mod_content = &program_mod\n        .content\n        .as_ref()\n        .ok_or_else(|| ParseError::new(program_mod.span(), \"program content not provided\"))?\n        .1;\n\n    let ixs = mod_content\n        .iter()\n        .filter_map(|item| match item {\n            syn::Item::Fn(item_fn) => {\n                let (ctx, _) = parse_args(item_fn).ok()?;\n                ctx_accounts_ident(&ctx.raw_arg).ok()?;\n                Some(item_fn)\n            }",
    "pub fn parse_args(method: &syn::ItemFn) -> ParseResult<(IxArg, Vec<IxArg>)> {\n    let mut args: Vec<IxArg> = method\n        .sig\n        .inputs\n        .iter()\n        .map(|arg: &syn::FnArg| match arg {\n            syn::FnArg::Typed(arg) => {\n                let docs = docs::parse(&arg.attrs);\n                let ident = match &*arg.pat {\n                    syn::Pat::Ident(ident) => &ident.ident,\n                    _ => return Err(ParseError::new(arg.pat.span(), \"expected argument name\")),\n                };\n                Ok(IxArg {\n                    name: ident.clone(),\n                    docs,\n                    raw_arg: arg.clone(),\n                })\n            }",
    "pub fn parse_return(method: &syn::ItemFn) -> ParseResult<IxReturn> {\n    match method.sig.output {\n        syn::ReturnType::Type(_, ref ty) => {\n            let ty = match ty.as_ref() {\n                syn::Type::Path(ty) => ty,\n                _ => return Err(ParseError::new(ty.span(), \"expected a return type\")),\n            };\n            // Assume unit return by default\n            let default_generic_arg = syn::GenericArgument::Type(syn::parse_str(\"()\").unwrap());\n            let generic_args = match &ty.path.segments.last().unwrap().arguments {\n                syn::PathArguments::AngleBracketed(params) => params.args.iter().last().unwrap(),\n                _ => &default_generic_arg,\n            };\n            let ty = match generic_args {\n                syn::GenericArgument::Type(ty) => ty.clone(),\n                _ => {\n                    return Err(ParseError::new(\n                        ty.span(),\n                        \"expected generic return type to be a type\",\n                    ))\n                }",
    "pub fn parse(program_mod: syn::ItemMod) -> ParseResult<Program> {\n    let docs = docs::parse(&program_mod.attrs);\n    let (ixs, fallback_fn) = instructions::parse(&program_mod)?;\n    Ok(Program {\n        ixs,\n        name: program_mod.ident.clone(),\n        docs,\n        program_mod,\n        fallback_fn,\n    })\n}",
    "pub fn amount(account: &AccountInfo) -> Result<u64> {\n        let bytes = account.try_borrow_data()?;\n        let mut amount_bytes = [0u8; 8];\n        amount_bytes.copy_from_slice(&bytes[64..72]);\n        Ok(u64::from_le_bytes(amount_bytes))\n    }",
    "pub fn mint(account: &AccountInfo) -> Result<Pubkey> {\n        let bytes = account.try_borrow_data()?;\n        let mut mint_bytes = [0u8; 32];\n        mint_bytes.copy_from_slice(&bytes[..32]);\n        Ok(Pubkey::new_from_array(mint_bytes))\n    }",
    "pub fn authority(account: &AccountInfo) -> Result<Pubkey> {\n        let bytes = account.try_borrow_data()?;\n        let mut owner_bytes = [0u8; 32];\n        owner_bytes.copy_from_slice(&bytes[32..64]);\n        Ok(Pubkey::new_from_array(owner_bytes))\n    }",
    "pub fn find_mint_account_size(extensions: Option<&ExtensionsVec>) -> anchor_lang::Result<usize> {\n    if let Some(extensions) = extensions {\n        Ok(ExtensionType::try_calculate_account_len::<\n            spl_token_2022::state::Mint,\n        >(extensions)?)\n    }",
    "pub fn initialize(\n        ctx: Context<Initialize>,\n        balance: f32,\n        amount: u32,\n        memo: String,\n        values: Vec<u128>,\n    ) -> Result<()> {\n        let my_account = &mut ctx.accounts.my_account;\n\n        my_account.balance = balance;\n        my_account.delegate_pubkey = ctx.accounts.user.key().clone();\n        my_account.sub = Sub {\n            values,\n            state: State::Confirmed { amount, memo },\n        };\n\n        Ok(())\n    }",
    "pub fn initialize(_ctx: Context<Initialize>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn uninitialize(_ctx: Context<Initialize>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn assert_is_ata(ata: &AccountInfo, wallet: &Pubkey, mint: &Pubkey) -> Result<Account> {\n    assert_owned_by(ata, &spl_token::id())?;\n    let ata_account: Account = assert_initialized(ata)?;\n    assert_keys_equal(ata_account.owner, *wallet)?;\n    assert_keys_equal(get_associated_token_address(wallet, mint), *ata.key)?;\n    Ok(ata_account)\n}",
    "pub fn assert_valid_delegation(\n    src_account: &AccountInfo,\n    dst_account: &AccountInfo,\n    src_wallet: &AccountInfo,\n    dst_wallet: &AccountInfo,\n    transfer_authority: &AccountInfo,\n    mint: &anchor_lang::accounts::account::Account<Mint>,\n    paysize: u64,\n) -> Result<()> {\n    match Account::unpack(&src_account.data.borrow()) {\n        Ok(token_account) => {\n            // Ensure that the delegated amount is exactly equal to the maker_size\n            msg!(\n                \"Delegate {}\",\n                token_account.delegate.unwrap_or(*src_wallet.key)\n            );\n            msg!(\"Delegated Amount {}\", token_account.delegated_amount);\n            if token_account.delegated_amount != paysize {\n                return Err(ProgramError::InvalidAccountData.into());\n            }\n            // Ensure that authority is the delegate of this token account\n            msg!(\"Authority key matches\");\n            if token_account.delegate != COption::Some(*transfer_authority.key) {\n                return Err(ProgramError::InvalidAccountData.into());\n            }\n\n            msg!(\"Delegate matches\");\n            assert_is_ata(src_account, src_wallet.key, &mint.key())?;\n            assert_is_ata(dst_account, dst_wallet.key, &mint.key())?;\n            msg!(\"ATAs match\")\n        }",
    "pub fn assert_keys_equal(key1: Pubkey, key2: Pubkey) -> Result<()> {\n    if key1 != key2 {\n        err!(ErrorCode::PublicKeyMismatch)\n    }",
    "pub fn assert_owned_by(account: &AccountInfo, owner: &Pubkey) -> Result<()> {\n    if account.owner != owner {\n        err!(ErrorCode::IncorrectOwner)\n    }",
    "pub fn get_mint_from_token_account(token_account_info: &AccountInfo) -> Result<Pubkey> {\n    // TokeAccount layout:   mint(32), owner(32), ...\n    let data = token_account_info.try_borrow_data()?;\n    let mint_data = array_ref![data, 0, 32];\n    Ok(Pubkey::new_from_array(*mint_data))\n}",
    "pub fn get_delegate_from_token_account(token_account_info: &AccountInfo) -> Result<Option<Pubkey>> {\n    // TokeAccount layout:   mint(32), owner(32), ...\n    let data = token_account_info.try_borrow_data()?;\n    let key_data = array_ref![data, 76, 32];\n    let coption_data = u32::from_le_bytes(*array_ref![data, 72, 4]);\n    if coption_data == 0 {\n        Ok(None)\n    }",
    "pub fn assert_derivation(program_id: &Pubkey, account: &AccountInfo, path: &[&[u8]]) -> Result<u8> {\n    let (key, bump) = Pubkey::find_program_address(&path, program_id);\n    if key != *account.key {\n        return err!(ErrorCode::DerivedKeyInvalid);\n    }\n    Ok(bump)\n}",
    "pub fn account_info1(_ctx: Context<AccountInfo1>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn account_info2(_ctx: Context<AccountInfo2>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn account_info4(_ctx: Context<AccountInfo4>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn account_info8(_ctx: Context<AccountInfo8>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn account_empty_init1(_ctx: Context<AccountEmptyInit1>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn account_empty_init2(_ctx: Context<AccountEmptyInit2>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn account_empty_init4(_ctx: Context<AccountEmptyInit4>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn account_empty_init8(_ctx: Context<AccountEmptyInit8>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn account_empty1(_ctx: Context<AccountEmpty1>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn account_empty2(_ctx: Context<AccountEmpty2>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn account_empty4(_ctx: Context<AccountEmpty4>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn account_empty8(_ctx: Context<AccountEmpty8>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn account_sized_init1(_ctx: Context<AccountSizedInit1>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn account_sized_init2(_ctx: Context<AccountSizedInit2>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn account_sized_init4(_ctx: Context<AccountSizedInit4>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn account_sized_init8(_ctx: Context<AccountSizedInit8>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn account_sized1(_ctx: Context<AccountSized1>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn account_sized2(_ctx: Context<AccountSized2>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn account_sized4(_ctx: Context<AccountSized4>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn account_sized8(_ctx: Context<AccountSized8>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn account_unsized_init1(_ctx: Context<AccountUnsizedInit1>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn account_unsized_init2(_ctx: Context<AccountUnsizedInit2>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn account_unsized_init4(_ctx: Context<AccountUnsizedInit4>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn account_unsized_init8(_ctx: Context<AccountUnsizedInit8>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn account_unsized1(_ctx: Context<AccountUnsized1>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn account_unsized2(_ctx: Context<AccountUnsized2>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn account_unsized4(_ctx: Context<AccountUnsized4>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn account_unsized8(_ctx: Context<AccountUnsized8>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn boxed_account_empty_init1(_ctx: Context<BoxedAccountEmptyInit1>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn boxed_account_empty_init2(_ctx: Context<BoxedAccountEmptyInit2>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn boxed_account_empty_init4(_ctx: Context<BoxedAccountEmptyInit4>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn boxed_account_empty_init8(_ctx: Context<BoxedAccountEmptyInit8>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn boxed_account_empty1(_ctx: Context<BoxedAccountEmpty1>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn boxed_account_empty2(_ctx: Context<BoxedAccountEmpty2>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn boxed_account_empty4(_ctx: Context<BoxedAccountEmpty4>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn boxed_account_empty8(_ctx: Context<BoxedAccountEmpty8>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn boxed_account_sized_init1(_ctx: Context<BoxedAccountSizedInit1>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn boxed_account_sized_init2(_ctx: Context<BoxedAccountSizedInit2>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn boxed_account_sized_init4(_ctx: Context<BoxedAccountSizedInit4>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn boxed_account_sized_init8(_ctx: Context<BoxedAccountSizedInit8>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn boxed_account_sized1(_ctx: Context<BoxedAccountSized1>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn boxed_account_sized2(_ctx: Context<BoxedAccountSized2>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn boxed_account_sized4(_ctx: Context<BoxedAccountSized4>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn boxed_account_sized8(_ctx: Context<BoxedAccountSized8>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn boxed_account_unsized_init1(_ctx: Context<BoxedAccountUnsizedInit1>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn boxed_account_unsized_init2(_ctx: Context<BoxedAccountUnsizedInit2>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn boxed_account_unsized_init4(_ctx: Context<BoxedAccountUnsizedInit4>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn boxed_account_unsized_init8(_ctx: Context<BoxedAccountUnsizedInit8>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn boxed_account_unsized1(_ctx: Context<BoxedAccountUnsized1>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn boxed_account_unsized2(_ctx: Context<BoxedAccountUnsized2>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn boxed_account_unsized4(_ctx: Context<BoxedAccountUnsized4>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn boxed_account_unsized8(_ctx: Context<BoxedAccountUnsized8>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn boxed_interface_account_mint1(_ctx: Context<BoxedInterfaceAccountMint1>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn boxed_interface_account_mint2(_ctx: Context<BoxedInterfaceAccountMint2>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn boxed_interface_account_mint4(_ctx: Context<BoxedInterfaceAccountMint4>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn boxed_interface_account_mint8(_ctx: Context<BoxedInterfaceAccountMint8>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn boxed_interface_account_token1(\n        _ctx: Context<BoxedInterfaceAccountToken1>,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn boxed_interface_account_token2(\n        _ctx: Context<BoxedInterfaceAccountToken2>,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn boxed_interface_account_token4(\n        _ctx: Context<BoxedInterfaceAccountToken4>,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn boxed_interface_account_token8(\n        _ctx: Context<BoxedInterfaceAccountToken8>,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn interface_account_mint1(_ctx: Context<InterfaceAccountMint1>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn interface_account_mint2(_ctx: Context<InterfaceAccountMint2>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn interface_account_mint4(_ctx: Context<InterfaceAccountMint4>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn interface_account_mint8(_ctx: Context<InterfaceAccountMint8>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn interface_account_token1(_ctx: Context<InterfaceAccountToken1>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn interface_account_token2(_ctx: Context<InterfaceAccountToken2>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn interface_account_token4(_ctx: Context<InterfaceAccountToken4>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn interface1(_ctx: Context<Interface1>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn interface2(_ctx: Context<Interface2>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn interface4(_ctx: Context<Interface4>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn interface8(_ctx: Context<Interface8>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn program1(_ctx: Context<Program1>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn program2(_ctx: Context<Program2>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn program4(_ctx: Context<Program4>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn program8(_ctx: Context<Program8>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn signer1(_ctx: Context<Signer1>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn signer2(_ctx: Context<Signer2>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn signer4(_ctx: Context<Signer4>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn signer8(_ctx: Context<Signer8>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn system_account1(_ctx: Context<SystemAccount1>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn system_account2(_ctx: Context<SystemAccount2>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn system_account4(_ctx: Context<SystemAccount4>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn system_account8(_ctx: Context<SystemAccount8>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn unchecked_account1(_ctx: Context<UncheckedAccount1>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn unchecked_account2(_ctx: Context<UncheckedAccount2>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn unchecked_account4(_ctx: Context<UncheckedAccount4>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn unchecked_account8(_ctx: Context<UncheckedAccount8>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn set_admin_settings(ctx: Context<SetAdminSettings>, admin_data: u64) -> Result<()> {\n        match *ctx.accounts.program {\n            UpgradeableLoaderState::Program {\n                programdata_address,\n            } => {\n                if programdata_address != ctx.accounts.program_data.key() {\n                    return err!(CustomError::InvalidProgramDataAddress);\n                }\n            }\n            _ => {\n                return err!(CustomError::AccountNotProgram);\n            }\n        };\n        ctx.accounts.settings.admin_data = admin_data;\n        Ok(())\n    }",
    "pub fn set_admin_settings_use_program_state(\n        ctx: Context<SetAdminSettingsUseProgramState>,\n        admin_data: u64,\n    ) -> Result<()> {\n        ctx.accounts.settings.admin_data = admin_data;\n        Ok(())\n    }",
    "pub fn create_check(\n        ctx: Context<CreateCheck>,\n        amount: u64,\n        memo: Option<String>,\n        nonce: u8,\n    ) -> Result<()> {\n        // Transfer funds to the check.\n        let cpi_accounts = Transfer {\n            from: ctx.accounts.from.to_account_info(),\n            to: ctx.accounts.vault.to_account_info(),\n            authority: ctx.accounts.owner.clone(),\n        };\n        let cpi_program = ctx.accounts.token_program.clone();\n        let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);\n        token::transfer(cpi_ctx, amount)?;\n\n        // Print the check.\n        let check = &mut ctx.accounts.check;\n        check.amount = amount;\n        check.from = *ctx.accounts.from.to_account_info().key;\n        check.to = *ctx.accounts.to.to_account_info().key;\n        check.vault = *ctx.accounts.vault.to_account_info().key;\n        check.nonce = nonce;\n        check.memo = memo;\n\n        Ok(())\n    }",
    "pub fn cash_check(ctx: Context<CashCheck>) -> Result<()> {\n        let seeds = &[\n            ctx.accounts.check.to_account_info().key.as_ref(),\n            &[ctx.accounts.check.nonce],\n        ];\n        let signer = &[&seeds[..]];\n        let cpi_accounts = Transfer {\n            from: ctx.accounts.vault.to_account_info(),\n            to: ctx.accounts.to.to_account_info(),\n            authority: ctx.accounts.check_signer.clone(),\n        };\n        let cpi_program = ctx.accounts.token_program.clone();\n        let cpi_ctx = CpiContext::new_with_signer(cpi_program, cpi_accounts, signer);\n        token::transfer(cpi_ctx, ctx.accounts.check.amount)?;\n        // Burn the check for one time use.\n        ctx.accounts.check.burned = true;\n        Ok(())\n    }",
    "pub fn cancel_check(ctx: Context<CancelCheck>) -> Result<()> {\n        let seeds = &[\n            ctx.accounts.check.to_account_info().key.as_ref(),\n            &[ctx.accounts.check.nonce],\n        ];\n        let signer = &[&seeds[..]];\n        let cpi_accounts = Transfer {\n            from: ctx.accounts.vault.to_account_info(),\n            to: ctx.accounts.from.to_account_info(),\n            authority: ctx.accounts.check_signer.clone(),\n        };\n        let cpi_program = ctx.accounts.token_program.clone();\n        let cpi_ctx = CpiContext::new_with_signer(cpi_program, cpi_accounts, signer);\n        token::transfer(cpi_ctx, ctx.accounts.check.amount)?;\n        ctx.accounts.check.burned = true;\n        Ok(())\n    }",
    "pub fn accounts(ctx: &Context<CreateCheck>, nonce: u8) -> Result<()> {\n        let signer = Pubkey::create_program_address(\n            &[ctx.accounts.check.to_account_info().key.as_ref(), &[nonce]],\n            ctx.program_id,\n        )\n        .map_err(|_| error!(ErrorCode::InvalidCheckNonce))?;\n        if &signer != ctx.accounts.check_signer.to_account_info().key {\n            return err!(ErrorCode::InvalidCheckSigner);\n        }\n        Ok(())\n    }",
    "pub fn create_officer(\n        ctx: Context<CreateOfficer>,\n        bumps: OfficerBumps,\n        d: Distribution,\n        registrar: Pubkey,\n        msrm_registrar: Pubkey,\n    ) -> Result<()> {\n        let officer = &mut ctx.accounts.officer;\n        officer.authority = *ctx.accounts.authority.key;\n        officer.swap_program = *ctx.accounts.swap_program.key;\n        officer.dex_program = ctx.accounts.dex_program.key();\n        officer.distribution = d;\n        officer.registrar = registrar;\n        officer.msrm_registrar = msrm_registrar;\n        officer.stake = *ctx.accounts.stake.to_account_info().key;\n        officer.treasury = *ctx.accounts.treasury.to_account_info().key;\n        officer.srm_vault = *ctx.accounts.srm_vault.to_account_info().key;\n        officer.bumps = bumps;\n        emit!(OfficerDidCreate {\n            pubkey: *officer.to_account_info().key,\n        });\n        Ok(())\n    }",
    "pub fn authorize_market(ctx: Context<AuthorizeMarket>, bump: u8) -> Result<()> {\n        ctx.accounts.market_auth.bump = bump;\n        Ok(())\n    }",
    "pub fn revoke_market(_ctx: Context<RevokeMarket>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn create_officer_token(_ctx: Context<CreateOfficerToken>, _bump: u8) -> Result<()> {\n        Ok(())\n    }",
    "pub fn create_officer_open_orders(\n        ctx: Context<CreateOfficerOpenOrders>,\n        _bump: u8,\n    ) -> Result<()> {\n        let seeds = [\n            ctx.accounts.dex_program.key.as_ref(),\n            &[ctx.accounts.officer.bumps.bump],\n        ];\n        let cpi_ctx = CpiContext::from(&*ctx.accounts);\n        dex::init_open_orders(cpi_ctx.with_signer(&[&seeds])).map_err(Into::into)\n    }",
    "pub fn set_distribution(ctx: Context<SetDistribution>, d: Distribution) -> Result<()> {\n        ctx.accounts.officer.distribution = d.clone();\n        emit!(DistributionDidChange { distribution: d });\n        Ok(())\n    }",
    "pub fn create_user(ctx: Context<CreateUser>, name: String) -> Result<()> {\n        ctx.accounts.user.name = name;\n        ctx.accounts.user.authority = *ctx.accounts.authority.key;\n        ctx.accounts.user.bump = ctx.bumps.user;\n        Ok(())\n    }",
    "pub fn create_chat_room(ctx: Context<CreateChatRoom>, name: String) -> Result<()> {\n        let given_name = name.as_bytes();\n        let mut name = [0u8; 280];\n        name[..given_name.len()].copy_from_slice(given_name);\n        let mut chat = ctx.accounts.chat_room.load_init()?;\n        chat.name = name;\n        Ok(())\n    }",
    "pub fn send_message(ctx: Context<SendMessage>, msg: String) -> Result<()> {\n        let mut chat = ctx.accounts.chat_room.load_mut()?;\n        chat.append({\n            let src = msg.as_bytes();\n            let mut data = [0u8; 280];\n            data[..src.len()].copy_from_slice(src);\n            Message {\n                from: *ctx.accounts.user.to_account_info().key,\n                data,\n            }\n        });\n        Ok(())\n    }",
    "pub fn initialize(_ctx: Context<Initialize>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn composite_update(\n        ctx: Context<CompositeUpdate>,\n        dummy_a: u64,\n        dummy_b: u64,\n    ) -> Result<()> {\n        let a = &mut ctx.accounts.foo.dummy_a;\n        let b = &mut ctx.accounts.bar.dummy_b;\n\n        a.data = dummy_a;\n        b.data = dummy_b;\n\n        Ok(())\n    }",
    "pub fn initialize(ctx: Context<Initialize>) -> Result<()> {\n        let account = &mut ctx.accounts.account;\n        account.value = 10;\n        Ok(())\n    }",
    "pub fn return_u64(_ctx: Context<CpiReturn>) -> Result<u64> {\n        Ok(10)\n    }",
    "pub fn return_struct(_ctx: Context<CpiReturn>) -> Result<StructReturn> {\n        let s = StructReturn { value: 11 };\n        Ok(s)\n    }",
    "pub fn return_vec(_ctx: Context<CpiReturn>) -> Result<Vec<u8>> {\n        Ok(vec![12, 13, 14, 100])\n    }",
    "pub fn return_u64_from_account(ctx: Context<CpiReturn>) -> Result<u64> {\n        let account = &ctx.accounts.account;\n        Ok(account.value)\n    }",
    "pub fn cpi_call_return_u64(ctx: Context<CpiReturnContext>) -> Result<()> {\n        let cpi_program = ctx.accounts.cpi_return_program.to_account_info();\n        let cpi_accounts = CpiReturn {\n            account: ctx.accounts.cpi_return.to_account_info(),\n        };\n        let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);\n        let result = callee::cpi::return_u64(cpi_ctx)?;\n        let solana_return = result.get();\n        anchor_lang::solana_program::log::sol_log_data(&[&solana_return.try_to_vec().unwrap()]);\n        Ok(())\n    }",
    "pub fn cpi_call_return_struct(ctx: Context<CpiReturnContext>) -> Result<()> {\n        let cpi_program = ctx.accounts.cpi_return_program.to_account_info();\n        let cpi_accounts = CpiReturn {\n            account: ctx.accounts.cpi_return.to_account_info(),\n        };\n        let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);\n        let result = callee::cpi::return_struct(cpi_ctx)?;\n        let solana_return = result.get();\n        anchor_lang::solana_program::log::sol_log_data(&[&solana_return.try_to_vec().unwrap()]);\n        Ok(())\n    }",
    "pub fn cpi_call_return_vec(ctx: Context<CpiReturnContext>) -> Result<()> {\n        let cpi_program = ctx.accounts.cpi_return_program.to_account_info();\n        let cpi_accounts = CpiReturn {\n            account: ctx.accounts.cpi_return.to_account_info(),\n        };\n        let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);\n        let result = callee::cpi::return_vec(cpi_ctx)?;\n        let solana_return = result.get();\n        anchor_lang::solana_program::log::sol_log_data(&[&solana_return.try_to_vec().unwrap()]);\n        Ok(())\n    }",
    "pub fn return_u64(ctx: Context<ReturnContext>) -> Result<u64> {\n        Ok(99)\n    }",
    "pub fn return_struct(ctx: Context<ReturnContext>) -> Result<Struct> {\n        Ok(Struct { a: 1, b: 2 })\n    }",
    "pub fn return_vec(ctx: Context<ReturnContext>) -> Result<Vec<u64>> {\n        Ok(vec![1, 2, 3])\n    }",
    "pub fn create_account(\n        ctx: Context<CreateAccount>,\n        lamports: u64,\n        space: u64,\n        owner: Pubkey,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn assign(ctx: Context<Assign>, owner: Pubkey) -> Result<()> {\n        Ok(())\n    }",
    "pub fn transfer(ctx: Context<Transfer>, lamports: u64) -> Result<()> {\n        Ok(())\n    }",
    "pub fn create_account_with_seed(\n        ctx: Context<CreateAccountWithSeed>,\n        base: Pubkey,\n        seed: String,\n        lamports: u64,\n        space: u64,\n        owner: Pubkey,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn advance_nonce_account(\n        ctx: Context<AdvanceNonceAccount>,\n        authorized: Pubkey,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn withdraw_nonce_account(ctx: Context<WithdrawNonceAccount>, lamports: u64) -> Result<()> {\n        Ok(())\n    }",
    "pub fn initialize_nonce_account(\n        ctx: Context<InitializeNonceAccount>,\n        authorized: Pubkey,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn authorize_nonce_account(\n        ctx: Context<AuthorizeNonceAccount>,\n        authorized: Pubkey,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn allocate(ctx: Context<Allocate>, space: u64) -> Result<()> {\n        Ok(())\n    }",
    "pub fn allocate_with_seed(\n        ctx: Context<AllocateWithSeed>,\n        base: Pubkey,\n        seed: String,\n        space: u64,\n        owner: Pubkey,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn assign_with_seed(\n        ctx: Context<AssignWithSeed>,\n        base: Pubkey,\n        seed: String,\n        owner: Pubkey,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn transfer_with_seed(\n        ctx: Context<TransferWithSeed>,\n        lamports: u64,\n        seed: String,\n        owner: Pubkey,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn check_accounts(_ctx: Context<CheckAccounts>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn int(_ctx: Context<DefaultIx>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn array(_ctx: Context<DefaultIx>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn byte_str(_ctx: Context<DefaultIx>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn constant(_ctx: Context<DefaultIx>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn const_fn(_ctx: Context<DefaultIx>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn account(ctx: Context<CustomAccountIx>, field: u8) -> Result<()> {\n        ctx.accounts.my_account.field = field;\n        Ok(())\n    }",
    "pub fn event(_ctx: Context<DefaultIx>, field: u8) -> Result<()> {\n        emit!(MyEvent { field });\n        Ok(())\n    }",
    "pub fn initialize(_ctx: Context<Initialize>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn cpi(ctx: Context<Cpi>, value: u32) -> Result<()> {\n        let cpi_my_account = &mut ctx.accounts.cpi_my_account;\n        require_keys_eq!(external::accounts::MyAccount::owner(), external::ID);\n        require_eq!(cpi_my_account.field, 0);\n\n        let cpi_ctx = CpiContext::new(\n            ctx.accounts.external_program.to_account_info(),\n            external::cpi::accounts::Update {\n                authority: ctx.accounts.authority.to_account_info(),\n                my_account: cpi_my_account.to_account_info(),\n            },\n        );\n        external::cpi::update(cpi_ctx, value)?;\n\n        cpi_my_account.reload()?;\n        require_eq!(cpi_my_account.field, value);\n\n        Ok(())\n    }",
    "pub fn cpi_composite(ctx: Context<Cpi>, value: u32) -> Result<()> {\n        let cpi_my_account = &mut ctx.accounts.cpi_my_account;\n\n        // Composite accounts that's also an instruction\n        let cpi_ctx = CpiContext::new(\n            ctx.accounts.external_program.to_account_info(),\n            external::cpi::accounts::UpdateComposite {\n                update: external::cpi::accounts::Update {\n                    authority: ctx.accounts.authority.to_account_info(),\n                    my_account: cpi_my_account.to_account_info(),\n                },\n            },\n        );\n        external::cpi::update_composite(cpi_ctx, 42)?;\n        cpi_my_account.reload()?;\n        require_eq!(cpi_my_account.field, 42);\n\n        // Composite accounts but not an actual instruction\n        let cpi_ctx = CpiContext::new(\n            ctx.accounts.external_program.to_account_info(),\n            external::cpi::accounts::UpdateNonInstructionComposite {\n                non_instruction_update: external::cpi::accounts::NonInstructionUpdate {\n                    authority: ctx.accounts.authority.to_account_info(),\n                    my_account: cpi_my_account.to_account_info(),\n                    program: ctx.accounts.external_program.to_account_info(),\n                },\n            },\n        );\n        external::cpi::update_non_instruction_composite(cpi_ctx, value)?;\n        cpi_my_account.reload()?;\n        require_eq!(cpi_my_account.field, value);\n\n        Ok(())\n    }",
    "pub fn account_utils(_ctx: Context<Utils>) -> Result<()> {\n        use external::utils::Account;\n\n        // Empty\n        if Account::try_from_bytes(&[]).is_ok() {\n            return Err(ProgramError::Custom(0).into());\n        }\n\n        const DISC: &[u8] = external::accounts::MyAccount::DISCRIMINATOR;\n\n        // Correct discriminator but invalid data\n        if Account::try_from_bytes(DISC).is_ok() {\n            return Err(ProgramError::Custom(1).into());\n        };\n\n        // Correct discriminator and valid data\n        match Account::try_from_bytes(&[DISC, &[1, 0, 0, 0]].concat()) {\n            Ok(Account::MyAccount(my_account)) => require_eq!(my_account.field, 1),\n            Err(e) => return Err(e.into()),\n        }\n\n        Ok(())\n    }",
    "pub fn event_utils(_ctx: Context<Utils>) -> Result<()> {\n        use external::utils::Event;\n\n        // Empty\n        if Event::try_from_bytes(&[]).is_ok() {\n            return Err(ProgramError::Custom(0).into());\n        }\n\n        const DISC: &[u8] = external::events::MyEvent::DISCRIMINATOR;\n\n        // Correct discriminator but invalid data\n        if Event::try_from_bytes(DISC).is_ok() {\n            return Err(ProgramError::Custom(1).into());\n        };\n\n        // Correct discriminator and valid data\n        match Event::try_from_bytes(&[DISC, &[1, 0, 0, 0]].concat()) {\n            Ok(Event::MyEvent(my_event)) => require_eq!(my_event.value, 1),\n            Err(e) => return Err(e.into()),\n        }\n\n        Ok(())\n    }",
    "pub fn init(_ctx: Context<Init>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn update(ctx: Context<Update>, value: u32) -> Result<()> {\n        ctx.accounts.my_account.field = value;\n        Ok(())\n    }",
    "pub fn update_composite(ctx: Context<UpdateComposite>, value: u32) -> Result<()> {\n        ctx.accounts.update.my_account.field = value;\n        Ok(())\n    }",
    "pub fn update_non_instruction_composite(\n        ctx: Context<UpdateNonInstructionComposite>,\n        value: u32,\n    ) -> Result<()> {\n        ctx.accounts.non_instruction_update.my_account.field = value;\n        Ok(())\n    }",
    "pub fn test_compilation_defined_type_param(\n        _ctx: Context<TestCompilation>,\n        _my_account: MyAccount,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_compilation_return_type(_ctx: Context<TestCompilation>) -> Result<bool> {\n        Ok(true)\n    }",
    "pub fn test_compilation_data_as_parameter_name(\n        _ctx: Context<TestCompilation>,\n        data: Vec<u8>,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_compilation_no_accounts(_ctx: Context<TestCompilationNoAccounts>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn hello(_ctx: Context<Hello>) -> Result<()> {\n        err!(MyError::Hello)\n    }",
    "pub fn hello_no_msg(_ctx: Context<Hello>) -> Result<()> {\n        err!(MyError::HelloNoMsg)\n    }",
    "pub fn hello_next(_ctx: Context<Hello>) -> Result<()> {\n        err!(MyError::HelloNext)\n    }",
    "pub fn test_require(_ctx: Context<Hello>) -> Result<()> {\n        require!(false, MyError::Hello);\n        Ok(())\n    }",
    "pub fn test_err(_ctx: Context<Hello>) -> Result<()> {\n        err!(MyError::Hello)\n    }",
    "pub fn test_program_error(_ctx: Context<Hello>) -> Result<()> {\n        Err(ProgramError::InvalidAccountData.into())\n    }",
    "pub fn test_program_error_with_source(_ctx: Context<Hello>) -> Result<()> {\n        Err(Error::from(ProgramError::InvalidAccountData).with_source(source!()))\n    }",
    "pub fn mut_error(_ctx: Context<MutError>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn has_one_error(_ctx: Context<HasOneError>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn signer_error(_ctx: Context<SignerError>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn raw_custom_error(_ctx: Context<RawCustomError>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn account_not_initialized_error(_ctx: Context<AccountNotInitializedError>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn account_owned_by_wrong_program_error(\n        _ctx: Context<AccountOwnedByWrongProgramError>,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn require_eq(_ctx: Context<RequireEq>) -> Result<()> {\n        require_eq!(5241, 124124124, MyError::ValueMismatch);\n        Ok(())\n    }",
    "pub fn require_eq_default_error(_ctx: Context<RequireEq>) -> Result<()> {\n        require_eq!(5241, 124124124);\n        Ok(())\n    }",
    "pub fn require_neq(_ctx: Context<RequireNeq>) -> Result<()> {\n        require_neq!(500, 500, MyError::ValueMatch);\n        Ok(())\n    }",
    "pub fn require_neq_default_error(_ctx: Context<RequireNeq>) -> Result<()> {\n        require_neq!(500, 500);\n        Ok(())\n    }",
    "pub fn require_keys_eq(ctx: Context<RequireKeysEq>) -> Result<()> {\n        require_keys_eq!(\n            ctx.accounts.some_account.key(),\n            *ctx.program_id,\n            MyError::ValueMismatch\n        );\n        Ok(())\n    }",
    "pub fn require_keys_eq_default_error(ctx: Context<RequireKeysEq>) -> Result<()> {\n        require_keys_eq!(ctx.accounts.some_account.key(), *ctx.program_id);\n        Ok(())\n    }",
    "pub fn require_keys_neq(ctx: Context<RequireKeysNeq>) -> Result<()> {\n        require_keys_neq!(\n            ctx.accounts.some_account.key(),\n            *ctx.program_id,\n            MyError::ValueMatch\n        );\n        Ok(())\n    }",
    "pub fn require_keys_neq_default_error(ctx: Context<RequireKeysNeq>) -> Result<()> {\n        require_keys_neq!(ctx.accounts.some_account.key(), *ctx.program_id);\n        Ok(())\n    }",
    "pub fn require_gt(_ctx: Context<RequireGt>) -> Result<()> {\n        require_gt!(5, 10, MyError::ValueLessOrEqual);\n        Ok(())\n    }",
    "pub fn require_gt_default_error(_ctx: Context<RequireGt>) -> Result<()> {\n        require_gt!(10, 10);\n        Ok(())\n    }",
    "pub fn require_gte(_ctx: Context<RequireGt>) -> Result<()> {\n        require_gte!(5, 10, MyError::ValueLess);\n        Ok(())\n    }",
    "pub fn require_gte_default_error(_ctx: Context<RequireGt>) -> Result<()> {\n        require_gte!(5, 10);\n        Ok(())\n    }",
    "pub fn try_into_integer(_ctx: Context<Hello>) -> Result<i64> {\n        Ok(u64::MAX.try_into()?)\n    }",
    "pub fn initialize_escrow(\n        ctx: Context<InitializeEscrow>,\n        initializer_amount: u64,\n        taker_amount: u64,\n    ) -> Result<()> {\n        ctx.accounts.escrow_account.initializer_key = *ctx.accounts.initializer.key;\n        ctx.accounts\n            .escrow_account\n            .initializer_deposit_token_account = *ctx\n            .accounts\n            .initializer_deposit_token_account\n            .to_account_info()\n            .key;\n        ctx.accounts\n            .escrow_account\n            .initializer_receive_token_account = *ctx\n            .accounts\n            .initializer_receive_token_account\n            .to_account_info()\n            .key;\n        ctx.accounts.escrow_account.initializer_amount = initializer_amount;\n        ctx.accounts.escrow_account.taker_amount = taker_amount;\n\n        let (pda, _bump_seed) = Pubkey::find_program_address(&[ESCROW_PDA_SEED], ctx.program_id);\n        token_interface::set_authority(\n            ctx.accounts.into(),\n            AuthorityType::AccountOwner,\n            Some(pda),\n        )?;\n        Ok(())\n    }",
    "pub fn cancel_escrow(ctx: Context<CancelEscrow>) -> Result<()> {\n        let (_pda, bump_seed) = Pubkey::find_program_address(&[ESCROW_PDA_SEED], ctx.program_id);\n        let seeds = &[&ESCROW_PDA_SEED[..], &[bump_seed]];\n\n        token_interface::set_authority(\n            ctx.accounts\n                .into_set_authority_context()\n                .with_signer(&[&seeds[..]]),\n            AuthorityType::AccountOwner,\n            Some(ctx.accounts.escrow_account.initializer_key),\n        )?;\n\n        Ok(())\n    }",
    "pub fn exchange(ctx: Context<Exchange>) -> Result<()> {\n        // Transferring from initializer to taker\n        let (_pda, bump_seed) = Pubkey::find_program_address(&[ESCROW_PDA_SEED], ctx.program_id);\n        let seeds = &[&ESCROW_PDA_SEED[..], &[bump_seed]];\n\n        token_interface::transfer_checked(\n            ctx.accounts\n                .into_transfer_to_taker_context()\n                .with_signer(&[&seeds[..]]),\n            ctx.accounts.escrow_account.initializer_amount,\n            ctx.accounts.receive_mint.decimals,\n        )?;\n\n        token_interface::transfer_checked(\n            ctx.accounts.into_transfer_to_initializer_context(),\n            ctx.accounts.escrow_account.taker_amount,\n            ctx.accounts.deposit_mint.decimals,\n        )?;\n\n        token_interface::set_authority(\n            ctx.accounts\n                .into_set_authority_context()\n                .with_signer(&[&seeds[..]]),\n            AuthorityType::AccountOwner,\n            Some(ctx.accounts.escrow_account.initializer_key),\n        )?;\n\n        Ok(())\n    }",
    "pub fn initialize(_ctx: Context<Initialize>) -> Result<()> {\n        emit!(MyEvent {\n            data: 5,\n            label: \"hello\".to_string(),\n        });\n        Ok(())\n    }",
    "pub fn test_event(_ctx: Context<TestEvent>) -> Result<()> {\n        emit!(MyOtherEvent {\n            data: 6,\n            label: \"bye\".to_string(),\n        });\n        Ok(())\n    }",
    "pub fn test_event_cpi(ctx: Context<TestEventCpi>) -> Result<()> {\n        emit_cpi!(MyOtherEvent {\n            data: 7,\n            label: \"cpi\".to_string(),\n        });\n        Ok(())\n    }",
    "pub fn create(ctx: Context<Create>, data_f32: f32, data_f64: f64) -> Result<()> {\n        let account = &mut ctx.accounts.account;\n        let authority = &mut ctx.accounts.authority;\n\n        account.data_f32 = data_f32;\n        account.data_f64 = data_f64;\n        account.authority = authority.key();\n\n        Ok(())\n    }",
    "pub fn update(ctx: Context<Update>, data_f32: f32, data_f64: f64) -> Result<()> {\n        let account = &mut ctx.accounts.account;\n\n        account.data_f32 = data_f32;\n        account.data_f64 = data_f64;\n\n        Ok(())\n    }",
    "pub fn test_idl_doc_parse(_ctx: Context<TestIdlDocParse>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn initialize(_ctx: Context<Initialize>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn generic(\n        ctx: Context<GenericCtx>,\n        generic_field: GenericType<u32, u64, 10>,\n    ) -> Result<()> {\n        ctx.accounts.generic_acc.data = generic_field;\n        Ok(())\n    }",
    "pub fn initialize(ctx: Context<Initialize>) -> Result<()> {\n        ctx.accounts.state.set_inner(State::default());\n        Ok(())\n    }",
    "pub fn initialize_with_values(\n        ctx: Context<Initialize>,\n        bool_field: bool,\n        u8_field: u8,\n        i8_field: i8,\n        u16_field: u16,\n        i16_field: i16,\n        u32_field: u32,\n        i32_field: i32,\n        f32_field: f32,\n        u64_field: u64,\n        i64_field: i64,\n        f64_field: f64,\n        u128_field: u128,\n        i128_field: i128,\n        bytes_field: Vec<u8>,\n        string_field: String,\n        pubkey_field: Pubkey,\n        vec_field: Vec<u64>,\n        vec_struct_field: Vec<FooStruct>,\n        option_field: Option<bool>,\n        option_struct_field: Option<FooStruct>,\n        struct_field: FooStruct,\n        array_field: [bool; 3],\n        enum_field_1: FooEnum,\n        enum_field_2: FooEnum,\n        enum_field_3: FooEnum,\n        enum_field_4: FooEnum,\n    ) -> Result<()> {\n        ctx.accounts.state.set_inner(State {\n            bool_field,\n            u8_field,\n            i8_field,\n            u16_field,\n            i16_field,\n            u32_field,\n            i32_field,\n            f32_field,\n            u64_field,\n            i64_field,\n            f64_field,\n            u128_field,\n            i128_field,\n            bytes_field,\n            string_field,\n            pubkey_field,\n            vec_field,\n            vec_struct_field,\n            option_field,\n            option_struct_field,\n            struct_field,\n            array_field,\n            enum_field_1,\n            enum_field_2,\n            enum_field_3,\n            enum_field_4,\n        });\n\n        Ok(())\n    }",
    "pub fn initialize_with_values2(\n        ctx: Context<Initialize2>,\n        vec_of_option: Vec<Option<u64>>,\n        box_field: Box<bool>,\n    ) -> Result<SomeRetStruct> {\n        ctx.accounts.state.set_inner(State2 {\n            vec_of_option,\n            box_field,\n        });\n        Ok(SomeRetStruct { some_field: 3 })\n    }",
    "pub fn cause_error(_ctx: Context<CauseError>) -> Result<()> {\n        Err(error!(ErrorCode::SomeError))\n    }",
    "pub fn no_case_conversion(ctx: Context<NoCaseConversion>, field_name: u8) -> Result<()> {\n        ctx.accounts.case_conversion_account.field_name = field_name;\n        emit!(SimpleEvent { field_name });\n        Ok(())\n    }",
    "pub fn empty(_ctx: Context<Empty>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn primitive_types(\n        ctx: Context<PrimitiveTypes>,\n        bool: bool,\n        i8: i8,\n        i16: i16,\n        i32: i32,\n        i64: i64,\n        i128: i128,\n        u8: u8,\n        u16: u16,\n        u32: u32,\n        u64: u64,\n        u128: u128,\n        f32: f32,\n        f64: f64,\n        pubkey: Pubkey,\n    ) -> Result<()> {\n        ctx.accounts.account.bool = bool;\n\n        ctx.accounts.account.i8 = i8;\n        ctx.accounts.account.i16 = i16;\n        ctx.accounts.account.i32 = i32;\n        ctx.accounts.account.i64 = i64;\n        ctx.accounts.account.i128 = i128;\n\n        ctx.accounts.account.u8 = u8;\n        ctx.accounts.account.u16 = u16;\n        ctx.accounts.account.u32 = u32;\n        ctx.accounts.account.u64 = u64;\n        ctx.accounts.account.u128 = u128;\n\n        ctx.accounts.account.f32 = f32;\n        ctx.accounts.account.f64 = f64;\n\n        ctx.accounts.account.pubkey = pubkey;\n        Ok(())\n    }",
    "pub fn unsized_types(ctx: Context<UnsizedTypes>, string: String, bytes: Vec<u8>) -> Result<()> {\n        ctx.accounts.account.string = string;\n        ctx.accounts.account.bytes = bytes;\n        Ok(())\n    }",
    "pub fn strct(\n        ctx: Context<Struct>,\n        unit: UnitStruct,\n        named: NamedStruct,\n        tuple: TupleStruct,\n    ) -> Result<()> {\n        ctx.accounts.account.unit = unit;\n        ctx.accounts.account.named = named;\n        ctx.accounts.account.tuple = tuple;\n        Ok(())\n    }",
    "pub fn enm(ctx: Context<Enum>, full_enum: FullEnum) -> Result<()> {\n        ctx.accounts.account.full_enum = full_enum;\n        Ok(())\n    }",
    "pub fn type_alias(\n        ctx: Context<TypeAlias>,\n        alias_u8: AliasU8,\n        alias_u8_array: AliasU8Array,\n        alias_struct: AliasStruct,\n        alias_vec_string: AliasVec<String>,\n        alias_option_vec_pubkey: AliasOptionVec<Pubkey>,\n        alias_generic_const: AliasGenericConst<4>,\n        alias_multiple_generics_mixed: AliasMultipleGenericMixed<bool, 2>,\n        alias_external: UnixTimestamp,\n    ) -> Result<()> {\n        ctx.accounts.account.alias_u8 = alias_u8;\n        ctx.accounts.account.alias_u8_array = alias_u8_array;\n        ctx.accounts.account.alias_struct = alias_struct;\n        ctx.accounts.account.alias_vec_string = alias_vec_string;\n        ctx.accounts.account.alias_option_vec_pubkey = alias_option_vec_pubkey;\n        ctx.accounts.account.alias_generic_const = alias_generic_const;\n        ctx.accounts.account.alias_multiple_generics_mixed = alias_multiple_generics_mixed;\n        ctx.accounts.account.alias_external = alias_external;\n        Ok(())\n    }",
    "pub fn account_and_event_arg_and_field(\n        ctx: Context<AccountAndEventArgAndField>,\n        account: AccountAndEventFieldAccount,\n    ) -> Result<()> {\n        *ctx.accounts.account = account;\n        Ok(())\n    }",
    "pub fn generic(ctx: Context<Generic>, generic_arg: GenericStruct<u16, 4>) -> Result<()> {\n        ctx.accounts.my_account.field = generic_arg;\n        Ok(())\n    }",
    "pub fn generic_custom_struct(\n        ctx: Context<GenericCustomStruct>,\n        generic_arg: GenericStruct<SomeStruct, 4>,\n    ) -> Result<()> {\n        ctx.accounts.my_account.field = generic_arg;\n        Ok(())\n    }",
    "pub fn full_path(\n        ctx: Context<FullPath>,\n        named_struct: NamedStruct,\n        some_module_named_struct: some_module::NamedStruct,\n    ) -> Result<()> {\n        ctx.accounts.account.named_struct = named_struct;\n        ctx.accounts.account.some_module_named_struct = some_module_named_struct;\n        Ok(())\n    }",
    "pub fn external(ctx: Context<External>, my_struct: external::MyStruct) -> Result<()> {\n        ctx.accounts.account.my_struct = my_struct;\n        Ok(())\n    }",
    "pub fn external_non_anchor(\n        ctx: Context<ExternalNonAnchor>,\n        feature: wrapped::Feature,\n    ) -> Result<()> {\n        ctx.accounts.account.feature = feature;\n        Ok(())\n    }",
    "pub fn init_base(ctx: Context<InitBase>) -> Result<()> {\n        ctx.accounts.account.my_account = ctx.accounts.my_account.key();\n        ctx.accounts.account.bump = ctx.bumps.account;\n        Ok(())\n    }",
    "pub fn test_relation(_ctx: Context<TestRelation>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn initialize_pool(\n        ctx: Context<InitializePool>,\n        ido_name: String,\n        _bumps: PoolBumps, // No longer used.\n        num_ido_tokens: u64,\n        ido_times: IdoTimes,\n    ) -> Result<()> {\n        msg!(\"INITIALIZE POOL\");\n\n        let ido_account = &mut ctx.accounts.ido_account;\n\n        let name_bytes = ido_name.as_bytes();\n        let mut name_data = [b' '; 10];\n        name_data[..name_bytes.len()].copy_from_slice(name_bytes);\n\n        ido_account.ido_name = name_data;\n        ido_account.bumps = PoolBumps {\n            ido_account: ctx.bumps.ido_account,\n            redeemable_mint: ctx.bumps.redeemable_mint,\n            pool_watermelon: ctx.bumps.pool_watermelon,\n            pool_usdc: ctx.bumps.pool_usdc,\n        };\n        ido_account.ido_authority = ctx.accounts.ido_authority.key();\n\n        ido_account.usdc_mint = ctx.accounts.usdc_mint.key();\n        ido_account.redeemable_mint = ctx.accounts.redeemable_mint.key();\n        ido_account.watermelon_mint = ctx.accounts.watermelon_mint.key();\n        ido_account.pool_usdc = ctx.accounts.pool_usdc.key();\n        ido_account.pool_watermelon = ctx.accounts.pool_watermelon.key();\n\n        ido_account.num_ido_tokens = num_ido_tokens;\n        ido_account.ido_times = ido_times;\n\n        // Transfer Watermelon from ido_authority to pool account.\n        let cpi_accounts = Transfer {\n            from: ctx.accounts.ido_authority_watermelon.to_account_info(),\n            to: ctx.accounts.pool_watermelon.to_account_info(),\n            authority: ctx.accounts.ido_authority.to_account_info(),\n        };\n        let cpi_program = ctx.accounts.token_program.to_account_info();\n        let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);\n        token::transfer(cpi_ctx, num_ido_tokens)?;\n\n        Ok(())\n    }",
    "pub fn init_user_redeemable(ctx: Context<InitUserRedeemable>) -> Result<()> {\n        msg!(\"INIT USER REDEEMABLE\");\n        Ok(())\n    }",
    "pub fn exchange_usdc_for_redeemable(\n        ctx: Context<ExchangeUsdcForRedeemable>,\n        amount: u64,\n    ) -> Result<()> {\n        msg!(\"EXCHANGE USDC FOR REDEEMABLE\");\n        // While token::transfer will check this, we prefer a verbose err msg.\n        if ctx.accounts.user_usdc.amount < amount {\n            return err!(ErrorCode::LowUsdc);\n        }\n\n        // Transfer user's USDC to pool USDC account.\n        let cpi_accounts = Transfer {\n            from: ctx.accounts.user_usdc.to_account_info(),\n            to: ctx.accounts.pool_usdc.to_account_info(),\n            authority: ctx.accounts.user_authority.to_account_info(),\n        };\n        let cpi_program = ctx.accounts.token_program.to_account_info();\n        let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);\n        token::transfer(cpi_ctx, amount)?;\n\n        // Mint Redeemable to user Redeemable account.\n        let ido_name = ctx.accounts.ido_account.ido_name.as_ref();\n        let seeds = &[\n            ido_name.trim_ascii_whitespace(),\n            &[ctx.accounts.ido_account.bumps.ido_account],\n        ];\n        let signer = &[&seeds[..]];\n        let cpi_accounts = MintTo {\n            mint: ctx.accounts.redeemable_mint.to_account_info(),\n            to: ctx.accounts.user_redeemable.to_account_info(),\n            authority: ctx.accounts.ido_account.to_account_info(),\n        };\n        let cpi_program = ctx.accounts.token_program.to_account_info();\n        let cpi_ctx = CpiContext::new_with_signer(cpi_program, cpi_accounts, signer);\n        token::mint_to(cpi_ctx, amount)?;\n\n        Ok(())\n    }",
    "pub fn init_escrow_usdc(ctx: Context<InitEscrowUsdc>) -> Result<()> {\n        msg!(\"INIT ESCROW USDC\");\n        Ok(())\n    }",
    "pub fn exchange_redeemable_for_usdc(\n        ctx: Context<ExchangeRedeemableForUsdc>,\n        amount: u64,\n    ) -> Result<()> {\n        msg!(\"EXCHANGE REDEEMABLE FOR USDC\");\n        // While token::burn will check this, we prefer a verbose err msg.\n        if ctx.accounts.user_redeemable.amount < amount {\n            return err!(ErrorCode::LowRedeemable);\n        }\n\n        let ido_name = ctx.accounts.ido_account.ido_name.as_ref();\n        let seeds = &[\n            ido_name.trim_ascii_whitespace(),\n            &[ctx.accounts.ido_account.bumps.ido_account],\n        ];\n        let signer = &[&seeds[..]];\n\n        // Burn the user's redeemable tokens.\n        let cpi_accounts = Burn {\n            mint: ctx.accounts.redeemable_mint.to_account_info(),\n            from: ctx.accounts.user_redeemable.to_account_info(),\n            authority: ctx.accounts.ido_account.to_account_info(),\n        };\n        let cpi_program = ctx.accounts.token_program.to_account_info();\n        let cpi_ctx = CpiContext::new_with_signer(cpi_program, cpi_accounts, signer);\n        token::burn(cpi_ctx, amount)?;\n\n        // Transfer USDC from pool account to the user's escrow account.\n        let cpi_accounts = Transfer {\n            from: ctx.accounts.pool_usdc.to_account_info(),\n            to: ctx.accounts.escrow_usdc.to_account_info(),\n            authority: ctx.accounts.ido_account.to_account_info(),\n        };\n        let cpi_program = ctx.accounts.token_program.to_account_info();\n        let cpi_ctx = CpiContext::new_with_signer(cpi_program, cpi_accounts, signer);\n        token::transfer(cpi_ctx, amount)?;\n\n        Ok(())\n    }",
    "pub fn exchange_redeemable_for_watermelon(\n        ctx: Context<ExchangeRedeemableForWatermelon>,\n        amount: u64,\n    ) -> Result<()> {\n        msg!(\"EXCHANGE REDEEMABLE FOR WATERMELON\");\n        // While token::burn will check this, we prefer a verbose err msg.\n        if ctx.accounts.user_redeemable.amount < amount {\n            return err!(ErrorCode::LowRedeemable);\n        }\n\n        // Calculate watermelon tokens due.\n        let watermelon_amount = (amount as u128)\n            .checked_mul(ctx.accounts.pool_watermelon.amount as u128)\n            .unwrap()\n            .checked_div(ctx.accounts.redeemable_mint.supply as u128)\n            .unwrap();\n\n        let ido_name = ctx.accounts.ido_account.ido_name.as_ref();\n        let seeds = &[\n            ido_name.trim_ascii_whitespace(),\n            &[ctx.accounts.ido_account.bumps.ido_account],\n        ];\n        let signer = &[&seeds[..]];\n\n        // Burn the user's redeemable tokens.\n        let cpi_accounts = Burn {\n            mint: ctx.accounts.redeemable_mint.to_account_info(),\n            from: ctx.accounts.user_redeemable.to_account_info(),\n            authority: ctx.accounts.ido_account.to_account_info(),\n        };\n        let cpi_program = ctx.accounts.token_program.to_account_info();\n        let cpi_ctx = CpiContext::new_with_signer(cpi_program, cpi_accounts, signer);\n        token::burn(cpi_ctx, amount)?;\n\n        // Transfer Watermelon from pool account to user.\n        let cpi_accounts = Transfer {\n            from: ctx.accounts.pool_watermelon.to_account_info(),\n            to: ctx.accounts.user_watermelon.to_account_info(),\n            authority: ctx.accounts.ido_account.to_account_info(),\n        };\n        let cpi_program = ctx.accounts.token_program.to_account_info();\n        let cpi_ctx = CpiContext::new_with_signer(cpi_program, cpi_accounts, signer);\n        token::transfer(cpi_ctx, watermelon_amount as u64)?;\n\n        // Send rent back to user if account is empty\n        ctx.accounts.user_redeemable.reload()?;\n        if ctx.accounts.user_redeemable.amount == 0 {\n            let cpi_accounts = CloseAccount {\n                account: ctx.accounts.user_redeemable.to_account_info(),\n                destination: ctx.accounts.user_authority.clone(),\n                authority: ctx.accounts.ido_account.to_account_info(),\n            };\n            let cpi_program = ctx.accounts.token_program.to_account_info();\n            let cpi_ctx = CpiContext::new_with_signer(cpi_program, cpi_accounts, signer);\n            token::close_account(cpi_ctx)?;\n        }\n\n        Ok(())\n    }",
    "pub fn withdraw_pool_usdc(ctx: Context<WithdrawPoolUsdc>) -> Result<()> {\n        msg!(\"WITHDRAW POOL USDC\");\n        // Transfer total USDC from pool account to ido_authority account.\n        let ido_name = ctx.accounts.ido_account.ido_name.as_ref();\n        let seeds = &[\n            ido_name.trim_ascii_whitespace(),\n            &[ctx.accounts.ido_account.bumps.ido_account],\n        ];\n        let signer = &[&seeds[..]];\n        let cpi_accounts = Transfer {\n            from: ctx.accounts.pool_usdc.to_account_info(),\n            to: ctx.accounts.ido_authority_usdc.to_account_info(),\n            authority: ctx.accounts.ido_account.to_account_info(),\n        };\n        let cpi_program = ctx.accounts.token_program.to_account_info();\n        let cpi_ctx = CpiContext::new_with_signer(cpi_program, cpi_accounts, signer);\n        token::transfer(cpi_ctx, ctx.accounts.pool_usdc.amount)?;\n\n        Ok(())\n    }",
    "pub fn withdraw_from_escrow(ctx: Context<WithdrawFromEscrow>, amount: u64) -> Result<()> {\n        msg!(\"WITHDRAW FROM ESCROW\");\n        // While token::transfer will check this, we prefer a verbose err msg.\n        if ctx.accounts.escrow_usdc.amount < amount {\n            return err!(ErrorCode::LowUsdc);\n        }\n\n        let ido_name = ctx.accounts.ido_account.ido_name.as_ref();\n        let seeds = &[\n            ido_name.trim_ascii_whitespace(),\n            &[ctx.accounts.ido_account.bumps.ido_account],\n        ];\n        let signer = &[&seeds[..]];\n\n        // Transfer USDC from user's escrow account to user's USDC account.\n        let cpi_accounts = Transfer {\n            from: ctx.accounts.escrow_usdc.to_account_info(),\n            to: ctx.accounts.user_usdc.to_account_info(),\n            authority: ctx.accounts.ido_account.to_account_info(),\n        };\n        let cpi_program = ctx.accounts.token_program.to_account_info();\n        let cpi_ctx = CpiContext::new_with_signer(cpi_program, cpi_accounts, signer);\n        token::transfer(cpi_ctx, amount)?;\n\n        // Send rent back to user if account is empty\n        ctx.accounts.escrow_usdc.reload()?;\n        if ctx.accounts.escrow_usdc.amount == 0 {\n            let cpi_accounts = CloseAccount {\n                account: ctx.accounts.escrow_usdc.to_account_info(),\n                destination: ctx.accounts.user_authority.clone(),\n                authority: ctx.accounts.ido_account.to_account_info(),\n            };\n            let cpi_program = ctx.accounts.token_program.to_account_info();\n            let cpi_ctx = CpiContext::new_with_signer(cpi_program, cpi_accounts, signer);\n            token::close_account(cpi_ctx)?;\n        }\n\n        Ok(())\n    }",
    "pub fn init(ctx: Context<Init>) -> Result<()> {\n        let mut my_account = ctx.accounts.my_account.load_mut()?;\n        my_account.authority = ctx.accounts.authority.key();\n\n        for _ in 0..MAX_DATA_LEN {\n            my_account.dynamic.push(ctx.accounts.authority.key());\n        }\n\n        Ok(())\n    }",
    "pub fn read(ctx: Context<Read>) -> Result<()> {\n        // Cached load due to the `has_one` constraint\n        let authority = ctx.accounts.my_account.load_authority()?;\n        msg!(\"Authority: {}\", authority);\n        Ok(())\n    }",
    "pub fn write(ctx: Context<Write>, new_authority: Pubkey) -> Result<()> {\n        // Cached load due to the `has_one` constraint\n        *ctx.accounts.my_account.load_mut_authority()? = new_authority;\n        Ok(())\n    }",
    "pub fn available_for_withdrawal(vesting: &Vesting, current_ts: i64) -> u64 {\n    std::cmp::min(outstanding_vested(vesting, current_ts), balance(vesting))\n}",
    "pub fn new(ctx: Context<Auth>) -> Result<Self> {\n            let mut whitelist = vec![];\n            whitelist.resize(Self::WHITELIST_SIZE, Default::default());\n            Ok(Lockup {\n                authority: *ctx.accounts.authority.key,\n                whitelist,\n            })\n        }",
    "pub fn whitelist_add(&mut self, ctx: Context<Auth>, entry: WhitelistEntry) -> Result<()> {\n            if self.whitelist.len() == Self::WHITELIST_SIZE {\n                return err!(ErrorCode::WhitelistFull);\n            }\n            if self.whitelist.contains(&entry) {\n                return err!(ErrorCode::WhitelistEntryAlreadyExists);\n            }\n            self.whitelist.push(entry);\n            Ok(())\n        }",
    "pub fn whitelist_delete(\n            &mut self,\n            ctx: Context<Auth>,\n            entry: WhitelistEntry,\n        ) -> Result<()> {\n            if !self.whitelist.contains(&entry) {\n                return err!(ErrorCode::WhitelistEntryNotFound);\n            }\n            self.whitelist.retain(|e| e != &entry);\n            Ok(())\n        }",
    "pub fn set_authority(&mut self, ctx: Context<Auth>, new_authority: Pubkey) -> Result<()> {\n            self.authority = new_authority;\n            Ok(())\n        }",
    "pub fn create_vesting(\n        ctx: Context<CreateVesting>,\n        beneficiary: Pubkey,\n        deposit_amount: u64,\n        nonce: u8,\n        start_ts: i64,\n        end_ts: i64,\n        period_count: u64,\n        realizor: Option<Realizor>,\n    ) -> Result<()> {\n        if deposit_amount == 0 {\n            return err!(ErrorCode::InvalidDepositAmount);\n        }\n        if !is_valid_schedule(start_ts, end_ts, period_count) {\n            return err!(ErrorCode::InvalidSchedule);\n        }\n        let vesting = &mut ctx.accounts.vesting;\n        vesting.beneficiary = beneficiary;\n        vesting.mint = ctx.accounts.vault.mint;\n        vesting.vault = *ctx.accounts.vault.to_account_info().key;\n        vesting.period_count = period_count;\n        vesting.start_balance = deposit_amount;\n        vesting.end_ts = end_ts;\n        vesting.start_ts = start_ts;\n        vesting.created_ts = ctx.accounts.clock.unix_timestamp;\n        vesting.outstanding = deposit_amount;\n        vesting.whitelist_owned = 0;\n        vesting.grantor = *ctx.accounts.depositor_authority.key;\n        vesting.nonce = nonce;\n        vesting.realizor = realizor;\n\n        token::transfer(ctx.accounts.into(), deposit_amount)?;\n\n        Ok(())\n    }",
    "pub fn withdraw(ctx: Context<Withdraw>, amount: u64) -> Result<()> {\n        // Has the given amount vested?\n        if amount\n            > calculator::available_for_withdrawal(\n                &ctx.accounts.vesting,\n                ctx.accounts.clock.unix_timestamp,\n            )\n        {\n            return err!(ErrorCode::InsufficientWithdrawalBalance);\n        }\n\n        // Transfer funds out.\n        let seeds = &[\n            ctx.accounts.vesting.to_account_info().key.as_ref(),\n            &[ctx.accounts.vesting.nonce],\n        ];\n        let signer = &[&seeds[..]];\n        let cpi_ctx = CpiContext::from(&*ctx.accounts).with_signer(signer);\n        token::transfer(cpi_ctx, amount)?;\n\n        // Bookeeping.\n        let vesting = &mut ctx.accounts.vesting;\n        vesting.outstanding -= amount;\n\n        Ok(())\n    }",
    "pub fn available_for_withdrawal(ctx: Context<AvailableForWithdrawal>) -> Result<()> {\n        let available = calculator::available_for_withdrawal(\n            &ctx.accounts.vesting,\n            ctx.accounts.clock.unix_timestamp,\n        );\n        // Log as string so that JS can read as a BN.\n        msg!(&format!(\"{{ \\\"result\\\": \\\"{}\\\" }}\", available));\n        Ok(())\n    }",
    "pub fn is_valid_schedule(start_ts: i64, end_ts: i64, period_count: u64) -> bool {\n    if end_ts <= start_ts {\n        return false;\n    }\n    if period_count > (end_ts - start_ts) as u64 {\n        return false;\n    }\n    if period_count == 0 {\n        return false;\n    }\n    true\n}\n\n// Returns Ok if the locked vesting account has been \"realized\". Realization\n// is application dependent. For example, in the case of staking, one must first\n// unstake before being able to earn locked tokens.\nfn is_realized(ctx: &Context<Withdraw>) -> Result<()> {\n    if let Some(realizor) = &ctx.accounts.vesting.realizor {\n        let cpi_program = {\n            let p = ctx.remaining_accounts[0].clone();\n            if p.key != &realizor.program {\n                return err!(ErrorCode::InvalidLockRealizor);\n            }\n            p\n        };\n        let cpi_accounts = ctx.remaining_accounts.to_vec()[1..].to_vec();\n        let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);\n        let vesting = (*ctx.accounts.vesting).clone();\n        realize_lock::is_realized(cpi_ctx, vesting)\n            .map_err(|_| error!(ErrorCode::UnrealizedVesting))?;\n    }\n    Ok(())\n}",
    "pub fn new(ctx: Context<Ctor>) -> Result<Self> {\n            Ok(Registry {\n                lockup_program: *ctx.accounts.lockup_program.key,\n            })\n        }",
    "pub fn set_lockup_program(\n            &mut self,\n            ctx: Context<SetLockupProgram>,\n            lockup_program: Pubkey,\n        ) -> Result<()> {\n            // Hard code the authority because the first version of this program\n            // did not set an authority account in the global state.\n            //\n            // When removing the program's upgrade authority, one should remove\n            // this method first, redeploy, then remove the upgrade authority.\n            let expected: Pubkey = \"HUgFuN4PbvF5YzjDSw9dQ8uTJUcwm2ANsMXwvRdY4ABx\"\n                .parse()\n                .unwrap();\n            if ctx.accounts.authority.key != &expected {\n                return err!(ErrorCode::InvalidProgramAuthority);\n            }\n\n            self.lockup_program = lockup_program;\n\n            Ok(())\n        }",
    "pub fn initialize(\n        ctx: Context<Initialize>,\n        mint: Pubkey,\n        authority: Pubkey,\n        nonce: u8,\n        withdrawal_timelock: i64,\n        stake_rate: u64,\n        reward_q_len: u32,\n    ) -> Result<()> {\n        let registrar = &mut ctx.accounts.registrar;\n\n        registrar.authority = authority;\n        registrar.nonce = nonce;\n        registrar.mint = mint;\n        registrar.pool_mint = *ctx.accounts.pool_mint.to_account_info().key;\n        registrar.stake_rate = stake_rate;\n        registrar.reward_event_q = *ctx.accounts.reward_event_q.to_account_info().key;\n        registrar.withdrawal_timelock = withdrawal_timelock;\n\n        let reward_q = &mut ctx.accounts.reward_event_q;\n        reward_q\n            .events\n            .resize(reward_q_len as usize, Default::default());\n\n        Ok(())\n    }",
    "pub fn update_registrar(\n        ctx: Context<UpdateRegistrar>,\n        new_authority: Option<Pubkey>,\n        withdrawal_timelock: Option<i64>,\n    ) -> Result<()> {\n        let registrar = &mut ctx.accounts.registrar;\n\n        if let Some(new_authority) = new_authority {\n            registrar.authority = new_authority;\n        }\n\n        if let Some(withdrawal_timelock) = withdrawal_timelock {\n            registrar.withdrawal_timelock = withdrawal_timelock;\n        }\n\n        Ok(())\n    }",
    "pub fn create_member(ctx: Context<CreateMember>, nonce: u8) -> Result<()> {\n        let member = &mut ctx.accounts.member;\n        member.registrar = *ctx.accounts.registrar.to_account_info().key;\n        member.beneficiary = *ctx.accounts.beneficiary.key;\n        member.balances = (&ctx.accounts.balances).into();\n        member.balances_locked = (&ctx.accounts.balances_locked).into();\n        member.nonce = nonce;\n        Ok(())\n    }",
    "pub fn update_member(ctx: Context<UpdateMember>, metadata: Option<Pubkey>) -> Result<()> {\n        let member = &mut ctx.accounts.member;\n        if let Some(m) = metadata {\n            member.metadata = m;\n        }\n        Ok(())\n    }",
    "pub fn deposit(ctx: Context<Deposit>, amount: u64) -> Result<()> {\n        token::transfer(ctx.accounts.into(), amount).map_err(Into::into)\n    }",
    "pub fn deposit_locked(ctx: Context<DepositLocked>, amount: u64) -> Result<()> {\n        token::transfer(ctx.accounts.into(), amount).map_err(Into::into)\n    }",
    "pub fn stake(ctx: Context<Stake>, spt_amount: u64, locked: bool) -> Result<()> {\n        let balances = {\n            if locked {\n                &ctx.accounts.balances_locked\n            } else {\n                &ctx.accounts.balances\n            }\n        };\n\n        // Transfer tokens into the stake vault.\n        {\n            let seeds = &[\n                ctx.accounts.registrar.to_account_info().key.as_ref(),\n                ctx.accounts.member.to_account_info().key.as_ref(),\n                &[ctx.accounts.member.nonce],\n            ];\n            let member_signer = &[&seeds[..]];\n            let cpi_ctx = CpiContext::new_with_signer(\n                ctx.accounts.token_program.clone(),\n                token::Transfer {\n                    from: balances.vault.to_account_info(),\n                    to: balances.vault_stake.to_account_info(),\n                    authority: ctx.accounts.member_signer.to_account_info(),\n                },\n                member_signer,\n            );\n            // Convert from stake-token units to mint-token units.\n            let token_amount = spt_amount\n                .checked_mul(ctx.accounts.registrar.stake_rate)\n                .unwrap();\n            token::transfer(cpi_ctx, token_amount)?;\n        }\n\n        // Mint pool tokens to the staker.\n        {\n            let seeds = &[\n                ctx.accounts.registrar.to_account_info().key.as_ref(),\n                &[ctx.accounts.registrar.nonce],\n            ];\n            let registrar_signer = &[&seeds[..]];\n\n            let cpi_ctx = CpiContext::new_with_signer(\n                ctx.accounts.token_program.clone(),\n                token::MintTo {\n                    mint: ctx.accounts.pool_mint.to_account_info(),\n                    to: balances.spt.to_account_info(),\n                    authority: ctx.accounts.registrar_signer.to_account_info(),\n                },\n                registrar_signer,\n            );\n            token::mint_to(cpi_ctx, spt_amount)?;\n        }\n\n        // Update stake timestamp.\n        let member = &mut ctx.accounts.member;\n        member.last_stake_ts = ctx.accounts.clock.unix_timestamp;\n\n        Ok(())\n    }",
    "pub fn start_unstake(ctx: Context<StartUnstake>, spt_amount: u64, locked: bool) -> Result<()> {\n        let balances = {\n            if locked {\n                &ctx.accounts.balances_locked\n            } else {\n                &ctx.accounts.balances\n            }\n        };\n\n        // Program signer.\n        let seeds = &[\n            ctx.accounts.registrar.to_account_info().key.as_ref(),\n            ctx.accounts.member.to_account_info().key.as_ref(),\n            &[ctx.accounts.member.nonce],\n        ];\n        let member_signer = &[&seeds[..]];\n\n        // Burn pool tokens.\n        {\n            let cpi_ctx = CpiContext::new_with_signer(\n                ctx.accounts.token_program.clone(),\n                token::Burn {\n                    mint: ctx.accounts.pool_mint.to_account_info(),\n                    from: balances.spt.to_account_info(),\n                    authority: ctx.accounts.member_signer.to_account_info(),\n                },\n                member_signer,\n            );\n            token::burn(cpi_ctx, spt_amount)?;\n        }\n\n        // Convert from stake-token units to mint-token units.\n        let token_amount = spt_amount\n            .checked_mul(ctx.accounts.registrar.stake_rate)\n            .unwrap();\n\n        // Transfer tokens from the stake to pending vault.\n        {\n            let cpi_ctx = CpiContext::new_with_signer(\n                ctx.accounts.token_program.clone(),\n                token::Transfer {\n                    from: balances.vault_stake.to_account_info(),\n                    to: balances.vault_pw.to_account_info(),\n                    authority: ctx.accounts.member_signer.to_account_info(),\n                },\n                member_signer,\n            );\n            token::transfer(cpi_ctx, token_amount)?;\n        }\n\n        // Print receipt.\n        let pending_withdrawal = &mut ctx.accounts.pending_withdrawal;\n        pending_withdrawal.burned = false;\n        pending_withdrawal.member = *ctx.accounts.member.to_account_info().key;\n        pending_withdrawal.start_ts = ctx.accounts.clock.unix_timestamp;\n        pending_withdrawal.end_ts =\n            ctx.accounts.clock.unix_timestamp + ctx.accounts.registrar.withdrawal_timelock;\n        pending_withdrawal.amount = token_amount;\n        pending_withdrawal.pool = ctx.accounts.registrar.pool_mint;\n        pending_withdrawal.registrar = *ctx.accounts.registrar.to_account_info().key;\n        pending_withdrawal.locked = locked;\n\n        // Update stake timestamp.\n        let member = &mut ctx.accounts.member;\n        member.last_stake_ts = ctx.accounts.clock.unix_timestamp;\n\n        Ok(())\n    }",
    "pub fn end_unstake(ctx: Context<EndUnstake>) -> Result<()> {\n        if ctx.accounts.pending_withdrawal.end_ts > ctx.accounts.clock.unix_timestamp {\n            return err!(ErrorCode::UnstakeTimelock);\n        }\n\n        // Select which balance set this affects.\n        let balances = {\n            if ctx.accounts.pending_withdrawal.locked {\n                &ctx.accounts.member.balances_locked\n            } else {\n                &ctx.accounts.member.balances\n            }\n        };\n        // Check the vaults given are correct.\n        if &balances.vault != ctx.accounts.vault.key {\n            return err!(ErrorCode::InvalidVault);\n        }\n        if &balances.vault_pw != ctx.accounts.vault_pw.key {\n            return err!(ErrorCode::InvalidVault);\n        }\n\n        // Transfer tokens between vaults.\n        {\n            let seeds = &[\n                ctx.accounts.registrar.to_account_info().key.as_ref(),\n                ctx.accounts.member.to_account_info().key.as_ref(),\n                &[ctx.accounts.member.nonce],\n            ];\n            let signer = &[&seeds[..]];\n            let cpi_ctx = CpiContext::new_with_signer(\n                ctx.accounts.token_program.clone(),\n                Transfer {\n                    from: ctx.accounts.vault_pw.to_account_info(),\n                    to: ctx.accounts.vault.to_account_info(),\n                    authority: ctx.accounts.member_signer.clone(),\n                },\n                signer,\n            );\n            token::transfer(cpi_ctx, ctx.accounts.pending_withdrawal.amount)?;\n        }\n\n        // Burn the pending withdrawal receipt.\n        let pending_withdrawal = &mut ctx.accounts.pending_withdrawal;\n        pending_withdrawal.burned = true;\n\n        Ok(())\n    }",
    "pub fn withdraw(ctx: Context<Withdraw>, amount: u64) -> Result<()> {\n        let seeds = &[\n            ctx.accounts.registrar.to_account_info().key.as_ref(),\n            ctx.accounts.member.to_account_info().key.as_ref(),\n            &[ctx.accounts.member.nonce],\n        ];\n        let signer = &[&seeds[..]];\n        let cpi_accounts = Transfer {\n            from: ctx.accounts.vault.to_account_info(),\n            to: ctx.accounts.depositor.to_account_info(),\n            authority: ctx.accounts.member_signer.clone(),\n        };\n        let cpi_program = ctx.accounts.token_program.clone();\n        let cpi_ctx = CpiContext::new_with_signer(cpi_program, cpi_accounts, signer);\n\n        token::transfer(cpi_ctx, amount).map_err(Into::into)\n    }",
    "pub fn withdraw_locked(ctx: Context<WithdrawLocked>, amount: u64) -> Result<()> {\n        let seeds = &[\n            ctx.accounts.registrar.to_account_info().key.as_ref(),\n            ctx.accounts.member.to_account_info().key.as_ref(),\n            &[ctx.accounts.member.nonce],\n        ];\n        let signer = &[&seeds[..]];\n        let cpi_accounts = Transfer {\n            from: ctx.accounts.member_vault.to_account_info(),\n            to: ctx.accounts.vesting_vault.to_account_info(),\n            authority: ctx.accounts.member_signer.clone(),\n        };\n        let cpi_program = ctx.accounts.token_program.clone();\n        let cpi_ctx = CpiContext::new_with_signer(cpi_program, cpi_accounts, signer);\n\n        token::transfer(cpi_ctx, amount).map_err(Into::into)\n    }",
    "pub fn drop_reward(\n        ctx: Context<DropReward>,\n        kind: RewardVendorKind,\n        total: u64,\n        expiry_ts: i64,\n        expiry_receiver: Pubkey,\n        nonce: u8,\n    ) -> Result<()> {\n        if total < ctx.accounts.pool_mint.supply {\n            return err!(ErrorCode::InsufficientReward);\n        }\n        if ctx.accounts.clock.unix_timestamp >= expiry_ts {\n            return err!(ErrorCode::InvalidExpiry);\n        }\n        if let RewardVendorKind::Locked {\n            start_ts,\n            end_ts,\n            period_count,\n        } = kind\n        {\n            if !lockup::is_valid_schedule(start_ts, end_ts, period_count) {\n                return err!(ErrorCode::InvalidVestingSchedule);\n            }\n        }\n\n        // Transfer funds into the vendor's vault.\n        token::transfer(ctx.accounts.into(), total)?;\n\n        // Add the event to the reward queue.\n        let reward_q = &mut ctx.accounts.reward_event_q;\n        let cursor = reward_q.append(RewardEvent {\n            vendor: *ctx.accounts.vendor.to_account_info().key,\n            ts: ctx.accounts.clock.unix_timestamp,\n            locked: kind != RewardVendorKind::Unlocked,\n        })?;\n\n        // Initialize the vendor.\n        let vendor = &mut ctx.accounts.vendor;\n        vendor.registrar = *ctx.accounts.registrar.to_account_info().key;\n        vendor.vault = *ctx.accounts.vendor_vault.to_account_info().key;\n        vendor.mint = ctx.accounts.vendor_vault.mint;\n        vendor.nonce = nonce;\n        vendor.pool_token_supply = ctx.accounts.pool_mint.supply;\n        vendor.reward_event_q_cursor = cursor;\n        vendor.start_ts = ctx.accounts.clock.unix_timestamp;\n        vendor.expiry_ts = expiry_ts;\n        vendor.expiry_receiver = expiry_receiver;\n        vendor.from = *ctx.accounts.depositor_authority.key;\n        vendor.total = total;\n        vendor.expired = false;\n        vendor.kind = kind;\n\n        Ok(())\n    }",
    "pub fn claim_reward(ctx: Context<ClaimReward>) -> Result<()> {\n        if RewardVendorKind::Unlocked != ctx.accounts.cmn.vendor.kind {\n            return err!(ErrorCode::ExpectedUnlockedVendor);\n        }\n        // Reward distribution.\n        let spt_total =\n            ctx.accounts.cmn.balances.spt.amount + ctx.accounts.cmn.balances_locked.spt.amount;\n        let reward_amount = spt_total\n            .checked_mul(ctx.accounts.cmn.vendor.total)\n            .unwrap()\n            .checked_div(ctx.accounts.cmn.vendor.pool_token_supply)\n            .unwrap();\n        assert!(reward_amount > 0);\n\n        // Send reward to the given token account.\n        let seeds = &[\n            ctx.accounts.cmn.registrar.to_account_info().key.as_ref(),\n            ctx.accounts.cmn.vendor.to_account_info().key.as_ref(),\n            &[ctx.accounts.cmn.vendor.nonce],\n        ];\n        let signer = &[&seeds[..]];\n        let cpi_ctx = CpiContext::new_with_signer(\n            ctx.accounts.cmn.token_program.clone(),\n            token::Transfer {\n                from: ctx.accounts.cmn.vault.to_account_info(),\n                to: ctx.accounts.to.to_account_info(),\n                authority: ctx.accounts.cmn.vendor_signer.to_account_info(),\n            },\n            signer,\n        );\n        token::transfer(cpi_ctx, reward_amount)?;\n\n        // Update member as having processed the reward.\n        let member = &mut ctx.accounts.cmn.member;\n        member.rewards_cursor = ctx.accounts.cmn.vendor.reward_event_q_cursor + 1;\n\n        Ok(())\n    }",
    "pub fn expire_reward(ctx: Context<ExpireReward>) -> Result<()> {\n        if ctx.accounts.clock.unix_timestamp < ctx.accounts.vendor.expiry_ts {\n            return err!(ErrorCode::VendorNotYetExpired);\n        }\n\n        // Send all remaining funds to the expiry receiver's token.\n        let seeds = &[\n            ctx.accounts.registrar.to_account_info().key.as_ref(),\n            ctx.accounts.vendor.to_account_info().key.as_ref(),\n            &[ctx.accounts.vendor.nonce],\n        ];\n        let signer = &[&seeds[..]];\n        let cpi_ctx = CpiContext::new_with_signer(\n            ctx.accounts.token_program.clone(),\n            token::Transfer {\n                to: ctx.accounts.expiry_receiver_token.to_account_info(),\n                from: ctx.accounts.vault.to_account_info(),\n                authority: ctx.accounts.vendor_signer.to_account_info(),\n            },\n            signer,\n        );\n        token::transfer(cpi_ctx, ctx.accounts.vault.amount)?;\n\n        // Burn the vendor.\n        let vendor = &mut ctx.accounts.vendor;\n        vendor.expired = true;\n\n        Ok(())\n    }",
    "pub fn append(&mut self, event: RewardEvent) -> Result<u32> {\n        let cursor = self.head;\n\n        // Insert into next available slot.\n        let h_idx = self.index_of(self.head);\n        self.events[h_idx] = event;\n\n        // Update head and tail counters.\n        let is_full = self.index_of(self.head + 1) == self.index_of(self.tail);\n        if is_full {\n            self.tail += 1;\n        }\n        self.head += 1;\n\n        Ok(cursor)\n    }",
    "pub fn index_of(&self, counter: u32) -> usize {\n        counter as usize % self.capacity()\n    }",
    "pub fn capacity(&self) -> usize {\n        self.events.len()\n    }",
    "pub fn get(&self, cursor: u32) -> &RewardEvent {\n        &self.events[cursor as usize % self.capacity()]\n    }\n\n    pub fn head(&self) -> u32 {\n        self.head\n    }\n\n    pub fn tail(&self) -> u32 {\n        self.tail\n    }\n}\n\n#[derive(Default, Clone, Copy, Debug, AnchorSerialize, AnchorDeserialize)]\npub struct RewardEvent {\n    vendor: Pubkey,\n    ts: i64,\n    locked: bool,\n}\n\n#[account]\npub struct RewardVendor {\n    pub registrar: Pubkey,\n    pub vault: Pubkey,\n    pub mint: Pubkey,\n    pub nonce: u8,\n    pub pool_token_supply: u64,\n    pub reward_event_q_cursor: u32,\n    pub start_ts: i64,\n    pub expiry_ts: i64,\n    pub expiry_receiver: Pubkey,\n    pub from: Pubkey,\n    pub total: u64,\n    pub expired: bool,\n    pub kind: RewardVendorKind,\n}\n\n#[derive(AnchorSerialize, AnchorDeserialize, Clone, PartialEq)]\npub enum RewardVendorKind {\n    Unlocked,\n    Locked {\n        start_ts: i64,\n        end_ts: i64,\n        period_count: u64,\n    },\n}\n\n#[error_code]\npub enum ErrorCode {\n    #[msg(\"The given reward queue has already been initialized.\")]\n    RewardQAlreadyInitialized,\n    #[msg(\"The nonce given doesn't derive a valid program address.\")]\n    InvalidNonce,\n    #[msg(\"Invalid pool mint authority\")]\n    InvalidPoolMintAuthority,\n    #[msg(\"Member signer doesn't match the derived address.\")]\n    InvalidMemberSigner,\n    #[msg(\"The given vault owner must match the signing depositor.\")]\n    InvalidVaultDeposit,\n    #[msg(\"The signing depositor doesn't match either of the balance accounts\")]\n    InvalidDepositor,\n    #[msg(\"The vault given does not match the vault expected.\")]\n    InvalidVault,\n    #[msg(\"Invalid vault owner.\")]\n    InvalidVaultOwner,\n    #[msg(\"An unknown error has occurred.\")]\n    Unknown,\n    #[msg(\"The unstake timelock has not yet expired.\")]\n    UnstakeTimelock,\n    #[msg(\"Reward vendors must have at least one token unit per pool token\")]\n    InsufficientReward,\n    #[msg(\"Reward expiry must be after the current clock timestamp.\")]\n    InvalidExpiry,\n    #[msg(\"The reward vendor has been expired.\")]\n    VendorExpired,\n    #[msg(\"This reward has already been processed.\")]\n    CursorAlreadyProcessed,\n    #[msg(\"The account was not staked at the time of this reward.\")]\n    NotStakedDuringDrop,\n    #[msg(\"The vendor is not yet eligible for expiry.\")]\n    VendorNotYetExpired,\n    #[msg(\"Please collect your reward before otherwise using the program.\")]\n    RewardsNeedsProcessing,\n    #[msg(\"Locked reward vendor expected but an unlocked vendor was given.\")]\n    ExpectedLockedVendor,\n    #[msg(\"Unlocked reward vendor expected but a locked vendor was given.\")]\n    ExpectedUnlockedVendor,\n    #[msg(\"Locked deposit from an invalid deposit authority.\")]\n    InvalidVestingSigner,\n    #[msg(\"Locked rewards cannot be realized until one unstaked all tokens.\")]\n    UnrealizedReward,\n    #[msg(\"The beneficiary doesn't match.\")]\n    InvalidBeneficiary,\n    #[msg(\"The given member account does not match the realizor metadata.\")]\n    InvalidRealizorMetadata,\n    #[msg(\"Invalid vesting schedule for the locked reward.\")]\n    InvalidVestingSchedule,\n    #[msg(\"Please specify the correct authority for this program.\")]\n    InvalidProgramAuthority,\n}\n\nimpl<'a, 'b, 'c, 'info> From<&mut Deposit<'info>>\n    for CpiContext<'a, 'b, 'c, 'info, Transfer<'info>>\n{\n    fn from(accounts: &mut Deposit<'info>) -> CpiContext<'a, 'b, 'c, 'info, Transfer<'info>> {\n        let cpi_accounts = Transfer {\n            from: accounts.depositor.clone(),\n            to: accounts.vault.to_account_info(),\n            authority: accounts.depositor_authority.clone(),\n        };\n        let cpi_program = accounts.token_program.clone();\n        CpiContext::new(cpi_program, cpi_accounts)\n    }",
    "pub fn initialize(ctx: Context<Initialize>, _val: u8) -> Result<()> {\n        ctx.accounts.acc.val = 1000;\n        Ok(())\n    }",
    "pub fn second_initialize(ctx: Context<SecondInitialize>, _val: u8) -> Result<()> {\n        ctx.accounts.acc.other_val = 2000;\n        Ok(())\n    }",
    "pub fn close(ctx: Context<Close>) -> Result<()> {\n        ctx.accounts.acc.val = 5000;\n        Ok(())\n    }",
    "pub fn transfer(ctx: Context<Transfer>, amount: u64) -> Result<()> {\n        let pda = &ctx.accounts.pda;\n        let signer = &ctx.accounts.signer;\n\n        // Transfer **to** PDA\n        {\n            // Get the balance of the PDA **before** the transfer to PDA\n            let pda_balance_before = pda.get_lamports();\n\n            // Transfer to the PDA\n            anchor_lang::system_program::transfer(\n                CpiContext::new(\n                    ctx.accounts.system_program.to_account_info(),\n                    anchor_lang::system_program::Transfer {\n                        from: signer.to_account_info(),\n                        to: pda.to_account_info(),\n                    },\n                ),\n                amount,\n            )?;\n\n            // Get the balance of the PDA **after** the transfer to PDA\n            let pda_balance_after = pda.get_lamports();\n\n            // Validate balance\n            require_eq!(pda_balance_after, pda_balance_before + amount);\n        }\n\n        // Transfer **from** PDA\n        {\n            // Get the balance of the PDA **before** the transfer from PDA\n            let pda_balance_before = pda.get_lamports();\n\n            // Transfer from the PDA\n            pda.sub_lamports(amount)?;\n            signer.add_lamports(amount)?;\n\n            // Get the balance of the PDA **after** the transfer from PDA\n            let pda_balance_after = pda.get_lamports();\n\n            // Validate balance\n            require_eq!(pda_balance_after, pda_balance_before - amount);\n        }\n\n        Ok(())\n    }",
    "pub fn overflow(ctx: Context<Overflow>) -> Result<()> {\n        let pda = &ctx.accounts.pda;\n\n        match pda.add_lamports(u64::MAX) {\n            Err(e) => assert_eq!(e, ProgramError::ArithmeticOverflow.into()),\n            _ => unreachable!(),\n        }\n\n        match pda.sub_lamports(u64::MAX) {\n            Err(e) => assert_eq!(e, ProgramError::ArithmeticOverflow.into()),\n            _ => unreachable!(),\n        }\n\n        Ok(())\n    }",
    "pub fn initialize(ctx: Context<Initialize>, udata: u128, idata: i128) -> Result<()> {\n        ctx.accounts.data.udata = udata;\n        ctx.accounts.data.idata = idata;\n        Ok(())\n    }",
    "pub fn initialize_no_rent_exempt(_ctx: Context<InitializeNoRentExempt>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn initialize_skip_rent_exempt(_ctx: Context<InitializeSkipRentExempt>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_owner(_ctx: Context<TestOwner>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_executable(_ctx: Context<TestExecutable>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_simulate(_ctx: Context<TestSimulate>, data: u32) -> Result<()> {\n        emit!(E1 { data });\n        emit!(E2 { data: 1234 });\n        emit!(E3 { data: 9 });\n        emit!(E5 {\n            data: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n        });\n        emit!(E6 {\n            data: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\n        });\n        Ok(())\n    }",
    "pub fn test_const_array_size(ctx: Context<TestConstArraySize>, data: u8) -> Result<()> {\n        ctx.accounts.data.data[0] = data;\n        Ok(())\n    }",
    "pub fn test_const_ix_data_size(\n        ctx: Context<TestConstIxDataSize>,\n        data: [u8; MAX_SIZE],\n    ) -> Result<()> {\n        ctx.accounts.data.data = data;\n        Ok(())\n    }",
    "pub fn test_close(_ctx: Context<TestClose>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_close_twice(ctx: Context<TestCloseTwice>) -> Result<()> {\n        let data_account = &ctx.accounts.data;\n        let sol_dest_info = ctx.accounts.sol_dest.to_account_info();\n        data_account.close(sol_dest_info)?;\n        let data_account_info: &AccountInfo = data_account.as_ref();\n        require_keys_eq!(*data_account_info.owner, System::id());\n        Ok(())\n    }",
    "pub fn test_close_mut(ctx: Context<TestCloseMut>) -> Result<()> {\n        let data_account = &ctx.accounts.data;\n        let sol_dest_info = ctx.accounts.sol_dest.to_account_info();\n        data_account.close(sol_dest_info)?;\n        let data_account_info: &AccountInfo = data_account.as_ref();\n        require_keys_eq!(*data_account_info.owner, System::id());\n        Ok(())\n    }",
    "pub fn test_instruction_constraint(\n        _ctx: Context<TestInstructionConstraint>,\n        _nonce: u8,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_pda_init(\n        ctx: Context<TestPdaInit>,\n        _domain: String,\n        _seed: Vec<u8>,\n        _bump: u8,\n    ) -> Result<()> {\n        ctx.accounts.my_pda.data = 6;\n        Ok(())\n    }",
    "pub fn test_pda_init_zero_copy(ctx: Context<TestPdaInitZeroCopy>) -> Result<()> {\n        let mut acc = ctx.accounts.my_pda.load_init()?;\n        acc.data = 9;\n        acc.bump = ctx.bumps.my_pda;\n        Ok(())\n    }",
    "pub fn test_pda_mut_zero_copy(ctx: Context<TestPdaMutZeroCopy>) -> Result<()> {\n        let mut acc = ctx.accounts.my_pda.load_mut()?;\n        acc.data = 1234;\n        Ok(())\n    }",
    "pub fn test_token_seeds_init(_ctx: Context<TestTokenSeedsInit>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_init(ctx: Context<TestInit>) -> Result<()> {\n        ctx.accounts.data.data = 3;\n        Ok(())\n    }",
    "pub fn test_init_zero_copy(ctx: Context<TestInitZeroCopy>) -> Result<()> {\n        let mut data = ctx.accounts.data.load_init()?;\n        data.data = 10;\n        data.bump = 2;\n        Ok(())\n    }",
    "pub fn test_init_mint(ctx: Context<TestInitMint>) -> Result<()> {\n        assert!(ctx.accounts.mint.decimals == 6);\n        Ok(())\n    }",
    "pub fn test_init_mint_with_token_program(\n        _ctx: Context<TestInitMintWithTokenProgram>,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_init_token(ctx: Context<TestInitToken>) -> Result<()> {\n        assert!(ctx.accounts.token.mint == ctx.accounts.mint.key());\n        Ok(())\n    }",
    "pub fn test_init_token_with_token_program(\n        _ctx: Context<TestInitTokenWithTokenProgram>,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_composite_payer(ctx: Context<TestCompositePayer>) -> Result<()> {\n        ctx.accounts.composite.data.data = 1;\n        ctx.accounts.data.udata = 2;\n        ctx.accounts.data.idata = 3;\n        Ok(())\n    }",
    "pub fn test_init_associated_token(ctx: Context<TestInitAssociatedToken>) -> Result<()> {\n        assert!(ctx.accounts.token.mint == ctx.accounts.mint.key());\n        Ok(())\n    }",
    "pub fn test_init_associated_token_with_token_program(\n        _ctx: Context<TestInitAssociatedTokenWithTokenProgram>,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_validate_associated_token(\n        _ctx: Context<TestValidateAssociatedToken>,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_fetch_all(ctx: Context<TestFetchAll>, filterable: Pubkey) -> Result<()> {\n        ctx.accounts.data.authority = ctx.accounts.authority.key();\n        ctx.accounts.data.filterable = filterable;\n        Ok(())\n    }",
    "pub fn test_init_with_empty_seeds(_ctx: Context<TestInitWithEmptySeeds>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_empty_seeds_constraint(_ctx: Context<TestEmptySeedsConstraint>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_init_if_needed(ctx: Context<TestInitIfNeeded>, data: u16) -> Result<()> {\n        ctx.accounts.data.data = data;\n        Ok(())\n    }",
    "pub fn test_init_if_needed_checks_owner(\n        _ctx: Context<TestInitIfNeededChecksOwner>,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_init_if_needed_checks_seeds(\n        _ctx: Context<TestInitIfNeededChecksSeeds>,\n        _seed_data: String,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_init_mint_if_needed(\n        _ctx: Context<TestInitMintIfNeeded>,\n        _decimals: u8,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_init_mint_if_needed_with_token_program(\n        _ctx: Context<TestInitMintIfNeededWithTokenProgram>,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_init_token_if_needed(_ctx: Context<TestInitTokenIfNeeded>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_init_token_if_needed_with_token_program(\n        _ctx: Context<TestInitTokenIfNeededWithTokenProgram>,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_init_associated_token_if_needed(\n        _ctx: Context<TestInitAssociatedTokenIfNeeded>,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_init_associated_token_if_needed_with_token_program(\n        _ctx: Context<TestInitAssociatedTokenIfNeededWithTokenProgram>,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn init_with_space(_ctx: Context<InitWithSpace>, _data: u16) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_multidimensional_array(\n        ctx: Context<TestMultidimensionalArray>,\n        data: [[u8; 10]; 10],\n    ) -> Result<()> {\n        ctx.accounts.data.data = data;\n        Ok(())\n    }",
    "pub fn test_multidimensional_array_const_sizes(\n        ctx: Context<TestMultidimensionalArrayConstSizes>,\n        data: [[u8; 11]; 10],\n    ) -> Result<()> {\n        ctx.accounts.data.data = data;\n        Ok(())\n    }",
    "pub fn test_no_rent_exempt(_ctx: Context<NoRentExempt>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_enforce_rent_exempt(_ctx: Context<EnforceRentExempt>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn init_decrease_lamports(ctx: Context<InitDecreaseLamports>) -> Result<()> {\n        **ctx.accounts.data.try_borrow_mut_lamports()? -= 1;\n        **ctx.accounts.user.try_borrow_mut_lamports()? += 1;\n        Ok(())\n    }",
    "pub fn init_if_needed_checks_rent_exemption(\n        _ctx: Context<InitIfNeededChecksRentExemption>,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_program_id_constraint(\n        _ctx: Context<TestProgramIdConstraint>,\n        _bump: u8,\n        _second_bump: u8,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_program_id_constraint_find_pda(\n        _ctx: Context<TestProgramIdConstraintUsingFindPda>,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_token_constraint(_ctx: Context<TestConstraintToken>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_token_auth_constraint(_ctx: Context<TestAuthorityConstraint>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_only_auth_constraint(_ctx: Context<TestOnlyAuthorityConstraint>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_only_mint_constraint(_ctx: Context<TestOnlyMintConstraint>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_only_token_program_constraint(\n        _ctx: Context<TestOnlyTokenProgramConstraint>,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_mint_constraint(_ctx: Context<TestMintConstraint>, _decimals: u8) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_mint_only_decimals_constraint(\n        _ctx: Context<TestMintOnlyDecimalsConstraint>,\n        _decimals: u8,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_mint_only_auth_constraint(\n        _ctx: Context<TestMintAuthorityConstraint>,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_mint_only_one_auth_constraint(\n        _ctx: Context<TestMintOneAuthorityConstraint>,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_mint_miss_mint_auth_constraint(\n        _ctx: Context<TestMintMissMintAuthConstraint>,\n        _decimals: u8,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_mint_only_token_program_constraint(\n        _ctx: Context<TestMintOnlyTokenProgramConstraint>,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_associated_constraint(_ctx: Context<TestAssociatedToken>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_associated_token_with_token_program_constraint(\n        _ctx: Context<TestAssociatedTokenWithTokenProgramConstraint>,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_used_identifiers(\n        _ctx: Context<TestUsedIdentifiers>,\n        program_id: u8,\n        accounts: u8,\n        ix_data: u8,\n        remaining_accounts: u8,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_init_many_associated_token_accounts(\n        _ctx: Context<InitManyAssociatedTokenAccounts>,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_boxed_owner_constraint(_ctx: Context<TestBoxedOwnerConstraint>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn only_my_feature(_ctx: Context<Empty>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_multiple_zero_constraint(_ctx: Context<TestMultipleZeroConstraint>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_init_and_zero(_ctx: Context<TestInitAndZero>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn initialize(ctx: Context<Initialize>, udata: u128, idata: i128) -> Result<()> {\n        ctx.accounts.data.as_mut().unwrap().udata = udata;\n        ctx.accounts.data.as_mut().unwrap().idata = idata;\n        Ok(())\n    }",
    "pub fn initialize_no_rent_exempt(_ctx: Context<InitializeNoRentExempt>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn initialize_skip_rent_exempt(_ctx: Context<InitializeSkipRentExempt>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_owner(_ctx: Context<TestOwner>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_executable(_ctx: Context<TestExecutable>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_simulate(_ctx: Context<TestSimulate>, data: u32) -> Result<()> {\n        emit!(E1 { data });\n        emit!(E2 { data: 1234 });\n        emit!(E3 { data: 9 });\n        emit!(E5 {\n            data: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n        });\n        emit!(E6 {\n            data: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\n        });\n        Ok(())\n    }",
    "pub fn test_const_array_size(ctx: Context<TestConstArraySize>, data: u8) -> Result<()> {\n        ctx.accounts.data.as_mut().unwrap().data[0] = data;\n        Ok(())\n    }",
    "pub fn test_const_ix_data_size(\n        ctx: Context<TestConstIxDataSize>,\n        data: [u8; MAX_SIZE],\n    ) -> Result<()> {\n        ctx.accounts.data.as_mut().unwrap().data = data;\n        Ok(())\n    }",
    "pub fn test_close(_ctx: Context<TestClose>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_close_twice(ctx: Context<TestCloseTwice>) -> Result<()> {\n        let data_account = &ctx.accounts.data.as_ref().unwrap();\n        let sol_dest_info = ctx.accounts.sol_dest.as_ref().unwrap().to_account_info();\n        data_account.close(sol_dest_info)?;\n        let data_account_info: &AccountInfo = data_account.as_ref();\n        require_keys_eq!(*data_account_info.owner, System::id());\n        Ok(())\n    }",
    "pub fn test_close_mut(ctx: Context<TestCloseMut>) -> Result<()> {\n        let data_account = &ctx.accounts.data.as_ref().unwrap();\n        let sol_dest_info = ctx.accounts.sol_dest.as_ref().unwrap().to_account_info();\n        data_account.close(sol_dest_info)?;\n        let data_account_info: &AccountInfo = data_account.as_ref();\n        require_keys_eq!(*data_account_info.owner, System::id());\n        Ok(())\n    }",
    "pub fn test_instruction_constraint(\n        _ctx: Context<TestInstructionConstraint>,\n        _nonce: u8,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_pda_init(\n        ctx: Context<TestPdaInit>,\n        _domain: String,\n        _seed: Vec<u8>,\n        _bump: u8,\n    ) -> Result<()> {\n        ctx.accounts.my_pda.as_mut().unwrap().data = 6;\n        Ok(())\n    }",
    "pub fn test_pda_init_zero_copy(ctx: Context<TestPdaInitZeroCopy>) -> Result<()> {\n        let mut acc = ctx.accounts.my_pda.as_ref().unwrap().load_init()?;\n        acc.data = 9;\n        acc.bump = ctx.bumps.my_pda.unwrap();\n        Ok(())\n    }",
    "pub fn test_pda_mut_zero_copy(ctx: Context<TestPdaMutZeroCopy>) -> Result<()> {\n        let mut acc = ctx.accounts.my_pda.as_mut().unwrap().load_mut()?;\n        acc.data = 1234;\n        Ok(())\n    }",
    "pub fn test_token_seeds_init(_ctx: Context<TestTokenSeedsInit>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_init(ctx: Context<TestInit>) -> Result<()> {\n        ctx.accounts.data.as_mut().unwrap().data = 3;\n        Ok(())\n    }",
    "pub fn test_init_zero_copy(ctx: Context<TestInitZeroCopy>) -> Result<()> {\n        let mut data = ctx.accounts.data.as_ref().unwrap().load_init()?;\n        data.data = 10;\n        data.bump = 2;\n        Ok(())\n    }",
    "pub fn test_init_mint(ctx: Context<TestInitMint>) -> Result<()> {\n        assert!(ctx.accounts.mint.as_ref().unwrap().decimals == 6);\n        Ok(())\n    }",
    "pub fn test_init_mint_with_token_program(\n        _ctx: Context<TestInitMintWithTokenProgram>,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_init_token(ctx: Context<TestInitToken>) -> Result<()> {\n        assert!(\n            ctx.accounts.token.as_ref().unwrap().mint == ctx.accounts.mint.as_ref().unwrap().key()\n        );\n        Ok(())\n    }",
    "pub fn test_init_token_with_token_program(\n        _ctx: Context<TestInitTokenWithTokenProgram>,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_composite_payer(ctx: Context<TestCompositePayer>) -> Result<()> {\n        ctx.accounts.composite.data.as_mut().unwrap().data = 1;\n        ctx.accounts.data.as_mut().unwrap().udata = 2;\n        ctx.accounts.data.as_mut().unwrap().idata = 3;\n        Ok(())\n    }",
    "pub fn test_init_associated_token(ctx: Context<TestInitAssociatedToken>) -> Result<()> {\n        assert!(\n            ctx.accounts.token.as_ref().unwrap().mint == ctx.accounts.mint.as_ref().unwrap().key()\n        );\n        Ok(())\n    }",
    "pub fn test_init_associated_token_with_token_program(\n        _ctx: Context<TestInitAssociatedTokenWithTokenProgram>,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_validate_associated_token(\n        _ctx: Context<TestValidateAssociatedToken>,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_fetch_all(ctx: Context<TestFetchAll>, filterable: Pubkey) -> Result<()> {\n        ctx.accounts.data.as_mut().unwrap().authority =\n            ctx.accounts.authority.as_ref().unwrap().key();\n        ctx.accounts.data.as_mut().unwrap().filterable = filterable;\n        Ok(())\n    }",
    "pub fn test_init_with_empty_seeds(_ctx: Context<TestInitWithEmptySeeds>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_empty_seeds_constraint(_ctx: Context<TestEmptySeedsConstraint>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_init_if_needed(ctx: Context<TestInitIfNeeded>, data: u16) -> Result<()> {\n        ctx.accounts.data.as_mut().unwrap().data = data;\n        Ok(())\n    }",
    "pub fn test_init_if_needed_checks_owner(\n        _ctx: Context<TestInitIfNeededChecksOwner>,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_init_if_needed_checks_seeds(\n        _ctx: Context<TestInitIfNeededChecksSeeds>,\n        _seed_data: String,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_init_mint_if_needed(\n        _ctx: Context<TestInitMintIfNeeded>,\n        _decimals: u8,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_init_mint_if_needed_with_token_program(\n        _ctx: Context<TestInitMintIfNeededWithTokenProgram>,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_init_token_if_needed(_ctx: Context<TestInitTokenIfNeeded>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_init_token_if_needed_with_token_program(\n        _ctx: Context<TestInitTokenIfNeededWithTokenProgram>,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_init_associated_token_if_needed(\n        _ctx: Context<TestInitAssociatedTokenIfNeeded>,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_init_associated_token_if_needed_with_token_program(\n        _ctx: Context<TestInitAssociatedTokenIfNeededWithTokenProgram>,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn init_with_space(_ctx: Context<InitWithSpace>, _data: u16) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_multidimensional_array(\n        ctx: Context<TestMultidimensionalArray>,\n        data: [[u8; 10]; 10],\n    ) -> Result<()> {\n        ctx.accounts.data.as_mut().unwrap().data = data;\n        Ok(())\n    }",
    "pub fn test_multidimensional_array_const_sizes(\n        ctx: Context<TestMultidimensionalArrayConstSizes>,\n        data: [[u8; 11]; 10],\n    ) -> Result<()> {\n        ctx.accounts.data.as_mut().unwrap().data = data;\n        Ok(())\n    }",
    "pub fn test_no_rent_exempt(_ctx: Context<NoRentExempt>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_enforce_rent_exempt(_ctx: Context<EnforceRentExempt>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn init_decrease_lamports(ctx: Context<InitDecreaseLamports>) -> Result<()> {\n        **ctx\n            .accounts\n            .data\n            .as_mut()\n            .unwrap()\n            .try_borrow_mut_lamports()? -= 1;\n        **ctx\n            .accounts\n            .user\n            .as_mut()\n            .unwrap()\n            .try_borrow_mut_lamports()? += 1;\n        Ok(())\n    }",
    "pub fn init_if_needed_checks_rent_exemption(\n        _ctx: Context<InitIfNeededChecksRentExemption>,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_program_id_constraint(\n        _ctx: Context<TestProgramIdConstraint>,\n        _bump: u8,\n        _second_bump: u8,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_program_id_constraint_find_pda(\n        _ctx: Context<TestProgramIdConstraintUsingFindPda>,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_token_constraint(_ctx: Context<TestConstraintToken>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_token_auth_constraint(_ctx: Context<TestAuthorityConstraint>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_only_auth_constraint(_ctx: Context<TestOnlyAuthorityConstraint>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_only_mint_constraint(_ctx: Context<TestOnlyMintConstraint>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_only_token_program_constraint(\n        _ctx: Context<TestOnlyTokenProgramConstraint>,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_mint_constraint(_ctx: Context<TestMintConstraint>, _decimals: u8) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_mint_only_decimals_constraint(\n        _ctx: Context<TestMintOnlyDecimalsConstraint>,\n        _decimals: u8,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_mint_only_auth_constraint(\n        _ctx: Context<TestMintAuthorityConstraint>,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_mint_only_one_auth_constraint(\n        _ctx: Context<TestMintOneAuthorityConstraint>,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_mint_miss_mint_auth_constraint(\n        _ctx: Context<TestMintMissMintAuthConstraint>,\n        _decimals: u8,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_mint_only_token_program_constraint(\n        _ctx: Context<TestMintOnlyTokenProgramConstraint>,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_associated_constraint(_ctx: Context<TestAssociatedToken>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_associated_token_with_token_program_constraint(\n        _ctx: Context<TestAssociatedTokenWithTokenProgramConstraint>,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_init_many_associated_token_accounts(\n        _ctx: Context<InitManyAssociatedTokenAccounts>,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_multiple_zero_constraint(_ctx: Context<TestMultipleZeroConstraint>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_init_and_zero(_ctx: Context<TestInitAndZero>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn initialize(ctx: Context<Initialize>) -> Result<()> {\n        *ctx.accounts.account = OverflowAccount {\n            i8_left: i8::MIN,\n            i8_right: i8::MAX,\n            i16_left: i16::MIN,\n            i16_right: i16::MAX,\n            i32_left: i32::MIN,\n            i32_right: i32::MAX,\n            i64_left: i64::MIN,\n            i64_right: i64::MAX,\n            i128_left: i128::MIN,\n            i128_right: i128::MAX,\n            u8_left: u8::MIN,\n            u8_right: u8::MAX,\n            u16_left: u16::MIN,\n            u16_right: u16::MAX,\n            u32_left: u32::MIN,\n            u32_right: u32::MAX,\n            u64_left: u64::MIN,\n            u64_right: u64::MAX,\n            u128_left: u128::MIN,\n            u128_right: u128::MAX,\n        };\n\n        Ok(())\n    }",
    "pub fn test_overflow_add(ctx: Context<TestOverflowAdd>) -> Result<()> {\n        let account = &mut ctx.accounts.account;\n        account.i8_right += 1;\n        account.i16_right += 1;\n        account.i32_right += 1;\n        account.i64_right += 1;\n        account.i128_right += 1;\n\n        account.u8_right += 1;\n        account.u16_right += 1;\n        account.u32_right += 1;\n        account.u64_right += 1;\n        account.u128_right += 1;\n\n        Ok(())\n    }",
    "pub fn test_overflow_sub(ctx: Context<TestOverflowSub>) -> Result<()> {\n        let account = &mut ctx.accounts.account;\n        account.i8_left -= 1;\n        account.i16_left -= 1;\n        account.i32_left -= 1;\n        account.i64_left -= 1;\n        account.i128_left -= 1;\n\n        account.u8_left -= 1;\n        account.u16_left -= 1;\n        account.u32_left -= 1;\n        account.u64_left -= 1;\n        account.u128_left -= 1;\n\n        Ok(())\n    }",
    "pub fn test_overflow_mul(ctx: Context<TestOverflowMul>) -> Result<()> {\n        let account = &mut ctx.accounts.account;\n        account.i8_right *= 2;\n        account.i16_right *= 2;\n        account.i32_right *= 2;\n        account.i64_right *= 2;\n        account.i128_right *= 2;\n\n        account.u8_right *= 2;\n        account.u16_right *= 2;\n        account.u32_right *= 2;\n        account.u64_right *= 2;\n        account.u128_right *= 2;\n\n        Ok(())\n    }",
    "pub fn test_init(_ctx: Context<TestInit>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_init_another(_ctx: Context<TestInitAnother>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn initialize(_ctx: Context<Initialize>, _val: u64) -> Result<()> {\n        Ok(())\n    }",
    "pub fn initialize(_ctx: Context<Initialize>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn create_multisig(\n        ctx: Context<CreateMultisig>,\n        owners: Vec<Pubkey>,\n        threshold: u64,\n        nonce: u8,\n    ) -> Result<()> {\n        let multisig = &mut ctx.accounts.multisig;\n        multisig.owners = owners;\n        multisig.threshold = threshold;\n        multisig.nonce = nonce;\n        Ok(())\n    }",
    "pub fn create_transaction(\n        ctx: Context<CreateTransaction>,\n        pid: Pubkey,\n        accs: Vec<TransactionAccount>,\n        data: Vec<u8>,\n    ) -> Result<()> {\n        let owner_index = ctx\n            .accounts\n            .multisig\n            .owners\n            .iter()\n            .position(|a| a == ctx.accounts.proposer.key)\n            .ok_or(error!(ErrorCode::InvalidOwner))?;\n\n        let mut signers = Vec::new();\n        signers.resize(ctx.accounts.multisig.owners.len(), false);\n        signers[owner_index] = true;\n\n        let tx = &mut ctx.accounts.transaction;\n        tx.program_id = pid;\n        tx.accounts = accs;\n        tx.data = data;\n        tx.signers = signers;\n        tx.multisig = *ctx.accounts.multisig.to_account_info().key;\n        tx.did_execute = false;\n\n        Ok(())\n    }",
    "pub fn approve(ctx: Context<Approve>) -> Result<()> {\n        let owner_index = ctx\n            .accounts\n            .multisig\n            .owners\n            .iter()\n            .position(|a| a == ctx.accounts.owner.key)\n            .ok_or(error!(ErrorCode::InvalidOwner))?;\n\n        ctx.accounts.transaction.signers[owner_index] = true;\n\n        Ok(())\n    }",
    "pub fn set_owners(ctx: Context<Auth>, owners: Vec<Pubkey>) -> Result<()> {\n        let multisig = &mut ctx.accounts.multisig;\n\n        if (owners.len() as u64) < multisig.threshold {\n            multisig.threshold = owners.len() as u64;\n        }\n\n        multisig.owners = owners;\n        Ok(())\n    }",
    "pub fn change_threshold(ctx: Context<Auth>, threshold: u64) -> Result<()> {\n        if threshold > ctx.accounts.multisig.owners.len() as u64 {\n            return err!(ErrorCode::InvalidThreshold);\n        }\n        let multisig = &mut ctx.accounts.multisig;\n        multisig.threshold = threshold;\n        Ok(())\n    }",
    "pub fn execute_transaction(ctx: Context<ExecuteTransaction>) -> Result<()> {\n        // Has this been executed already?\n        if ctx.accounts.transaction.did_execute {\n            return err!(ErrorCode::AlreadyExecuted);\n        }\n\n        // Do we have enough signers?\n        let sig_count = ctx\n            .accounts\n            .transaction\n            .signers\n            .iter()\n            .filter_map(|s| match s {\n                false => None,\n                true => Some(true),\n            })\n            .collect::<Vec<_>>()\n            .len() as u64;\n        if sig_count < ctx.accounts.multisig.threshold {\n            return err!(ErrorCode::NotEnoughSigners);\n        }\n\n        // Execute the transaction signed by the multisig.\n        let mut ix: Instruction = (&*ctx.accounts.transaction).into();\n        ix.accounts = ix\n            .accounts\n            .iter()\n            .map(|acc| {\n                if &acc.pubkey == ctx.accounts.multisig_signer.key {\n                    AccountMeta::new_readonly(acc.pubkey, true)\n                }",
    "pub fn do_stuff(ctx: Context<DoStuff>) -> Result<()> {\n        msg!(\"Doing stuff...\");\n        let optional_2 = &mut ctx.accounts.optional_2;\n        if let Some(data_account) = optional_2 {\n            data_account.data = 42;\n        }\n\n        Ok(())\n    }",
    "pub fn initialize(ctx: Context<Initialize>, value: u64, key: Pubkey) -> Result<()> {\n        let optional_pda = &mut ctx.accounts.optional_pda;\n        let optional_account = &mut ctx.accounts.optional_account;\n        let required = &mut ctx.accounts.required;\n\n        required.data = 0;\n\n        if let Some(data_account) = optional_account {\n            if let Some(data_pda) = optional_pda {\n                data_pda.data_account = key;\n                data_account.data = value;\n            } else {\n                data_account.data = value * 2;\n            }\n        }\n\n        Ok(())\n    }",
    "pub fn update(ctx: Context<Update>, value: u64, key: Pubkey, _pda_bump: u8) -> Result<()> {\n        if let Some(data_account) = &mut ctx.accounts.optional_account {\n            data_account.data = value;\n        }\n        if let Some(data_account) = &mut ctx.accounts.optional_pda {\n            data_account.data_account = key;\n        }\n        Ok(())\n    }",
    "pub fn realloc(ctx: Context<Realloc>, new_size: u64) -> Result<()> {\n        let optional_pda = &ctx.accounts.optional_pda;\n        let optional_account = &ctx.accounts.optional_account;\n        if let Some(data_pda) = optional_pda {\n            let len = data_pda.to_account_info().data_len();\n            if len != new_size as usize {\n                return err!(OptionalErrors::ReallocFailed);\n            }\n        }\n        if let Some(data_account) = optional_account {\n            let len = data_account.to_account_info().data_len();\n            if len != new_size as usize {\n                return err!(OptionalErrors::ReallocFailed);\n            }\n        }\n        Ok(())\n    }",
    "pub fn close(_ctx: Context<Close>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn init_base(ctx: Context<InitBase>, data: u64, data_key: Pubkey) -> Result<()> {\n        let base = &mut ctx.accounts.base;\n        base.base_data = data;\n        base.base_data_key = data_key;\n        Ok(())\n    }",
    "pub fn init_another(ctx: Context<InitAnotherBase>, data: u64) -> Result<()> {\n        let base = &mut ctx.accounts.base;\n        base.data = data;\n        Ok(())\n    }",
    "pub fn init_my_account(ctx: Context<InitMyAccount>, _seed_a: u8) -> Result<()> {\n        ctx.accounts.account.data = 1337;\n        Ok(())\n    }",
    "pub fn test_seed_constant(_ctx: Context<TestSeedConstant>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn associated_token_resolution(_ctx: Context<AssociatedTokenResolution>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn seed_math_expr(_ctx: Context<SeedMathExpr>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn resolution_error(_ctx: Context<ResolutionError>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn unsupported_program_seed(_ctx: Context<UnsupportedProgramSeed>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn call_expr_with_no_args(_ctx: Context<CallExprWithNoArgs>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn pubkey_const(_ctx: Context<PubkeyConst>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn seeds_program_account(_ctx: Context<SeedsProgramAccount>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn seeds_program_arg(_ctx: Context<SeedsProgramArg>, _some_program: Pubkey) -> Result<()> {\n        Ok(())\n    }",
    "pub fn initialize(ctx: Context<Initialize>, price: i64, expo: i32, conf: u64) -> Result<()> {\n        let oracle = &ctx.accounts.price;\n\n        let mut price_oracle = Price::load(&oracle).unwrap();\n\n        price_oracle.agg.price = price;\n        price_oracle.agg.conf = conf;\n        price_oracle.expo = expo;\n        price_oracle.ptype = pc::PriceType::Price;\n        Ok(())\n    }",
    "pub fn set_price(ctx: Context<SetPrice>, price: i64) -> Result<()> {\n        let oracle = &ctx.accounts.price;\n        let mut price_oracle = Price::load(&oracle).unwrap();\n        price_oracle.agg.price = price as i64;\n        Ok(())\n    }",
    "pub fn initialize(ctx: Context<Initialize>) -> Result<()> {\n        ctx.accounts.sample.data = vec![0];\n        ctx.accounts.sample.bump = ctx.bumps.sample;\n        Ok(())\n    }",
    "pub fn realloc(ctx: Context<Realloc>, len: u16) -> Result<()> {\n        ctx.accounts\n            .sample\n            .data\n            .resize_with(len as usize, Default::default);\n        Ok(())\n    }",
    "pub fn realloc2(ctx: Context<Realloc2>, len: u16) -> Result<()> {\n        ctx.accounts\n            .sample1\n            .data\n            .resize_with(len as usize, Default::default);\n\n        ctx.accounts\n            .sample2\n            .data\n            .resize_with(len as usize, Default::default);\n        Ok(())\n    }",
    "pub fn init_base(ctx: Context<InitBase>) -> Result<()> {\n        ctx.accounts.account.my_account = ctx.accounts.my_account.key();\n        ctx.accounts.account.bump = ctx.bumps.account;\n        Ok(())\n    }",
    "pub fn test_relation(_ctx: Context<TestRelation>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn test_address(_ctx: Context<TestAddress>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn initialize(ctx: Context<Initialize>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn initialize(ctx: Context<Initialize>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn initialize(ctx: Context<Initialize>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn handler(ctx: Context<CreateMintAccount>, args: CreateMintAccountArgs) -> Result<()> {\n    ctx.accounts.initialize_token_metadata(\n        args.name.clone(),\n        args.symbol.clone(),\n        args.uri.clone(),\n    )?;\n    ctx.accounts.mint.reload()?;\n    let mint_data = &mut ctx.accounts.mint.to_account_info();\n    let metadata = get_mint_extensible_extension_data::<TokenMetadata>(mint_data)?;\n    assert_eq!(metadata.mint, ctx.accounts.mint.key());\n    assert_eq!(metadata.name, args.name);\n    assert_eq!(metadata.symbol, args.symbol);\n    assert_eq!(metadata.uri, args.uri);\n    let metadata_pointer = get_mint_extension_data::<MetadataPointer>(mint_data)?;\n    let mint_key: Option<Pubkey> = Some(ctx.accounts.mint.key());\n    let authority_key: Option<Pubkey> = Some(ctx.accounts.authority.key());\n    assert_eq!(\n        metadata_pointer.metadata_address,\n        OptionalNonZeroPubkey::try_from(mint_key)?\n    );\n    assert_eq!(\n        metadata_pointer.authority,\n        OptionalNonZeroPubkey::try_from(authority_key)?\n    );\n    let permanent_delegate = get_mint_extension_data::<PermanentDelegate>(mint_data)?;\n    assert_eq!(\n        permanent_delegate.delegate,\n        OptionalNonZeroPubkey::try_from(authority_key)?\n    );\n    let close_authority = get_mint_extension_data::<MintCloseAuthority>(mint_data)?;\n    assert_eq!(\n        close_authority.close_authority,\n        OptionalNonZeroPubkey::try_from(authority_key)?\n    );\n    let transfer_hook = get_mint_extension_data::<TransferHook>(mint_data)?;\n    let program_id: Option<Pubkey> = Some(ctx.program_id.key());\n    assert_eq!(\n        transfer_hook.authority,\n        OptionalNonZeroPubkey::try_from(authority_key)?\n    );\n    assert_eq!(\n        transfer_hook.program_id,\n        OptionalNonZeroPubkey::try_from(program_id)?\n    );\n    let group_member_pointer = get_mint_extension_data::<GroupMemberPointer>(mint_data)?;\n    assert_eq!(\n        group_member_pointer.authority,\n        OptionalNonZeroPubkey::try_from(authority_key)?\n    );\n    assert_eq!(\n        group_member_pointer.member_address,\n        OptionalNonZeroPubkey::try_from(mint_key)?\n    );\n    // transfer minimum rent to mint account\n    update_account_lamports_to_minimum_balance(\n        ctx.accounts.mint.to_account_info(),\n        ctx.accounts.payer.to_account_info(),\n        ctx.accounts.system_program.to_account_info(),\n    )?;\n\n    Ok(())\n}",
    "pub fn create_mint_account(\n        ctx: Context<CreateMintAccount>,\n        args: CreateMintAccountArgs,\n    ) -> Result<()> {\n        instructions::handler(ctx, args)\n    }",
    "pub fn check_mint_extensions_constraints(\n        _ctx: Context<CheckMintExtensionConstraints>,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn get_extra_meta_list_account_pda(mint: Pubkey) -> Pubkey {\n    Pubkey::find_program_address(&[META_LIST_ACCOUNT_SEED, mint.as_ref()], &crate::id()).0\n}\n\npub fn get_approve_account_pda(mint: Pubkey) -> Pubkey {\n    Pubkey::find_program_address(&[APPROVE_ACCOUNT_SEED, mint.as_ref()], &crate::id()).0\n}\n\n/// Determine if we are in CPI\npub fn hook_in_cpi() -> bool {\n    let stack_height = get_stack_height();\n    let tx_height = TRANSACTION_LEVEL_STACK_HEIGHT;\n    let hook_height: usize = tx_height + 1;\n\n    stack_height > hook_height\n}\n\npub fn get_meta_list(approve_account: Option<Pubkey>) -> Vec<ExtraAccountMeta> {\n    if let Some(approve_account) = approve_account {\n        return vec![ExtraAccountMeta {\n            discriminator: 0,\n            address_config: approve_account.to_bytes(),\n            is_signer: false.into(),\n            is_writable: true.into(),\n        }];\n    }\n    vec![]\n}\n\npub fn get_meta_list_size(approve_account: Option<Pubkey>) -> usize {\n    // safe because it's either 0 or 1\n    ExtraAccountMetaList::size_of(get_meta_list(approve_account).len()).unwrap()\n}",
    "pub fn proxy_transfer(ctx: Context<ProxyTransfer>, amount: u64) -> Result<()> {\n        #[allow(deprecated)]\n        token_interface::transfer(ctx.accounts.into(), amount)\n    }",
    "pub fn proxy_optional_transfer(ctx: Context<ProxyOptionalTransfer>, amount: u64) -> Result<()> {\n        if let Some(token_program) = &ctx.accounts.token_program {\n            if let Some(mint) = &ctx.accounts.mint {\n                let cpi_accounts = TransferChecked {\n                    from: ctx.accounts.from.to_account_info(),\n                    mint: mint.to_account_info(),\n                    to: ctx.accounts.to.to_account_info(),\n                    authority: ctx.accounts.authority.clone(),\n                };\n                let cpi_program = token_program.to_account_info();\n                let cpi_context = CpiContext::new(cpi_program, cpi_accounts);\n                token_interface::transfer_checked(cpi_context, amount, mint.decimals)\n            }",
    "pub fn proxy_mint_to(ctx: Context<ProxyMintTo>, amount: u64) -> Result<()> {\n        token_interface::mint_to(ctx.accounts.into(), amount)\n    }",
    "pub fn proxy_burn(ctx: Context<ProxyBurn>, amount: u64) -> Result<()> {\n        token_interface::burn(ctx.accounts.into(), amount)\n    }",
    "pub fn proxy_set_authority(\n        ctx: Context<ProxySetAuthority>,\n        authority_type: AuthorityType,\n        new_authority: Option<Pubkey>,\n    ) -> Result<()> {\n        token_interface::set_authority(ctx.accounts.into(), authority_type.into(), new_authority)\n    }",
    "pub fn proxy_create_token_account(_ctx: Context<ProxyCreateTokenAccount>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn proxy_create_associated_token_account(\n        _ctx: Context<ProxyCreateAssociatedTokenAccount>,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn proxy_create_mint(_ctx: Context<ProxyCreateMint>, _name: String) -> Result<()> {\n        Ok(())\n    }",
    "pub fn initialize(ctx: Context<Initialize>, initializer_amount: u64) -> Result<()> {\n        // deposit into vault\n        token_interface::transfer_checked(\n            CpiContext::new(\n                ctx.accounts.deposit_token_program.to_account_info(),\n                token_interface::TransferChecked {\n                    from: ctx\n                        .accounts\n                        .initializer_deposit_token_account\n                        .to_account_info(),\n                    mint: ctx.accounts.deposit_mint.to_account_info(),\n                    to: ctx.accounts.deposit_token_vault.to_account_info(),\n                    authority: ctx.accounts.initializer.to_account_info(),\n                },\n            ),\n            initializer_amount,\n            ctx.accounts.deposit_mint.decimals,\n        )?;\n\n        // mint wrapped tokens\n        let inner_seeds = [\n            WRAPPER_AUTH_SEED,\n            ctx.accounts.deposit_mint.to_account_info().key.as_ref(),\n            ctx.accounts.wrapped_mint.to_account_info().key.as_ref(),\n            &[ctx.bumps.wrapper_authority],\n        ];\n        let signer_seeds = &[&inner_seeds[..]];\n        token_interface::mint_to(\n            CpiContext::new_with_signer(\n                ctx.accounts.wrapped_token_program.to_account_info(),\n                token_interface::MintTo {\n                    mint: ctx.accounts.wrapped_mint.to_account_info(),\n                    to: ctx\n                        .accounts\n                        .initializer_wrapped_token_account\n                        .to_account_info(),\n                    authority: ctx.accounts.wrapper_authority.to_account_info(),\n                },\n                signer_seeds,\n            ),\n            initializer_amount,\n        )?;\n\n        Ok(())\n    }",
    "pub fn wrap(ctx: Context<Wrap>, wrap_amount: u64) -> Result<()> {\n        // deposit into vault\n        token_interface::transfer_checked(\n            CpiContext::new(\n                ctx.accounts.deposit_token_program.to_account_info(),\n                token_interface::TransferChecked {\n                    from: ctx.accounts.user_deposit_token_account.to_account_info(),\n                    mint: ctx.accounts.deposit_mint.to_account_info(),\n                    to: ctx.accounts.deposit_token_vault.to_account_info(),\n                    authority: ctx.accounts.signer.to_account_info(),\n                },\n            ),\n            wrap_amount,\n            ctx.accounts.deposit_mint.decimals,\n        )?;\n\n        // mint wrapped tokens\n        let inner_seeds = [\n            WRAPPER_AUTH_SEED,\n            ctx.accounts.deposit_mint.to_account_info().key.as_ref(),\n            ctx.accounts.wrapped_mint.to_account_info().key.as_ref(),\n            &[ctx.bumps.wrapper_authority],\n        ];\n        let signer_seeds = &[&inner_seeds[..]];\n        token_interface::mint_to(\n            CpiContext::new_with_signer(\n                ctx.accounts.wrapped_token_program.to_account_info(),\n                token_interface::MintTo {\n                    mint: ctx.accounts.wrapped_mint.to_account_info(),\n                    to: ctx.accounts.user_wrapped_token_account.to_account_info(),\n                    authority: ctx.accounts.wrapper_authority.to_account_info(),\n                },\n                signer_seeds,\n            ),\n            wrap_amount,\n        )?;\n\n        Ok(())\n    }",
    "pub fn unwrap(ctx: Context<Unwrap>, unwrap_amount: u64) -> Result<()> {\n        // burn wrapped tokens\n        token_interface::burn(\n            CpiContext::new(\n                ctx.accounts.wrapped_token_program.to_account_info(),\n                token_interface::Burn {\n                    mint: ctx.accounts.wrapped_mint.to_account_info(),\n                    from: ctx.accounts.user_wrapped_token_account.to_account_info(),\n                    authority: ctx.accounts.signer.to_account_info(),\n                },\n            ),\n            unwrap_amount,\n        )?;\n\n        // withdraw from vault\n        let inner_seeds = [\n            WRAPPER_AUTH_SEED,\n            ctx.accounts.deposit_mint.to_account_info().key.as_ref(),\n            ctx.accounts.wrapped_mint.to_account_info().key.as_ref(),\n            &[ctx.bumps.wrapper_authority],\n        ];\n        let signer_seeds = &[&inner_seeds[..]];\n        token_interface::transfer_checked(\n            CpiContext::new_with_signer(\n                ctx.accounts.deposit_token_program.to_account_info(),\n                token_interface::TransferChecked {\n                    from: ctx.accounts.deposit_token_vault.to_account_info(),\n                    mint: ctx.accounts.deposit_mint.to_account_info(),\n                    to: ctx.accounts.user_deposit_token_account.to_account_info(),\n                    authority: ctx.accounts.wrapper_authority.to_account_info(),\n                },\n                signer_seeds,\n            ),\n            unwrap_amount,\n            ctx.accounts.deposit_mint.decimals,\n        )?;\n\n        Ok(())\n    }",
    "pub fn initialize(ctx: Context<Initialize>, metas: Vec<AnchorExtraAccountMeta>) -> Result<()> {\n        let extra_metas_account = &ctx.accounts.extra_metas_account;\n        let mint = &ctx.accounts.mint;\n        let mint_authority = &ctx.accounts.mint_authority;\n\n        if mint_authority.key()\n            != mint.mint_authority.ok_or(Into::<ProgramError>::into(\n                TransferHookError::MintHasNoMintAuthority,\n            ))?\n        {\n            Err(Into::<ProgramError>::into(\n                TransferHookError::IncorrectMintAuthority,\n            ))?;\n        }\n\n        let metas: Vec<ExtraAccountMeta> = metas.into_iter().map(|meta| meta.into()).collect();\n        let mut data = extra_metas_account.try_borrow_mut_data()?;\n        ExtraAccountMetaList::init::<ExecuteInstruction>(&mut data, &metas)?;\n\n        Ok(())\n    }",
    "pub fn execute(ctx: Context<Execute>, amount: u64) -> Result<()> {\n        let source_account = &ctx.accounts.source_account;\n        let destination_account = &ctx.accounts.destination_account;\n\n        check_token_account_is_transferring(&source_account.to_account_info().try_borrow_data()?)?;\n        check_token_account_is_transferring(\n            &destination_account.to_account_info().try_borrow_data()?,\n        )?;\n\n        let data = ctx.accounts.extra_metas_account.try_borrow_data()?;\n        ExtraAccountMetaList::check_account_infos::<ExecuteInstruction>(\n            &ctx.accounts.to_account_infos(),\n            &TransferHookInstruction::Execute { amount }.pack(),\n            &ctx.program_id,\n            &data,\n        )?;\n\n        Ok(())\n    }",
    "pub fn initialize(_ctx: Context<Initialize>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn sysvars(_ctx: Context<Sysvars>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn initialize_dashboard(ctx: Context<Initializedashboard>) -> Result<()> {\n        let dashboard = &mut ctx.accounts.dashboard;\n        dashboard.game_count = 0;\n        dashboard.address = *dashboard.to_account_info().key;\n        Ok(())\n    }",
    "pub fn initialize(ctx: Context<Initialize>) -> Result<()> {\n        let dashboard = &mut ctx.accounts.dashboard;\n        let game = &mut ctx.accounts.game;\n        dashboard.game_count = dashboard.game_count + 1;\n        dashboard.latest_game = *game.to_account_info().key;\n        game.player_x = *ctx.accounts.player_x.key;\n        Ok(())\n    }",
    "pub fn player_join(ctx: Context<Playerjoin>) -> Result<()> {\n        let game = &mut ctx.accounts.game;\n        game.player_o = *ctx.accounts.player_o.key;\n        game.game_state = 1;\n        Ok(())\n    }",
    "pub fn player_move(ctx: Context<Playermove>, x_or_o: u8, player_move: u8) -> Result<()> {\n        let game = &mut ctx.accounts.game;\n        game.board[player_move as usize] = x_or_o;\n        game.status(x_or_o);\n        Ok(())\n    }",
    "pub fn status(ctx: Context<Status>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn accounts(ctx: &Context<Playermove>, x_or_o: u8, player_move: u8) -> Result<()> {\n        if ctx.accounts.game.board[player_move as usize] != 0 {\n            return Err(ErrorCode::Illegalmove.into());\n        }\n        if x_or_o == BOARD_ITEM_X {\n            return Playermove::player_x_checks(ctx);\n        } else if x_or_o == BOARD_ITEM_O {\n            return Playermove::player_o_checks(ctx);\n        } else {\n            return Err(ErrorCode::UnexpectedValue.into());\n        }\n    }\n\n    pub fn player_x_checks(ctx: &Context<Playermove>) -> Result<()> {\n        if ctx.accounts.game.player_x != *ctx.accounts.player.key {\n            return Err(ErrorCode::Unauthorized.into());\n        }\n        if ctx.accounts.game.game_state != 1 {\n            return Err(ErrorCode::Gamestate.into());\n        }\n        Ok(())\n    }",
    "pub fn player_o_checks(ctx: &Context<Playermove>) -> Result<()> {\n        if ctx.accounts.game.player_o != *ctx.accounts.player.key {\n            return Err(ErrorCode::Unauthorized.into());\n        }\n        if ctx.accounts.game.game_state != 2 {\n            return Err(ErrorCode::Gamestate.into());\n        }\n        Ok(())\n    }",
    "pub fn status(self: &mut Game, x_or_o: u8) {\n        let winner =\n            // Check rows.\n            Game::same(x_or_o, &self.board[0..3])\n            || Game::same(x_or_o, &self.board[3..6])\n            || Game::same(x_or_o, &self.board[6..9])\n            // Check columns.\n            || Game::same(x_or_o, &[self.board[0], self.board[3], self.board[6]])\n            || Game::same(x_or_o, &[self.board[1], self.board[4], self.board[7]])\n            || Game::same(x_or_o, &[self.board[2], self.board[5], self.board[8]])\n            // Check both diagonals.\n            || Game::same(x_or_o, &[self.board[0], self.board[4], self.board[8]])\n            || Game::same(x_or_o, &[self.board[2], self.board[4], self.board[6]]);\n\n        if winner {\n            self.game_state = x_or_o + 2;\n        } else if self.board.iter().all(|&p| p != BOARD_ITEM_FREE) {\n            self.game_state = 5;\n        } else {\n            if x_or_o == BOARD_ITEM_X {\n                self.game_state = 2;\n            } else {\n                self.game_state = 1;\n            }\n        }\n    }\n\n    pub fn same(x_or_o: u8, triple: &[u8]) -> bool {\n        triple.iter().all(|&i| i == x_or_o)\n    }",
    "pub fn initialize(ctx: Context<Initialize>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn initialize(_ctx: Context<Initialize>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn create_foo(ctx: Context<CreateFoo>) -> Result<()> {\n        let foo = &mut ctx.accounts.foo.load_init()?;\n        foo.authority = *ctx.accounts.authority.key;\n        foo.set_second_authority(ctx.accounts.authority.key);\n        Ok(())\n    }",
    "pub fn update_foo(ctx: Context<UpdateFoo>, data: u64) -> Result<()> {\n        let mut foo = ctx.accounts.foo.load_mut()?;\n        foo.data = data;\n        Ok(())\n    }",
    "pub fn update_foo_second(ctx: Context<UpdateFooSecond>, second_data: u64) -> Result<()> {\n        let mut foo = ctx.accounts.foo.load_mut()?;\n        foo.second_data = second_data;\n        Ok(())\n    }",
    "pub fn create_bar(ctx: Context<CreateBar>) -> Result<()> {\n        let bar = &mut ctx.accounts.bar.load_init()?;\n        bar.authority = *ctx.accounts.authority.key;\n        Ok(())\n    }",
    "pub fn update_bar(ctx: Context<UpdateBar>, data: u64) -> Result<()> {\n        let bar = &mut ctx.accounts.bar.load_mut()?;\n        bar.data = data;\n        Ok(())\n    }",
    "pub fn create_large_account(_ctx: Context<CreateLargeAccount>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn update_large_account(\n        ctx: Context<UpdateLargeAccount>,\n        idx: u32,\n        data: u64,\n    ) -> Result<()> {\n        let event_q = &mut ctx.accounts.event_q.load_mut()?;\n        event_q.events[idx as usize] = Event {\n            data,\n            from: *ctx.accounts.from.key,\n        };\n        Ok(())\n    }",
    "pub fn check_cpi(ctx: Context<CheckCpi>, data: u64) -> Result<()> {\n        let cpi_program = ctx.accounts.zero_copy_program.to_account_info();\n        let cpi_accounts = UpdateBar {\n            authority: ctx.accounts.authority.clone(),\n            bar: ctx.accounts.bar.to_account_info(),\n            foo: ctx.accounts.foo.to_account_info(),\n        };\n        let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);\n        zero_copy::cpi::update_bar(cpi_ctx, data)?;\n        Ok(())\n    }",
    "pub fn create(ctx: Context<Create>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn create_idempotent(ctx: Context<CreateIdempotent>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn recover_nested(ctx: Context<RecoverNested>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn initialize_binary_option(\n        ctx: Context<InitializeBinaryOption>,\n        decimals: u8,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn trade(ctx: Context<Trade>, size: u64, buy_price: u64, sell_price: u64) -> Result<()> {\n        Ok(())\n    }",
    "pub fn settle(ctx: Context<Settle>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn collect(ctx: Context<Collect>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn init_pool(\n        ctx: Context<InitPool>,\n        mint_end_slot: u64,\n        decide_end_slot: u64,\n        bump_seed: u8,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn deposit(ctx: Context<Deposit>, arg: u64) -> Result<()> {\n        Ok(())\n    }",
    "pub fn withdraw(ctx: Context<Withdraw>, arg: u64) -> Result<()> {\n        Ok(())\n    }",
    "pub fn decide(ctx: Context<Decide>, arg: bool) -> Result<()> {\n        Ok(())\n    }",
    "pub fn propose(\n        ctx: Context<Propose>,\n        tokens_to_mint: u64,\n        acceptance_criteria: AcceptanceCriteria,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn tally(ctx: Context<Tally>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn create_realm(\n        ctx: Context<CreateRealm>,\n        name: String,\n        config_args: RealmConfigArgs,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn deposit_governing_tokens(\n        ctx: Context<DepositGoverningTokens>,\n        amount: u64,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn withdraw_governing_tokens(ctx: Context<WithdrawGoverningTokens>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn set_governance_delegate(\n        ctx: Context<SetGovernanceDelegate>,\n        new_governance_delegate: Option<Pubkey>,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn create_governance(\n        ctx: Context<CreateGovernance>,\n        config: GovernanceConfig,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn create_program_governance(\n        ctx: Context<CreateProgramGovernance>,\n        config: GovernanceConfig,\n        transfer_upgrade_authority: bool,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn create_proposal(\n        ctx: Context<CreateProposal>,\n        name: String,\n        description_link: String,\n        vote_type: VoteType,\n        options: Vec<String>,\n        use_deny_option: bool,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn add_signatory(ctx: Context<AddSignatory>, signatory: Pubkey) -> Result<()> {\n        Ok(())\n    }",
    "pub fn remove_signatory(ctx: Context<RemoveSignatory>, signatory: Pubkey) -> Result<()> {\n        Ok(())\n    }",
    "pub fn insert_transaction(\n        ctx: Context<InsertTransaction>,\n        option_index: u8,\n        index: u16,\n        hold_up_time: u32,\n        instructions: Vec<InstructionData>,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn remove_transaction(ctx: Context<RemoveTransaction>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn cancel_proposal(ctx: Context<CancelProposal>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn sign_off_proposal(ctx: Context<SignOffProposal>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn cast_vote(ctx: Context<CastVote>, vote: Vote) -> Result<()> {\n        Ok(())\n    }",
    "pub fn finalize_vote(ctx: Context<FinalizeVote>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn relinquish_vote(ctx: Context<RelinquishVote>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn execute_transaction(ctx: Context<ExecuteTransaction>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn create_mint_governance(\n        ctx: Context<CreateMintGovernance>,\n        config: GovernanceConfig,\n        transfer_mint_authorities: bool,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn create_token_governance(\n        ctx: Context<CreateTokenGovernance>,\n        config: GovernanceConfig,\n        transfer_account_authorities: bool,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn set_governance_config(\n        ctx: Context<SetGovernanceConfig>,\n        config: GovernanceConfig,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn flag_transaction_error(ctx: Context<FlagTransactionError>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn set_realm_authority(\n        ctx: Context<SetRealmAuthority>,\n        action: SetRealmAuthorityAction,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn set_realm_config(\n        ctx: Context<SetRealmConfig>,\n        config_args: RealmConfigArgs,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn create_token_owner_record(ctx: Context<CreateTokenOwnerRecord>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn update_program_metadata(ctx: Context<UpdateProgramMetadata>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn create_native_treasury(ctx: Context<CreateNativeTreasury>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn add_memo(ctx: Context<AddMemo>, memo: String) -> Result<()> {\n        Ok(())\n    }",
    "pub fn create(\n        ctx: Context<Create>,\n        hashed_name: Vec<u8>,\n        lamports: u64,\n        space: u32,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn update(ctx: Context<Update>, offset: u32, data: Vec<u8>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn transfer(ctx: Context<Transfer>, new_owner: Pubkey) -> Result<()> {\n        Ok(())\n    }",
    "pub fn delete(ctx: Context<Delete>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn initialize(ctx: Context<Initialize>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn write(ctx: Context<Write>, offset: u64, data: Vec<u8>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn set_authority(ctx: Context<SetAuthority>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn close_account(ctx: Context<CloseAccount>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn initialize(\n        ctx: Context<Initialize>,\n        fee: Fee,\n        withdrawal_fee: Fee,\n        deposit_fee: Fee,\n        referral_fee: u8,\n        max_validators: u32,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn add_validator_to_pool(ctx: Context<AddValidatorToPool>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn remove_validator_from_pool(ctx: Context<RemoveValidatorFromPool>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn decrease_validator_stake(\n        ctx: Context<DecreaseValidatorStake>,\n        lamports: u64,\n        transient_stake_seed: u64,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn increase_validator_stake(\n        ctx: Context<IncreaseValidatorStake>,\n        lamports: u64,\n        transient_stake_seed: u64,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn set_preferred_validator(\n        ctx: Context<SetPreferredValidator>,\n        validator_type: PreferredValidatorType,\n        validator_vote_address: Option<Pubkey>,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn update_validator_list_balance(\n        ctx: Context<UpdateValidatorListBalance>,\n        start_index: u32,\n        no_merge: bool,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn update_stake_pool_balance(ctx: Context<UpdateStakePoolBalance>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn cleanup_removed_validator_entries(\n        ctx: Context<CleanupRemovedValidatorEntries>,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn deposit_stake(ctx: Context<DepositStake>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn withdraw_stake(ctx: Context<WithdrawStake>, arg: u64) -> Result<()> {\n        Ok(())\n    }",
    "pub fn set_manager(ctx: Context<SetManager>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn set_fee(ctx: Context<SetFee>, fee: FeeType) -> Result<()> {\n        Ok(())\n    }",
    "pub fn set_staker(ctx: Context<SetStaker>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn deposit_sol(ctx: Context<DepositSol>, arg: u64) -> Result<()> {\n        Ok(())\n    }",
    "pub fn set_funding_authority(\n        ctx: Context<SetFundingAuthority>,\n        arg: FundingType,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn withdraw_sol(ctx: Context<WithdrawSol>, arg: u64) -> Result<()> {\n        Ok(())\n    }",
    "pub fn create_token_metadata(\n        ctx: Context<CreateTokenMetadata>,\n        name: String,\n        symbol: String,\n        uri: String,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn update_token_metadata(\n        ctx: Context<UpdateTokenMetadata>,\n        name: String,\n        symbol: String,\n        uri: String,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn accept_offer(\n        ctx: Context<AcceptOffer>,\n        has_metadata: bool,\n        maker_size: u64,\n        taker_size: u64,\n        bump_seed: u8,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn initialize_mint(\n        ctx: Context<InitializeMint>,\n        decimals: u8,\n        mint_authority: Pubkey,\n        freeze_authority: COption<Pubkey>,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn initialize_account(ctx: Context<InitializeAccount>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn initialize_multisig(ctx: Context<InitializeMultisig>, m: u8) -> Result<()> {\n        Ok(())\n    }",
    "pub fn transfer(ctx: Context<Transfer>, amount: u64) -> Result<()> {\n        Ok(())\n    }",
    "pub fn approve(ctx: Context<Approve>, amount: u64) -> Result<()> {\n        Ok(())\n    }",
    "pub fn revoke(ctx: Context<Revoke>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn set_authority(\n        ctx: Context<SetAuthority>,\n        authority_type: AuthorityType,\n        new_authority: COption<Pubkey>,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn mint_to(ctx: Context<MintTo>, amount: u64) -> Result<()> {\n        Ok(())\n    }",
    "pub fn burn(ctx: Context<Burn>, amount: u64) -> Result<()> {\n        Ok(())\n    }",
    "pub fn close_account(ctx: Context<CloseAccount>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn freeze_account(ctx: Context<FreezeAccount>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn thaw_account(ctx: Context<ThawAccount>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn transfer_checked(\n        ctx: Context<TransferChecked>,\n        amount: u64,\n        decimals: u8,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn approve_checked(ctx: Context<ApproveChecked>, amount: u64, decimals: u8) -> Result<()> {\n        Ok(())\n    }",
    "pub fn mint_to_checked(ctx: Context<MintToChecked>, amount: u64, decimals: u8) -> Result<()> {\n        Ok(())\n    }",
    "pub fn burn_checked(ctx: Context<BurnChecked>, amount: u64, decimals: u8) -> Result<()> {\n        Ok(())\n    }",
    "pub fn initialize_account2(ctx: Context<InitializeAccount2>, owner: Pubkey) -> Result<()> {\n        Ok(())\n    }",
    "pub fn sync_native(ctx: Context<SyncNative>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn initialize_account3(ctx: Context<InitializeAccount3>, owner: Pubkey) -> Result<()> {\n        Ok(())\n    }",
    "pub fn initialize_multisig2(ctx: Context<InitializeMultisig2>, m: u8) -> Result<()> {\n        Ok(())\n    }",
    "pub fn initialize_mint2(\n        ctx: Context<InitializeMint2>,\n        decimals: u8,\n        mint_authority: Pubkey,\n        freeze_authority: COption<Pubkey>,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn get_account_data_size(ctx: Context<GetAccountDataSize>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn initialize_immutable_owner(ctx: Context<InitializeImmutableOwner>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn amount_to_ui_amount(ctx: Context<AmountToUiAmount>, amount: u64) -> Result<()> {\n        Ok(())\n    }",
    "pub fn ui_amount_to_amount(ctx: Context<UiAmountToAmount>, ui_amount: &'a str) -> Result<()> {\n        Ok(())\n    }",
    "pub fn init_lending_market(\n        ctx: Context<InitLendingMarket>,\n        owner: Pubkey,\n        quote_currency: [u8; 32],\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn set_lending_market_owner(\n        ctx: Context<SetLendingMarketOwner>,\n        new_owner: Pubkey,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn init_reserve(\n        ctx: Context<InitReserve>,\n        liquidity_amount: u64,\n        config: ReserveConfig,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn refresh_reserve(ctx: Context<RefreshReserve>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn deposit_reserve_liquidity(\n        ctx: Context<DepositReserveLiquidity>,\n        liquidity_amount: u64,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn redeem_reserve_collateral(\n        ctx: Context<RedeemReserveCollateral>,\n        collateral_amount: u64,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn init_obligation(ctx: Context<InitObligation>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn refresh_obligation(ctx: Context<RefreshObligation>) -> Result<()> {\n        Ok(())\n    }",
    "pub fn deposit_obligation_collateral(\n        ctx: Context<DepositObligationCollateral>,\n        collateral_amount: u64,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn withdraw_obligation_collateral(\n        ctx: Context<WithdrawObligationCollateral>,\n        collateral_amount: u64,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn borrow_obligation_liquidity(\n        ctx: Context<BorrowObligationLiquidity>,\n        liquidity_amount: u64,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn repay_obligation_liquidity(\n        ctx: Context<RepayObligationLiquidity>,\n        liquidity_amount: u64,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn liquidate_obligation(\n        ctx: Context<LiquidateObligation>,\n        liquidity_amount: u64,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn flash_loan(ctx: Context<FlashLoan>, amount: u64) -> Result<()> {\n        Ok(())\n    }",
    "pub fn initialize(ctx: Context<Initialize>, fees: Fees, swap_curve: SwapCurve) -> Result<()> {\n        Ok(())\n    }",
    "pub fn swap(ctx: Context<Swap>, amount_in: u64, minimum_amount_out: u64) -> Result<()> {\n        Ok(())\n    }",
    "pub fn deposit_all_token_types(\n        ctx: Context<DepositAllTokenTypes>,\n        pool_token_amount: u64,\n        maximum_token_a_amount: u64,\n        maximum_token_b_amount: u64,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn withdraw_all_token_types(\n        ctx: Context<WithdrawAllTokenTypes>,\n        pool_token_amount: u64,\n        minimum_token_a_amount: u64,\n        minimum_token_b_amount: u64,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn deposit_single_token_type_exact_amount_in(\n        ctx: Context<DepositSingleTokenTypeExactAmountIn>,\n        source_token_amount: u64,\n        minimum_pool_token_amount: u64,\n    ) -> Result<()> {\n        Ok(())\n    }",
    "pub fn withdraw_single_token_type_exact_amount_out(\n        ctx: Context<WithdrawSingleTokenTypeExactAmountOut>,\n        destination_token_amount: u64,\n        maximum_pool_token_amount: u64,\n    ) -> Result<()> {\n        Ok(())\n    }"
  ],
  "solana": [
    "pub fn check_canopy_bytes(canopy_bytes: &[u8]) -> Result<()> {\n    if canopy_bytes.len() % size_of::<Node>() != 0 {\n        msg!(\n            \"Canopy byte length {} is not a multiple of {}\",\n            canopy_bytes.len(),\n            size_of::<Node>()\n        );\n        err!(AccountCompressionError::CanopyLengthMismatch)\n    }",
    "pub fn update_canopy(\n    canopy_bytes: &mut [u8],\n    max_depth: u32,\n    change_log: Option<&ChangeLogEvent>,\n) -> Result<()> {\n    check_canopy_bytes(canopy_bytes)?;\n    let canopy = cast_slice_mut::<u8, Node>(canopy_bytes);\n    let path_len = get_cached_path_length(canopy, max_depth)?;\n    if let Some(cl_event) = change_log {\n        match &*cl_event {\n            ChangeLogEvent::V1(cl) => {\n                // Update the canopy from the newest change log\n                for path_node in cl.path.iter().rev().skip(1).take(path_len as usize) {\n                    // node_idx - 2 maps to the canopy index\n                    canopy[(path_node.index - 2) as usize] = path_node.node;\n                }\n            }\n        }\n    }\n    Ok(())\n}",
    "pub fn fill_in_proof_from_canopy(\n    canopy_bytes: &[u8],\n    max_depth: u32,\n    index: u32,\n    proof: &mut Vec<Node>,\n) -> Result<()> {\n    let mut empty_node_cache = Box::new([EMPTY; MAX_SUPPORTED_DEPTH]);\n    check_canopy_bytes(canopy_bytes)?;\n    let canopy = cast_slice::<u8, Node>(canopy_bytes);\n    let path_len = get_cached_path_length(canopy, max_depth)?;\n\n    // We want to compute the node index (w.r.t. the canopy) where the current path\n    // intersects the leaves of the canopy\n    let mut node_idx = ((1 << max_depth) + index) >> (max_depth - path_len);\n    let mut inferred_nodes = vec![];\n    while node_idx > 1 {\n        // node_idx - 2 maps to the canopy index\n        let shifted_index = node_idx as usize - 2;\n        let cached_idx = if shifted_index % 2 == 0 {\n            shifted_index + 1\n        } else {\n            shifted_index - 1\n        };\n        if canopy[cached_idx] == EMPTY {\n            let level = max_depth - (31 - node_idx.leading_zeros());\n            let empty_node = empty_node_cached::<MAX_SUPPORTED_DEPTH>(level, &mut empty_node_cache);\n            inferred_nodes.push(empty_node);\n        } else {\n            inferred_nodes.push(canopy[cached_idx]);\n        }\n        node_idx >>= 1;\n    }\n    // We only want to add inferred canopy nodes such that the proof length\n    // is equal to the tree depth. If the length of proof + length of canopy nodes is\n    // less than the tree depth, the instruction will fail.\n    let overlap = (proof.len() + inferred_nodes.len()).saturating_sub(max_depth as usize);\n    proof.extend(inferred_nodes.iter().skip(overlap));\n    Ok(())\n}",
    "pub fn set_canopy_leaf_nodes(\n    canopy_bytes: &mut [u8],\n    max_depth: u32,\n    start_index: u32,\n    nodes: &[Node],\n) -> Result<()> {\n    check_canopy_bytes(canopy_bytes)?;\n    let canopy = cast_slice_mut::<u8, Node>(canopy_bytes);\n    let path_len = get_cached_path_length(canopy, max_depth)?;\n    if path_len == 0 {\n        return err!(AccountCompressionError::CanopyNotAllocated);\n    }\n    let start_canopy_node = leaf_node_index_to_canopy_index(path_len, start_index)?;\n    let start_canopy_idx = start_canopy_node - 2;\n    // set the \"leaf\" nodes of the canopy first - that's the lowest level of the canopy\n    for (i, node) in nodes.iter().enumerate() {\n        canopy[start_canopy_idx + i] = *node;\n    }\n    let mut start_canopy_node = start_canopy_node;\n    let mut end_canopy_node = start_canopy_node + nodes.len() - 1;\n    let mut empty_node_cache = Box::new([EMPTY; MAX_SUPPORTED_DEPTH]);\n    let leaf_node_level = max_depth - path_len;\n    // traverse up the tree and update the parent nodes in the modified subtree\n    for level in leaf_node_level + 1..max_depth {\n        start_canopy_node >>= 1;\n        end_canopy_node >>= 1;\n        for node in start_canopy_node..end_canopy_node + 1 {\n            let left_child = get_value_for_node::<MAX_SUPPORTED_DEPTH>(\n                node << 1,\n                level - 1,\n                canopy,\n                &mut empty_node_cache,\n            );\n            let right_child = get_value_for_node::<MAX_SUPPORTED_DEPTH>(\n                (node << 1) + 1,\n                level - 1,\n                canopy,\n                &mut empty_node_cache,\n            );\n            canopy[node - 2].copy_from_slice(hashv(&[&left_child, &right_child]).as_ref());\n        }\n    }\n    Ok(())\n}",
    "pub fn check_canopy_root(canopy_bytes: &[u8], expected_root: &Node, max_depth: u32) -> Result<()> {\n    check_canopy_bytes(canopy_bytes)?;\n    let canopy = cast_slice::<u8, Node>(canopy_bytes);\n    if canopy.is_empty() {\n        return Ok(()); // Canopy is empty\n    }\n    let mut empty_node_cache = Box::new([EMPTY; MAX_SUPPORTED_DEPTH]);\n    // first two nodes are the children of the root, they have index 2 and 3 respectively\n    let left_root_child =\n        get_value_for_node::<MAX_SUPPORTED_DEPTH>(2, max_depth - 1, canopy, &mut empty_node_cache);\n    let right_root_child =\n        get_value_for_node::<MAX_SUPPORTED_DEPTH>(3, max_depth - 1, canopy, &mut empty_node_cache);\n    let actual_root = hashv(&[&left_root_child, &right_root_child]).to_bytes();\n    if actual_root != *expected_root {\n        msg!(\n            \"Canopy root mismatch. Expected: {:?}, Actual: {:?}\",\n            expected_root,\n            actual_root\n        );\n        err!(AccountCompressionError::CanopyRootMismatch)\n    }",
    "pub fn check_canopy_no_nodes_to_right_of_index(\n    canopy_bytes: &[u8],\n    max_depth: u32,\n    index: u32,\n) -> Result<()> {\n    check_canopy_bytes(canopy_bytes)?;\n    check_index(index, max_depth)?;\n    let canopy = cast_slice::<u8, Node>(canopy_bytes);\n    let path_len = get_cached_path_length(canopy, max_depth)?;\n\n    let mut node_idx = ((1 << max_depth) + index) >> (max_depth - path_len);\n    // no need to check the node_idx as it's the leaf continaing the index underneath it\n    while node_idx & (node_idx + 1) != 0 {\n        // check the next node to the right\n        node_idx += 1;\n        // find the top-most node that has the node as its left-most child\n        node_idx >>= node_idx.trailing_zeros();\n\n        let shifted_index = node_idx as usize - 2;\n        if canopy[shifted_index] != EMPTY {\n            msg!(\"Canopy node at index {} is not empty\", shifted_index);\n            return err!(AccountCompressionError::CanopyRightmostLeafMismatch);\n        }\n    }\n    Ok(())\n}",
    "pub fn merkle_tree_initialize_empty(\n    header: &ConcurrentMerkleTreeHeader,\n    tree_id: Pubkey,\n    tree_bytes: &mut [u8],\n) -> Result<Box<ChangeLogEvent>> {\n    merkle_tree_apply_fn_mut!(header, tree_id, tree_bytes, initialize,)\n}",
    "pub fn merkle_tree_initialize_with_root(\n    header: &ConcurrentMerkleTreeHeader,\n    tree_id: Pubkey,\n    tree_bytes: &mut [u8],\n    args: &InitializeWithRootArgs,\n) -> Result<Box<ChangeLogEvent>> {\n    merkle_tree_apply_fn_mut!(header, tree_id, tree_bytes, initialize_with_root, args)\n}",
    "pub fn merkle_tree_set_leaf(\n    header: &ConcurrentMerkleTreeHeader,\n    tree_id: Pubkey,\n    tree_bytes: &mut [u8],\n    args: &SetLeafArgs,\n) -> Result<Box<ChangeLogEvent>> {\n    merkle_tree_apply_fn_mut!(header, tree_id, tree_bytes, set_leaf, args)\n}",
    "pub fn merkle_tree_fill_empty_or_append(\n    header: &ConcurrentMerkleTreeHeader,\n    tree_id: Pubkey,\n    tree_bytes: &mut [u8],\n    args: &FillEmptyOrAppendArgs,\n) -> Result<Box<ChangeLogEvent>> {\n    merkle_tree_apply_fn_mut!(header, tree_id, tree_bytes, fill_empty_or_append, args)\n}",
    "pub fn merkle_tree_prove_leaf(\n    header: &ConcurrentMerkleTreeHeader,\n    tree_id: Pubkey,\n    tree_bytes: &[u8],\n    args: &ProveLeafArgs,\n) -> Result<Box<ChangeLogEvent>> {\n    merkle_tree_apply_fn!(header, tree_id, tree_bytes, prove_leaf, args)\n}",
    "pub fn merkle_tree_append_leaf(\n    header: &ConcurrentMerkleTreeHeader,\n    tree_id: Pubkey,\n    tree_bytes: &mut [u8],\n    args: &[u8; 32],\n) -> Result<Box<ChangeLogEvent>> {\n    merkle_tree_apply_fn_mut!(header, tree_id, tree_bytes, append, *args)\n}",
    "pub fn tree_bytes_uninitialized(tree_bytes: &[u8]) -> bool {\n    tree_bytes.iter().all(|&x| x == 0)\n}",
    "pub fn assert_tree_is_empty(\n    header: &ConcurrentMerkleTreeHeader,\n    tree_id: Pubkey,\n    tree_bytes: &mut [u8],\n) -> Result<()> {\n    // If the tree is batch initialized and not finalized yet, we can treat it as empty.\n    // Before the tree is finalized, the tree_bytes will be all 0 as only the header will be\n    // initialized at that point, so we may skip the deserialization.\n    if header.get_is_batch_initialized() && tree_bytes_uninitialized(tree_bytes) {\n        return Ok(());\n    }\n    // check the tree is empty\n    merkle_tree_apply_fn_mut!(header, tree_id, tree_bytes, prove_tree_is_empty,)?;\n    Ok(())\n}",
    "pub fn init_empty_merkle_tree(\n        ctx: Context<Initialize>,\n        max_depth: u32,\n        max_buffer_size: u32,\n    ) -> Result<()> {\n        require_eq!(\n            *ctx.accounts.merkle_tree.owner,\n            crate::id(),\n            AccountCompressionError::IncorrectAccountOwner\n        );\n        let mut merkle_tree_bytes = ctx.accounts.merkle_tree.try_borrow_mut_data()?;\n\n        let (mut header_bytes, rest) =\n            merkle_tree_bytes.split_at_mut(CONCURRENT_MERKLE_TREE_HEADER_SIZE_V1);\n\n        let mut header = ConcurrentMerkleTreeHeader::try_from_slice(header_bytes)?;\n        header.initialize(\n            max_depth,\n            max_buffer_size,\n            &ctx.accounts.authority.key(),\n            Clock::get()?.slot,\n        );\n        header.serialize(&mut header_bytes)?;\n\n        let merkle_tree_size = merkle_tree_get_size(&header)?;\n        let (tree_bytes, canopy_bytes) = rest.split_at_mut(merkle_tree_size);\n        let id = ctx.accounts.merkle_tree.key();\n\n        let change_log_event = merkle_tree_initialize_empty(&header, id, tree_bytes)?;\n\n        wrap_event(\n            &AccountCompressionEvent::ChangeLog(*change_log_event),\n            &ctx.accounts.noop,\n        )?;\n        update_canopy(canopy_bytes, header.get_max_depth(), None)\n    }",
    "pub fn prepare_batch_merkle_tree(\n        ctx: Context<Initialize>,\n        max_depth: u32,\n        max_buffer_size: u32,\n    ) -> Result<()> {\n        require_eq!(\n            *ctx.accounts.merkle_tree.owner,\n            crate::id(),\n            AccountCompressionError::IncorrectAccountOwner\n        );\n        let mut merkle_tree_bytes = ctx.accounts.merkle_tree.try_borrow_mut_data()?;\n\n        let (mut header_bytes, rest) =\n            merkle_tree_bytes.split_at_mut(CONCURRENT_MERKLE_TREE_HEADER_SIZE_V1);\n\n        let mut header = ConcurrentMerkleTreeHeader::try_from_slice(header_bytes)?;\n        header.initialize_batched(\n            max_depth,\n            max_buffer_size,\n            &ctx.accounts.authority.key(),\n            Clock::get()?.slot,\n        );\n        header.serialize(&mut header_bytes)?;\n        let merkle_tree_size = merkle_tree_get_size(&header)?;\n        let (_tree_bytes, canopy_bytes) = rest.split_at_mut(merkle_tree_size);\n        check_canopy_bytes(canopy_bytes)\n    }",
    "pub fn append_canopy_nodes(\n        ctx: Context<Modify>,\n        start_index: u32,\n        canopy_nodes: Vec<[u8; 32]>,\n    ) -> Result<()> {\n        require_eq!(\n            *ctx.accounts.merkle_tree.owner,\n            crate::id(),\n            AccountCompressionError::IncorrectAccountOwner\n        );\n        let mut merkle_tree_bytes = ctx.accounts.merkle_tree.try_borrow_mut_data()?;\n\n        let (header_bytes, rest) =\n            merkle_tree_bytes.split_at_mut(CONCURRENT_MERKLE_TREE_HEADER_SIZE_V1);\n\n        let header = ConcurrentMerkleTreeHeader::try_from_slice(header_bytes)?;\n        header.assert_valid_authority(&ctx.accounts.authority.key())?;\n        header.assert_is_batch_initialized()?;\n        // assert the tree is not initialized yet, we don't want to overwrite the canopy of an\n        // initialized tree\n        let merkle_tree_size = merkle_tree_get_size(&header)?;\n        let (tree_bytes, canopy_bytes) = rest.split_at_mut(merkle_tree_size);\n        // ensure the tree is not initialized, the hacky way\n        require!(\n            tree_bytes_uninitialized(tree_bytes),\n            AccountCompressionError::TreeAlreadyInitialized\n        );\n        set_canopy_leaf_nodes(\n            canopy_bytes,\n            header.get_max_depth(),\n            start_index,\n            &canopy_nodes,\n        )\n    }",
    "pub fn init_prepared_tree_with_root(\n        ctx: Context<Modify>,\n        root: [u8; 32],\n        rightmost_leaf: [u8; 32],\n        rightmost_index: u32,\n    ) -> Result<()> {\n        require_eq!(\n            *ctx.accounts.merkle_tree.owner,\n            crate::id(),\n            AccountCompressionError::IncorrectAccountOwner\n        );\n        let mut merkle_tree_bytes = ctx.accounts.merkle_tree.try_borrow_mut_data()?;\n\n        let (header_bytes, rest) =\n            merkle_tree_bytes.split_at_mut(CONCURRENT_MERKLE_TREE_HEADER_SIZE_V1);\n        // the header should already be initialized with prepare_batch_merkle_tree\n        let header = ConcurrentMerkleTreeHeader::try_from_slice(header_bytes)?;\n        header.assert_valid_authority(&ctx.accounts.authority.key())?;\n        header.assert_is_batch_initialized()?;\n        let merkle_tree_size = merkle_tree_get_size(&header)?;\n        let (tree_bytes, canopy_bytes) = rest.split_at_mut(merkle_tree_size);\n        // check the canopy root matches the tree root\n        check_canopy_root(canopy_bytes, &root, header.get_max_depth())?;\n        // verify the canopy does not conain any nodes to the right of the rightmost leaf\n        check_canopy_no_nodes_to_right_of_index(\n            canopy_bytes,\n            header.get_max_depth(),\n            rightmost_index,\n        )?;\n\n        // Get rightmost proof from accounts\n        let mut proof = vec![];\n        for node in ctx.remaining_accounts.iter() {\n            proof.push(node.key().to_bytes());\n        }\n        fill_in_proof_from_canopy(\n            canopy_bytes,\n            header.get_max_depth(),\n            rightmost_index,\n            &mut proof,\n        )?;\n        assert_eq!(proof.len(), header.get_max_depth() as usize);\n\n        let id = ctx.accounts.merkle_tree.key();\n        // A call is made to ConcurrentMerkleTree::initialize_with_root\n        let args = &InitializeWithRootArgs {\n            root,\n            rightmost_leaf,\n            proof_vec: proof,\n            index: rightmost_index,\n        };\n        let change_log = merkle_tree_initialize_with_root(&header, id, tree_bytes, args)?;\n        update_canopy(canopy_bytes, header.get_max_depth(), Some(&change_log))?;\n        wrap_event(\n            &AccountCompressionEvent::ChangeLog(*change_log),\n            &ctx.accounts.noop,\n        )\n    }",
    "pub fn replace_leaf(\n        ctx: Context<Modify>,\n        root: [u8; 32],\n        previous_leaf: [u8; 32],\n        new_leaf: [u8; 32],\n        index: u32,\n    ) -> Result<()> {\n        require_eq!(\n            *ctx.accounts.merkle_tree.owner,\n            crate::id(),\n            AccountCompressionError::IncorrectAccountOwner\n        );\n        let mut merkle_tree_bytes = ctx.accounts.merkle_tree.try_borrow_mut_data()?;\n        let (header_bytes, rest) =\n            merkle_tree_bytes.split_at_mut(CONCURRENT_MERKLE_TREE_HEADER_SIZE_V1);\n\n        let header = ConcurrentMerkleTreeHeader::try_from_slice(header_bytes)?;\n        header.assert_valid_authority(&ctx.accounts.authority.key())?;\n        header.assert_valid_leaf_index(index)?;\n\n        let merkle_tree_size = merkle_tree_get_size(&header)?;\n        let (tree_bytes, canopy_bytes) = rest.split_at_mut(merkle_tree_size);\n\n        let mut proof = vec![];\n        for node in ctx.remaining_accounts.iter() {\n            proof.push(node.key().to_bytes());\n        }\n        fill_in_proof_from_canopy(canopy_bytes, header.get_max_depth(), index, &mut proof)?;\n        let id = ctx.accounts.merkle_tree.key();\n        // A call is made to ConcurrentMerkleTree::set_leaf(root, previous_leaf, new_leaf, proof, index)\n        let args = &SetLeafArgs {\n            current_root: root,\n            previous_leaf,\n            new_leaf,\n            proof_vec: proof,\n            index,\n        };\n        let change_log_event = merkle_tree_set_leaf(&header, id, tree_bytes, args)?;\n\n        update_canopy(\n            canopy_bytes,\n            header.get_max_depth(),\n            Some(&change_log_event),\n        )?;\n        wrap_event(\n            &AccountCompressionEvent::ChangeLog(*change_log_event),\n            &ctx.accounts.noop,\n        )\n    }",
    "pub fn transfer_authority(\n        ctx: Context<TransferAuthority>,\n        new_authority: Pubkey,\n    ) -> Result<()> {\n        require_eq!(\n            *ctx.accounts.merkle_tree.owner,\n            crate::id(),\n            AccountCompressionError::IncorrectAccountOwner\n        );\n        let mut merkle_tree_bytes = ctx.accounts.merkle_tree.try_borrow_mut_data()?;\n        let (mut header_bytes, _) =\n            merkle_tree_bytes.split_at_mut(CONCURRENT_MERKLE_TREE_HEADER_SIZE_V1);\n\n        let mut header = ConcurrentMerkleTreeHeader::try_from_slice(header_bytes)?;\n        header.assert_valid_authority(&ctx.accounts.authority.key())?;\n\n        header.set_new_authority(&new_authority);\n        header.serialize(&mut header_bytes)?;\n\n        Ok(())\n    }",
    "pub fn verify_leaf(\n        ctx: Context<VerifyLeaf>,\n        root: [u8; 32],\n        leaf: [u8; 32],\n        index: u32,\n    ) -> Result<()> {\n        require_eq!(\n            *ctx.accounts.merkle_tree.owner,\n            crate::id(),\n            AccountCompressionError::IncorrectAccountOwner\n        );\n        let merkle_tree_bytes = ctx.accounts.merkle_tree.try_borrow_data()?;\n        let (header_bytes, rest) =\n            merkle_tree_bytes.split_at(CONCURRENT_MERKLE_TREE_HEADER_SIZE_V1);\n\n        let header = ConcurrentMerkleTreeHeader::try_from_slice(header_bytes)?;\n        header.assert_valid()?;\n        header.assert_valid_leaf_index(index)?;\n\n        let merkle_tree_size = merkle_tree_get_size(&header)?;\n        let (tree_bytes, canopy_bytes) = rest.split_at(merkle_tree_size);\n\n        let mut proof = vec![];\n        for node in ctx.remaining_accounts.iter() {\n            proof.push(node.key().to_bytes());\n        }\n        fill_in_proof_from_canopy(canopy_bytes, header.get_max_depth(), index, &mut proof)?;\n        let id = ctx.accounts.merkle_tree.key();\n\n        let args = &ProveLeafArgs {\n            current_root: root,\n            leaf,\n            proof_vec: proof,\n            index,\n        };\n        merkle_tree_prove_leaf(&header, id, tree_bytes, args)?;\n\n        Ok(())\n    }",
    "pub fn append(ctx: Context<Modify>, leaf: [u8; 32]) -> Result<()> {\n        require_eq!(\n            *ctx.accounts.merkle_tree.owner,\n            crate::id(),\n            AccountCompressionError::IncorrectAccountOwner\n        );\n        let mut merkle_tree_bytes = ctx.accounts.merkle_tree.try_borrow_mut_data()?;\n        let (header_bytes, rest) =\n            merkle_tree_bytes.split_at_mut(CONCURRENT_MERKLE_TREE_HEADER_SIZE_V1);\n\n        let header = ConcurrentMerkleTreeHeader::try_from_slice(header_bytes)?;\n        header.assert_valid_authority(&ctx.accounts.authority.key())?;\n\n        let id = ctx.accounts.merkle_tree.key();\n        let merkle_tree_size = merkle_tree_get_size(&header)?;\n        let (tree_bytes, canopy_bytes) = rest.split_at_mut(merkle_tree_size);\n        let change_log_event = merkle_tree_append_leaf(&header, id, tree_bytes, &leaf)?;\n        update_canopy(\n            canopy_bytes,\n            header.get_max_depth(),\n            Some(&change_log_event),\n        )?;\n        wrap_event(\n            &AccountCompressionEvent::ChangeLog(*change_log_event),\n            &ctx.accounts.noop,\n        )\n    }",
    "pub fn insert_or_append(\n        ctx: Context<Modify>,\n        root: [u8; 32],\n        leaf: [u8; 32],\n        index: u32,\n    ) -> Result<()> {\n        require_eq!(\n            *ctx.accounts.merkle_tree.owner,\n            crate::id(),\n            AccountCompressionError::IncorrectAccountOwner\n        );\n        let mut merkle_tree_bytes = ctx.accounts.merkle_tree.try_borrow_mut_data()?;\n        let (header_bytes, rest) =\n            merkle_tree_bytes.split_at_mut(CONCURRENT_MERKLE_TREE_HEADER_SIZE_V1);\n\n        let header = ConcurrentMerkleTreeHeader::try_from_slice(header_bytes)?;\n        header.assert_valid_authority(&ctx.accounts.authority.key())?;\n        header.assert_valid_leaf_index(index)?;\n\n        let merkle_tree_size = merkle_tree_get_size(&header)?;\n        let (tree_bytes, canopy_bytes) = rest.split_at_mut(merkle_tree_size);\n\n        let mut proof = vec![];\n        for node in ctx.remaining_accounts.iter() {\n            proof.push(node.key().to_bytes());\n        }\n        fill_in_proof_from_canopy(canopy_bytes, header.get_max_depth(), index, &mut proof)?;\n        // A call is made to ConcurrentMerkleTree::fill_empty_or_append\n        let id = ctx.accounts.merkle_tree.key();\n        let args = &FillEmptyOrAppendArgs {\n            current_root: root,\n            leaf,\n            proof_vec: proof,\n            index,\n        };\n        let change_log_event = merkle_tree_fill_empty_or_append(&header, id, tree_bytes, args)?;\n\n        update_canopy(\n            canopy_bytes,\n            header.get_max_depth(),\n            Some(&change_log_event),\n        )?;\n        wrap_event(\n            &AccountCompressionEvent::ChangeLog(*change_log_event),\n            &ctx.accounts.noop,\n        )\n    }",
    "pub fn close_empty_tree(ctx: Context<CloseTree>) -> Result<()> {\n        require_eq!(\n            *ctx.accounts.merkle_tree.owner,\n            crate::id(),\n            AccountCompressionError::IncorrectAccountOwner\n        );\n        let mut merkle_tree_bytes = ctx.accounts.merkle_tree.try_borrow_mut_data()?;\n        let (header_bytes, rest) =\n            merkle_tree_bytes.split_at_mut(CONCURRENT_MERKLE_TREE_HEADER_SIZE_V1);\n\n        let header = ConcurrentMerkleTreeHeader::try_from_slice(header_bytes)?;\n        header.assert_valid_authority(&ctx.accounts.authority.key())?;\n\n        let merkle_tree_size = merkle_tree_get_size(&header)?;\n        let (tree_bytes, canopy_bytes) = rest.split_at_mut(merkle_tree_size);\n\n        let id = ctx.accounts.merkle_tree.key();\n        assert_tree_is_empty(&header, id, tree_bytes)?;\n\n        // Close merkle tree account\n        // 1. Move lamports\n        let dest_starting_lamports = ctx.accounts.recipient.lamports();\n        **ctx.accounts.recipient.lamports.borrow_mut() = dest_starting_lamports\n            .checked_add(ctx.accounts.merkle_tree.lamports())\n            .unwrap();\n        **ctx.accounts.merkle_tree.lamports.borrow_mut() = 0;\n\n        // 2. Set all CMT account bytes to 0\n        header_bytes.fill(0);\n        tree_bytes.fill(0);\n        canopy_bytes.fill(0);\n\n        Ok(())\n    }",
    "pub fn new(id: Pubkey, path: Vec<PathNode>, seq: u64, index: u32) -> Self {\n        Self::V1(ChangeLogEventV1 {\n            id,\n            path,\n            seq,\n            index,\n        })\n    }",
    "pub fn initialize(\n        &mut self,\n        max_depth: u32,\n        max_buffer_size: u32,\n        authority: &Pubkey,\n        creation_slot: u64,\n    ) {\n        self.account_type = CompressionAccountType::ConcurrentMerkleTree;\n\n        match self.header {\n            ConcurrentMerkleTreeHeaderData::V1(ref mut header) => {\n                // Double check header is empty after deserialization from zero'd bytes\n                assert_eq!(header.max_buffer_size, 0);\n                assert_eq!(header.max_depth, 0);\n                header.max_buffer_size = max_buffer_size;\n                header.max_depth = max_depth;\n                header.authority = *authority;\n                header.creation_slot = creation_slot;\n                // is_batch_initialized is left false by default\n            }\n        }\n    }\n\n    /// Initializes the header with the given parameters and sets the `is_batch_initialized` flag to\n    /// true.\n    pub fn initialize_batched(\n        &mut self,\n        max_depth: u32,\n        max_buffer_size: u32,\n        authority: &Pubkey,\n        creation_slot: u64,\n    ) {\n        self.initialize(max_depth, max_buffer_size, authority, creation_slot);\n        match self.header {\n            ConcurrentMerkleTreeHeaderData::V1(ref mut header) => {\n                header.is_batch_initialized = true;\n            }\n        }\n    }\n\n    pub fn get_max_depth(&self) -> u32 {\n        match &self.header {\n            ConcurrentMerkleTreeHeaderData::V1(header) => header.max_depth,\n        }\n    }\n\n    pub fn get_max_buffer_size(&self) -> u32 {\n        match &self.header {\n            ConcurrentMerkleTreeHeaderData::V1(header) => header.max_buffer_size,\n        }\n    }\n\n    pub fn get_creation_slot(&self) -> u64 {\n        match &self.header {\n            ConcurrentMerkleTreeHeaderData::V1(header) => header.creation_slot,\n        }\n    }\n\n    pub fn get_is_batch_initialized(&self) -> bool {\n        match &self.header {\n            ConcurrentMerkleTreeHeaderData::V1(header) => header.is_batch_initialized,\n        }\n    }\n\n    pub fn set_new_authority(&mut self, new_authority: &Pubkey) {\n        match self.header {\n            ConcurrentMerkleTreeHeaderData::V1(ref mut header) => {\n                header.authority = new_authority.clone();\n                msg!(\"Authority transferred to: {:?}\", header.authority);\n            }\n        }\n    }\n\n    pub fn assert_valid(&self) -> Result<()> {\n        require_eq!(\n            self.account_type,\n            CompressionAccountType::ConcurrentMerkleTree,\n            AccountCompressionError::IncorrectAccountType,\n        );\n        Ok(())\n    }",
    "pub fn assert_valid_authority(&self, expected_authority: &Pubkey) -> Result<()> {\n        self.assert_valid()?;\n        match &self.header {\n            ConcurrentMerkleTreeHeaderData::V1(header) => {\n                require_eq!(\n                    header.authority,\n                    *expected_authority,\n                    AccountCompressionError::IncorrectAuthority,\n                );\n            }\n        }\n        Ok(())\n    }",
    "pub fn assert_valid_leaf_index(&self, leaf_index: u32) -> Result<()> {\n        if leaf_index >= (1 << self.get_max_depth()) {\n            return Err(AccountCompressionError::LeafIndexOutOfBounds.into());\n        }\n        Ok(())\n    }",
    "pub fn assert_is_batch_initialized(&self) -> Result<()> {\n        match &self.header {\n            ConcurrentMerkleTreeHeaderData::V1(header) => {\n                require!(\n                    header.is_batch_initialized,\n                    AccountCompressionError::BatchNotInitialized\n                );\n            }\n        }\n        Ok(())\n    }",
    "pub fn merkle_tree_get_size(header: &ConcurrentMerkleTreeHeader) -> Result<usize> {\n    // Note: max_buffer_size MUST be a power of 2\n    match (header.get_max_depth(), header.get_max_buffer_size()) {\n        (3, 8) => Ok(size_of::<ConcurrentMerkleTree<3, 8>>()),\n        (5, 8) => Ok(size_of::<ConcurrentMerkleTree<5, 8>>()),\n        (6, 16) => Ok(size_of::<ConcurrentMerkleTree<6, 16>>()),\n        (7, 16) => Ok(size_of::<ConcurrentMerkleTree<7, 16>>()),\n        (8, 16) => Ok(size_of::<ConcurrentMerkleTree<8, 16>>()),\n        (9, 16) => Ok(size_of::<ConcurrentMerkleTree<9, 16>>()),\n        (10, 32) => Ok(size_of::<ConcurrentMerkleTree<10, 32>>()),\n        (11, 32) => Ok(size_of::<ConcurrentMerkleTree<11, 32>>()),\n        (12, 32) => Ok(size_of::<ConcurrentMerkleTree<12, 32>>()),\n        (13, 32) => Ok(size_of::<ConcurrentMerkleTree<13, 32>>()),\n        (14, 64) => Ok(size_of::<ConcurrentMerkleTree<14, 64>>()),\n        (14, 256) => Ok(size_of::<ConcurrentMerkleTree<14, 256>>()),\n        (14, 1024) => Ok(size_of::<ConcurrentMerkleTree<14, 1024>>()),\n        (14, 2048) => Ok(size_of::<ConcurrentMerkleTree<14, 2048>>()),\n        (15, 64) => Ok(size_of::<ConcurrentMerkleTree<15, 64>>()),\n        (16, 64) => Ok(size_of::<ConcurrentMerkleTree<16, 64>>()),\n        (17, 64) => Ok(size_of::<ConcurrentMerkleTree<17, 64>>()),\n        (18, 64) => Ok(size_of::<ConcurrentMerkleTree<18, 64>>()),\n        (19, 64) => Ok(size_of::<ConcurrentMerkleTree<19, 64>>()),\n        (20, 64) => Ok(size_of::<ConcurrentMerkleTree<20, 64>>()),\n        (20, 256) => Ok(size_of::<ConcurrentMerkleTree<20, 256>>()),\n        (20, 1024) => Ok(size_of::<ConcurrentMerkleTree<20, 1024>>()),\n        (20, 2048) => Ok(size_of::<ConcurrentMerkleTree<20, 2048>>()),\n        (24, 64) => Ok(size_of::<ConcurrentMerkleTree<24, 64>>()),\n        (24, 256) => Ok(size_of::<ConcurrentMerkleTree<24, 256>>()),\n        (24, 512) => Ok(size_of::<ConcurrentMerkleTree<24, 512>>()),\n        (24, 1024) => Ok(size_of::<ConcurrentMerkleTree<24, 1024>>()),\n        (24, 2048) => Ok(size_of::<ConcurrentMerkleTree<24, 2048>>()),\n        (26, 512) => Ok(size_of::<ConcurrentMerkleTree<26, 512>>()),\n        (26, 1024) => Ok(size_of::<ConcurrentMerkleTree<26, 1024>>()),\n        (26, 2048) => Ok(size_of::<ConcurrentMerkleTree<26, 2048>>()),\n        (30, 512) => Ok(size_of::<ConcurrentMerkleTree<30, 512>>()),\n        (30, 1024) => Ok(size_of::<ConcurrentMerkleTree<30, 1024>>()),\n        (30, 2048) => Ok(size_of::<ConcurrentMerkleTree<30, 2048>>()),\n        _ => {\n            msg!(\n                \"Failed to get size of max depth {} and max buffer size {}\",\n                header.get_max_depth(),\n                header.get_max_buffer_size()\n            );\n            err!(AccountCompressionError::ConcurrentMerkleTreeConstantsError)\n        }",
    "pub fn noop(\n    _program_id: &Pubkey,\n    _accounts: &[AccountInfo],\n    _instruction_data: &[u8],\n) -> ProgramResult {\n    Ok(())\n}",
    "pub fn process(\n        program_id: &Pubkey,\n        accounts: &[AccountInfo],\n        instruction_data: &[u8],\n    ) -> ProgramResult {\n        let instruction = BinaryOptionInstruction::try_from_slice(instruction_data)?;\n        match instruction {\n            BinaryOptionInstruction::InitializeBinaryOption(args) => {\n                msg!(\"Instruction: InitializeBinaryOption\");\n                process_initialize_binary_option(program_id, accounts, args.decimals)\n            }",
    "pub fn process_initialize_binary_option(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    decimals: u8,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let binary_option_account_info = next_account_info(account_info_iter)?;\n    let escrow_mint_info = next_account_info(account_info_iter)?;\n    let escrow_account_info = next_account_info(account_info_iter)?;\n    let long_token_mint_info = next_account_info(account_info_iter)?;\n    let short_token_mint_info = next_account_info(account_info_iter)?;\n    let mint_authority_info = next_account_info(account_info_iter)?;\n    let update_authority_info = next_account_info(account_info_iter)?;\n    let token_program_info = next_account_info(account_info_iter)?;\n    let system_account_info = next_account_info(account_info_iter)?;\n    let rent_info = next_account_info(account_info_iter)?;\n\n    create_new_account(\n        mint_authority_info,\n        long_token_mint_info,\n        Mint::LEN,\n        token_program_info,\n        rent_info,\n    )?;\n    create_new_account(\n        mint_authority_info,\n        short_token_mint_info,\n        Mint::LEN,\n        token_program_info,\n        rent_info,\n    )?;\n    create_new_account(\n        update_authority_info,\n        escrow_account_info,\n        Account::LEN,\n        token_program_info,\n        rent_info,\n    )?;\n    spl_mint_initialize(\n        token_program_info,\n        long_token_mint_info,\n        mint_authority_info,\n        mint_authority_info,\n        rent_info,\n        0,\n    )?;\n    spl_mint_initialize(\n        token_program_info,\n        short_token_mint_info,\n        mint_authority_info,\n        mint_authority_info,\n        rent_info,\n        0,\n    )?;\n    spl_initialize(\n        token_program_info,\n        escrow_account_info,\n        escrow_mint_info,\n        update_authority_info,\n        rent_info,\n    )?;\n\n    assert_keys_equal(*token_program_info.key, spl_token::id())?;\n\n    // Transfer ownership of the escrow accounts to a PDA\n    let (authority_key, _) = Pubkey::find_program_address(\n        &[\n            long_token_mint_info.key.as_ref(),\n            short_token_mint_info.key.as_ref(),\n            token_program_info.key.as_ref(),\n            program_id.as_ref(),\n        ],\n        program_id,\n    );\n    spl_set_authority(\n        token_program_info,\n        escrow_account_info,\n        Some(authority_key),\n        AuthorityType::AccountOwner,\n        update_authority_info,\n    )?;\n    spl_set_authority(\n        token_program_info,\n        long_token_mint_info,\n        Some(authority_key),\n        AuthorityType::MintTokens,\n        update_authority_info,\n    )?;\n    spl_set_authority(\n        token_program_info,\n        short_token_mint_info,\n        Some(authority_key),\n        AuthorityType::MintTokens,\n        update_authority_info,\n    )?;\n\n    create_or_allocate_account_raw(\n        *program_id,\n        binary_option_account_info,\n        rent_info,\n        system_account_info,\n        update_authority_info,\n        BinaryOption::LEN,\n    )?;\n\n    let mut binary_option =\n        BinaryOption::try_from_slice(&binary_option_account_info.data.borrow_mut())?;\n    binary_option.decimals = decimals;\n    binary_option.circulation = 0;\n    binary_option.settled = false;\n    binary_option.long_mint_account_pubkey = *long_token_mint_info.key;\n    binary_option.short_mint_account_pubkey = *short_token_mint_info.key;\n    binary_option.escrow_mint_account_pubkey = *escrow_mint_info.key;\n    binary_option.escrow_account_pubkey = *escrow_account_info.key;\n    binary_option.owner = *update_authority_info.key;\n    borsh::to_writer(\n        &mut binary_option_account_info.data.borrow_mut()[..],\n        &binary_option,\n    )?;\n    Ok(())\n}",
    "pub fn process_trade(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    size: u64,\n    buy_price: u64,\n    sell_price: u64,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let binary_option_account_info = next_account_info(account_info_iter)?;\n    let escrow_account_info = next_account_info(account_info_iter)?;\n    let long_token_mint_info = next_account_info(account_info_iter)?;\n    let short_token_mint_info = next_account_info(account_info_iter)?;\n    let buyer_info = next_account_info(account_info_iter)?;\n    let seller_info = next_account_info(account_info_iter)?;\n    let buyer_account_info = next_account_info(account_info_iter)?;\n    let seller_account_info = next_account_info(account_info_iter)?;\n    let buyer_long_token_account_info = next_account_info(account_info_iter)?;\n    let buyer_short_token_account_info = next_account_info(account_info_iter)?;\n    let seller_long_token_account_info = next_account_info(account_info_iter)?;\n    let seller_short_token_account_info = next_account_info(account_info_iter)?;\n    let authority_info = next_account_info(account_info_iter)?;\n    let token_program_info = next_account_info(account_info_iter)?;\n\n    // Unpack accounts\n    let long_token_mint: Mint = assert_initialized(long_token_mint_info)?;\n    let short_token_mint: Mint = assert_initialized(short_token_mint_info)?;\n    let buyer_long_token_account: Account = assert_initialized(buyer_long_token_account_info)?;\n    let buyer_short_token_account: Account = assert_initialized(buyer_short_token_account_info)?;\n    let seller_long_token_account: Account = assert_initialized(seller_long_token_account_info)?;\n    let seller_short_token_account: Account = assert_initialized(seller_short_token_account_info)?;\n    let buyer_account: Account = assert_initialized(buyer_account_info)?;\n    let seller_account: Account = assert_initialized(seller_account_info)?;\n    let mut binary_option =\n        BinaryOption::try_from_slice(&binary_option_account_info.data.borrow_mut())?;\n\n    // Get program derived address for escrow\n    let (authority_key, bump_seed) = Pubkey::find_program_address(\n        &[\n            long_token_mint_info.key.as_ref(),\n            short_token_mint_info.key.as_ref(),\n            token_program_info.key.as_ref(),\n            program_id.as_ref(),\n        ],\n        program_id,\n    );\n    let seeds = &[\n        long_token_mint_info.key.as_ref(),\n        short_token_mint_info.key.as_ref(),\n        token_program_info.key.as_ref(),\n        program_id.as_ref(),\n        &[bump_seed],\n    ];\n\n    // Validate data\n    let total_price = buy_price\n        .checked_add(sell_price)\n        .ok_or(BinaryOptionError::TradePricesIncorrect)?;\n    if total_price != u64::pow(10, binary_option.decimals as u32) {\n        return Err(BinaryOptionError::TradePricesIncorrect.into());\n    }\n    if binary_option.settled {\n        return Err(BinaryOptionError::AlreadySettled.into());\n    }\n    assert_keys_equal(*token_program_info.key, spl_token::id())?;\n    assert_keys_unequal(*buyer_info.key, *seller_info.key)?;\n    assert_keys_equal(*long_token_mint_info.owner, spl_token::id())?;\n    assert_keys_equal(*short_token_mint_info.owner, spl_token::id())?;\n    assert_keys_equal(buyer_long_token_account.owner, *buyer_info.key)?;\n    assert_keys_equal(buyer_short_token_account.owner, *buyer_info.key)?;\n    assert_keys_equal(seller_long_token_account.owner, *seller_info.key)?;\n    assert_keys_equal(seller_short_token_account.owner, *seller_info.key)?;\n    assert_keys_equal(buyer_account.owner, *buyer_info.key)?;\n    assert_keys_equal(seller_account.owner, *seller_info.key)?;\n    assert_keys_equal(authority_key, *authority_info.key)?;\n    assert_keys_equal(\n        *long_token_mint_info.key,\n        binary_option.long_mint_account_pubkey,\n    )?;\n    assert_keys_equal(\n        *short_token_mint_info.key,\n        binary_option.short_mint_account_pubkey,\n    )?;\n    assert_keys_equal(\n        *escrow_account_info.key,\n        binary_option.escrow_account_pubkey,\n    )?;\n    assert_keys_equal(\n        buyer_long_token_account.mint,\n        binary_option.long_mint_account_pubkey,\n    )?;\n    assert_keys_equal(\n        buyer_short_token_account.mint,\n        binary_option.short_mint_account_pubkey,\n    )?;\n    assert_keys_equal(\n        seller_long_token_account.mint,\n        binary_option.long_mint_account_pubkey,\n    )?;\n    assert_keys_equal(\n        seller_short_token_account.mint,\n        binary_option.short_mint_account_pubkey,\n    )?;\n    assert_keys_equal(buyer_account.mint, binary_option.escrow_mint_account_pubkey)?;\n    assert_keys_equal(\n        seller_account.mint,\n        binary_option.escrow_mint_account_pubkey,\n    )?;\n\n    let n = size;\n    let n_b = buyer_short_token_account.amount;\n    let n_s = seller_long_token_account.amount;\n\n    let mut b_l = buyer_long_token_account.amount;\n    let mut b_s = n_b;\n    let mut s_l = n_s;\n    let mut s_s = seller_short_token_account.amount;\n\n    match [n_b >= n, n_s >= n] {\n        /*\n        When n is less than both n_b and n_s, this means that both buyer and seller are simply reducing their existing inventory.\n        Therefore, we can just remove n long tokens and n short tokens from circulation. Both parties are also entitled to the locked up\n        funds for their positions that were closed. This always results in a decrease in total circulation.\n        */\n        [true, true] => {\n            msg!(\"Case 1\");\n            spl_burn(\n                token_program_info,\n                buyer_short_token_account_info,\n                short_token_mint_info,\n                buyer_info,\n                n,\n            )?;\n            spl_burn(\n                token_program_info,\n                seller_long_token_account_info,\n                long_token_mint_info,\n                seller_info,\n                n,\n            )?;\n            spl_token_transfer_signed(\n                token_program_info,\n                escrow_account_info,\n                buyer_account_info,\n                authority_info,\n                n * sell_price,\n                seeds,\n            )?;\n            spl_token_transfer_signed(\n                token_program_info,\n                escrow_account_info,\n                seller_account_info,\n                authority_info,\n                n * buy_price,\n                seeds,\n            )?;\n            b_s -= n;\n            s_l -= n;\n            binary_option.decrement_supply(n)?;\n        }\n        /*\n        When n is greater than both n_b and n_s, this means that both buyer and seller have put on a position that is different from their\n        existing position. We will first burn the tokens of representing the opposite position and then mint new tokens to ensure the buyer's\n        change is +n and the seller's change is -n. Both parties are also entitled to the locked up funds for their positions that were closed.\n        The net change in tokens can be calculated as follows: (-n_b - n_s + 2n - n_b - n_s) / 2 = n - n_b - n_s. If this quantity is positive, this\n        means that the trade causes a net increase in the total supply of contracts in the betting pool. Otherwise, it results in a net decrease\n        in total circulation.\n        */\n        [false, false] => {\n            msg!(\"Case 2\");\n            spl_burn(\n                token_program_info,\n                buyer_short_token_account_info,\n                short_token_mint_info,\n                buyer_info,\n                n_b,\n            )?;\n            spl_burn(\n                token_program_info,\n                seller_long_token_account_info,\n                long_token_mint_info,\n                seller_info,\n                n_s,\n            )?;\n            b_s -= n_b;\n            s_l -= n_s;\n            spl_mint_to(\n                token_program_info,\n                buyer_long_token_account_info,\n                long_token_mint_info,\n                authority_info,\n                n - n_b,\n                seeds,\n            )?;\n            spl_mint_to(\n                token_program_info,\n                seller_short_token_account_info,\n                short_token_mint_info,\n                authority_info,\n                n - n_s,\n                seeds,\n            )?;\n            b_l += n - n_b;\n            s_s += n - n_s;\n            spl_token_transfer(\n                token_program_info,\n                buyer_account_info,\n                escrow_account_info,\n                buyer_info,\n                (n - n_b) * buy_price,\n            )?;\n            spl_token_transfer(\n                token_program_info,\n                seller_account_info,\n                escrow_account_info,\n                seller_info,\n                (n - n_s) * sell_price,\n            )?;\n            spl_token_transfer_signed(\n                token_program_info,\n                escrow_account_info,\n                buyer_account_info,\n                authority_info,\n                n_b * sell_price,\n                seeds,\n            )?;\n            spl_token_transfer_signed(\n                token_program_info,\n                escrow_account_info,\n                seller_account_info,\n                authority_info,\n                n_s * buy_price,\n                seeds,\n            )?;\n            if n > n_b + n_s {\n                binary_option.increment_supply(n - n_b - n_s)?;\n            } else {\n                binary_option.decrement_supply(n - n_b - n_s)?;\n            }\n        }\n        /*\n        When n is greater than n_b but less than n_s, this means that the buyer has put on a position that is different from their\n        existing position, and the seller has reduced their inventory. We will burn and mint tokens such the buyer's net change in\n        position is +n and the seller's net change is -n. Both parties are also entitled to the locked up funds for their positions that were closed.\n        The net change in tokens can be calculated as follows: (-n - n_s + n - n_s) / 2 = -n_s. This always results in a decrease in total\n        circulation.\n        */\n        [true, false] => {\n            msg!(\"Case 3\");\n            spl_burn(\n                token_program_info,\n                buyer_short_token_account_info,\n                short_token_mint_info,\n                buyer_info,\n                n,\n            )?;\n            spl_burn(\n                token_program_info,\n                seller_long_token_account_info,\n                long_token_mint_info,\n                seller_info,\n                n_s,\n            )?;\n            b_s -= n;\n            s_l -= n_s;\n            spl_mint_to(\n                token_program_info,\n                seller_short_token_account_info,\n                short_token_mint_info,\n                authority_info,\n                n - n_s,\n                seeds,\n            )?;\n            s_s += n - n_s;\n            spl_token_transfer(\n                token_program_info,\n                seller_account_info,\n                escrow_account_info,\n                seller_info,\n                (n - n_s) * sell_price,\n            )?;\n            spl_token_transfer_signed(\n                token_program_info,\n                escrow_account_info,\n                seller_account_info,\n                authority_info,\n                n_s * buy_price,\n                seeds,\n            )?;\n            spl_token_transfer_signed(\n                token_program_info,\n                escrow_account_info,\n                buyer_account_info,\n                authority_info,\n                n * sell_price,\n                seeds,\n            )?;\n            binary_option.decrement_supply(n_s)?;\n        }\n        /*\n        When n is greater than n_s bust less than n_b, this means that the seller has put on a position that is different from their\n        existing position, and the buyer has reduced their inventory. We will burn and mint tokens such the buyer's net change in\n        position is +n and the seller's net change is -n. Both parties are also entitled to the locked up funds for their positions that were closed.\n        The net change in tokens can be calculated as follows: (-n - n_b + n - n_b) / 2 = -n_b. This always results in a decrease in total\n        circulation.\n        */\n        [false, true] => {\n            msg!(\"Case 4\");\n            spl_burn(\n                token_program_info,\n                seller_long_token_account_info,\n                long_token_mint_info,\n                seller_info,\n                n,\n            )?;\n            spl_burn(\n                token_program_info,\n                buyer_short_token_account_info,\n                short_token_mint_info,\n                buyer_info,\n                n_b,\n            )?;\n            b_s -= n_b;\n            s_l -= n;\n            spl_mint_to(\n                token_program_info,\n                buyer_long_token_account_info,\n                long_token_mint_info,\n                authority_info,\n                n - n_b,\n                seeds,\n            )?;\n            b_l += n - n_b;\n            spl_token_transfer(\n                token_program_info,\n                buyer_account_info,\n                escrow_account_info,\n                buyer_info,\n                (n - n_b) * buy_price,\n            )?;\n            spl_token_transfer_signed(\n                token_program_info,\n                escrow_account_info,\n                buyer_account_info,\n                authority_info,\n                n_b * sell_price,\n                seeds,\n            )?;\n            spl_token_transfer_signed(\n                token_program_info,\n                escrow_account_info,\n                seller_account_info,\n                authority_info,\n                n * buy_price,\n                seeds,\n            )?;\n            binary_option.decrement_supply(n_b)?;\n        }\n    }\n    // Delegate the burn authority to the PDA, so a private key is unnecessary on\n    // collection This can probably be optimized to reduce the number of\n    // instructions needed at some point\n    spl_approve(\n        token_program_info,\n        buyer_long_token_account_info,\n        long_token_mint_info,\n        authority_info,\n        buyer_info,\n        b_l,\n        long_token_mint.decimals,\n    )?;\n    spl_approve(\n        token_program_info,\n        seller_short_token_account_info,\n        short_token_mint_info,\n        authority_info,\n        seller_info,\n        s_s,\n        short_token_mint.decimals,\n    )?;\n    spl_approve(\n        token_program_info,\n        buyer_short_token_account_info,\n        short_token_mint_info,\n        authority_info,\n        buyer_info,\n        b_s,\n        short_token_mint.decimals,\n    )?;\n    spl_approve(\n        token_program_info,\n        seller_long_token_account_info,\n        long_token_mint_info,\n        authority_info,\n        seller_info,\n        s_l,\n        long_token_mint.decimals,\n    )?;\n    borsh::to_writer(\n        &mut binary_option_account_info.data.borrow_mut()[..],\n        &binary_option,\n    )?;\n    Ok(())\n}",
    "pub fn process_settle(_program_id: &Pubkey, accounts: &[AccountInfo]) -> ProgramResult {\n    // This should NEVER be called directly (otherwise this is literally a rug)\n    // The `pool_owner_info` needs to approve this action, so the recommended use\n    // case is to have a higher level program own the pool and use an oracle to\n    // resolve settlements\n    let account_info_iter = &mut accounts.iter();\n    let binary_option_account_info = next_account_info(account_info_iter)?;\n    let winning_mint_account_info = next_account_info(account_info_iter)?;\n    let pool_owner_info = next_account_info(account_info_iter)?;\n\n    let mut binary_option =\n        BinaryOption::try_from_slice(&binary_option_account_info.data.borrow_mut())?;\n    if !pool_owner_info.is_signer {\n        return Err(ProgramError::MissingRequiredSignature);\n    }\n    if binary_option.settled {\n        return Err(BinaryOptionError::AlreadySettled.into());\n    }\n\n    assert_keys_equal(*pool_owner_info.key, binary_option.owner)?;\n    if *winning_mint_account_info.key == binary_option.long_mint_account_pubkey\n        || *winning_mint_account_info.key == binary_option.short_mint_account_pubkey\n    {\n        binary_option.winning_side_pubkey = *winning_mint_account_info.key;\n    } else {\n        return Err(BinaryOptionError::InvalidWinner.into());\n    }\n    binary_option.settled = true;\n    borsh::to_writer(\n        &mut binary_option_account_info.data.borrow_mut()[..],\n        &binary_option,\n    )?;\n    Ok(())\n}",
    "pub fn process_collect(program_id: &Pubkey, accounts: &[AccountInfo]) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let binary_option_account_info = next_account_info(account_info_iter)?;\n    let collector_info = next_account_info(account_info_iter)?;\n    let collector_long_token_account_info = next_account_info(account_info_iter)?;\n    let collector_short_token_account_info = next_account_info(account_info_iter)?;\n    let collector_account_info = next_account_info(account_info_iter)?;\n    let long_token_mint_info = next_account_info(account_info_iter)?;\n    let short_token_mint_info = next_account_info(account_info_iter)?;\n    let escrow_account_info = next_account_info(account_info_iter)?;\n    let escrow_authority_info = next_account_info(account_info_iter)?;\n    let token_program_info = next_account_info(account_info_iter)?;\n\n    let collector_long_token_account: Account =\n        assert_initialized(collector_long_token_account_info)?;\n    let collector_short_token_account: Account =\n        assert_initialized(collector_short_token_account_info)?;\n    let collector_account: Account = assert_initialized(collector_account_info)?;\n    let escrow_account: Account = assert_initialized(escrow_account_info)?;\n    let mut binary_option =\n        BinaryOption::try_from_slice(&binary_option_account_info.data.borrow_mut())?;\n\n    // Get program derived address for escrow\n    let (escrow_owner_key, bump_seed) = Pubkey::find_program_address(\n        &[\n            long_token_mint_info.key.as_ref(),\n            short_token_mint_info.key.as_ref(),\n            token_program_info.key.as_ref(),\n            program_id.as_ref(),\n        ],\n        program_id,\n    );\n    let seeds = &[\n        long_token_mint_info.key.as_ref(),\n        short_token_mint_info.key.as_ref(),\n        token_program_info.key.as_ref(),\n        program_id.as_ref(),\n        &[bump_seed],\n    ];\n\n    if !binary_option.settled {\n        return Err(BinaryOptionError::BetNotSettled.into());\n    }\n    assert_owned_by(long_token_mint_info, &spl_token::id())?;\n    assert_owned_by(short_token_mint_info, &spl_token::id())?;\n    assert_keys_equal(collector_long_token_account.owner, *collector_info.key)?;\n    assert_keys_equal(collector_short_token_account.owner, *collector_info.key)?;\n    assert_keys_equal(collector_account.owner, *collector_info.key)?;\n    assert_keys_equal(escrow_owner_key, *escrow_authority_info.key)?;\n    assert_keys_equal(\n        *long_token_mint_info.key,\n        binary_option.long_mint_account_pubkey,\n    )?;\n    assert_keys_equal(\n        *short_token_mint_info.key,\n        binary_option.short_mint_account_pubkey,\n    )?;\n    assert_keys_equal(\n        *escrow_account_info.key,\n        binary_option.escrow_account_pubkey,\n    )?;\n    assert_keys_equal(\n        collector_long_token_account.mint,\n        binary_option.long_mint_account_pubkey,\n    )?;\n    assert_keys_equal(\n        collector_short_token_account.mint,\n        binary_option.short_mint_account_pubkey,\n    )?;\n    assert_keys_equal(\n        collector_account.mint,\n        binary_option.escrow_mint_account_pubkey,\n    )?;\n\n    let reward = if collector_long_token_account.mint == binary_option.winning_side_pubkey {\n        collector_long_token_account.amount\n    } else if collector_short_token_account.mint == binary_option.winning_side_pubkey {\n        collector_short_token_account.amount\n    } else {\n        return Err(BinaryOptionError::TokenNotFoundInPool.into());\n    };\n\n    spl_burn_signed(\n        token_program_info,\n        collector_long_token_account_info,\n        long_token_mint_info,\n        escrow_authority_info,\n        collector_long_token_account.amount,\n        seeds,\n    )?;\n    spl_burn_signed(\n        token_program_info,\n        collector_short_token_account_info,\n        short_token_mint_info,\n        escrow_authority_info,\n        collector_short_token_account.amount,\n        seeds,\n    )?;\n    if reward > 0 {\n        let amount = reward\n            .checked_mul(escrow_account.amount)\n            .ok_or(BinaryOptionError::AmountOverflow)?;\n        let amount = amount / binary_option.circulation;\n        spl_token_transfer_signed(\n            token_program_info,\n            escrow_account_info,\n            collector_account_info,\n            escrow_authority_info,\n            amount,\n            seeds,\n        )?;\n        binary_option.decrement_supply(reward)?;\n    }\n    borsh::to_writer(\n        &mut binary_option_account_info.data.borrow_mut()[..],\n        &binary_option,\n    )?;\n    Ok(())\n}",
    "pub fn from_account_info(a: &AccountInfo) -> Result<BinaryOption, ProgramError> {\n        let binary_option = BinaryOption::try_from_slice(&a.data.borrow_mut())?;\n        Ok(binary_option)\n    }",
    "pub fn increment_supply(&mut self, n: u64) -> ProgramResult {\n        self.circulation = self\n            .circulation\n            .checked_add(n)\n            .ok_or(BinaryOptionError::AmountOverflow)?;\n        Ok(())\n    }",
    "pub fn decrement_supply(&mut self, n: u64) -> ProgramResult {\n        if self.circulation < n {\n            return Err(BinaryOptionError::InvalidSupply.into());\n        }\n        self.circulation -= n;\n        Ok(())\n    }",
    "pub fn assert_keys_equal(key1: Pubkey, key2: Pubkey) -> ProgramResult {\n    if key1 != key2 {\n        Err(BinaryOptionError::PublicKeyMismatch.into())\n    }",
    "pub fn assert_keys_unequal(key1: Pubkey, key2: Pubkey) -> ProgramResult {\n    if key1 == key2 {\n        Err(BinaryOptionError::PublicKeysShouldBeUnique.into())\n    }",
    "pub fn assert_owned_by(account: &AccountInfo, owner: &Pubkey) -> ProgramResult {\n    if account.owner != owner {\n        Err(BinaryOptionError::IncorrectOwner.into())\n    }",
    "pub fn init_pool(\n    program_id: &Pubkey,\n    pool: &Pubkey,\n    authority: &Pubkey,\n    decider: &Pubkey,\n    deposit_token_mint: &Pubkey,\n    deposit_account: &Pubkey,\n    token_pass_mint: &Pubkey,\n    token_fail_mint: &Pubkey,\n    token_program_id: &Pubkey,\n    init_args: InitArgs,\n) -> Result<Instruction, ProgramError> {\n    let init_data = PoolInstruction::InitPool(init_args);\n    let data = borsh::to_vec(&init_data)?;\n    let accounts = vec![\n        AccountMeta::new(*pool, false),\n        AccountMeta::new_readonly(*authority, false),\n        AccountMeta::new_readonly(*decider, false),\n        AccountMeta::new_readonly(*deposit_token_mint, false),\n        AccountMeta::new(*deposit_account, false),\n        AccountMeta::new(*token_pass_mint, false),\n        AccountMeta::new(*token_fail_mint, false),\n        AccountMeta::new_readonly(sysvar::rent::id(), false),\n        AccountMeta::new_readonly(*token_program_id, false),\n    ];\n    Ok(Instruction {\n        program_id: *program_id,\n        accounts,\n        data,\n    })\n}",
    "pub fn deposit(\n    program_id: &Pubkey,\n    pool: &Pubkey,\n    authority: &Pubkey,\n    user_transfer_authority: &Pubkey,\n    user_token_account: &Pubkey,\n    pool_deposit_token_account: &Pubkey,\n    token_pass_mint: &Pubkey,\n    token_fail_mint: &Pubkey,\n    token_pass_destination_account: &Pubkey,\n    token_fail_destination_account: &Pubkey,\n    token_program_id: &Pubkey,\n    amount: u64,\n) -> Result<Instruction, ProgramError> {\n    let init_data = PoolInstruction::Deposit(amount);\n    let data = borsh::to_vec(&init_data)?;\n\n    let accounts = vec![\n        AccountMeta::new_readonly(*pool, false),\n        AccountMeta::new_readonly(*authority, false),\n        AccountMeta::new_readonly(\n            *user_transfer_authority,\n            authority != user_transfer_authority,\n        ),\n        AccountMeta::new(*user_token_account, false),\n        AccountMeta::new(*pool_deposit_token_account, false),\n        AccountMeta::new(*token_pass_mint, false),\n        AccountMeta::new(*token_fail_mint, false),\n        AccountMeta::new(*token_pass_destination_account, false),\n        AccountMeta::new(*token_fail_destination_account, false),\n        AccountMeta::new_readonly(sysvar::clock::id(), false),\n        AccountMeta::new_readonly(*token_program_id, false),\n    ];\n    Ok(Instruction {\n        program_id: *program_id,\n        accounts,\n        data,\n    })\n}",
    "pub fn withdraw(\n    program_id: &Pubkey,\n    pool: &Pubkey,\n    authority: &Pubkey,\n    user_transfer_authority: &Pubkey,\n    pool_deposit_token_account: &Pubkey,\n    token_pass_user_account: &Pubkey,\n    token_fail_user_account: &Pubkey,\n    token_pass_mint: &Pubkey,\n    token_fail_mint: &Pubkey,\n    user_token_destination_account: &Pubkey,\n    token_program_id: &Pubkey,\n    amount: u64,\n) -> Result<Instruction, ProgramError> {\n    let init_data = PoolInstruction::Withdraw(amount);\n    let data = borsh::to_vec(&init_data)?;\n    let accounts = vec![\n        AccountMeta::new_readonly(*pool, false),\n        AccountMeta::new_readonly(*authority, false),\n        AccountMeta::new_readonly(\n            *user_transfer_authority,\n            authority != user_transfer_authority,\n        ),\n        AccountMeta::new(*pool_deposit_token_account, false),\n        AccountMeta::new(*token_pass_user_account, false),\n        AccountMeta::new(*token_fail_user_account, false),\n        AccountMeta::new(*token_pass_mint, false),\n        AccountMeta::new(*token_fail_mint, false),\n        AccountMeta::new(*user_token_destination_account, false),\n        AccountMeta::new_readonly(sysvar::clock::id(), false),\n        AccountMeta::new_readonly(*token_program_id, false),\n    ];\n    Ok(Instruction {\n        program_id: *program_id,\n        accounts,\n        data,\n    })\n}",
    "pub fn decide(\n    program_id: &Pubkey,\n    pool: &Pubkey,\n    decider: &Pubkey,\n    decision: bool,\n) -> Result<Instruction, ProgramError> {\n    let init_data = PoolInstruction::Decide(decision);\n    let data = borsh::to_vec(&init_data)?;\n    let accounts = vec![\n        AccountMeta::new(*pool, false),\n        AccountMeta::new_readonly(*decider, true),\n        AccountMeta::new_readonly(sysvar::clock::id(), false),\n    ];\n    Ok(Instruction {\n        program_id: *program_id,\n        accounts,\n        data,\n    })\n}",
    "pub fn authority_id(\n        program_id: &Pubkey,\n        my_info: &Pubkey,\n        bump_seed: u8,\n    ) -> Result<Pubkey, ProgramError> {\n        Pubkey::create_program_address(&[&my_info.to_bytes()[..32], &[bump_seed]], program_id)\n            .map_err(|_| PoolError::InvalidAuthorityData.into())\n    }",
    "pub fn process_init_pool(\n        program_id: &Pubkey,\n        accounts: &[AccountInfo],\n        mint_end_slot: Slot,\n        decide_end_slot: Slot,\n        bump_seed: u8,\n    ) -> ProgramResult {\n        let account_info_iter = &mut accounts.iter();\n        let pool_account_info = next_account_info(account_info_iter)?;\n        let authority_info = next_account_info(account_info_iter)?;\n        let decider_info = next_account_info(account_info_iter)?;\n        let deposit_token_mint_info = next_account_info(account_info_iter)?;\n        let deposit_account_info = next_account_info(account_info_iter)?;\n        let token_pass_mint_info = next_account_info(account_info_iter)?;\n        let token_fail_mint_info = next_account_info(account_info_iter)?;\n        let rent_info = next_account_info(account_info_iter)?;\n        let rent = &Rent::from_account_info(rent_info)?;\n        let token_program_info = next_account_info(account_info_iter)?;\n\n        let mut pool = Pool::try_from_slice(&pool_account_info.data.borrow())?;\n        // Pool account should not be already initialized\n        if pool.is_initialized() {\n            return Err(PoolError::AlreadyInUse.into());\n        }\n\n        // Check if pool account is rent-exempt\n        if !rent.is_exempt(pool_account_info.lamports(), pool_account_info.data_len()) {\n            return Err(PoolError::NotRentExempt.into());\n        }\n\n        // Check if deposit token's mint owner is token program\n        if deposit_token_mint_info.owner != token_program_info.key {\n            return Err(PoolError::InvalidTokenMint.into());\n        }\n\n        // Check if deposit token mint is initialized\n        let deposit_token_mint = Mint::unpack(&deposit_token_mint_info.data.borrow())?;\n\n        // Check if bump seed is correct\n        let authority = Self::authority_id(program_id, pool_account_info.key, bump_seed)?;\n        if &authority != authority_info.key {\n            return Err(PoolError::InvalidAuthorityAccount.into());\n        }\n\n        let deposit_account = Account::unpack_unchecked(&deposit_account_info.data.borrow())?;\n        if deposit_account.is_initialized() {\n            return Err(PoolError::DepositAccountInUse.into());\n        }\n\n        let token_pass = Mint::unpack_unchecked(&token_pass_mint_info.data.borrow())?;\n        if token_pass.is_initialized() {\n            return Err(PoolError::TokenMintInUse.into());\n        }\n\n        let token_fail = Mint::unpack_unchecked(&token_fail_mint_info.data.borrow())?;\n        if token_fail.is_initialized() {\n            return Err(PoolError::TokenMintInUse.into());\n        }\n\n        invoke(\n            &spl_token::instruction::initialize_account(\n                token_program_info.key,\n                deposit_account_info.key,\n                deposit_token_mint_info.key,\n                authority_info.key,\n            )\n            .unwrap(),\n            &[\n                token_program_info.clone(),\n                deposit_account_info.clone(),\n                deposit_token_mint_info.clone(),\n                authority_info.clone(),\n                rent_info.clone(),\n            ],\n        )?;\n\n        invoke(\n            &spl_token::instruction::initialize_mint(\n                &spl_token::id(),\n                token_pass_mint_info.key,\n                authority_info.key,\n                None,\n                deposit_token_mint.decimals,\n            )\n            .unwrap(),\n            &[\n                token_program_info.clone(),\n                token_pass_mint_info.clone(),\n                rent_info.clone(),\n            ],\n        )?;\n\n        invoke(\n            &spl_token::instruction::initialize_mint(\n                &spl_token::id(),\n                token_fail_mint_info.key,\n                authority_info.key,\n                None,\n                deposit_token_mint.decimals,\n            )\n            .unwrap(),\n            &[\n                token_program_info.clone(),\n                token_fail_mint_info.clone(),\n                rent_info.clone(),\n            ],\n        )?;\n\n        pool.version = POOL_VERSION;\n        pool.bump_seed = bump_seed;\n        pool.token_program_id = *token_program_info.key;\n        pool.deposit_account = *deposit_account_info.key;\n        pool.token_pass_mint = *token_pass_mint_info.key;\n        pool.token_fail_mint = *token_fail_mint_info.key;\n        pool.decider = *decider_info.key;\n        pool.mint_end_slot = mint_end_slot;\n        pool.decide_end_slot = decide_end_slot;\n        pool.decision = Decision::Undecided;\n\n        borsh::to_writer(&mut pool_account_info.data.borrow_mut()[..], &pool).map_err(|e| e.into())\n    }",
    "pub fn process_deposit(\n        program_id: &Pubkey,\n        accounts: &[AccountInfo],\n        amount: u64,\n    ) -> ProgramResult {\n        let account_info_iter = &mut accounts.iter();\n        let pool_account_info = next_account_info(account_info_iter)?;\n        let authority_account_info = next_account_info(account_info_iter)?;\n        let user_transfer_authority_info = next_account_info(account_info_iter)?;\n        let user_token_account_info = next_account_info(account_info_iter)?;\n        let pool_deposit_token_account_info = next_account_info(account_info_iter)?;\n        let token_pass_mint_info = next_account_info(account_info_iter)?;\n        let token_fail_mint_info = next_account_info(account_info_iter)?;\n        let token_pass_destination_account_info = next_account_info(account_info_iter)?;\n        let token_fail_destination_account_info = next_account_info(account_info_iter)?;\n        let clock_info = next_account_info(account_info_iter)?;\n        let clock = &Clock::from_account_info(clock_info)?;\n        let token_program_id_info = next_account_info(account_info_iter)?;\n\n        if amount == 0 {\n            return Err(PoolError::InvalidAmount.into());\n        }\n\n        let pool = Pool::try_from_slice(&pool_account_info.data.borrow())?;\n\n        if clock.slot > pool.mint_end_slot {\n            return Err(PoolError::InvalidSlotForDeposit.into());\n        }\n\n        let authority_pub_key =\n            Self::authority_id(program_id, pool_account_info.key, pool.bump_seed)?;\n        if *authority_account_info.key != authority_pub_key {\n            return Err(PoolError::InvalidAuthorityAccount.into());\n        }\n\n        // Transfer deposit tokens from user's account to our deposit account\n        Self::transfer(\n            token_program_id_info.clone(),\n            user_token_account_info.clone(),\n            pool_deposit_token_account_info.clone(),\n            authority_account_info.clone(),\n            user_transfer_authority_info.clone(),\n            amount,\n            pool_account_info.key,\n            pool.bump_seed,\n        )?;\n\n        // Mint PASS tokens to user account\n        Self::mint(\n            token_program_id_info.clone(),\n            token_pass_mint_info.clone(),\n            token_pass_destination_account_info.clone(),\n            authority_account_info.clone(),\n            amount,\n            pool_account_info.key,\n            pool.bump_seed,\n        )?;\n        // Mint FAIL tokens to user account\n        Self::mint(\n            token_program_id_info.clone(),\n            token_fail_mint_info.clone(),\n            token_fail_destination_account_info.clone(),\n            authority_account_info.clone(),\n            amount,\n            pool_account_info.key,\n            pool.bump_seed,\n        )?;\n\n        Ok(())\n    }",
    "pub fn process_withdraw(\n        program_id: &Pubkey,\n        accounts: &[AccountInfo],\n        amount: u64,\n    ) -> ProgramResult {\n        let account_info_iter = &mut accounts.iter();\n        let pool_account_info = next_account_info(account_info_iter)?;\n        let authority_account_info = next_account_info(account_info_iter)?;\n        let user_transfer_authority_info = next_account_info(account_info_iter)?;\n        let pool_deposit_token_account_info = next_account_info(account_info_iter)?;\n        let token_pass_user_account_info = next_account_info(account_info_iter)?;\n        let token_fail_user_account_info = next_account_info(account_info_iter)?;\n        let token_pass_mint_info = next_account_info(account_info_iter)?;\n        let token_fail_mint_info = next_account_info(account_info_iter)?;\n        let user_token_destination_account_info = next_account_info(account_info_iter)?;\n        let clock_info = next_account_info(account_info_iter)?;\n        let clock = &Clock::from_account_info(clock_info)?;\n        let token_program_id_info = next_account_info(account_info_iter)?;\n\n        if amount == 0 {\n            return Err(PoolError::InvalidAmount.into());\n        }\n\n        let user_pass_token_account = Account::unpack(&token_pass_user_account_info.data.borrow())?;\n        let user_fail_token_account = Account::unpack(&token_fail_user_account_info.data.borrow())?;\n\n        let pool = Pool::try_from_slice(&pool_account_info.data.borrow())?;\n\n        if pool.token_pass_mint != *token_pass_mint_info.key {\n            return Err(PoolError::InvalidTokenMint.into());\n        }\n        if pool.token_fail_mint != *token_fail_mint_info.key {\n            return Err(PoolError::InvalidTokenMint.into());\n        }\n        let authority_pub_key =\n            Self::authority_id(program_id, pool_account_info.key, pool.bump_seed)?;\n        if *authority_account_info.key != authority_pub_key {\n            return Err(PoolError::InvalidAuthorityAccount.into());\n        }\n\n        match pool.decision {\n            Decision::Pass => {\n                // Burn PASS tokens\n                Self::burn(\n                    token_program_id_info.clone(),\n                    token_pass_user_account_info.clone(),\n                    token_pass_mint_info.clone(),\n                    authority_account_info.clone(),\n                    user_transfer_authority_info.clone(),\n                    amount,\n                    pool_account_info.key,\n                    pool.bump_seed,\n                )?;\n\n                // Transfer deposit tokens from pool deposit account to user destination account\n                Self::transfer(\n                    token_program_id_info.clone(),\n                    pool_deposit_token_account_info.clone(),\n                    user_token_destination_account_info.clone(),\n                    authority_account_info.clone(),\n                    authority_account_info.clone(),\n                    amount,\n                    pool_account_info.key,\n                    pool.bump_seed,\n                )?;\n            }\n            Decision::Fail => {\n                // Burn FAIL tokens\n                Self::burn(\n                    token_program_id_info.clone(),\n                    token_fail_user_account_info.clone(),\n                    token_fail_mint_info.clone(),\n                    authority_account_info.clone(),\n                    user_transfer_authority_info.clone(),\n                    amount,\n                    pool_account_info.key,\n                    pool.bump_seed,\n                )?;\n\n                // Transfer deposit tokens from pool deposit account to user destination account\n                Self::transfer(\n                    token_program_id_info.clone(),\n                    pool_deposit_token_account_info.clone(),\n                    user_token_destination_account_info.clone(),\n                    authority_account_info.clone(),\n                    authority_account_info.clone(),\n                    amount,\n                    pool_account_info.key,\n                    pool.bump_seed,\n                )?;\n            }\n            Decision::Undecided => {\n                let current_slot = clock.slot;\n                if current_slot < pool.mint_end_slot || current_slot > pool.decide_end_slot {\n                    let possible_withdraw_amount = amount\n                        .min(user_pass_token_account.amount)\n                        .min(user_fail_token_account.amount);\n\n                    // Burn PASS tokens\n                    Self::burn(\n                        token_program_id_info.clone(),\n                        token_pass_user_account_info.clone(),\n                        token_pass_mint_info.clone(),\n                        authority_account_info.clone(),\n                        user_transfer_authority_info.clone(),\n                        possible_withdraw_amount,\n                        pool_account_info.key,\n                        pool.bump_seed,\n                    )?;\n\n                    // Burn FAIL tokens\n                    Self::burn(\n                        token_program_id_info.clone(),\n                        token_fail_user_account_info.clone(),\n                        token_fail_mint_info.clone(),\n                        authority_account_info.clone(),\n                        user_transfer_authority_info.clone(),\n                        amount,\n                        pool_account_info.key,\n                        pool.bump_seed,\n                    )?;\n\n                    // Transfer deposit tokens from pool deposit account to user destination account\n                    Self::transfer(\n                        token_program_id_info.clone(),\n                        pool_deposit_token_account_info.clone(),\n                        user_token_destination_account_info.clone(),\n                        authority_account_info.clone(),\n                        authority_account_info.clone(),\n                        amount,\n                        pool_account_info.key,\n                        pool.bump_seed,\n                    )?;\n                } else {\n                    return Err(PoolError::NoDecisionMadeYet.into());\n                }\n            }\n        }\n\n        Ok(())\n    }",
    "pub fn process_decide(\n        _program_id: &Pubkey,\n        accounts: &[AccountInfo],\n        decision: bool,\n    ) -> ProgramResult {\n        let account_info_iter = &mut accounts.iter();\n        let pool_account_info = next_account_info(account_info_iter)?;\n        let decider_account_info = next_account_info(account_info_iter)?;\n        let clock_info = next_account_info(account_info_iter)?;\n        let clock = &Clock::from_account_info(clock_info)?;\n\n        let mut pool = Pool::try_from_slice(&pool_account_info.data.borrow())?;\n\n        if *decider_account_info.key != pool.decider {\n            return Err(PoolError::WrongDeciderAccount.into());\n        }\n\n        if !decider_account_info.is_signer {\n            return Err(PoolError::SignatureMissing.into());\n        }\n\n        if pool.decision != Decision::Undecided {\n            return Err(PoolError::DecisionAlreadyMade.into());\n        }\n\n        let current_slot = clock.slot;\n        if current_slot < pool.mint_end_slot || current_slot > pool.decide_end_slot {\n            return Err(PoolError::InvalidSlotForDecision.into());\n        }\n\n        pool.decision = if decision {\n            Decision::Pass\n        } else {\n            Decision::Fail\n        };\n\n        borsh::to_writer(&mut pool_account_info.data.borrow_mut()[..], &pool).map_err(|e| e.into())\n    }",
    "pub fn process_instruction(\n        program_id: &Pubkey,\n        accounts: &[AccountInfo],\n        input: &[u8],\n    ) -> ProgramResult {\n        let instruction = PoolInstruction::try_from_slice(input)?;\n        match instruction {\n            PoolInstruction::InitPool(init_args) => {\n                msg!(\"Instruction: InitPool\");\n                Self::process_init_pool(\n                    program_id,\n                    accounts,\n                    init_args.mint_end_slot,\n                    init_args.decide_end_slot,\n                    init_args.bump_seed,\n                )\n            }",
    "pub fn program_test() -> ProgramTest {\n    ProgramTest::new(\n        \"spl_binary_oracle_pair\",\n        id(),\n        processor!(processor::Processor::process_instruction),\n    )\n}",
    "pub fn new() -> Self {\n        let pool_account = Keypair::new();\n        let (authority, bump_seed) =\n            Pubkey::find_program_address(&[&pool_account.pubkey().to_bytes()[..32]], &id());\n        Self {\n            pool_account,\n            authority,\n            bump_seed,\n            deposit_token_mint: Keypair::new(),\n            deposit_token_mint_owner: Keypair::new(),\n            pool_deposit_account: Keypair::new(),\n            token_pass_mint: Keypair::new(),\n            token_fail_mint: Keypair::new(),\n            decider: Keypair::new(),\n            mint_end_slot: 2,\n            decide_end_slot: 2000,\n        }\n    }\n\n    pub async fn init_pool(\n        &self,\n        banks_client: &mut BanksClient,\n        payer: &Keypair,\n        recent_blockhash: &Hash,\n    ) {\n        let rent = banks_client.get_rent().await.unwrap();\n        let pool_rent = rent.minimum_balance(state::Pool::LEN);\n        let mint_rent = rent.minimum_balance(spl_token::state::Mint::LEN);\n        let account_rent = rent.minimum_balance(spl_token::state::Account::LEN);\n\n        // create pool account\n        create_account(\n            banks_client,\n            payer,\n            recent_blockhash,\n            &self.pool_account,\n            pool_rent,\n            state::Pool::LEN as u64,\n            &id(),\n        )\n        .await\n        .unwrap();\n\n        // create mint of deposit token\n        create_mint(\n            banks_client,\n            payer,\n            recent_blockhash,\n            &self.deposit_token_mint,\n            mint_rent,\n            &self.deposit_token_mint_owner.pubkey(),\n        )\n        .await\n        .unwrap();\n\n        let init_args = instruction::InitArgs {\n            mint_end_slot: self.mint_end_slot,\n            decide_end_slot: self.decide_end_slot,\n            bump_seed: self.bump_seed,\n        };\n\n        let mut transaction = Transaction::new_with_payer(\n            &[\n                system_instruction::create_account(\n                    &payer.pubkey(),\n                    &self.pool_deposit_account.pubkey(),\n                    account_rent,\n                    spl_token::state::Account::LEN as u64,\n                    &spl_token::id(),\n                ),\n                system_instruction::create_account(\n                    &payer.pubkey(),\n                    &self.token_pass_mint.pubkey(),\n                    mint_rent,\n                    spl_token::state::Mint::LEN as u64,\n                    &spl_token::id(),\n                ),\n                system_instruction::create_account(\n                    &payer.pubkey(),\n                    &self.token_fail_mint.pubkey(),\n                    mint_rent,\n                    spl_token::state::Mint::LEN as u64,\n                    &spl_token::id(),\n                ),\n                instruction::init_pool(\n                    &id(),\n                    &self.pool_account.pubkey(),\n                    &self.authority,\n                    &self.decider.pubkey(),\n                    &self.deposit_token_mint.pubkey(),\n                    &self.pool_deposit_account.pubkey(),\n                    &self.token_pass_mint.pubkey(),\n                    &self.token_fail_mint.pubkey(),\n                    &spl_token::id(),\n                    init_args,\n                )\n                .unwrap(),\n            ],\n            Some(&payer.pubkey()),\n        );\n\n        transaction.sign(\n            &[\n                payer,\n                &self.pool_deposit_account,\n                &self.token_pass_mint,\n                &self.token_fail_mint,\n            ],\n            *recent_blockhash,\n        );\n        banks_client.process_transaction(transaction).await.unwrap();\n    }\n\n    #[allow(clippy::too_many_arguments)]\n    pub async fn prepare_accounts_for_deposit(\n        &self,\n        banks_client: &mut BanksClient,\n        payer: &Keypair,\n        recent_blockhash: &Hash,\n        deposit_tokens_to_mint: u64,\n        deposit_tokens_for_allowance: u64,\n        user_account: &Keypair,\n        authority: &Pubkey,\n        user_account_owner: &Keypair,\n        user_pass_account: &Keypair,\n        user_fail_account: &Keypair,\n    ) {\n        // Create user account\n        create_token_account(\n            banks_client,\n            payer,\n            recent_blockhash,\n            user_account,\n            &self.deposit_token_mint.pubkey(),\n            &user_account_owner.pubkey(),\n        )\n        .await\n        .unwrap();\n\n        // Mint to him some deposit tokens\n        mint_tokens_to(\n            banks_client,\n            payer,\n            recent_blockhash,\n            &self.deposit_token_mint.pubkey(),\n            &user_account.pubkey(),\n            &self.deposit_token_mint_owner,\n            deposit_tokens_to_mint,\n        )\n        .await\n        .unwrap();\n\n        // Give allowance to pool authority\n        approve_delegate(\n            banks_client,\n            payer,\n            recent_blockhash,\n            &user_account.pubkey(),\n            authority,\n            user_account_owner,\n            deposit_tokens_for_allowance,\n        )\n        .await\n        .unwrap();\n\n        // Create token accounts for PASS and FAIL tokens\n        create_token_account(\n            banks_client,\n            payer,\n            recent_blockhash,\n            user_pass_account,\n            &self.token_pass_mint.pubkey(),\n            &user_account_owner.pubkey(),\n        )\n        .await\n        .unwrap();\n\n        create_token_account(\n            banks_client,\n            payer,\n            recent_blockhash,\n            user_fail_account,\n            &self.token_fail_mint.pubkey(),\n            &user_account_owner.pubkey(),\n        )\n        .await\n        .unwrap();\n    }\n\n    #[allow(clippy::too_many_arguments)]\n    pub async fn make_deposit(\n        &self,\n        banks_client: &mut BanksClient,\n        payer: &Keypair,\n        recent_blockhash: &Hash,\n        user_account: &Keypair,\n        user_pass_account: &Keypair,\n        user_fail_account: &Keypair,\n        deposit_amount: u64,\n    ) {\n        let mut transaction = Transaction::new_with_payer(\n            &[instruction::deposit(\n                &id(),\n                &self.pool_account.pubkey(),\n                &self.authority,\n                &self.authority,\n                &user_account.pubkey(),\n                &self.pool_deposit_account.pubkey(),\n                &self.token_pass_mint.pubkey(),\n                &self.token_fail_mint.pubkey(),\n                &user_pass_account.pubkey(),\n                &user_fail_account.pubkey(),\n                &spl_token::id(),\n                deposit_amount,\n            )\n            .unwrap()],\n            Some(&payer.pubkey()),\n        );\n        transaction.sign(&[payer], *recent_blockhash);\n        banks_client.process_transaction(transaction).await.unwrap();\n    }\n\n    #[allow(clippy::too_many_arguments)]\n    pub async fn make_deposit_with_user_transfer_authority(\n        &self,\n        banks_client: &mut BanksClient,\n        payer: &Keypair,\n        recent_blockhash: &Hash,\n        user_account: &Keypair,\n        user_authority: &Keypair,\n        user_pass_account: &Keypair,\n        user_fail_account: &Keypair,\n        deposit_amount: u64,\n    ) {\n        let mut transaction = Transaction::new_with_payer(\n            &[instruction::deposit(\n                &id(),\n                &self.pool_account.pubkey(),\n                &self.authority,\n                &user_authority.pubkey(),\n                &user_account.pubkey(),\n                &self.pool_deposit_account.pubkey(),\n                &self.token_pass_mint.pubkey(),\n                &self.token_fail_mint.pubkey(),\n                &user_pass_account.pubkey(),\n                &user_fail_account.pubkey(),\n                &spl_token::id(),\n                deposit_amount,\n            )\n            .unwrap()],\n            Some(&payer.pubkey()),\n        );\n        transaction.sign(&[payer, user_authority], *recent_blockhash);\n        banks_client.process_transaction(transaction).await.unwrap();\n    }\n}\nimpl Default for TestPool {\n    fn default() -> Self {\n        Self::new()\n    }",
    "pub fn process_instruction(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    instruction_data: &[u8],\n) -> ProgramResult {\n    // Create in iterator to safety reference accounts in the slice\n    let account_info_iter = &mut accounts.iter();\n\n    // Account info for the program being invoked\n    let system_program_info = next_account_info(account_info_iter)?;\n    // Account info to allocate\n    let allocated_info = next_account_info(account_info_iter)?;\n\n    let expected_allocated_key =\n        Pubkey::create_program_address(&[b\"You pass butter\", &[instruction_data[0]]], program_id)?;\n    if *allocated_info.key != expected_allocated_key {\n        // allocated key does not match the derived address\n        return Err(ProgramError::InvalidArgument);\n    }\n\n    // Invoke the system program to allocate account data\n    invoke_signed(\n        &system_instruction::allocate(allocated_info.key, SIZE as u64),\n        // Order doesn't matter and this slice could include all the accounts and be:\n        // `&accounts`\n        &[\n            system_program_info.clone(), // program being invoked also needs to be included\n            allocated_info.clone(),\n        ],\n        &[&[b\"You pass butter\", &[instruction_data[0]]]],\n    )?;\n\n    Ok(())\n}",
    "pub fn process_instruction(\n    _program_id: &Pubkey,\n    _accounts: &[AccountInfo],\n    _instruction_data: &[u8],\n) -> ProgramResult {\n    let vec = vec![42_u8; 5];\n    sol_log_slice(&vec);\n    Ok(())\n}",
    "pub fn process_instruction(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    instruction_data: &[u8],\n) -> ProgramResult {\n    // Log a string\n    msg!(\"static string\");\n\n    // Log a slice\n    sol_log_slice(instruction_data);\n\n    // Log a formatted message, use with caution can be expensive\n    msg!(\"formatted {}: {:?}\", \"message\", instruction_data);\n\n    // Log a public key\n    program_id.log();\n\n    // Log all the program's input parameters\n    sol_log_params(accounts, instruction_data);\n\n    // Log the number of compute units remaining that the program can consume.\n    sol_log_compute_units();\n\n    Ok(())\n}",
    "pub fn process_instruction(\n    _program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    _instruction_data: &[u8],\n) -> ProgramResult {\n    // Create in iterator to safety reference accounts in the slice\n    let account_info_iter = &mut accounts.iter();\n\n    // Get the clock sysvar via syscall\n    let clock_via_sysvar = Clock::get()?;\n    // Or deserialize the account into a clock struct\n    let clock_sysvar_info = next_account_info(account_info_iter)?;\n    let clock_via_account = Clock::from_account_info(clock_sysvar_info)?;\n    // Both produce the same sysvar\n    assert_eq!(clock_via_sysvar, clock_via_account);\n    // Note: `format!` can be very expensive, use cautiously\n    msg!(\"{:?}\", clock_via_sysvar);\n\n    // Get the rent sysvar via syscall\n    let rent_via_sysvar = Rent::get()?;\n    // Or deserialize the account into a rent struct\n    let rent_sysvar_info = next_account_info(account_info_iter)?;\n    let rent_via_account = Rent::from_account_info(rent_sysvar_info)?;\n    // Both produce the same sysvar\n    assert_eq!(rent_via_sysvar, rent_via_account);\n    // Can't print `exemption_threshold` because BPF does not support printing\n    // floats\n    msg!(\n        \"Rent: lamports_per_byte_year: {:?}, burn_percent: {:?}\",\n        rent_via_sysvar.lamports_per_byte_year,\n        rent_via_sysvar.burn_percent\n    );\n\n    Ok(())\n}",
    "pub fn process_instruction(\n    _program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    _instruction_data: &[u8],\n) -> ProgramResult {\n    // Create an iterator to safely reference accounts in the slice\n    let account_info_iter = &mut accounts.iter();\n\n    // As part of the program specification the first account is the source\n    // account and the second is the destination account\n    let source_info = next_account_info(account_info_iter)?;\n    let destination_info = next_account_info(account_info_iter)?;\n\n    // Withdraw five lamports from the source\n    **source_info.try_borrow_mut_lamports()? -= 5;\n    // Deposit five lamports into the destination\n    **destination_info.try_borrow_mut_lamports()? += 5;\n\n    Ok(())\n}",
    "pub fn process_instruction(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    _instruction_data: &[u8],\n) -> ProgramResult {\n    // Create an iterator to safely reference accounts in the slice\n    let account_info_iter = &mut accounts.iter();\n\n    // As part of the program specification the instruction gives:\n    let source_info = next_account_info(account_info_iter)?; // 1.\n    let mint_info = next_account_info(account_info_iter)?; // 2.\n    let destination_info = next_account_info(account_info_iter)?; // 3.\n    let authority_info = next_account_info(account_info_iter)?; // 4.\n    let token_program_info = next_account_info(account_info_iter)?; // 5.\n\n    // In order to transfer from the source account, owned by the program-derived\n    // address, we must have the correct address and seeds.\n    let (expected_authority, bump_seed) = Pubkey::find_program_address(&[b\"authority\"], program_id);\n    if expected_authority != *authority_info.key {\n        return Err(ProgramError::InvalidSeeds);\n    }\n\n    // The program transfers everything out of its account, so extract that from\n    // the account data.\n    let source_account = Account::unpack(&source_info.try_borrow_data()?)?;\n    let amount = source_account.amount;\n\n    // The program uses `transfer_checked`, which requires the number of decimals\n    // in the mint, so extract that from the account data too.\n    let mint = Mint::unpack(&mint_info.try_borrow_data()?)?;\n    let decimals = mint.decimals;\n\n    // Invoke the transfer\n    msg!(\"Attempting to transfer {} tokens\", amount);\n    invoke_signed(\n        &transfer_checked(\n            token_program_info.key,\n            source_info.key,\n            mint_info.key,\n            destination_info.key,\n            authority_info.key,\n            &[], // no multisig allowed\n            amount,\n            decimals,\n        )\n        .unwrap(),\n        &[\n            source_info.clone(),\n            mint_info.clone(),\n            destination_info.clone(),\n            authority_info.clone(),\n            token_program_info.clone(), // not required, but better for clarity\n        ],\n        &[&[b\"authority\", &[bump_seed]]],\n    )\n}",
    "pub fn process_instruction(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    input: &[u8],\n) -> ProgramResult {\n    let instruction = VoterWeightAddinInstruction::try_from_slice(input)\n        .map_err(|_| ProgramError::InvalidInstructionData)?;\n\n    msg!(\"GOVERNANCE-VOTER-WEIGHT-INSTRUCTION: {:?}\", instruction);\n\n    match instruction {\n        VoterWeightAddinInstruction::SetupVoterWeightRecord {\n            voter_weight,\n            voter_weight_expiry,\n            weight_action,\n            weight_action_target,\n        } => process_setup_voter_weight_record(\n            program_id,\n            accounts,\n            voter_weight,\n            voter_weight_expiry,\n            weight_action,\n            weight_action_target,\n        ),\n        VoterWeightAddinInstruction::SetupMaxVoterWeightRecord {\n            max_voter_weight,\n            max_voter_weight_expiry,\n        } => process_setup_max_voter_weight_record(\n            program_id,\n            accounts,\n            max_voter_weight,\n            max_voter_weight_expiry,\n        ),\n    }\n}\n\n/// Processes SetupVoterWeightRecord instruction\npub fn process_setup_voter_weight_record(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    voter_weight: u64,\n    voter_weight_expiry: Option<Slot>,\n    weight_action: Option<VoterWeightAction>,\n    weight_action_target: Option<Pubkey>,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n\n    let realm_info = next_account_info(account_info_iter)?; // 0\n    let governing_token_mint_info = next_account_info(account_info_iter)?; // 1\n    let governing_token_owner_info = next_account_info(account_info_iter)?; // 2\n    let voter_weight_record_info = next_account_info(account_info_iter)?; // 3\n    let payer_info = next_account_info(account_info_iter)?; // 4\n    let system_info = next_account_info(account_info_iter)?; // 5\n\n    let voter_weight_record_data = VoterWeightRecord {\n        account_discriminator: VoterWeightRecord::ACCOUNT_DISCRIMINATOR,\n        realm: *realm_info.key,\n        governing_token_mint: *governing_token_mint_info.key,\n        governing_token_owner: *governing_token_owner_info.key,\n        voter_weight,\n        voter_weight_expiry,\n        weight_action,\n        weight_action_target,\n        reserved: [0; 8],\n    };\n\n    create_and_serialize_account(\n        payer_info,\n        voter_weight_record_info,\n        &voter_weight_record_data,\n        program_id,\n        system_info,\n    )?;\n\n    Ok(())\n}",
    "pub fn process_setup_max_voter_weight_record(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    max_voter_weight: u64,\n    max_voter_weight_expiry: Option<Slot>,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n\n    let realm_info = next_account_info(account_info_iter)?; // 0\n    let governing_token_mint_info = next_account_info(account_info_iter)?; // 1\n    let max_voter_weight_record_info = next_account_info(account_info_iter)?; // 2\n    let payer_info = next_account_info(account_info_iter)?; // 3\n    let system_info = next_account_info(account_info_iter)?; // 4\n\n    let max_voter_weight_record_data = MaxVoterWeightRecord {\n        account_discriminator: MaxVoterWeightRecord::ACCOUNT_DISCRIMINATOR,\n        realm: *realm_info.key,\n        governing_token_mint: *governing_token_mint_info.key,\n        max_voter_weight,\n        max_voter_weight_expiry,\n        reserved: [0; 8],\n    };\n\n    create_and_serialize_account(\n        payer_info,\n        max_voter_weight_record_info,\n        &max_voter_weight_record_data,\n        program_id,\n        system_info,\n    )?;\n\n    Ok(())\n}",
    "pub fn process_instruction(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    input: &[u8],\n) -> ProgramResult {\n    msg!(\"VERSION:{:?}\", env!(\"CARGO_PKG_VERSION\"));\n\n    let instruction = GovernanceChatInstruction::try_from_slice(input)\n        .map_err(|_| ProgramError::InvalidInstructionData)?;\n\n    match instruction {\n        GovernanceChatInstruction::PostMessage { body, is_reply } => {\n            msg!(\"GOVERNANCE-CHAT-INSTRUCTION: PostMessage\");\n            process_post_message(program_id, accounts, body, is_reply)\n        }",
    "pub fn process_post_message(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    body: MessageBody,\n    is_reply: bool,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n\n    let governance_program_info = next_account_info(account_info_iter)?; // 0\n    let realm_info = next_account_info(account_info_iter)?; // 1\n    let governance_info = next_account_info(account_info_iter)?; // 2\n    let proposal_info = next_account_info(account_info_iter)?; // 3\n    let token_owner_record_info = next_account_info(account_info_iter)?; // 4\n    let governance_authority_info = next_account_info(account_info_iter)?; // 5\n\n    let chat_message_info = next_account_info(account_info_iter)?; // 6\n\n    let payer_info = next_account_info(account_info_iter)?; // 7\n    let system_info = next_account_info(account_info_iter)?; // 8\n\n    let reply_to_address = if is_reply {\n        let reply_to_info = next_account_info(account_info_iter)?; // 9\n        assert_is_valid_chat_message(program_id, reply_to_info)?;\n        Some(*reply_to_info.key)\n    }",
    "pub fn assert_is_valid_chat_message(\n    program_id: &Pubkey,\n    chat_message_info: &AccountInfo,\n) -> Result<(), ProgramError> {\n    assert_is_valid_account_of_type(\n        program_id,\n        chat_message_info,\n        GovernanceChatAccountType::ChatMessage,\n    )\n}",
    "pub fn create_realm(\n    program_id: &Pubkey,\n    // Accounts\n    realm_authority: &Pubkey,\n    community_token_mint: &Pubkey,\n    payer: &Pubkey,\n    council_token_mint: Option<Pubkey>,\n    // Accounts Args\n    community_token_config_args: Option<GoverningTokenConfigAccountArgs>,\n    council_token_config_args: Option<GoverningTokenConfigAccountArgs>,\n    // Args\n    name: String,\n    min_community_weight_to_create_governance: u64,\n    community_mint_max_voter_weight_source: MintMaxVoterWeightSource,\n) -> Instruction {\n    let realm_address = get_realm_address(program_id, &name);\n    let community_token_holding_address =\n        get_governing_token_holding_address(program_id, &realm_address, community_token_mint);\n\n    let mut accounts = vec![\n        AccountMeta::new(realm_address, false),\n        AccountMeta::new_readonly(*realm_authority, false),\n        AccountMeta::new_readonly(*community_token_mint, false),\n        AccountMeta::new(community_token_holding_address, false),\n        AccountMeta::new(*payer, true),\n        AccountMeta::new_readonly(system_program::id(), false),\n        AccountMeta::new_readonly(spl_token::id(), false),\n        AccountMeta::new_readonly(sysvar::rent::id(), false),\n    ];\n\n    let use_council_mint = if let Some(council_token_mint) = council_token_mint {\n        let council_token_holding_address =\n            get_governing_token_holding_address(program_id, &realm_address, &council_token_mint);\n\n        accounts.push(AccountMeta::new_readonly(council_token_mint, false));\n        accounts.push(AccountMeta::new(council_token_holding_address, false));\n        true\n    } else {\n        false\n    };\n\n    let realm_config_address = get_realm_config_address(program_id, &realm_address);\n    accounts.push(AccountMeta::new(realm_config_address, false));\n\n    let community_token_config_args =\n        with_governing_token_config_args(&mut accounts, community_token_config_args);\n\n    let council_token_config_args =\n        with_governing_token_config_args(&mut accounts, council_token_config_args);\n\n    let instruction = GovernanceInstruction::CreateRealm {\n        config_args: RealmConfigArgs {\n            use_council_mint,\n            min_community_weight_to_create_governance,\n            community_mint_max_voter_weight_source,\n            community_token_config_args,\n            council_token_config_args,\n        },\n        name,\n    };\n\n    Instruction {\n        program_id: *program_id,\n        accounts,\n        data: borsh::to_vec(&instruction).unwrap(),\n    }\n}\n\n/// Creates DepositGoverningTokens instruction\n#[allow(clippy::too_many_arguments)]\npub fn deposit_governing_tokens(\n    program_id: &Pubkey,\n    // Accounts\n    realm: &Pubkey,\n    governing_token_source: &Pubkey,\n    governing_token_owner: &Pubkey,\n    governing_token_source_authority: &Pubkey,\n    payer: &Pubkey,\n    // Args\n    amount: u64,\n    governing_token_mint: &Pubkey,\n) -> Instruction {\n    let token_owner_record_address = get_token_owner_record_address(\n        program_id,\n        realm,\n        governing_token_mint,\n        governing_token_owner,\n    );\n\n    let governing_token_holding_address =\n        get_governing_token_holding_address(program_id, realm, governing_token_mint);\n\n    let realm_config_address = get_realm_config_address(program_id, realm);\n\n    let accounts = vec![\n        AccountMeta::new_readonly(*realm, false),\n        AccountMeta::new(governing_token_holding_address, false),\n        AccountMeta::new(*governing_token_source, false),\n        AccountMeta::new_readonly(*governing_token_owner, true),\n        AccountMeta::new_readonly(*governing_token_source_authority, true),\n        AccountMeta::new(token_owner_record_address, false),\n        AccountMeta::new(*payer, true),\n        AccountMeta::new_readonly(system_program::id(), false),\n        AccountMeta::new_readonly(spl_token::id(), false),\n        AccountMeta::new_readonly(realm_config_address, false),\n    ];\n\n    let instruction = GovernanceInstruction::DepositGoverningTokens { amount };\n\n    Instruction {\n        program_id: *program_id,\n        accounts,\n        data: borsh::to_vec(&instruction).unwrap(),\n    }\n}\n\n/// Creates WithdrawGoverningTokens instruction\npub fn withdraw_governing_tokens(\n    program_id: &Pubkey,\n    // Accounts\n    realm: &Pubkey,\n    governing_token_destination: &Pubkey,\n    governing_token_owner: &Pubkey,\n    // Args\n    governing_token_mint: &Pubkey,\n) -> Instruction {\n    let token_owner_record_address = get_token_owner_record_address(\n        program_id,\n        realm,\n        governing_token_mint,\n        governing_token_owner,\n    );\n\n    let governing_token_holding_address =\n        get_governing_token_holding_address(program_id, realm, governing_token_mint);\n\n    let realm_config_address = get_realm_config_address(program_id, realm);\n\n    let accounts = vec![\n        AccountMeta::new_readonly(*realm, false),\n        AccountMeta::new(governing_token_holding_address, false),\n        AccountMeta::new(*governing_token_destination, false),\n        AccountMeta::new_readonly(*governing_token_owner, true),\n        AccountMeta::new(token_owner_record_address, false),\n        AccountMeta::new_readonly(spl_token::id(), false),\n        AccountMeta::new_readonly(realm_config_address, false),\n    ];\n\n    let instruction = GovernanceInstruction::WithdrawGoverningTokens {};\n\n    Instruction {\n        program_id: *program_id,\n        accounts,\n        data: borsh::to_vec(&instruction).unwrap(),\n    }\n}\n\n/// Creates SetGovernanceDelegate instruction\npub fn set_governance_delegate(\n    program_id: &Pubkey,\n    // Accounts\n    governance_authority: &Pubkey,\n    // Args\n    realm: &Pubkey,\n    governing_token_mint: &Pubkey,\n    governing_token_owner: &Pubkey,\n    new_governance_delegate: &Option<Pubkey>,\n) -> Instruction {\n    let vote_record_address = get_token_owner_record_address(\n        program_id,\n        realm,\n        governing_token_mint,\n        governing_token_owner,\n    );\n\n    let accounts = vec![\n        AccountMeta::new_readonly(*governance_authority, true),\n        AccountMeta::new(vote_record_address, false),\n    ];\n\n    let instruction = GovernanceInstruction::SetGovernanceDelegate {\n        new_governance_delegate: *new_governance_delegate,\n    };\n\n    Instruction {\n        program_id: *program_id,\n        accounts,\n        data: borsh::to_vec(&instruction).unwrap(),\n    }\n}\n\n/// Creates CreateGovernance instruction using optional voter weight addin\n#[allow(clippy::too_many_arguments)]\npub fn create_governance(\n    program_id: &Pubkey,\n    // Accounts\n    realm: &Pubkey,\n    governance_seed: &Pubkey,\n    token_owner_record: &Pubkey,\n    payer: &Pubkey,\n    create_authority: &Pubkey,\n    voter_weight_record: Option<Pubkey>,\n    // Args\n    config: GovernanceConfig,\n) -> Instruction {\n    let governance_address = get_governance_address(program_id, realm, governance_seed);\n\n    let mut accounts = vec![\n        AccountMeta::new_readonly(*realm, false),\n        AccountMeta::new(governance_address, false),\n        AccountMeta::new_readonly(*governance_seed, false),\n        AccountMeta::new_readonly(*token_owner_record, false),\n        AccountMeta::new(*payer, true),\n        AccountMeta::new_readonly(system_program::id(), false),\n        AccountMeta::new_readonly(*create_authority, true),\n    ];\n\n    with_realm_config_accounts(program_id, &mut accounts, realm, voter_weight_record, None);\n\n    let instruction = GovernanceInstruction::CreateGovernance { config };\n\n    Instruction {\n        program_id: *program_id,\n        accounts,\n        data: borsh::to_vec(&instruction).unwrap(),\n    }\n}\n\n/// Creates CreateProposal instruction\n#[allow(clippy::too_many_arguments)]\npub fn create_proposal(\n    program_id: &Pubkey,\n    // Accounts\n    governance: &Pubkey,\n    proposal_owner_record: &Pubkey,\n    governance_authority: &Pubkey,\n    payer: &Pubkey,\n    voter_weight_record: Option<Pubkey>,\n    // Args\n    realm: &Pubkey,\n    name: String,\n    description_link: String,\n    governing_token_mint: &Pubkey,\n    vote_type: VoteType,\n    options: Vec<String>,\n    use_deny_option: bool,\n    proposal_seed: &Pubkey,\n) -> Instruction {\n    let proposal_address =\n        get_proposal_address(program_id, governance, governing_token_mint, proposal_seed);\n\n    let mut accounts = vec![\n        AccountMeta::new_readonly(*realm, false),\n        AccountMeta::new(proposal_address, false),\n        AccountMeta::new(*governance, false),\n        AccountMeta::new(*proposal_owner_record, false),\n        AccountMeta::new_readonly(*governing_token_mint, false),\n        AccountMeta::new_readonly(*governance_authority, true),\n        AccountMeta::new(*payer, true),\n        AccountMeta::new_readonly(system_program::id(), false),\n    ];\n\n    with_realm_config_accounts(program_id, &mut accounts, realm, voter_weight_record, None);\n\n    // Deposit is only required when there are more active proposal then the\n    // configured exempt amount Note: We always pass the account because the\n    // actual value is not known here without passing Governance account data\n    let proposal_deposit_address =\n        get_proposal_deposit_address(program_id, &proposal_address, payer);\n    accounts.push(AccountMeta::new(proposal_deposit_address, false));\n\n    let instruction = GovernanceInstruction::CreateProposal {\n        name,\n        description_link,\n        vote_type,\n        options,\n        use_deny_option,\n        proposal_seed: *proposal_seed,\n    };\n\n    Instruction {\n        program_id: *program_id,\n        accounts,\n        data: borsh::to_vec(&instruction).unwrap(),\n    }\n}\n\n/// Creates AddSignatory instruction\npub fn add_signatory(\n    program_id: &Pubkey,\n    // Accounts\n    governance: &Pubkey,\n    proposal: &Pubkey,\n    add_signatory_authority: &AddSignatoryAuthority,\n    payer: &Pubkey,\n    // Args\n    signatory: &Pubkey,\n) -> Instruction {\n    let signatory_record_address = get_signatory_record_address(program_id, proposal, signatory);\n\n    let mut accounts = vec![\n        AccountMeta::new_readonly(*governance, false),\n        AccountMeta::new(*proposal, false),\n        AccountMeta::new(signatory_record_address, false),\n        AccountMeta::new(*payer, true),\n        AccountMeta::new_readonly(system_program::id(), false),\n    ];\n\n    match add_signatory_authority {\n        AddSignatoryAuthority::ProposalOwner {\n            governance_authority,\n            token_owner_record,\n        } => {\n            accounts.push(AccountMeta::new_readonly(*token_owner_record, false));\n            accounts.push(AccountMeta::new_readonly(*governance_authority, true));\n        }\n        AddSignatoryAuthority::None => {\n            accounts.push(AccountMeta::new_readonly(\n                get_required_signatory_address(program_id, governance, signatory),\n                false,\n            ));\n        }\n    };\n\n    let instruction = GovernanceInstruction::AddSignatory {\n        signatory: *signatory,\n    };\n\n    Instruction {\n        program_id: *program_id,\n        accounts,\n        data: borsh::to_vec(&instruction).unwrap(),\n    }\n}\n\n#[derive(Debug, Copy, Clone)]\n/// Enum to specify the authority by which the instruction should add a\n/// signatory\npub enum AddSignatoryAuthority {\n    /// Proposal owners can add optional signatories to a proposal\n    ProposalOwner {\n        /// Token owner or its delegate\n        governance_authority: Pubkey,\n        /// Token owner record of the Proposal owner\n        token_owner_record: Pubkey,\n    },\n    /// Anyone can add signatories that are required by the governance to a\n    /// proposal\n    None,\n}\n\n/// Creates SignOffProposal instruction\npub fn sign_off_proposal(\n    program_id: &Pubkey,\n    // Accounts\n    realm: &Pubkey,\n    governance: &Pubkey,\n    proposal: &Pubkey,\n    signatory: &Pubkey,\n    proposal_owner_record: Option<&Pubkey>,\n) -> Instruction {\n    let mut accounts = vec![\n        AccountMeta::new_readonly(*realm, false),\n        AccountMeta::new_readonly(*governance, false),\n        AccountMeta::new(*proposal, false),\n        AccountMeta::new_readonly(*signatory, true),\n    ];\n\n    if let Some(proposal_owner_record) = proposal_owner_record {\n        accounts.push(AccountMeta::new_readonly(*proposal_owner_record, false))\n    }",
    "pub fn assert_is_valid_max_voter_weight(\n    max_voter_weight_record: &MaxVoterWeightRecord,\n) -> Result<(), ProgramError> {\n    // Assert max voter weight is not stale\n    if let Some(max_voter_weight_expiry) = max_voter_weight_record.max_voter_weight_expiry {\n        let slot = Clock::get()?.slot;\n\n        if slot > max_voter_weight_expiry {\n            return Err(GovernanceError::MaxVoterWeightRecordExpired.into());\n        }\n    }\n\n    Ok(())\n}",
    "pub fn get_max_voter_weight_record_data(\n    program_id: &Pubkey,\n    max_voter_weight_record_info: &AccountInfo,\n) -> Result<MaxVoterWeightRecord, ProgramError> {\n    get_account_data::<MaxVoterWeightRecord>(program_id, max_voter_weight_record_info)\n}",
    "pub fn get_max_voter_weight_record_data_for_realm_and_governing_token_mint(\n    program_id: &Pubkey,\n    max_voter_weight_record_info: &AccountInfo,\n    realm: &Pubkey,\n    governing_token_mint: &Pubkey,\n) -> Result<MaxVoterWeightRecord, ProgramError> {\n    let max_voter_weight_record_data =\n        get_max_voter_weight_record_data(program_id, max_voter_weight_record_info)?;\n\n    if max_voter_weight_record_data.realm != *realm {\n        return Err(GovernanceError::InvalidMaxVoterWeightRecordForRealm.into());\n    }\n\n    if max_voter_weight_record_data.governing_token_mint != *governing_token_mint {\n        return Err(GovernanceError::InvalidMaxVoterWeightRecordForGoverningTokenMint.into());\n    }\n\n    Ok(max_voter_weight_record_data)\n}",
    "pub fn assert_is_valid_voter_weight(\n    voter_weight_record: &VoterWeightRecord,\n    weight_action: VoterWeightAction,\n    weight_action_target: &Pubkey,\n) -> Result<(), ProgramError> {\n    // Assert the weight is not stale\n    if let Some(voter_weight_expiry) = voter_weight_record.voter_weight_expiry {\n        let slot = Clock::get()?.slot;\n\n        if slot > voter_weight_expiry {\n            return Err(GovernanceError::VoterWeightRecordExpired.into());\n        }\n    }\n\n    // Assert the weight is for the action specified by the addin\n    if let Some(voter_weight_action) = &voter_weight_record.weight_action {\n        if voter_weight_action != &weight_action {\n            return Err(GovernanceError::VoterWeightRecordInvalidAction.into());\n        }\n    }\n\n    // Assert the weight is for the action target specified by the addin\n    if let Some(voter_weight_action_target) = &voter_weight_record.weight_action_target {\n        if voter_weight_action_target != weight_action_target {\n            return Err(GovernanceError::VoterWeightRecordInvalidActionTarget.into());\n        }\n    }\n\n    Ok(())\n}",
    "pub fn get_voter_weight_record_data(\n    program_id: &Pubkey,\n    voter_weight_record_info: &AccountInfo,\n) -> Result<VoterWeightRecord, ProgramError> {\n    get_account_data::<VoterWeightRecord>(program_id, voter_weight_record_info)\n}",
    "pub fn get_voter_weight_record_data_for_token_owner_record(\n    program_id: &Pubkey,\n    voter_weight_record_info: &AccountInfo,\n    token_owner_record: &TokenOwnerRecordV2,\n) -> Result<VoterWeightRecord, ProgramError> {\n    let voter_weight_record_data =\n        get_voter_weight_record_data(program_id, voter_weight_record_info)?;\n\n    if voter_weight_record_data.realm != token_owner_record.realm {\n        return Err(GovernanceError::InvalidVoterWeightRecordForRealm.into());\n    }\n\n    if voter_weight_record_data.governing_token_mint != token_owner_record.governing_token_mint {\n        return Err(GovernanceError::InvalidVoterWeightRecordForGoverningTokenMint.into());\n    }\n\n    if voter_weight_record_data.governing_token_owner != token_owner_record.governing_token_owner {\n        return Err(GovernanceError::InvalidVoterWeightRecordForTokenOwner.into());\n    }\n\n    Ok(voter_weight_record_data)\n}",
    "pub fn process_instruction(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    input: &[u8],\n) -> ProgramResult {\n    msg!(\"VERSION:{:?}\", env!(\"CARGO_PKG_VERSION\"));\n    // Use try_from_slice_unchecked to support forward compatibility of newer UI\n    // with older program\n    let instruction: GovernanceInstruction =\n        try_from_slice_unchecked(input).map_err(|_| ProgramError::InvalidInstructionData)?;\n\n    if let GovernanceInstruction::InsertTransaction {\n        option_index,\n        index,\n        legacy: _,\n        instructions: _,\n    } = instruction\n    {\n        // Do not dump instruction data into logs\n        msg!(\n            \"GOVERNANCE-INSTRUCTION: InsertInstruction {{option_index: {:?}, index: {:?}}}\",\n            option_index,\n            index,\n        );\n    } else {\n        msg!(\"GOVERNANCE-INSTRUCTION: {:?}\", instruction);\n    }\n\n    match instruction {\n        GovernanceInstruction::CreateRealm { name, config_args } => {\n            process_create_realm(program_id, accounts, name, config_args)\n        }",
    "pub fn process_add_required_signatory(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    signatory: Pubkey,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n\n    let governance_info = next_account_info(account_info_iter)?; // 0\n\n    let required_signatory_info = next_account_info(account_info_iter)?; // 1\n\n    let payer_info = next_account_info(account_info_iter)?; // 2\n    let system_info = next_account_info(account_info_iter)?; // 3\n\n    let rent = Rent::get()?;\n\n    // Only governance PDA via a proposal can authorize change to its own config\n    if !governance_info.is_signer {\n        return Err(GovernanceError::GovernancePdaMustSign.into());\n    };\n\n    let mut governance_data = get_governance_data(program_id, governance_info)?;\n    governance_data.required_signatories_count = governance_data\n        .required_signatories_count\n        .checked_add(1)\n        .unwrap();\n    governance_data.serialize(&mut governance_info.data.borrow_mut()[..])?;\n\n    let signatory_record_data = RequiredSignatory {\n        signatory,\n        account_type: GovernanceAccountType::RequiredSignatory,\n        governance: *governance_info.key,\n        account_version: 0,\n    };\n\n    create_and_serialize_account_signed::<RequiredSignatory>(\n        payer_info,\n        required_signatory_info,\n        &signatory_record_data,\n        &get_required_signatory_address_seeds(governance_info.key, &signatory),\n        program_id,\n        system_info,\n        &rent,\n        0,\n    )?;\n\n    Ok(())\n}",
    "pub fn process_add_signatory(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    signatory: Pubkey,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n\n    let governance_info = next_account_info(account_info_iter)?; // 0\n    let proposal_info = next_account_info(account_info_iter)?; // 1\n    let signatory_record_info = next_account_info(account_info_iter)?; // 2\n\n    let payer_info = next_account_info(account_info_iter)?; // 3\n    let system_info = next_account_info(account_info_iter)?; // 4\n\n    let governance_data = get_governance_data(program_id, governance_info)?;\n\n    let mut proposal_data =\n        get_proposal_data_for_governance(program_id, proposal_info, governance_info.key)?;\n    proposal_data.assert_can_edit_signatories()?;\n\n    if !signatory_record_info.data_is_empty() {\n        return Err(GovernanceError::SignatoryRecordAlreadyExists.into());\n    }\n\n    // All required signatories must be added before additional signatories can be\n    // added\n    if proposal_data.signatories_count < governance_data.required_signatories_count {\n        let required_signatory_info = next_account_info(account_info_iter)?; // 5\n        let required_signatory_data = get_required_signatory_data_for_governance(\n            program_id,\n            required_signatory_info,\n            governance_info.key,\n        )?;\n\n        if required_signatory_data.signatory != signatory {\n            return Err(GovernanceError::InvalidSignatoryAddress.into());\n        }\n    } else {\n        let token_owner_record_info = next_account_info(account_info_iter)?; // 5\n        let governance_authority_info = next_account_info(account_info_iter)?; // 6\n\n        let token_owner_record_data = get_token_owner_record_data_for_proposal_owner(\n            program_id,\n            token_owner_record_info,\n            &proposal_data.token_owner_record,\n        )?;\n\n        token_owner_record_data\n            .assert_token_owner_or_delegate_is_signer(governance_authority_info)?;\n    }\n\n    let rent = Rent::get()?;\n\n    let signatory_record_data = SignatoryRecordV2 {\n        account_type: GovernanceAccountType::SignatoryRecordV2,\n        proposal: *proposal_info.key,\n        signatory,\n        signed_off: false,\n        reserved_v2: [0; 8],\n    };\n\n    create_and_serialize_account_signed::<SignatoryRecordV2>(\n        payer_info,\n        signatory_record_info,\n        &signatory_record_data,\n        &get_signatory_record_address_seeds(proposal_info.key, &signatory),\n        program_id,\n        system_info,\n        &rent,\n        0,\n    )?;\n\n    proposal_data.signatories_count = proposal_data.signatories_count.checked_add(1).unwrap();\n    proposal_data.serialize(&mut proposal_info.data.borrow_mut()[..])?;\n\n    Ok(())\n}",
    "pub fn process_cancel_proposal(program_id: &Pubkey, accounts: &[AccountInfo]) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n\n    let realm_info = next_account_info(account_info_iter)?; // 0\n    let governance_info = next_account_info(account_info_iter)?; // 1\n    let proposal_info = next_account_info(account_info_iter)?; // 2\n    let proposal_owner_record_info = next_account_info(account_info_iter)?; // 3\n    let governance_authority_info = next_account_info(account_info_iter)?; // 4\n\n    let clock = Clock::get()?;\n\n    assert_is_valid_realm(program_id, realm_info)?;\n\n    let mut governance_data =\n        get_governance_data_for_realm(program_id, governance_info, realm_info.key)?;\n\n    let mut proposal_data =\n        get_proposal_data_for_governance(program_id, proposal_info, governance_info.key)?;\n    proposal_data.assert_can_cancel(&governance_data.config, clock.unix_timestamp)?;\n\n    let mut proposal_owner_record_data = get_token_owner_record_data_for_proposal_owner(\n        program_id,\n        proposal_owner_record_info,\n        &proposal_data.token_owner_record,\n    )?;\n\n    proposal_owner_record_data\n        .assert_token_owner_or_delegate_is_signer(governance_authority_info)?;\n\n    proposal_owner_record_data.decrease_outstanding_proposal_count();\n    proposal_owner_record_data.serialize(&mut proposal_owner_record_info.data.borrow_mut()[..])?;\n\n    proposal_data.state = ProposalState::Cancelled;\n    proposal_data.closed_at = Some(clock.unix_timestamp);\n\n    proposal_data.serialize(&mut proposal_info.data.borrow_mut()[..])?;\n\n    // Update  Governance active_proposal_count\n    governance_data.active_proposal_count = governance_data.active_proposal_count.saturating_sub(1);\n    governance_data.serialize(&mut governance_info.data.borrow_mut()[..])?;\n\n    Ok(())\n}",
    "pub fn process_cast_vote(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    vote: Vote,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n\n    let realm_info = next_account_info(account_info_iter)?; // 0\n    let governance_info = next_account_info(account_info_iter)?; // 1\n\n    let proposal_info = next_account_info(account_info_iter)?; // 2\n    let proposal_owner_record_info = next_account_info(account_info_iter)?; // 3\n\n    let voter_token_owner_record_info = next_account_info(account_info_iter)?; // 4\n    let governance_authority_info = next_account_info(account_info_iter)?; // 5\n\n    let vote_record_info = next_account_info(account_info_iter)?; // 6\n    let vote_governing_token_mint_info = next_account_info(account_info_iter)?; // 7\n\n    let payer_info = next_account_info(account_info_iter)?; // 8\n    let system_info = next_account_info(account_info_iter)?; // 9\n\n    let rent = Rent::get()?;\n    let clock = Clock::get()?;\n\n    if !vote_record_info.data_is_empty() {\n        return Err(GovernanceError::VoteAlreadyExists.into());\n    }\n\n    let realm_data = get_realm_data_for_governing_token_mint(\n        program_id,\n        realm_info,\n        vote_governing_token_mint_info.key,\n    )?;\n\n    let mut governance_data =\n        get_governance_data_for_realm(program_id, governance_info, realm_info.key)?;\n\n    let vote_kind = get_vote_kind(&vote);\n\n    // Get the governing_token_mint which the Proposal should be configured with as\n    // the voting population for the given vote For Approve, Deny and Abstain\n    // votes it's the same as vote_governing_token_mint For Veto it's the\n    // governing token mint of the opposite voting population\n    let proposal_governing_token_mint = realm_data.get_proposal_governing_token_mint_for_vote(\n        vote_governing_token_mint_info.key,\n        &vote_kind,\n    )?;\n\n    let mut proposal_data = get_proposal_data_for_governance_and_governing_mint(\n        program_id,\n        proposal_info,\n        governance_info.key,\n        &proposal_governing_token_mint,\n    )?;\n    proposal_data.assert_can_cast_vote(&governance_data.config, &vote, clock.unix_timestamp)?;\n\n    let mut voter_token_owner_record_data =\n        get_token_owner_record_data_for_realm_and_governing_mint(\n            program_id,\n            voter_token_owner_record_info,\n            &governance_data.realm,\n            vote_governing_token_mint_info.key,\n        )?;\n    voter_token_owner_record_data\n        .assert_token_owner_or_delegate_is_signer(governance_authority_info)?;\n\n    // Update TokenOwnerRecord vote counts\n    voter_token_owner_record_data.unrelinquished_votes_count = voter_token_owner_record_data\n        .unrelinquished_votes_count\n        .checked_add(1)\n        .unwrap();\n\n    let realm_config_info = next_account_info(account_info_iter)?; // 9\n    let realm_config_data =\n        get_realm_config_data_for_realm(program_id, realm_config_info, realm_info.key)?;\n\n    let voter_weight = voter_token_owner_record_data.resolve_voter_weight(\n        account_info_iter, // voter_weight_record  *10\n        &realm_data,\n        &realm_config_data,\n        VoterWeightAction::CastVote,\n        proposal_info.key,\n    )?;\n\n    proposal_data.assert_valid_vote(&vote)?;\n\n    // Calculate Proposal voting weights\n    match &vote {\n        Vote::Approve(choices) => {\n            for (option, choice) in proposal_data.options.iter_mut().zip(choices) {\n                option.vote_weight = option\n                    .vote_weight\n                    .checked_add(choice.get_choice_weight(voter_weight)?)\n                    .unwrap();\n            }\n        }\n        Vote::Deny => {\n            proposal_data.deny_vote_weight = Some(\n                proposal_data\n                    .deny_vote_weight\n                    .unwrap()\n                    .checked_add(voter_weight)\n                    .unwrap(),\n            )\n        }",
    "pub fn process_complete_proposal(program_id: &Pubkey, accounts: &[AccountInfo]) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n\n    let proposal_info = next_account_info(account_info_iter)?; // 0\n    let token_owner_record_info = next_account_info(account_info_iter)?; // 1\n    let complete_proposal_authority_info = next_account_info(account_info_iter)?; // 2\n\n    let mut proposal_data = get_proposal_data(program_id, proposal_info)?;\n    proposal_data.assert_can_complete()?;\n\n    let token_owner_record_data = get_token_owner_record_data_for_proposal_owner(\n        program_id,\n        token_owner_record_info,\n        &proposal_data.token_owner_record,\n    )?;\n    token_owner_record_data\n        .assert_token_owner_or_delegate_is_signer(complete_proposal_authority_info)?;\n\n    let clock = Clock::get()?;\n    proposal_data.closed_at = Some(clock.unix_timestamp);\n    proposal_data.state = ProposalState::Completed;\n\n    proposal_data.serialize(&mut proposal_info.data.borrow_mut()[..])?;\n    Ok(())\n}",
    "pub fn process_create_governance(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    config: GovernanceConfig,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n\n    let realm_info = next_account_info(account_info_iter)?; // 0\n    let governance_info = next_account_info(account_info_iter)?; // 1\n    let governance_seed_info = next_account_info(account_info_iter)?; // 2\n\n    let token_owner_record_info = next_account_info(account_info_iter)?; // 3\n\n    let payer_info = next_account_info(account_info_iter)?; // 4\n    let system_info = next_account_info(account_info_iter)?; // 5\n\n    let rent = Rent::get()?;\n\n    let create_authority_info = next_account_info(account_info_iter)?; // 6\n\n    assert_valid_create_governance_args(program_id, &config, realm_info)?;\n\n    let realm_data = get_realm_data(program_id, realm_info)?;\n\n    realm_data.assert_create_authority_can_create_governance(\n        program_id,\n        realm_info.key,\n        token_owner_record_info,\n        create_authority_info,\n        account_info_iter, // realm_config_info 7, voter_weight_record_info 8\n    )?;\n\n    let governance_data = GovernanceV2 {\n        account_type: GovernanceAccountType::GovernanceV2,\n        realm: *realm_info.key,\n        governance_seed: *governance_seed_info.key,\n        config,\n        reserved1: 0,\n        reserved_v2: Reserved119::default(),\n        required_signatories_count: 0,\n        active_proposal_count: 0,\n    };\n\n    create_and_serialize_account_signed::<GovernanceV2>(\n        payer_info,\n        governance_info,\n        &governance_data,\n        &get_governance_address_seeds(realm_info.key, governance_seed_info.key),\n        program_id,\n        system_info,\n        &rent,\n        0,\n    )?;\n\n    Ok(())\n}",
    "pub fn process_create_native_treasury(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n\n    let governance_info = next_account_info(account_info_iter)?; // 0\n    let native_treasury_info = next_account_info(account_info_iter)?; // 1\n    let payer_info = next_account_info(account_info_iter)?; // 2\n    let system_info = next_account_info(account_info_iter)?; // 3\n\n    let rent = Rent::get()?;\n\n    assert_is_valid_governance(program_id, governance_info)?;\n\n    let native_treasury_data = NativeTreasury {};\n\n    create_and_serialize_account_with_owner_signed(\n        payer_info,\n        native_treasury_info,\n        &native_treasury_data,\n        &get_native_treasury_address_seeds(governance_info.key),\n        program_id,\n        &system_program::id(), // System program as the PDA owner\n        system_info,\n        &rent,\n        0,\n    )?;\n\n    Ok(())\n}",
    "pub fn process_create_proposal(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    name: String,\n    description_link: String,\n    vote_type: VoteType,\n    options: Vec<String>,\n    use_deny_option: bool,\n    proposal_seed: Pubkey,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n\n    let realm_info = next_account_info(account_info_iter)?; // 0\n    let proposal_info = next_account_info(account_info_iter)?; // 1\n    let governance_info = next_account_info(account_info_iter)?; // 2\n\n    let proposal_owner_record_info = next_account_info(account_info_iter)?; // 3\n    let governing_token_mint_info = next_account_info(account_info_iter)?; // 4\n    let governance_authority_info = next_account_info(account_info_iter)?; // 5\n\n    let payer_info = next_account_info(account_info_iter)?; // 6\n    let system_info = next_account_info(account_info_iter)?; // 7\n\n    let rent = Rent::get()?;\n    let clock = Clock::get()?;\n\n    if !proposal_info.data_is_empty() {\n        return Err(GovernanceError::ProposalAlreadyExists.into());\n    }\n\n    let realm_data = get_realm_data_for_governing_token_mint(\n        program_id,\n        realm_info,\n        governing_token_mint_info.key,\n    )?;\n\n    let mut governance_data =\n        get_governance_data_for_realm(program_id, governance_info, realm_info.key)?;\n\n    governance_data.assert_governing_token_mint_can_vote(\n        &realm_data,\n        governing_token_mint_info.key,\n        &VoteKind::Electorate,\n    )?;\n\n    let mut proposal_owner_record_data = get_token_owner_record_data_for_realm(\n        program_id,\n        proposal_owner_record_info,\n        realm_info.key,\n    )?;\n\n    // Proposal owner (TokenOwner) or its governance_delegate must sign this\n    // transaction\n    proposal_owner_record_data\n        .assert_token_owner_or_delegate_is_signer(governance_authority_info)?;\n\n    let realm_config_info = next_account_info(account_info_iter)?; // 8\n    let realm_config_data =\n        get_realm_config_data_for_realm(program_id, realm_config_info, realm_info.key)?;\n\n    let voter_weight = proposal_owner_record_data.resolve_voter_weight(\n        account_info_iter, // voter_weight_record  *9\n        &realm_data,\n        &realm_config_data,\n        VoterWeightAction::CreateProposal,\n        governance_info.key,\n    )?;\n\n    // Ensure proposal owner (TokenOwner) has enough tokens to create proposal and\n    // no outstanding proposals\n    proposal_owner_record_data.assert_can_create_proposal(\n        &realm_data,\n        &governance_data.config,\n        voter_weight,\n    )?;\n\n    proposal_owner_record_data.outstanding_proposal_count = proposal_owner_record_data\n        .outstanding_proposal_count\n        .checked_add(1)\n        .unwrap();\n    proposal_owner_record_data.serialize(&mut proposal_owner_record_info.data.borrow_mut()[..])?;\n\n    assert_valid_proposal_options(&options, &vote_type)?;\n\n    let proposal_options: Vec<ProposalOption> = options\n        .iter()\n        .map(|o| ProposalOption {\n            label: o.to_string(),\n            vote_weight: 0,\n            vote_result: OptionVoteResult::None,\n            transactions_executed_count: 0,\n            transactions_count: 0,\n            transactions_next_index: 0,\n        })\n        .collect();\n\n    let deny_vote_weight = if use_deny_option { Some(0) }",
    "pub fn process_create_realm(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    name: String,\n    realm_config_args: RealmConfigArgs,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n\n    let realm_info = next_account_info(account_info_iter)?; // 0\n    let realm_authority_info = next_account_info(account_info_iter)?; // 1\n    let governance_token_mint_info = next_account_info(account_info_iter)?; // 2\n    let governance_token_holding_info = next_account_info(account_info_iter)?; // 3\n    let payer_info = next_account_info(account_info_iter)?; // 4\n    let system_info = next_account_info(account_info_iter)?; // 5\n    let spl_token_info = next_account_info(account_info_iter)?; // 6\n\n    let rent_sysvar_info = next_account_info(account_info_iter)?; // 7\n    let rent = &Rent::from_account_info(rent_sysvar_info)?;\n\n    if !realm_info.data_is_empty() {\n        return Err(GovernanceError::RealmAlreadyExists.into());\n    }\n\n    assert_valid_realm_config_args(&realm_config_args)?;\n\n    // Create Community token holding account\n    create_spl_token_account_signed(\n        payer_info,\n        governance_token_holding_info,\n        &get_governing_token_holding_address_seeds(realm_info.key, governance_token_mint_info.key),\n        governance_token_mint_info,\n        realm_info,\n        program_id,\n        system_info,\n        spl_token_info,\n        rent_sysvar_info,\n        rent,\n    )?;\n\n    // Create Council token holding account\n    let council_token_mint_address = if realm_config_args.use_council_mint {\n        let council_token_mint_info = next_account_info(account_info_iter)?; // 8\n        let council_token_holding_info = next_account_info(account_info_iter)?; // 9\n\n        create_spl_token_account_signed(\n            payer_info,\n            council_token_holding_info,\n            &get_governing_token_holding_address_seeds(realm_info.key, council_token_mint_info.key),\n            council_token_mint_info,\n            realm_info,\n            program_id,\n            system_info,\n            spl_token_info,\n            rent_sysvar_info,\n            rent,\n        )?;\n\n        Some(*council_token_mint_info.key)\n    }",
    "pub fn process_create_token_owner_record(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n\n    let realm_info = next_account_info(account_info_iter)?; // 0\n    let governing_token_owner_info = next_account_info(account_info_iter)?; // 1\n    let token_owner_record_info = next_account_info(account_info_iter)?; // 2\n    let governing_token_mint_info = next_account_info(account_info_iter)?; // 3\n    let payer_info = next_account_info(account_info_iter)?; // 4\n    let system_info = next_account_info(account_info_iter)?; // 5\n    let rent = Rent::get()?;\n\n    let realm_data = get_realm_data(program_id, realm_info)?;\n    realm_data.assert_is_valid_governing_token_mint(governing_token_mint_info.key)?;\n\n    if !token_owner_record_info.data_is_empty() {\n        return Err(GovernanceError::TokenOwnerRecordAlreadyExists.into());\n    }\n\n    let token_owner_record_data = TokenOwnerRecordV2 {\n        account_type: GovernanceAccountType::TokenOwnerRecordV2,\n        realm: *realm_info.key,\n        governing_token_owner: *governing_token_owner_info.key,\n        governing_token_deposit_amount: 0,\n        governing_token_mint: *governing_token_mint_info.key,\n        governance_delegate: None,\n        unrelinquished_votes_count: 0,\n        outstanding_proposal_count: 0,\n        version: TOKEN_OWNER_RECORD_LAYOUT_VERSION,\n        reserved: [0; 6],\n        reserved_v2: [0; 124],\n        locks: vec![],\n    };\n\n    create_and_serialize_account_signed(\n        payer_info,\n        token_owner_record_info,\n        &token_owner_record_data,\n        &get_token_owner_record_address_seeds(\n            realm_info.key,\n            governing_token_mint_info.key,\n            governing_token_owner_info.key,\n        ),\n        program_id,\n        system_info,\n        &rent,\n        0,\n    )\n}",
    "pub fn process_deposit_governing_tokens(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    amount: u64,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n\n    let realm_info = next_account_info(account_info_iter)?; // 0\n    let governing_token_holding_info = next_account_info(account_info_iter)?; // 1\n    let governing_token_source_info = next_account_info(account_info_iter)?; // 2\n    let governing_token_owner_info = next_account_info(account_info_iter)?; // 3\n    let governing_token_source_authority_info = next_account_info(account_info_iter)?; // 4\n    let token_owner_record_info = next_account_info(account_info_iter)?; // 5\n    let payer_info = next_account_info(account_info_iter)?; // 6\n    let system_info = next_account_info(account_info_iter)?; // 7\n    let spl_token_info = next_account_info(account_info_iter)?; // 8\n    let realm_config_info = next_account_info(account_info_iter)?; // 9\n\n    let rent = Rent::get()?;\n\n    let realm_data = get_realm_data(program_id, realm_info)?;\n    let governing_token_mint = get_spl_token_mint(governing_token_holding_info)?;\n\n    realm_data.assert_is_valid_governing_token_mint_and_holding(\n        program_id,\n        realm_info.key,\n        &governing_token_mint,\n        governing_token_holding_info.key,\n    )?;\n\n    let realm_config_data =\n        get_realm_config_data_for_realm(program_id, realm_config_info, realm_info.key)?;\n\n    realm_config_data.assert_can_deposit_governing_token(&realm_data, &governing_token_mint)?;\n\n    if is_spl_token_account(governing_token_source_info) {\n        // If the source is spl-token token account then transfer tokens from it\n        transfer_spl_tokens(\n            governing_token_source_info,\n            governing_token_holding_info,\n            governing_token_source_authority_info,\n            amount,\n            spl_token_info,\n        )?;\n    } else if is_spl_token_mint(governing_token_source_info) {\n        // If it's a mint then mint the tokens\n        mint_spl_tokens_to(\n            governing_token_source_info,\n            governing_token_holding_info,\n            governing_token_source_authority_info,\n            amount,\n            spl_token_info,\n        )?;\n    } else {\n        return Err(GovernanceError::InvalidGoverningTokenSource.into());\n    }\n\n    let token_owner_record_address_seeds = get_token_owner_record_address_seeds(\n        realm_info.key,\n        &governing_token_mint,\n        governing_token_owner_info.key,\n    );\n\n    if token_owner_record_info.data_is_empty() {\n        // Deposited tokens can only be withdrawn by the owner so let's make sure the\n        // owner signed the transaction\n        if !governing_token_owner_info.is_signer {\n            return Err(GovernanceError::GoverningTokenOwnerMustSign.into());\n        }\n\n        let token_owner_record_data = TokenOwnerRecordV2 {\n            account_type: GovernanceAccountType::TokenOwnerRecordV2,\n            realm: *realm_info.key,\n            governing_token_owner: *governing_token_owner_info.key,\n            governing_token_deposit_amount: amount,\n            governing_token_mint,\n            governance_delegate: None,\n            unrelinquished_votes_count: 0,\n            outstanding_proposal_count: 0,\n            version: TOKEN_OWNER_RECORD_LAYOUT_VERSION,\n            reserved: [0; 6],\n            reserved_v2: [0; 124],\n            locks: vec![],\n        };\n\n        create_and_serialize_account_signed(\n            payer_info,\n            token_owner_record_info,\n            &token_owner_record_data,\n            &token_owner_record_address_seeds,\n            program_id,\n            system_info,\n            &rent,\n            0,\n        )?;\n    } else {\n        let mut token_owner_record_data = get_token_owner_record_data_for_seeds(\n            program_id,\n            token_owner_record_info,\n            &token_owner_record_address_seeds,\n        )?;\n\n        token_owner_record_data.governing_token_deposit_amount = token_owner_record_data\n            .governing_token_deposit_amount\n            .checked_add(amount)\n            .unwrap();\n\n        token_owner_record_data.serialize(&mut token_owner_record_info.data.borrow_mut()[..])?;\n    }\n\n    Ok(())\n}",
    "pub fn process_execute_transaction(program_id: &Pubkey, accounts: &[AccountInfo]) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n\n    let governance_info = next_account_info(account_info_iter)?; // 0\n    let proposal_info = next_account_info(account_info_iter)?; // 1\n    let proposal_transaction_info = next_account_info(account_info_iter)?; // 2\n\n    let clock = Clock::get()?;\n\n    let governance_data = get_governance_data(program_id, governance_info)?;\n\n    let mut proposal_data =\n        get_proposal_data_for_governance(program_id, proposal_info, governance_info.key)?;\n\n    let mut proposal_transaction_data = get_proposal_transaction_data_for_proposal(\n        program_id,\n        proposal_transaction_info,\n        proposal_info.key,\n    )?;\n\n    proposal_data.assert_can_execute_transaction(\n        &proposal_transaction_data,\n        &governance_data.config,\n        clock.unix_timestamp,\n    )?;\n\n    // Execute instruction with Governance PDA as signer\n    let instructions = proposal_transaction_data\n        .instructions\n        .iter()\n        .map(Instruction::from);\n\n    // In the current implementation accounts for all instructions are passed to\n    // each instruction invocation. This is an overhead but shouldn't be a\n    // showstopper because if we can invoke the parent instruction with that many\n    // accounts then we should also be able to invoke all the nested ones\n    // TODO: Optimize the invocation to split the provided accounts for each\n    // individual instruction\n    let instruction_account_infos = account_info_iter.as_slice();\n\n    let mut signers_seeds: Vec<&[&[u8]]> = vec![];\n\n    // Sign the transaction using the governance PDA\n    let mut governance_seeds = governance_data.get_governance_address_seeds()?.to_vec();\n    let (_, bump_seed) = Pubkey::find_program_address(&governance_seeds, program_id);\n    let bump = &[bump_seed];\n    governance_seeds.push(bump);\n\n    signers_seeds.push(&governance_seeds[..]);\n\n    // Sign the transaction using the governance treasury PDA if required by the\n    // instruction\n    let mut treasury_seeds = get_native_treasury_address_seeds(governance_info.key).to_vec();\n    let (treasury_address, treasury_bump_seed) =\n        Pubkey::find_program_address(&treasury_seeds, program_id);\n    let treasury_bump = &[treasury_bump_seed];\n\n    if instruction_account_infos\n        .iter()\n        .any(|a| a.key == &treasury_address)\n    {\n        treasury_seeds.push(treasury_bump);\n        signers_seeds.push(&treasury_seeds[..]);\n    }\n\n    for instruction in instructions {\n        invoke_signed(&instruction, instruction_account_infos, &signers_seeds[..])?;\n    }\n\n    // Update proposal and instruction accounts\n    if proposal_data.state == ProposalState::Succeeded {\n        proposal_data.executing_at = Some(clock.unix_timestamp);\n        proposal_data.state = ProposalState::Executing;\n    }\n\n    let option = &mut proposal_data.options[proposal_transaction_data.option_index as usize];\n    option.transactions_executed_count = option.transactions_executed_count.checked_add(1).unwrap();\n\n    // Checking for Executing and ExecutingWithErrors states because instruction can\n    // still be executed after being flagged with error The check for\n    // instructions_executed_count ensures Proposal can't be transitioned to\n    // Completed state from ExecutingWithErrors\n    if (proposal_data.state == ProposalState::Executing\n        || proposal_data.state == ProposalState::ExecutingWithErrors)\n        && proposal_data\n            .options\n            .iter()\n            .filter(|o| o.vote_result == OptionVoteResult::Succeeded)\n            .all(|o| o.transactions_executed_count == o.transactions_count)\n    {\n        proposal_data.closed_at = Some(clock.unix_timestamp);\n        proposal_data.state = ProposalState::Completed;\n    }\n\n    proposal_data.serialize(&mut proposal_info.data.borrow_mut()[..])?;\n\n    proposal_transaction_data.executed_at = Some(clock.unix_timestamp);\n    proposal_transaction_data.execution_status = TransactionExecutionStatus::Success;\n    proposal_transaction_data.serialize(&mut proposal_transaction_info.data.borrow_mut()[..])?;\n\n    Ok(())\n}",
    "pub fn process_finalize_vote(program_id: &Pubkey, accounts: &[AccountInfo]) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n\n    let realm_info = next_account_info(account_info_iter)?; // 0\n    let governance_info = next_account_info(account_info_iter)?; // 1\n    let proposal_info = next_account_info(account_info_iter)?; // 2\n    let proposal_owner_record_info = next_account_info(account_info_iter)?; // 3\n\n    let governing_token_mint_info = next_account_info(account_info_iter)?; // 4\n\n    let clock = Clock::get()?;\n\n    let realm_data = get_realm_data_for_governing_token_mint(\n        program_id,\n        realm_info,\n        governing_token_mint_info.key,\n    )?;\n    let mut governance_data =\n        get_governance_data_for_realm(program_id, governance_info, realm_info.key)?;\n\n    let mut proposal_data = get_proposal_data_for_governance_and_governing_mint(\n        program_id,\n        proposal_info,\n        governance_info.key,\n        governing_token_mint_info.key,\n    )?;\n\n    let realm_config_info = next_account_info(account_info_iter)?; //5\n    let realm_config_data =\n        get_realm_config_data_for_realm(program_id, realm_config_info, realm_info.key)?;\n\n    let max_voter_weight = proposal_data.resolve_max_voter_weight(\n        account_info_iter, // *6\n        realm_info.key,\n        &realm_data,\n        &realm_config_data,\n        governing_token_mint_info,\n        &VoteKind::Electorate,\n    )?;\n\n    let vote_threshold = governance_data.resolve_vote_threshold(\n        &realm_data,\n        governing_token_mint_info.key,\n        &VoteKind::Electorate,\n    )?;\n\n    proposal_data.finalize_vote(\n        max_voter_weight,\n        &governance_data.config,\n        clock.unix_timestamp,\n        &vote_threshold,\n    )?;\n\n    let mut proposal_owner_record_data = get_token_owner_record_data_for_proposal_owner(\n        program_id,\n        proposal_owner_record_info,\n        &proposal_data.token_owner_record,\n    )?;\n\n    proposal_owner_record_data.decrease_outstanding_proposal_count();\n    proposal_owner_record_data.serialize(&mut proposal_owner_record_info.data.borrow_mut()[..])?;\n\n    proposal_data.serialize(&mut proposal_info.data.borrow_mut()[..])?;\n\n    // Update  Governance active_proposal_count\n    governance_data.active_proposal_count = governance_data.active_proposal_count.saturating_sub(1);\n    governance_data.serialize(&mut governance_info.data.borrow_mut()[..])?;\n\n    Ok(())\n}",
    "pub fn process_insert_transaction(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    option_index: u8,\n    instruction_index: u16,\n    instructions: Vec<InstructionData>,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n\n    let governance_info = next_account_info(account_info_iter)?; // 0\n    let proposal_info = next_account_info(account_info_iter)?; // 1\n    let token_owner_record_info = next_account_info(account_info_iter)?; // 2\n    let governance_authority_info = next_account_info(account_info_iter)?; // 3\n\n    let proposal_transaction_info = next_account_info(account_info_iter)?; // 4\n\n    let payer_info = next_account_info(account_info_iter)?; // 5\n    let system_info = next_account_info(account_info_iter)?; // 6\n\n    let rent_sysvar_info = next_account_info(account_info_iter)?; // 7\n    let rent = &Rent::from_account_info(rent_sysvar_info)?;\n\n    if !proposal_transaction_info.data_is_empty() {\n        return Err(GovernanceError::TransactionAlreadyExists.into());\n    }\n\n    // Governance account is no longer used and it's deserialized only to validate\n    // the provided account\n    let _governance_data = get_governance_data(program_id, governance_info)?;\n\n    let mut proposal_data =\n        get_proposal_data_for_governance(program_id, proposal_info, governance_info.key)?;\n    proposal_data.assert_can_edit_instructions()?;\n\n    let token_owner_record_data = get_token_owner_record_data_for_proposal_owner(\n        program_id,\n        token_owner_record_info,\n        &proposal_data.token_owner_record,\n    )?;\n\n    token_owner_record_data.assert_token_owner_or_delegate_is_signer(governance_authority_info)?;\n\n    let option = &mut proposal_data.options[option_index as usize];\n\n    match instruction_index.cmp(&option.transactions_next_index) {\n        Ordering::Greater => return Err(GovernanceError::InvalidTransactionIndex.into()),\n        // If the index is the same as instructions_next_index then we are adding a new instruction\n        // If the index is below instructions_next_index then we are inserting into an existing\n        // empty space\n        Ordering::Equal => {\n            option.transactions_next_index = option.transactions_next_index.checked_add(1).unwrap();\n        }\n        Ordering::Less => {}\n    }\n\n    option.transactions_count = option.transactions_count.checked_add(1).unwrap();\n    proposal_data.serialize(&mut proposal_info.data.borrow_mut()[..])?;\n\n    let proposal_transaction_data = ProposalTransactionV2 {\n        account_type: GovernanceAccountType::ProposalTransactionV2,\n        option_index,\n        transaction_index: instruction_index,\n        legacy: 0,\n        instructions,\n        executed_at: None,\n        execution_status: TransactionExecutionStatus::None,\n        proposal: *proposal_info.key,\n        reserved_v2: [0; 8],\n    };\n\n    create_and_serialize_account_signed::<ProposalTransactionV2>(\n        payer_info,\n        proposal_transaction_info,\n        &proposal_transaction_data,\n        &get_proposal_transaction_address_seeds(\n            proposal_info.key,\n            &option_index.to_le_bytes(),\n            &instruction_index.to_le_bytes(),\n        ),\n        program_id,\n        system_info,\n        rent,\n        0,\n    )?;\n\n    Ok(())\n}",
    "pub fn process_refund_proposal_deposit(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n\n    let proposal_info = next_account_info(account_info_iter)?; // 0\n\n    let proposal_deposit_info = next_account_info(account_info_iter)?; // 1\n    let proposal_deposit_payer_info = next_account_info(account_info_iter)?; // 2\n\n    let proposal_data = get_proposal_data(program_id, proposal_info)?;\n\n    proposal_data.assert_can_refund_proposal_deposit()?;\n\n    // Assert we are disposing a deposit which belongs to the Proposal and the\n    // deposit payer\n    let _proposal_deposit_data = get_proposal_deposit_data_for_proposal_and_deposit_payer(\n        program_id,\n        proposal_deposit_info,\n        proposal_info.key,\n        proposal_deposit_payer_info.key,\n    )?;\n\n    dispose_account(proposal_deposit_info, proposal_deposit_payer_info)?;\n\n    Ok(())\n}",
    "pub fn process_relinquish_token_owner_record_locks(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    lock_ids: Option<Vec<u8>>,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n\n    let realm_info = next_account_info(account_info_iter)?; // 0\n    let realm_config_info = next_account_info(account_info_iter)?; // 1\n    let token_owner_record_info = next_account_info(account_info_iter)?; // 2\n\n    let realm_data = get_realm_data(program_id, realm_info)?;\n    let realm_config_data =\n        get_realm_config_data_for_realm(program_id, realm_config_info, realm_info.key)?;\n\n    let mut token_owner_record_data = get_token_owner_record_data_for_realm(\n        program_id,\n        token_owner_record_info,\n        &realm_config_data.realm,\n    )?;\n\n    if let Some(lock_ids) = lock_ids {\n        let token_owner_record_lock_authority_info = next_account_info(account_info_iter)?; // 3\n\n        if realm_config_data\n            .get_token_config(&realm_data, &token_owner_record_data.governing_token_mint)?\n            .lock_authorities\n            .contains(token_owner_record_lock_authority_info.key)\n        {\n            // If the authority is a configured lock authority it must sign the transaction\n            if !token_owner_record_lock_authority_info.is_signer {\n                return Err(GovernanceError::TokenOwnerRecordLockAuthorityMustSign.into());\n            }\n        }\n\n        // Remove the locks\n        for lock_id in lock_ids {\n            token_owner_record_data\n                .remove_lock(lock_id, token_owner_record_lock_authority_info.key)?;\n        }\n    }\n\n    // Trim expired locks\n    let clock = Clock::get()?;\n    token_owner_record_data.remove_expired_locks(clock.unix_timestamp);\n\n    token_owner_record_data.serialize(&mut token_owner_record_info.data.borrow_mut()[..])?;\n\n    Ok(())\n}",
    "pub fn process_relinquish_vote(program_id: &Pubkey, accounts: &[AccountInfo]) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n\n    let realm_info = next_account_info(account_info_iter)?; // 0\n    let governance_info = next_account_info(account_info_iter)?; // 1\n    let proposal_info = next_account_info(account_info_iter)?; // 2\n    let token_owner_record_info = next_account_info(account_info_iter)?; // 3\n\n    let vote_record_info = next_account_info(account_info_iter)?; // 4\n    let vote_governing_token_mint_info = next_account_info(account_info_iter)?; // 5\n\n    let realm_data = get_realm_data_for_governing_token_mint(\n        program_id,\n        realm_info,\n        vote_governing_token_mint_info.key,\n    )?;\n\n    let governance_data =\n        get_governance_data_for_realm(program_id, governance_info, realm_info.key)?;\n\n    let mut proposal_data =\n        get_proposal_data_for_governance(program_id, proposal_info, governance_info.key)?;\n\n    let mut token_owner_record_data = get_token_owner_record_data_for_realm_and_governing_mint(\n        program_id,\n        token_owner_record_info,\n        &governance_data.realm,\n        vote_governing_token_mint_info.key,\n    )?;\n\n    let mut vote_record_data = get_vote_record_data_for_proposal_and_token_owner_record(\n        program_id,\n        vote_record_info,\n        &realm_data,\n        proposal_info.key,\n        &proposal_data,\n        &token_owner_record_data,\n    )?;\n    vote_record_data.assert_can_relinquish_vote()?;\n\n    let clock = Clock::get()?;\n\n    // If the Proposal is still being voted on then the token owner vote will be\n    // withdrawn and it won't count towards the vote outcome Note: If there is\n    // no tipping point the proposal can be still in Voting state but already past\n    // the configured max voting time (base + cool off voting time)\n    //       It means it awaits manual finalization (FinalizeVote) and it should no\n    // longer be possible to withdraw the vote\n    if proposal_data.state == ProposalState::Voting\n        && !proposal_data.has_voting_max_time_ended(&governance_data.config, clock.unix_timestamp)\n    {\n        let governance_authority_info = next_account_info(account_info_iter)?; // 5\n        let beneficiary_info = next_account_info(account_info_iter)?; // 6\n\n        // Note: It's only required to sign by governing_authority if relinquishing the\n        // vote results in vote change If the Proposal is already decided then\n        // anybody can prune active votes for token owner\n        token_owner_record_data\n            .assert_token_owner_or_delegate_is_signer(governance_authority_info)?;\n\n        match vote_record_data.vote {\n            Vote::Approve(choices) => {\n                for (option, choice) in proposal_data.options.iter_mut().zip(choices) {\n                    option.vote_weight = option\n                        .vote_weight\n                        .checked_sub(choice.get_choice_weight(vote_record_data.voter_weight)?)\n                        .unwrap();\n                }\n            }\n            Vote::Deny => {\n                proposal_data.deny_vote_weight = Some(\n                    proposal_data\n                        .deny_vote_weight\n                        .unwrap()\n                        .checked_sub(vote_record_data.voter_weight)\n                        .unwrap(),\n                )\n            }",
    "pub fn process_remove_required_signatory(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n\n    let governance_info = next_account_info(account_info_iter)?; // 0\n    let required_signatory_info = next_account_info(account_info_iter)?; // 1\n    let beneficiary_info = next_account_info(account_info_iter)?; // 2\n\n    if !governance_info.is_signer {\n        return Err(GovernanceError::GovernancePdaMustSign.into());\n    };\n\n    let mut governance_data = get_governance_data(program_id, governance_info)?;\n\n    get_required_signatory_data_for_governance(\n        program_id,\n        required_signatory_info,\n        governance_info.key,\n    )?;\n\n    governance_data.required_signatories_count = governance_data\n        .required_signatories_count\n        .checked_sub(1)\n        .unwrap();\n    governance_data.serialize(&mut governance_info.data.borrow_mut()[..])?;\n\n    dispose_account(required_signatory_info, beneficiary_info)?;\n\n    Ok(())\n}",
    "pub fn process_remove_transaction(program_id: &Pubkey, accounts: &[AccountInfo]) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n\n    let proposal_info = next_account_info(account_info_iter)?; // 0\n    let token_owner_record_info = next_account_info(account_info_iter)?; // 1\n    let governance_authority_info = next_account_info(account_info_iter)?; // 2\n\n    let proposal_transaction_info = next_account_info(account_info_iter)?; // 3\n    let beneficiary_info = next_account_info(account_info_iter)?; // 4\n\n    let mut proposal_data = get_proposal_data(program_id, proposal_info)?;\n    proposal_data.assert_can_edit_instructions()?;\n\n    let token_owner_record_data = get_token_owner_record_data_for_proposal_owner(\n        program_id,\n        token_owner_record_info,\n        &proposal_data.token_owner_record,\n    )?;\n\n    token_owner_record_data.assert_token_owner_or_delegate_is_signer(governance_authority_info)?;\n\n    let proposal_transaction_data = get_proposal_transaction_data_for_proposal(\n        program_id,\n        proposal_transaction_info,\n        proposal_info.key,\n    )?;\n\n    dispose_account(proposal_transaction_info, beneficiary_info)?;\n\n    let option = &mut proposal_data.options[proposal_transaction_data.option_index as usize];\n    option.transactions_count = option.transactions_count.checked_sub(1).unwrap();\n\n    proposal_data.serialize(&mut proposal_info.data.borrow_mut()[..])?;\n\n    Ok(())\n}",
    "pub fn process_revoke_governing_tokens(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    amount: u64,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n\n    let realm_info = next_account_info(account_info_iter)?; // 0\n\n    let governing_token_holding_info = next_account_info(account_info_iter)?; // 1\n    let token_owner_record_info = next_account_info(account_info_iter)?; // 2\n\n    let governing_token_mint_info = next_account_info(account_info_iter)?; // 3\n    let revoke_authority_info = next_account_info(account_info_iter)?; // 4\n\n    let realm_config_info = next_account_info(account_info_iter)?; // 5\n    let spl_token_info = next_account_info(account_info_iter)?; // 6\n\n    let realm_data = get_realm_data(program_id, realm_info)?;\n\n    realm_data.assert_is_valid_governing_token_mint_and_holding(\n        program_id,\n        realm_info.key,\n        governing_token_mint_info.key,\n        governing_token_holding_info.key,\n    )?;\n\n    let realm_config_data =\n        get_realm_config_data_for_realm(program_id, realm_config_info, realm_info.key)?;\n\n    realm_config_data\n        .assert_can_revoke_governing_token(&realm_data, governing_token_mint_info.key)?;\n\n    let mut token_owner_record_data = get_token_owner_record_data_for_realm_and_governing_mint(\n        program_id,\n        token_owner_record_info,\n        realm_info.key,\n        governing_token_mint_info.key,\n    )?;\n\n    // If the governing token owner voluntarily revokes their own membership then\n    // the owner must sign the transaction\n    if *revoke_authority_info.key == token_owner_record_data.governing_token_owner {\n        if !revoke_authority_info.is_signer {\n            return Err(GovernanceError::GoverningTokenOwnerMustSign.into());\n        }\n    } else {\n        // If its a forceful membership revocation then the governing_token_mint\n        // authority must sign the transaction\n        assert_spl_token_mint_authority_is_signer(\n            governing_token_mint_info,\n            revoke_authority_info,\n        )?;\n    }\n\n    token_owner_record_data.governing_token_deposit_amount = token_owner_record_data\n        .governing_token_deposit_amount\n        .checked_sub(amount)\n        .ok_or(GovernanceError::InvalidRevokeAmount)?;\n\n    token_owner_record_data.serialize(&mut token_owner_record_info.data.borrow_mut()[..])?;\n\n    burn_spl_tokens_signed(\n        governing_token_holding_info,\n        governing_token_mint_info,\n        realm_info,\n        &get_realm_address_seeds(&realm_data.name),\n        program_id,\n        amount,\n        spl_token_info,\n    )?;\n\n    Ok(())\n}",
    "pub fn process_set_governance_config(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    config: GovernanceConfig,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n\n    let governance_info = next_account_info(account_info_iter)?; // 0\n\n    // Only governance PDA via a proposal can authorize change to its own config\n    if !governance_info.is_signer {\n        return Err(GovernanceError::GovernancePdaMustSign.into());\n    };\n\n    assert_is_valid_governance_config(&config)?;\n\n    let mut governance_data = get_governance_data(program_id, governance_info)?;\n\n    // Note: Config change leaves voting proposals in unpredictable state and it's\n    // DAOs responsibility to ensure the changes are made when there are no\n    // proposals in voting state For example changing approval quorum could\n    // accidentally make proposals to succeed which would otherwise be defeated\n\n    governance_data.config = config;\n\n    governance_data.serialize(&mut governance_info.data.borrow_mut()[..])?;\n\n    Ok(())\n}",
    "pub fn process_set_governance_delegate(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    new_governance_delegate: &Option<Pubkey>,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n\n    let governance_authority_info = next_account_info(account_info_iter)?; // 0\n    let token_owner_record_info = next_account_info(account_info_iter)?; // 1\n\n    let mut token_owner_record_data =\n        get_token_owner_record_data(program_id, token_owner_record_info)?;\n\n    token_owner_record_data.assert_token_owner_or_delegate_is_signer(governance_authority_info)?;\n\n    token_owner_record_data.governance_delegate = *new_governance_delegate;\n    token_owner_record_data.serialize(&mut token_owner_record_info.data.borrow_mut()[..])?;\n\n    Ok(())\n}",
    "pub fn process_set_realm_authority(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    action: SetRealmAuthorityAction,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n\n    let realm_info = next_account_info(account_info_iter)?; // 0\n    let realm_authority_info = next_account_info(account_info_iter)?; // 1\n\n    let mut realm_data =\n        get_realm_data_for_authority(program_id, realm_info, realm_authority_info.key)?;\n\n    if !realm_authority_info.is_signer {\n        return Err(GovernanceError::RealmAuthorityMustSign.into());\n    }\n\n    let new_realm_authority = match action {\n        SetRealmAuthorityAction::SetUnchecked | SetRealmAuthorityAction::SetChecked => {\n            let new_realm_authority_info = next_account_info(account_info_iter)?; // 2\n\n            if action == SetRealmAuthorityAction::SetChecked {\n                // Ensure the new realm authority is one of the governances from the realm\n                assert_governance_for_realm(program_id, new_realm_authority_info, realm_info.key)?;\n            }\n\n            Some(*new_realm_authority_info.key)\n        }",
    "pub fn process_set_realm_config(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    realm_config_args: RealmConfigArgs,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n\n    let realm_info = next_account_info(account_info_iter)?; // 0\n    let realm_authority_info = next_account_info(account_info_iter)?; // 1\n\n    let mut realm_data =\n        get_realm_data_for_authority(program_id, realm_info, realm_authority_info.key)?;\n\n    if !realm_authority_info.is_signer {\n        return Err(GovernanceError::RealmAuthorityMustSign.into());\n    }\n\n    // Note: Config change leaves voting proposals in unpredictable state and it's\n    // DAOs responsibility to ensure the changes are made when there are no\n    // proposals in voting state For example changing voter-weight or\n    // max-voter-weight addin could accidentally make proposals to succeed which\n    // would otherwise be defeated\n\n    assert_valid_realm_config_args(&realm_config_args)?;\n\n    // Setup council\n    if realm_config_args.use_council_mint {\n        let council_token_mint_info = next_account_info(account_info_iter)?; // 2\n        let _council_token_holding_info = next_account_info(account_info_iter)?; // 3\n\n        // Council mint can only be at present set to None (removed) and changing it to\n        // other mint is not supported It might be implemented in future\n        // versions but it needs careful planning It can potentially open a can\n        // of warms like what happens with existing deposits or pending proposals\n        if let Some(council_token_mint) = realm_data.config.council_mint {\n            // Council mint can't be changed to different one\n            if council_token_mint != *council_token_mint_info.key {\n                return Err(GovernanceError::RealmCouncilMintChangeIsNotSupported.into());\n            }\n        } else {\n            // Council mint can't be restored (changed from None)\n            return Err(GovernanceError::RealmCouncilMintChangeIsNotSupported.into());\n        }\n    } else {\n        // Remove council mint from realm\n        // Note: In the current implementation this also makes it impossible to withdraw\n        // council tokens\n        realm_data.config.council_mint = None;\n    }\n\n    let system_info = next_account_info(account_info_iter)?; // 4\n\n    let realm_config_info = next_account_info(account_info_iter)?; // 5\n    let mut realm_config_data =\n        get_realm_config_data_for_realm(program_id, realm_config_info, realm_info.key)?;\n\n    realm_config_data.assert_can_change_config(&realm_config_args)?;\n\n    // Setup configs for tokens (plugins and token types)\n\n    // 6, 7\n    let community_token_config = resolve_governing_token_config(\n        account_info_iter,\n        &realm_config_args.community_token_config_args,\n        Some(realm_config_data.community_token_config.clone()),\n    )?;\n\n    // 8, 9\n    let council_token_config = resolve_governing_token_config(\n        account_info_iter,\n        &realm_config_args.council_token_config_args,\n        Some(realm_config_data.council_token_config.clone()),\n    )?;\n\n    realm_config_data.community_token_config = community_token_config;\n    realm_config_data.council_token_config = council_token_config;\n\n    let payer_info = next_account_info(account_info_iter)?; // 10\n    let rent = Rent::get()?;\n\n    realm_config_data.serialize(\n        program_id,\n        realm_config_info,\n        payer_info,\n        system_info,\n        &rent,\n    )?;\n\n    // Update RealmConfig (Realm.config field)\n    realm_data.config.community_mint_max_voter_weight_source =\n        realm_config_args.community_mint_max_voter_weight_source;\n\n    realm_data.config.min_community_weight_to_create_governance =\n        realm_config_args.min_community_weight_to_create_governance;\n\n    realm_data.config.legacy1 = 0;\n    realm_data.config.legacy2 = 0;\n\n    realm_data.serialize(&mut realm_info.data.borrow_mut()[..])?;\n\n    Ok(())\n}",
    "pub fn process_set_realm_config_item(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    args: SetRealmConfigItemArgs,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n\n    let realm_info = next_account_info(account_info_iter)?; // 0\n    let realm_config_info = next_account_info(account_info_iter)?; // 1\n    let realm_authority_info = next_account_info(account_info_iter)?; // 2\n    let payer_info = next_account_info(account_info_iter)?; // 3\n    let system_info = next_account_info(account_info_iter)?; // 4\n\n    let rent = Rent::get()?;\n\n    let realm_data =\n        get_realm_data_for_authority(program_id, realm_info, realm_authority_info.key)?;\n\n    if !realm_authority_info.is_signer {\n        return Err(GovernanceError::RealmAuthorityMustSign.into());\n    }\n\n    let mut realm_config_data =\n        get_realm_config_data_for_realm(program_id, realm_config_info, realm_info.key)?;\n\n    match args {\n        SetRealmConfigItemArgs::TokenOwnerRecordLockAuthority {\n            action,\n            governing_token_mint,\n            authority,\n        } => {\n            let token_config =\n                realm_config_data.get_token_config_mut(&realm_data, &governing_token_mint)?;\n\n            match action {\n                SetConfigItemActionType::Add => {\n                    if token_config.lock_authorities.contains(&authority) {\n                        return Err(\n                            GovernanceError::TokenOwnerRecordLockAuthorityAlreadyExists.into()\n                        );\n                    }\n\n                    token_config.lock_authorities.push(authority);\n                }\n                SetConfigItemActionType::Remove => {\n                    if let Some(lock_authority_index) = token_config\n                        .lock_authorities\n                        .iter()\n                        .position(|lock_authority| lock_authority == &authority)\n                    {\n                        token_config.lock_authorities.remove(lock_authority_index);\n                    } else {\n                        return Err(GovernanceError::TokenOwnerRecordLockAuthorityNotFound.into());\n                    }\n                }\n            }\n        }\n    }\n\n    realm_config_data.serialize(\n        program_id,\n        realm_config_info,\n        payer_info,\n        system_info,\n        &rent,\n    )?;\n\n    Ok(())\n}",
    "pub fn process_set_token_owner_record_lock(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    lock_id: u8,\n    expiry: Option<UnixTimestamp>,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n\n    let realm_info = next_account_info(account_info_iter)?; // 0\n    let realm_config_info = next_account_info(account_info_iter)?; // 1\n    let token_owner_record_info = next_account_info(account_info_iter)?; // 2\n    let token_owner_record_lock_authority_info = next_account_info(account_info_iter)?; // 3\n    let payer_info = next_account_info(account_info_iter)?; // 4\n    let system_info = next_account_info(account_info_iter)?; // 5\n\n    let rent = Rent::get()?;\n    let clock = Clock::get()?;\n\n    if !token_owner_record_lock_authority_info.is_signer {\n        return Err(GovernanceError::TokenOwnerRecordLockAuthorityMustSign.into());\n    }\n\n    let token_owner_record_lock = TokenOwnerRecordLock {\n        lock_id,\n        authority: *token_owner_record_lock_authority_info.key,\n        expiry,\n    };\n\n    // Reject the lock if already expired\n    if token_owner_record_lock.is_expired(clock.unix_timestamp) {\n        return Err(GovernanceError::ExpiredTokenOwnerRecordLock.into());\n    }\n\n    let realm_data = get_realm_data(program_id, realm_info)?;\n    let realm_config_data =\n        get_realm_config_data_for_realm(program_id, realm_config_info, realm_info.key)?;\n\n    let mut token_owner_record_data = get_token_owner_record_data_for_realm(\n        program_id,\n        token_owner_record_info,\n        &realm_config_data.realm,\n    )?;\n\n    if !realm_config_data\n        .get_token_config(&realm_data, &token_owner_record_data.governing_token_mint)?\n        .lock_authorities\n        .contains(token_owner_record_lock_authority_info.key)\n    {\n        return Err(GovernanceError::InvalidTokenOwnerRecordLockAuthority.into());\n    }\n\n    // Trim expired locks\n    token_owner_record_data.remove_expired_locks(clock.unix_timestamp);\n\n    // Add or update the lock for the given authority and lock id\n    token_owner_record_data.upsert_lock(token_owner_record_lock);\n\n    token_owner_record_data.serialize_with_resize(\n        token_owner_record_info,\n        payer_info,\n        system_info,\n        &rent,\n    )?;\n\n    Ok(())\n}",
    "pub fn process_sign_off_proposal(program_id: &Pubkey, accounts: &[AccountInfo]) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n\n    let realm_info = next_account_info(account_info_iter)?; // 0\n    let governance_info = next_account_info(account_info_iter)?; // 1\n    let proposal_info = next_account_info(account_info_iter)?; // 2\n\n    let signatory_info = next_account_info(account_info_iter)?; // 3\n\n    let clock = Clock::get()?;\n\n    assert_is_valid_realm(program_id, realm_info)?;\n\n    let governance_data =\n        get_governance_data_for_realm(program_id, governance_info, realm_info.key)?;\n\n    let mut proposal_data =\n        get_proposal_data_for_governance(program_id, proposal_info, governance_info.key)?;\n\n    proposal_data.assert_can_sign_off()?;\n\n    if governance_data.required_signatories_count > 0\n        && proposal_data.signatories_count < governance_data.required_signatories_count\n    {\n        return Err(GovernanceError::MissingRequiredSignatories.into());\n    }\n\n    // If the owner of the proposal hasn't appointed any signatories then can sign\n    // off the proposal themself\n    if proposal_data.signatories_count == 0 {\n        let proposal_owner_record_info = next_account_info(account_info_iter)?; // 4\n\n        let proposal_owner_record_data = get_token_owner_record_data_for_proposal_owner(\n            program_id,\n            proposal_owner_record_info,\n            &proposal_data.token_owner_record,\n        )?;\n\n        // Proposal owner (TokenOwner) or its governance_delegate must be the signatory\n        // and sign this transaction\n        proposal_owner_record_data.assert_token_owner_or_delegate_is_signer(signatory_info)?;\n\n        proposal_data.signing_off_at = Some(clock.unix_timestamp);\n    } else {\n        let signatory_record_info = next_account_info(account_info_iter)?; // 4\n\n        let mut signatory_record_data = get_signatory_record_data_for_seeds(\n            program_id,\n            signatory_record_info,\n            proposal_info.key,\n            signatory_info.key,\n        )?;\n\n        signatory_record_data.assert_can_sign_off(signatory_info)?;\n\n        signatory_record_data.signed_off = true;\n        signatory_record_data.serialize(&mut signatory_record_info.data.borrow_mut()[..])?;\n\n        if proposal_data.signatories_signed_off_count == 0 {\n            proposal_data.signing_off_at = Some(clock.unix_timestamp);\n            proposal_data.state = ProposalState::SigningOff;\n        }\n\n        proposal_data.signatories_signed_off_count = proposal_data\n            .signatories_signed_off_count\n            .checked_add(1)\n            .unwrap();\n    }\n\n    // If all Signatories signed off we can start voting\n    if proposal_data.signatories_signed_off_count == proposal_data.signatories_count {\n        proposal_data.voting_at = Some(clock.unix_timestamp);\n        proposal_data.voting_at_slot = Some(clock.slot);\n        proposal_data.state = ProposalState::Voting;\n    }\n\n    proposal_data.serialize(&mut proposal_info.data.borrow_mut()[..])?;\n\n    Ok(())\n}",
    "pub fn process_update_program_metadata(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n\n    let program_metadata_info = next_account_info(account_info_iter)?; // 0\n    let payer_info = next_account_info(account_info_iter)?; // 1\n    let system_info = next_account_info(account_info_iter)?; // 2\n\n    let rent = Rent::get()?;\n    let updated_at = Clock::get()?.slot;\n\n    const VERSION: &str = env!(\"CARGO_PKG_VERSION\");\n\n    // Put the metadata info into the logs to make it possible to extract it using\n    // Tx simulation\n    msg!(\"PROGRAM-VERSION:{:?}\", VERSION);\n\n    if program_metadata_info.data_is_empty() {\n        let program_metadata_data = ProgramMetadata {\n            account_type: GovernanceAccountType::ProgramMetadata,\n            updated_at,\n            version: VERSION.to_string(),\n            reserved: [0; 64],\n        };\n\n        create_and_serialize_account_signed(\n            payer_info,\n            program_metadata_info,\n            &program_metadata_data,\n            &get_program_metadata_seeds(),\n            program_id,\n            system_info,\n            &rent,\n            0,\n        )?;\n    } else {\n        let mut program_metadata_data =\n            get_program_metadata_data(program_id, program_metadata_info)?;\n\n        program_metadata_data.version = VERSION.to_string();\n        program_metadata_data.updated_at = updated_at;\n\n        borsh::to_writer(\n            &mut program_metadata_info.data.borrow_mut()[..],\n            &program_metadata_data,\n        )?;\n    }\n\n    Ok(())\n}",
    "pub fn process_withdraw_governing_tokens(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n\n    let realm_info = next_account_info(account_info_iter)?; // 0\n    let governing_token_holding_info = next_account_info(account_info_iter)?; // 1\n    let governing_token_destination_info = next_account_info(account_info_iter)?; // 2\n    let governing_token_owner_info = next_account_info(account_info_iter)?; // 3\n    let token_owner_record_info = next_account_info(account_info_iter)?; // 4\n    let spl_token_info = next_account_info(account_info_iter)?; // 5\n    let realm_config_info = next_account_info(account_info_iter)?; // 6\n    let clock = Clock::get()?;\n\n    if !governing_token_owner_info.is_signer {\n        return Err(GovernanceError::GoverningTokenOwnerMustSign.into());\n    }\n\n    let realm_data = get_realm_data(program_id, realm_info)?;\n    let governing_token_mint = get_spl_token_mint(governing_token_holding_info)?;\n\n    realm_data.assert_is_valid_governing_token_mint_and_holding(\n        program_id,\n        realm_info.key,\n        &governing_token_mint,\n        governing_token_holding_info.key,\n    )?;\n\n    let realm_config_data =\n        get_realm_config_data_for_realm(program_id, realm_config_info, realm_info.key)?;\n\n    realm_config_data.assert_can_withdraw_governing_token(&realm_data, &governing_token_mint)?;\n\n    let token_owner_record_address_seeds = get_token_owner_record_address_seeds(\n        realm_info.key,\n        &governing_token_mint,\n        governing_token_owner_info.key,\n    );\n\n    let mut token_owner_record_data = get_token_owner_record_data_for_seeds(\n        program_id,\n        token_owner_record_info,\n        &token_owner_record_address_seeds,\n    )?;\n\n    token_owner_record_data.assert_can_withdraw_governing_tokens(clock.unix_timestamp)?;\n\n    transfer_spl_tokens_signed(\n        governing_token_holding_info,\n        governing_token_destination_info,\n        realm_info,\n        &get_realm_address_seeds(&realm_data.name),\n        program_id,\n        token_owner_record_data.governing_token_deposit_amount,\n        spl_token_info,\n    )?;\n\n    token_owner_record_data.governing_token_deposit_amount = 0;\n    token_owner_record_data.serialize(&mut token_owner_record_info.data.borrow_mut()[..])?;\n\n    Ok(())\n}",
    "pub fn is_governance_v2_account_type(account_type: &GovernanceAccountType) -> bool {\n    match account_type {\n        GovernanceAccountType::GovernanceV2\n        | GovernanceAccountType::ProgramGovernanceV2\n        | GovernanceAccountType::MintGovernanceV2\n        | GovernanceAccountType::TokenGovernanceV2 => true,\n        GovernanceAccountType::Uninitialized\n        | GovernanceAccountType::RealmV1\n        | GovernanceAccountType::RealmV2\n        | GovernanceAccountType::RealmConfig\n        | GovernanceAccountType::TokenOwnerRecordV1\n        | GovernanceAccountType::TokenOwnerRecordV2\n        | GovernanceAccountType::GovernanceV1\n        | GovernanceAccountType::ProgramGovernanceV1\n        | GovernanceAccountType::MintGovernanceV1\n        | GovernanceAccountType::TokenGovernanceV1\n        | GovernanceAccountType::ProposalV1\n        | GovernanceAccountType::ProposalV2\n        | GovernanceAccountType::SignatoryRecordV1\n        | GovernanceAccountType::SignatoryRecordV2\n        | GovernanceAccountType::ProposalInstructionV1\n        | GovernanceAccountType::ProposalTransactionV2\n        | GovernanceAccountType::VoteRecordV1\n        | GovernanceAccountType::VoteRecordV2\n        | GovernanceAccountType::ProgramMetadata\n        | GovernanceAccountType::ProposalDeposit\n        | GovernanceAccountType::RequiredSignatory => false,\n    }\n}\n\n/// Returns GovernanceV2 type for given GovernanceV1 type or None if the given\n/// account type is not GovernanceV1\npub fn try_get_governance_v2_type_for_v1(\n    account_type: &GovernanceAccountType,\n) -> Option<GovernanceAccountType> {\n    match account_type {\n        GovernanceAccountType::GovernanceV1 => Some(GovernanceAccountType::GovernanceV2),\n        GovernanceAccountType::ProgramGovernanceV1 => {\n            Some(GovernanceAccountType::ProgramGovernanceV2)\n        }",
    "pub fn is_governance_account_type(account_type: &GovernanceAccountType) -> bool {\n    is_governance_v1_account_type(account_type) || is_governance_v2_account_type(account_type)\n}",
    "pub fn get_governance_address_seeds(&self) -> Result<[&[u8]; 3], ProgramError> {\n        let seeds = match self.account_type {\n            GovernanceAccountType::GovernanceV1 | GovernanceAccountType::GovernanceV2 => {\n                get_governance_address_seeds(&self.realm, &self.governance_seed)\n            }",
    "pub fn assert_governing_token_mint_can_vote(\n        &self,\n        realm_data: &RealmV2,\n        vote_governing_token_mint: &Pubkey,\n        vote_kind: &VoteKind,\n    ) -> Result<(), ProgramError> {\n        // resolve_vote_threshold() asserts the vote threshold exists for the given\n        // governing_token_mint and is not disabled\n        let _ = self.resolve_vote_threshold(realm_data, vote_governing_token_mint, vote_kind)?;\n\n        Ok(())\n    }",
    "pub fn resolve_vote_threshold(\n        &self,\n        realm_data: &RealmV2,\n        vote_governing_token_mint: &Pubkey,\n        vote_kind: &VoteKind,\n    ) -> Result<VoteThreshold, ProgramError> {\n        let vote_threshold = if realm_data.community_mint == *vote_governing_token_mint {\n            match vote_kind {\n                VoteKind::Electorate => &self.config.community_vote_threshold,\n                VoteKind::Veto => &self.config.community_veto_vote_threshold,\n            }\n        } else if realm_data.config.council_mint == Some(*vote_governing_token_mint) {\n            match vote_kind {\n                VoteKind::Electorate => &self.config.council_vote_threshold,\n                VoteKind::Veto => &self.config.council_veto_vote_threshold,\n            }\n        } else {\n            return Err(GovernanceError::InvalidGoverningTokenMint.into());\n        };\n\n        if *vote_threshold == VoteThreshold::Disabled {\n            return Err(GovernanceError::GoverningTokenMintNotAllowedToVote.into());\n        }\n\n        Ok(vote_threshold.clone())\n    }",
    "pub fn get_vote_tipping(\n        &self,\n        realm_data: &RealmV2,\n        governing_token_mint: &Pubkey,\n    ) -> Result<&VoteTipping, ProgramError> {\n        let vote_tipping = if *governing_token_mint == realm_data.community_mint {\n            &self.config.community_vote_tipping\n        } else if Some(*governing_token_mint) == realm_data.config.council_mint {\n            &self.config.council_vote_tipping\n        } else {\n            return Err(GovernanceError::InvalidGoverningTokenMint.into());\n        };\n\n        Ok(vote_tipping)\n    }",
    "pub fn get_proposal_deposit_amount(&self) -> u64 {\n        self.active_proposal_count\n            .saturating_sub(self.config.deposit_exempt_proposal_count as u64)\n            .saturating_mul(SECURITY_DEPOSIT_BASE_LAMPORTS)\n    }",
    "pub fn get_governance_data(\n    program_id: &Pubkey,\n    governance_info: &AccountInfo,\n) -> Result<GovernanceV2, ProgramError> {\n    let account_type: GovernanceAccountType = get_account_type(program_id, governance_info)?;\n\n    // If the account is V1 version then translate to V2\n    let mut governance_data = if is_governance_v1_account_type(&account_type) {\n        let governance_data_v1 = get_account_data::<GovernanceV1>(program_id, governance_info)?;\n\n        GovernanceV2 {\n            account_type,\n            realm: governance_data_v1.realm,\n            governance_seed: governance_data_v1.governance_seed,\n            reserved1: 0,\n            config: governance_data_v1.config,\n            reserved_v2: Reserved119::default(),\n            required_signatories_count: 0,\n            // GovernanceV1 layout doesn't support active_proposal_count\n            // For any legacy GovernanceV1 account it's not preserved until the account layout is\n            // migrated to GovernanceV2 in CreateProposal\n            active_proposal_count: 0,\n        }\n    } else {\n        get_account_data::<GovernanceV2>(program_id, governance_info)?\n    };\n\n    // In previous versions of spl-gov (< 3) we had\n    // config.proposal_cool_off_time:u32 which was unused and always 0\n    // In version 3.0.0 proposal_cool_off_time was replaced with\n    // council_vote_threshold:VoteThreshold and\n    // council_veto_vote_threshold:VoteThreshold If we read a legacy account\n    // then council_vote_threshold == VoteThreshold::YesVotePercentage(0)\n    //\n    // Note: assert_is_valid_governance_config() prevents setting\n    // council_vote_threshold to VoteThreshold::YesVotePercentage(0) which gives\n    // as guarantee that it is a legacy account layout set with\n    // proposal_cool_off_time = 0\n    //\n    // Note: All the settings below are one time config migration from program V1 &\n    // V2 account data to V3\n    if governance_data.config.council_vote_threshold == VoteThreshold::YesVotePercentage(0) {\n        // Set council_vote_threshold to community_vote_threshold which was used for\n        // both council and community thresholds before\n        governance_data.config.council_vote_threshold =\n            governance_data.config.community_vote_threshold.clone();\n\n        // The assumption here is that council should have Veto vote enabled by default\n        // and equal to council_vote_threshold\n        governance_data.config.council_veto_vote_threshold =\n            governance_data.config.council_vote_threshold.clone();\n\n        // For legacy accounts default Council VoteTipping to the Community\n        governance_data.config.council_vote_tipping =\n            governance_data.config.community_vote_tipping.clone();\n\n        // For legacy accounts set the community Veto threshold to Disabled\n        governance_data.config.community_veto_vote_threshold = VoteThreshold::Disabled;\n\n        // Reset voting_cool_off_time and deposit_exempt_proposal_count  previously used\n        // for voting_proposal_count\n        governance_data.config.voting_cool_off_time = 0;\n        governance_data.config.deposit_exempt_proposal_count =\n            DEFAULT_DEPOSIT_EXEMPT_PROPOSAL_COUNT;\n\n        // Reset reserved space previously used for proposal_count\n        governance_data.reserved1 = 0;\n    }\n\n    Ok(governance_data)\n}",
    "pub fn get_governance_data_for_realm(\n    program_id: &Pubkey,\n    governance_info: &AccountInfo,\n    realm: &Pubkey,\n) -> Result<GovernanceV2, ProgramError> {\n    let governance_data = get_governance_data(program_id, governance_info)?;\n\n    if governance_data.realm != *realm {\n        return Err(GovernanceError::InvalidRealmForGovernance.into());\n    }\n\n    Ok(governance_data)\n}",
    "pub fn assert_governance_for_realm(\n    program_id: &Pubkey,\n    governance_info: &AccountInfo,\n    realm: &Pubkey,\n) -> Result<(), ProgramError> {\n    get_governance_data_for_realm(program_id, governance_info, realm)?;\n    Ok(())\n}",
    "pub fn assert_is_valid_governance(\n    program_id: &Pubkey,\n    governance_info: &AccountInfo,\n) -> Result<(), ProgramError> {\n    assert_is_valid_account_of_types(program_id, governance_info, is_governance_account_type)\n}",
    "pub fn assert_valid_create_governance_args(\n    program_id: &Pubkey,\n    governance_config: &GovernanceConfig,\n    realm_info: &AccountInfo,\n) -> Result<(), ProgramError> {\n    assert_is_valid_realm(program_id, realm_info)?;\n\n    assert_is_valid_governance_config(governance_config)?;\n\n    Ok(())\n}",
    "pub fn assert_is_valid_governance_config(\n    governance_config: &GovernanceConfig,\n) -> Result<(), ProgramError> {\n    assert_is_valid_vote_threshold(&governance_config.community_vote_threshold)?;\n    assert_is_valid_vote_threshold(&governance_config.community_veto_vote_threshold)?;\n\n    assert_is_valid_vote_threshold(&governance_config.council_vote_threshold)?;\n    assert_is_valid_vote_threshold(&governance_config.council_veto_vote_threshold)?;\n\n    // Setting both thresholds to Disabled is not allowed, however we might\n    // reconsider it as a way to disable Governance permanently\n    if governance_config.community_vote_threshold == VoteThreshold::Disabled\n        && governance_config.council_vote_threshold == VoteThreshold::Disabled\n    {\n        return Err(GovernanceError::AtLeastOneVoteThresholdRequired.into());\n    }\n\n    // Make u8::MAX invalid value in case we would like to use the magic number as\n    // Disabled value in the future\n    if governance_config.deposit_exempt_proposal_count == u8::MAX {\n        return Err(GovernanceError::InvalidDepositExemptProposalCount.into());\n    }\n\n    Ok(())\n}",
    "pub fn assert_is_valid_vote_threshold(vote_threshold: &VoteThreshold) -> Result<(), ProgramError> {\n    match *vote_threshold {\n        VoteThreshold::YesVotePercentage(yes_vote_threshold_percentage) => {\n            if !(1..=100).contains(&yes_vote_threshold_percentage) {\n                return Err(GovernanceError::InvalidVoteThresholdPercentage.into());\n            }\n        }\n        VoteThreshold::QuorumPercentage(_) => {\n            return Err(GovernanceError::VoteThresholdTypeNotSupported.into());\n        }\n        VoteThreshold::Disabled => {}\n    }\n\n    Ok(())\n}",
    "pub fn is_governance_v1_account_type(account_type: &GovernanceAccountType) -> bool {\n    match account_type {\n        GovernanceAccountType::GovernanceV1\n        | GovernanceAccountType::ProgramGovernanceV1\n        | GovernanceAccountType::MintGovernanceV1\n        | GovernanceAccountType::TokenGovernanceV1 => true,\n        GovernanceAccountType::Uninitialized\n        | GovernanceAccountType::RealmV1\n        | GovernanceAccountType::RealmV2\n        | GovernanceAccountType::RealmConfig\n        | GovernanceAccountType::TokenOwnerRecordV1\n        | GovernanceAccountType::TokenOwnerRecordV2\n        | GovernanceAccountType::GovernanceV2\n        | GovernanceAccountType::ProgramGovernanceV2\n        | GovernanceAccountType::MintGovernanceV2\n        | GovernanceAccountType::TokenGovernanceV2\n        | GovernanceAccountType::ProposalV1\n        | GovernanceAccountType::ProposalV2\n        | GovernanceAccountType::SignatoryRecordV1\n        | GovernanceAccountType::SignatoryRecordV2\n        | GovernanceAccountType::ProposalInstructionV1\n        | GovernanceAccountType::ProposalTransactionV2\n        | GovernanceAccountType::VoteRecordV1\n        | GovernanceAccountType::VoteRecordV2\n        | GovernanceAccountType::ProgramMetadata\n        | GovernanceAccountType::ProposalDeposit\n        | GovernanceAccountType::RequiredSignatory => false,\n    }\n}\n\nimpl IsInitialized for GovernanceV1 {\n    fn is_initialized(&self) -> bool {\n        is_governance_v1_account_type(&self.account_type)\n    }",
    "pub fn get_program_metadata_address(program_id: &Pubkey) -> Pubkey {\n    Pubkey::find_program_address(&get_program_metadata_seeds(), program_id).0\n}\n\n/// Returns ProgramMetadata PDA seeds\npub fn get_program_metadata_seeds<'a>() -> [&'a [u8]; 1] {\n    [b\"metadata\"]\n}\n\n/// Deserializes account and checks owner program\npub fn get_program_metadata_data(\n    program_id: &Pubkey,\n    program_metadata_info: &AccountInfo,\n) -> Result<ProgramMetadata, ProgramError> {\n    get_account_data::<ProgramMetadata>(program_id, program_metadata_info)\n}",
    "pub fn assert_can_edit_signatories(&self) -> Result<(), ProgramError> {\n        self.assert_is_draft_state()\n            .map_err(|_| GovernanceError::InvalidStateCannotEditSignatories.into())\n    }",
    "pub fn assert_can_sign_off(&self) -> Result<(), ProgramError> {\n        match self.state {\n            ProposalState::Draft | ProposalState::SigningOff => Ok(()),\n            ProposalState::Executing\n            | ProposalState::ExecutingWithErrors\n            | ProposalState::Completed\n            | ProposalState::Cancelled\n            | ProposalState::Voting\n            | ProposalState::Succeeded\n            | ProposalState::Defeated\n            | ProposalState::Vetoed => Err(GovernanceError::InvalidStateCannotSignOff.into()),\n        }\n    }\n\n    /// Checks the Proposal is in Voting state\n    fn assert_is_voting_state(&self) -> Result<(), ProgramError> {\n        if self.state != ProposalState::Voting {\n            return Err(GovernanceError::InvalidProposalState.into());\n        }\n\n        Ok(())\n    }",
    "pub fn assert_is_final_state(&self) -> Result<(), ProgramError> {\n        match self.state {\n            ProposalState::Completed\n            | ProposalState::Cancelled\n            | ProposalState::Defeated\n            | ProposalState::Vetoed => Ok(()),\n            ProposalState::Executing\n            | ProposalState::ExecutingWithErrors\n            | ProposalState::SigningOff\n            | ProposalState::Voting\n            | ProposalState::Draft\n            | ProposalState::Succeeded => Err(GovernanceError::InvalidStateNotFinal.into()),\n        }\n    }\n\n    /// Checks if Proposal can be voted on\n    pub fn assert_can_cast_vote(\n        &self,\n        config: &GovernanceConfig,\n        vote: &Vote,\n        current_unix_timestamp: UnixTimestamp,\n    ) -> Result<(), ProgramError> {\n        self.assert_is_voting_state()\n            .map_err(|_| GovernanceError::InvalidStateCannotVote)?;\n\n        // Check if we are still within the configured max voting time period\n        if self.has_voting_max_time_ended(config, current_unix_timestamp) {\n            return Err(GovernanceError::ProposalVotingTimeExpired.into());\n        }\n\n        match vote {\n            Vote::Approve(_) | Vote::Abstain => {\n                // Once the base voting time passes and we are in the voting cool off time\n                // approving votes are no longer accepted Abstain is considered\n                // as positive vote because when attendance quorum is used it can tip the scales\n                if self.has_voting_base_time_ended(config, current_unix_timestamp) {\n                    Err(GovernanceError::VoteNotAllowedInCoolOffTime.into())\n                }",
    "pub fn assert_can_refund_proposal_deposit(&self) -> Result<(), ProgramError> {\n        match self.state {\n            ProposalState::Succeeded\n            | ProposalState::Executing\n            | ProposalState::Completed\n            | ProposalState::Cancelled\n            | ProposalState::Defeated\n            | ProposalState::ExecutingWithErrors\n            | ProposalState::Vetoed => Ok(()),\n            ProposalState::Draft | ProposalState::SigningOff | ProposalState::Voting => {\n                Err(GovernanceError::CannotRefundProposalDeposit.into())\n            }",
    "pub fn voting_base_time_end(&self, config: &GovernanceConfig) -> UnixTimestamp {\n        self.voting_at\n            .unwrap()\n            .checked_add(config.voting_base_time as i64)\n            .unwrap()\n    }",
    "pub fn has_voting_base_time_ended(\n        &self,\n        config: &GovernanceConfig,\n        current_unix_timestamp: UnixTimestamp,\n    ) -> bool {\n        // Check if we passed the configured base vote end time\n        self.voting_base_time_end(config) < current_unix_timestamp\n    }\n\n    /// Expected max vote end time determined by the configured\n    /// base_voting_time, optional voting_cool_off_time and actual voting start\n    /// time\n    pub fn voting_max_time_end(&self, config: &GovernanceConfig) -> UnixTimestamp {\n        self.voting_base_time_end(config)\n            .checked_add(config.voting_cool_off_time as i64)\n            .unwrap()\n    }",
    "pub fn has_voting_max_time_ended(\n        &self,\n        config: &GovernanceConfig,\n        current_unix_timestamp: UnixTimestamp,\n    ) -> bool {\n        // Check if we passed the max vote end time\n        self.voting_max_time_end(config) < current_unix_timestamp\n    }\n\n    /// Checks if Proposal can be finalized\n    pub fn assert_can_finalize_vote(\n        &self,\n        config: &GovernanceConfig,\n        current_unix_timestamp: UnixTimestamp,\n    ) -> Result<(), ProgramError> {\n        self.assert_is_voting_state()\n            .map_err(|_| GovernanceError::InvalidStateCannotFinalize)?;\n\n        // We can only finalize the vote after the configured max_voting_time has\n        // expired and vote time ended\n        if !self.has_voting_max_time_ended(config, current_unix_timestamp) {\n            return Err(GovernanceError::CannotFinalizeVotingInProgress.into());\n        }\n\n        Ok(())\n    }",
    "pub fn finalize_vote(\n        &mut self,\n        max_voter_weight: u64,\n        config: &GovernanceConfig,\n        current_unix_timestamp: UnixTimestamp,\n        vote_threshold: &VoteThreshold,\n    ) -> Result<(), ProgramError> {\n        self.assert_can_finalize_vote(config, current_unix_timestamp)?;\n\n        self.state = self.resolve_final_vote_state(max_voter_weight, vote_threshold)?;\n        self.voting_completed_at = Some(self.voting_max_time_end(config));\n\n        // Capture vote params to correctly display historical results\n        self.max_vote_weight = Some(max_voter_weight);\n        self.vote_threshold = Some(vote_threshold.clone());\n\n        Ok(())\n    }",
    "pub fn resolve_max_voter_weight(\n        &mut self,\n        account_info_iter: &mut Iter<AccountInfo>,\n        realm: &Pubkey,\n        realm_data: &RealmV2,\n        realm_config_data: &RealmConfigAccount,\n        vote_governing_token_mint_info: &AccountInfo,\n        vote_kind: &VoteKind,\n    ) -> Result<u64, ProgramError> {\n        // if the Realm is configured to use max voter weight for the given voting\n        // governing_token_mint then use the externally provided max_voter_weight\n        // instead of the supply based max\n        if let Some(max_voter_weight_addin) = realm_config_data\n            .get_token_config(realm_data, vote_governing_token_mint_info.key)?\n            .max_voter_weight_addin\n        {\n            let max_voter_weight_record_info = next_account_info(account_info_iter)?;\n\n            let max_voter_weight_record_data =\n                get_max_voter_weight_record_data_for_realm_and_governing_token_mint(\n                    &max_voter_weight_addin,\n                    max_voter_weight_record_info,\n                    realm,\n                    vote_governing_token_mint_info.key,\n                )?;\n\n            assert_is_valid_max_voter_weight(&max_voter_weight_record_data)?;\n\n            // When the max voter weight addin is used it's possible it can be inaccurate\n            // and we can have more votes then the max provided by the addin and\n            // we have to adjust it to whatever result is higher\n            return Ok(self.coerce_max_voter_weight(\n                max_voter_weight_record_data.max_voter_weight,\n                vote_kind,\n            ));\n        }\n\n        let vote_governing_token_mint_supply =\n            get_spl_token_mint_supply(vote_governing_token_mint_info)?;\n\n        let max_voter_weight = self.get_max_voter_weight_from_mint_supply(\n            realm_data,\n            vote_governing_token_mint_info.key,\n            vote_governing_token_mint_supply,\n            vote_kind,\n        )?;\n\n        Ok(max_voter_weight)\n    }",
    "pub fn try_tip_vote(\n        &mut self,\n        max_voter_weight: u64,\n        vote_tipping: &VoteTipping,\n        current_unix_timestamp: UnixTimestamp,\n        vote_threshold: &VoteThreshold,\n        vote_kind: &VoteKind,\n    ) -> Result<bool, ProgramError> {\n        if let Some(tipped_state) = self.try_get_tipped_vote_state(\n            max_voter_weight,\n            vote_tipping,\n            vote_threshold,\n            vote_kind,\n        ) {\n            self.state = tipped_state;\n            self.voting_completed_at = Some(current_unix_timestamp);\n\n            // Capture vote params to correctly display historical results\n            // Note: For Veto vote the captured params are from the Veto config\n            self.max_vote_weight = Some(max_voter_weight);\n            self.vote_threshold = Some(vote_threshold.clone());\n\n            Ok(true)\n        }",
    "pub fn try_get_tipped_vote_state(\n        &mut self,\n        max_voter_weight: u64,\n        vote_tipping: &VoteTipping,\n        vote_threshold: &VoteThreshold,\n        vote_kind: &VoteKind,\n    ) -> Option<ProposalState> {\n        let min_vote_threshold_weight =\n            get_min_vote_threshold_weight(vote_threshold, max_voter_weight).unwrap();\n\n        match vote_kind {\n            VoteKind::Electorate => self.try_get_tipped_electorate_vote_state(\n                max_voter_weight,\n                vote_tipping,\n                min_vote_threshold_weight,\n            ),\n            VoteKind::Veto => self.try_get_tipped_veto_vote_state(min_vote_threshold_weight),\n        }\n    }\n\n    /// Checks if Electorate vote can be tipped and automatically transitioned\n    /// to Succeeded or Defeated state.\n    /// If yes then Some(ProposalState) is returned and None otherwise\n    fn try_get_tipped_electorate_vote_state(\n        &mut self,\n        max_voter_weight: u64,\n        vote_tipping: &VoteTipping,\n        min_vote_threshold_weight: u64,\n    ) -> Option<ProposalState> {\n        // Vote tipping is currently supported for SingleChoice votes with\n        // single Yes and No (rejection) options only.\n        // Note: Tipping for multiple options (single choice and multiple\n        // choices) should be possible but it requires a great deal of\n        // considerations and I decided to fight it another day\n        if self.vote_type != VoteType::SingleChoice\n            // Tipping should not be allowed for opinion only proposals (surveys\n            // without rejection) to allow everybody's voice to be heard\n            || self.deny_vote_weight.is_none()\n            || self.options.len() != 1\n        {\n            return None;\n        };\n\n        let yes_option = &mut self.options[0];\n\n        let yes_vote_weight = yes_option.vote_weight;\n        let deny_vote_weight = self.deny_vote_weight.unwrap();\n\n        match vote_tipping {\n            VoteTipping::Disabled => {}\n            VoteTipping::Strict => {\n                if yes_vote_weight >= min_vote_threshold_weight\n                    && yes_vote_weight > (max_voter_weight.saturating_sub(yes_vote_weight))\n                {\n                    yes_option.vote_result = OptionVoteResult::Succeeded;\n                    return Some(ProposalState::Succeeded);\n                }\n            }\n            VoteTipping::Early => {\n                if yes_vote_weight >= min_vote_threshold_weight\n                    && yes_vote_weight > deny_vote_weight\n                {\n                    yes_option.vote_result = OptionVoteResult::Succeeded;\n                    return Some(ProposalState::Succeeded);\n                }\n            }\n        }\n\n        // If vote tipping isn't disabled entirely, allow a vote to complete as\n        // \"defeated\" if there is no possible way of reaching majority or the\n        // min_vote_threshold_weight for another option. This tipping is always\n        // strict, there's no equivalent to \"early\" tipping for deny votes.\n        if *vote_tipping != VoteTipping::Disabled\n            && (deny_vote_weight > (max_voter_weight.saturating_sub(min_vote_threshold_weight))\n                || deny_vote_weight >= (max_voter_weight.saturating_sub(deny_vote_weight)))\n        {\n            yes_option.vote_result = OptionVoteResult::Defeated;\n            return Some(ProposalState::Defeated);\n        }\n\n        None\n    }\n\n    /// Checks if vote can be tipped and transitioned to Vetoed state\n    /// If yes then Some(ProposalState::Vetoed) is returned and None otherwise\n    fn try_get_tipped_veto_vote_state(\n        &mut self,\n        min_vote_threshold_weight: u64,\n    ) -> Option<ProposalState> {\n        // Veto vote tips as soon as the required threshold is reached\n        // It's irrespectively of vote_tipping config because the outcome of the\n        // Proposal can't change any longer after being vetoed\n        if self.veto_vote_weight >= min_vote_threshold_weight {\n            // Note: Since we don't tip multi option votes all options vote_result would\n            // remain as None\n            Some(ProposalState::Vetoed)\n        }",
    "pub fn assert_can_cancel(\n        &self,\n        config: &GovernanceConfig,\n        current_unix_timestamp: UnixTimestamp,\n    ) -> Result<(), ProgramError> {\n        match self.state {\n            ProposalState::Draft | ProposalState::SigningOff => Ok(()),\n            ProposalState::Voting => {\n                // Note: If there is no tipping point the proposal can be still in Voting state\n                // but already past the configured max_voting_time In that case\n                // we treat the proposal as finalized and it's no longer allowed to be canceled\n                if self.has_voting_max_time_ended(config, current_unix_timestamp) {\n                    return Err(GovernanceError::ProposalVotingTimeExpired.into());\n                }\n                Ok(())\n            }",
    "pub fn assert_can_edit_instructions(&self) -> Result<(), ProgramError> {\n        if self.assert_is_draft_state().is_err() {\n            return Err(GovernanceError::InvalidStateCannotEditTransactions.into());\n        }\n\n        // For security purposes only proposals with the reject option can have\n        // executable instructions\n        if self.deny_vote_weight.is_none() {\n            return Err(GovernanceError::ProposalIsNotExecutable.into());\n        }\n\n        Ok(())\n    }",
    "pub fn assert_can_execute_transaction(\n        &self,\n        proposal_transaction_data: &ProposalTransactionV2,\n        governance_config: &GovernanceConfig,\n        current_unix_timestamp: UnixTimestamp,\n    ) -> Result<(), ProgramError> {\n        match self.state {\n            ProposalState::Succeeded\n            | ProposalState::Executing\n            | ProposalState::ExecutingWithErrors => {}\n            ProposalState::Draft\n            | ProposalState::SigningOff\n            | ProposalState::Completed\n            | ProposalState::Voting\n            | ProposalState::Cancelled\n            | ProposalState::Defeated\n            | ProposalState::Vetoed => {\n                return Err(GovernanceError::InvalidStateCannotExecuteTransaction.into())\n            }",
    "pub fn assert_can_complete(&self) -> Result<(), ProgramError> {\n        // Proposal vote must be successful\n        if self.state != ProposalState::Succeeded {\n            return Err(GovernanceError::InvalidStateToCompleteProposal.into());\n        }\n\n        // There must be no on-chain executable actions\n        if self.options.iter().any(|o| o.transactions_count != 0) {\n            return Err(GovernanceError::InvalidStateToCompleteProposal.into());\n        }\n\n        Ok(())\n    }",
    "pub fn assert_valid_vote(&self, vote: &Vote) -> Result<(), ProgramError> {\n        match vote {\n            Vote::Approve(choices) => {\n                if self.options.len() != choices.len() {\n                    return Err(GovernanceError::InvalidNumberOfVoteChoices.into());\n                }\n\n                let mut choice_count = 0u16;\n                let mut total_choice_weight_percentage = 0u8;\n\n                for choice in choices {\n                    if choice.rank > 0 {\n                        return Err(GovernanceError::RankedVoteIsNotSupported.into());\n                    }\n\n                    if choice.weight_percentage > 0 {\n                        choice_count = choice_count.checked_add(1).unwrap();\n\n                        match self.vote_type {\n                            VoteType::MultiChoice {\n                                choice_type: MultiChoiceType::Weighted,\n                                min_voter_options: _,\n                                max_voter_options: _,\n                                max_winning_options: _,\n                            } => {\n                                // Calculate the total percentage for all choices for weighted\n                                // choice vote. The total must add up\n                                // to exactly 100%\n                                total_choice_weight_percentage = total_choice_weight_percentage\n                                    .checked_add(choice.weight_percentage)\n                                    .ok_or(GovernanceError::TotalVoteWeightMustBe100Percent)?;\n                            }\n                            _ => {\n                                if choice.weight_percentage != 100 {\n                                    return Err(\n                                        GovernanceError::ChoiceWeightMustBe100Percent.into()\n                                    );\n                                }\n                            }\n                        }\n                    }\n                }\n\n                match self.vote_type {\n                    VoteType::SingleChoice => {\n                        if choice_count != 1 {\n                            return Err(GovernanceError::SingleChoiceOnlyIsAllowed.into());\n                        }\n                    }\n                    VoteType::MultiChoice {\n                        choice_type: MultiChoiceType::FullWeight,\n                        min_voter_options: _,\n                        max_voter_options: _,\n                        max_winning_options: _,\n                    } => {\n                        if choice_count == 0 {\n                            return Err(GovernanceError::AtLeastSingleChoiceIsRequired.into());\n                        }\n                    }\n                    VoteType::MultiChoice {\n                        choice_type: MultiChoiceType::Weighted,\n                        min_voter_options: _,\n                        max_voter_options: _,\n                        max_winning_options: _,\n                    } => {\n                        if choice_count == 0 {\n                            return Err(GovernanceError::AtLeastSingleChoiceIsRequired.into());\n                        }\n                        if total_choice_weight_percentage != 100 {\n                            return Err(GovernanceError::TotalVoteWeightMustBe100Percent.into());\n                        }\n                    }\n                }\n            }\n            Vote::Deny => {\n                if self.deny_vote_weight.is_none() {\n                    return Err(GovernanceError::DenyVoteIsNotAllowed.into());\n                }\n            }\n            Vote::Abstain => {\n                return Err(GovernanceError::NotSupportedVoteType.into());\n            }\n            Vote::Veto => {}\n        }\n\n        Ok(())\n    }",
    "pub fn get_proposal_data(\n    program_id: &Pubkey,\n    proposal_info: &AccountInfo,\n) -> Result<ProposalV2, ProgramError> {\n    let account_type: GovernanceAccountType = get_account_type(program_id, proposal_info)?;\n\n    // If the account is V1 version then translate to V2\n    if account_type == GovernanceAccountType::ProposalV1 {\n        let proposal_data_v1 = get_account_data::<ProposalV1>(program_id, proposal_info)?;\n\n        let vote_result = match proposal_data_v1.state {\n            ProposalState::Draft\n            | ProposalState::SigningOff\n            | ProposalState::Voting\n            | ProposalState::Cancelled => OptionVoteResult::None,\n            ProposalState::Succeeded\n            | ProposalState::Executing\n            | ProposalState::ExecutingWithErrors\n            | ProposalState::Completed => OptionVoteResult::Succeeded,\n            ProposalState::Vetoed | ProposalState::Defeated => OptionVoteResult::None,\n        };\n\n        return Ok(ProposalV2 {\n            account_type,\n            governance: proposal_data_v1.governance,\n            governing_token_mint: proposal_data_v1.governing_token_mint,\n            state: proposal_data_v1.state,\n            token_owner_record: proposal_data_v1.token_owner_record,\n            signatories_count: proposal_data_v1.signatories_count,\n            signatories_signed_off_count: proposal_data_v1.signatories_signed_off_count,\n            vote_type: VoteType::SingleChoice,\n            options: vec![ProposalOption {\n                label: \"Yes\".to_string(),\n                vote_weight: proposal_data_v1.yes_votes_count,\n                vote_result,\n                transactions_executed_count: proposal_data_v1.instructions_executed_count,\n                transactions_count: proposal_data_v1.instructions_count,\n                transactions_next_index: proposal_data_v1.instructions_next_index,\n            }],\n            deny_vote_weight: Some(proposal_data_v1.no_votes_count),\n            veto_vote_weight: 0,\n            abstain_vote_weight: None,\n            start_voting_at: None,\n            draft_at: proposal_data_v1.draft_at,\n            signing_off_at: proposal_data_v1.signing_off_at,\n            voting_at: proposal_data_v1.voting_at,\n            voting_at_slot: proposal_data_v1.voting_at_slot,\n            voting_completed_at: proposal_data_v1.voting_completed_at,\n            executing_at: proposal_data_v1.executing_at,\n            closed_at: proposal_data_v1.closed_at,\n            execution_flags: proposal_data_v1.execution_flags,\n            max_vote_weight: proposal_data_v1.max_vote_weight,\n            max_voting_time: None,\n            vote_threshold: proposal_data_v1.vote_threshold,\n            name: proposal_data_v1.name,\n            description_link: proposal_data_v1.description_link,\n            reserved: [0; 64],\n            reserved1: 0,\n        });\n    }\n\n    get_account_data::<ProposalV2>(program_id, proposal_info)\n}",
    "pub fn get_proposal_data_for_governance_and_governing_mint(\n    program_id: &Pubkey,\n    proposal_info: &AccountInfo,\n    governance: &Pubkey,\n    governing_token_mint: &Pubkey,\n) -> Result<ProposalV2, ProgramError> {\n    let proposal_data = get_proposal_data_for_governance(program_id, proposal_info, governance)?;\n\n    if proposal_data.governing_token_mint != *governing_token_mint {\n        return Err(GovernanceError::InvalidGoverningMintForProposal.into());\n    }\n\n    Ok(proposal_data)\n}",
    "pub fn get_proposal_data_for_governance(\n    program_id: &Pubkey,\n    proposal_info: &AccountInfo,\n    governance: &Pubkey,\n) -> Result<ProposalV2, ProgramError> {\n    let proposal_data = get_proposal_data(program_id, proposal_info)?;\n\n    if proposal_data.governance != *governance {\n        return Err(GovernanceError::InvalidGovernanceForProposal.into());\n    }\n\n    Ok(proposal_data)\n}",
    "pub fn assert_valid_proposal_options(\n    options: &[String],\n    vote_type: &VoteType,\n) -> Result<(), ProgramError> {\n    if options.is_empty() || options.len() > 10 {\n        return Err(GovernanceError::InvalidProposalOptions.into());\n    }\n\n    if let VoteType::MultiChoice {\n        choice_type: _,\n        min_voter_options,\n        max_voter_options,\n        max_winning_options,\n    } = vote_type\n    {\n        if options.len() == 1\n            || *max_voter_options as usize != options.len()\n            || *max_winning_options as usize != options.len()\n            || *min_voter_options != 1\n        {\n            return Err(GovernanceError::InvalidMultiChoiceProposalParameters.into());\n        }\n    }\n\n    // TODO: Check for duplicated option labels\n    // The options are identified by index so it's ok for now\n\n    if options.iter().any(|o| o.is_empty()) {\n        return Err(GovernanceError::InvalidProposalOptions.into());\n    }\n\n    Ok(())\n}",
    "pub fn test_finalize_vote_with_expired_voting_time_error() {\n        // Arrange\n        let mut proposal = create_test_proposal();\n        proposal.state = ProposalState::Voting;\n        let governance_config = create_test_governance_config();\n\n        let current_timestamp =\n            proposal.voting_at.unwrap() + governance_config.voting_base_time as i64;\n\n        let realm = create_test_realm();\n        let governing_token_mint = proposal.governing_token_mint;\n        let vote_kind = VoteKind::Electorate;\n\n        let max_voter_weight = proposal\n            .get_max_voter_weight_from_mint_supply(&realm, &governing_token_mint, 100, &vote_kind)\n            .unwrap();\n\n        let vote_threshold = &governance_config.community_vote_threshold;\n\n        // Act\n        let err = proposal\n            .finalize_vote(\n                max_voter_weight,\n                &governance_config,\n                current_timestamp,\n                vote_threshold,\n            )\n            .err()\n            .unwrap();\n\n        // Assert\n        assert_eq!(err, GovernanceError::CannotFinalizeVotingInProgress.into());\n    }\n\n    #[test]\n    pub fn test_finalize_vote_after_voting_time() {\n        // Arrange\n        let mut proposal = create_test_proposal();\n        proposal.state = ProposalState::Voting;\n        let governance_config = create_test_governance_config();\n\n        let current_timestamp =\n            proposal.voting_at.unwrap() + governance_config.voting_base_time as i64 + 1;\n\n        let realm = create_test_realm();\n        let governing_token_mint = proposal.governing_token_mint;\n        let vote_kind = VoteKind::Electorate;\n\n        let max_voter_weight = proposal\n            .get_max_voter_weight_from_mint_supply(&realm, &governing_token_mint, 100, &vote_kind)\n            .unwrap();\n\n        let vote_threshold = &governance_config.community_vote_threshold;\n\n        // Act\n        let result = proposal.finalize_vote(\n            max_voter_weight,\n            &governance_config,\n            current_timestamp,\n            vote_threshold,\n        );\n\n        // Assert\n        assert_eq!(result, Ok(()));\n    }\n\n    #[test]\n    pub fn test_assert_can_vote_with_expired_voting_time_error() {\n        // Arrange\n        let mut proposal = create_test_proposal();\n        proposal.state = ProposalState::Voting;\n        let governance_config = create_test_governance_config();\n\n        let current_timestamp =\n            proposal.voting_at.unwrap() + governance_config.voting_base_time as i64 + 1;\n\n        let vote = Vote::Approve(vec![]);\n\n        // Act\n        let err = proposal\n            .assert_can_cast_vote(&governance_config, &vote, current_timestamp)\n            .err()\n            .unwrap();\n\n        // Assert\n        assert_eq!(err, GovernanceError::ProposalVotingTimeExpired.into());\n    }\n\n    #[test]\n    pub fn test_assert_can_vote_within_voting_time() {\n        // Arrange\n        let mut proposal = create_test_proposal();\n        proposal.state = ProposalState::Voting;\n        let governance_config = create_test_governance_config();\n\n        let current_timestamp =\n            proposal.voting_at.unwrap() + governance_config.voting_base_time as i64;\n\n        let vote = Vote::Approve(vec![]);\n\n        // Act\n        let result = proposal.assert_can_cast_vote(&governance_config, &vote, current_timestamp);\n\n        // Assert\n        assert_eq!(result, Ok(()));\n    }\n\n    #[test]\n    pub fn test_assert_can_vote_approve_before_voting_cool_off_time() {\n        // Arrange\n        let mut proposal = create_test_proposal();\n        proposal.state = ProposalState::Voting;\n\n        let mut governance_config = create_test_governance_config();\n        governance_config.voting_cool_off_time = 2;\n\n        let current_timestamp =\n            proposal.voting_at.unwrap() + governance_config.voting_base_time as i64 - 1;\n\n        let vote = Vote::Approve(vec![]);\n\n        // Act\n        let result = proposal.assert_can_cast_vote(&governance_config, &vote, current_timestamp);\n\n        // Assert\n        assert_eq!(result, Ok(()));\n    }\n\n    #[test]\n    pub fn test_assert_cannot_vote_approve_within_voting_cool_off_time() {\n        // Arrange\n        let mut proposal = create_test_proposal();\n        proposal.state = ProposalState::Voting;\n\n        let mut governance_config = create_test_governance_config();\n        governance_config.voting_cool_off_time = 2;\n\n        let current_timestamp =\n            proposal.voting_at.unwrap() + governance_config.voting_base_time as i64 + 1;\n\n        let vote = Vote::Approve(vec![]);\n\n        // Act\n        let err = proposal\n            .assert_can_cast_vote(&governance_config, &vote, current_timestamp)\n            .err()\n            .unwrap();\n\n        // Assert\n        assert_eq!(err, GovernanceError::VoteNotAllowedInCoolOffTime.into());\n    }\n\n    #[test]\n    pub fn test_assert_can_vote_veto_within_voting_cool_off_time() {\n        // Arrange\n        let mut proposal = create_test_proposal();\n        proposal.state = ProposalState::Voting;\n\n        let mut governance_config = create_test_governance_config();\n        governance_config.voting_cool_off_time = 2;\n\n        let current_timestamp =\n            proposal.voting_at.unwrap() + governance_config.voting_base_time as i64 + 1;\n\n        let vote = Vote::Veto;\n\n        // Act\n        let result = proposal.assert_can_cast_vote(&governance_config, &vote, current_timestamp);\n\n        // Assert\n        assert_eq!(result, Ok(()));\n    }\n\n    #[test]\n    pub fn test_assert_can_vote_deny_within_voting_cool_off_time() {\n        // Arrange\n        let mut proposal = create_test_proposal();\n        proposal.state = ProposalState::Voting;\n\n        let mut governance_config = create_test_governance_config();\n        governance_config.voting_cool_off_time = 1;\n\n        let current_timestamp =\n            proposal.voting_at.unwrap() + governance_config.voting_base_time as i64 + 1;\n\n        let vote = Vote::Deny;\n\n        // Act\n        let result = proposal.assert_can_cast_vote(&governance_config, &vote, current_timestamp);\n\n        // Assert\n        assert_eq!(result, Ok(()));\n    }\n\n    #[test]\n    pub fn test_assert_valid_vote_with_deny_vote_for_survey_only_proposal_error() {\n        // Arrange\n        let mut proposal = create_test_proposal();\n        proposal.deny_vote_weight = None;\n\n        // Survey only proposal can't be denied\n        let vote = Vote::Deny;\n\n        // Act\n        let result = proposal.assert_valid_vote(&vote);\n\n        // Assert\n        assert_eq!(result, Err(GovernanceError::DenyVoteIsNotAllowed.into()));\n    }\n\n    #[test]\n    pub fn test_assert_valid_vote_with_too_many_options_error() {\n        // Arrange\n        let proposal = create_test_proposal();\n\n        let choices = vec![\n            VoteChoice {\n                rank: 0,\n                weight_percentage: 100,\n            },\n            VoteChoice {\n                rank: 0,\n                weight_percentage: 100,\n            },\n        ];\n\n        let vote = Vote::Approve(choices.clone());\n\n        // Ensure\n        assert!(proposal.options.len() != choices.len());\n\n        // Act\n        let result = proposal.assert_valid_vote(&vote);\n\n        // Assert\n        assert_eq!(\n            result,\n            Err(GovernanceError::InvalidNumberOfVoteChoices.into())\n        );\n    }\n\n    #[test]\n    pub fn test_assert_valid_vote_with_no_choice_for_single_choice_error() {\n        // Arrange\n        let proposal = create_test_proposal();\n\n        let choices = vec![VoteChoice {\n            rank: 0,\n            weight_percentage: 0,\n        }];\n\n        let vote = Vote::Approve(choices.clone());\n\n        // Ensure\n        assert_eq!(proposal.options.len(), choices.len());\n\n        // Act\n        let result = proposal.assert_valid_vote(&vote);\n\n        // Assert\n        assert_eq!(\n            result,\n            Err(GovernanceError::SingleChoiceOnlyIsAllowed.into())\n        );\n    }\n\n    #[test]\n    pub fn test_assert_valid_vote_with_to_many_choices_for_single_choice_error() {\n        // Arrange\n        let proposal = create_test_multi_option_proposal();\n        let choices = vec![\n            VoteChoice {\n                rank: 0,\n                weight_percentage: 100,\n            },\n            VoteChoice {\n                rank: 0,\n                weight_percentage: 100,\n            },\n            VoteChoice {\n                rank: 0,\n                weight_percentage: 0,\n            },\n        ];\n\n        let vote = Vote::Approve(choices.clone());\n\n        // Ensure\n        assert_eq!(proposal.options.len(), choices.len());\n\n        // Act\n        let result = proposal.assert_valid_vote(&vote);\n\n        // Assert\n        assert_eq!(\n            result,\n            Err(GovernanceError::SingleChoiceOnlyIsAllowed.into())\n        );\n    }\n\n    #[test]\n    pub fn test_assert_valid_multi_choice_full_weight_vote() {\n        // Arrange\n        let mut proposal = create_test_multi_option_proposal();\n        proposal.vote_type = VoteType::MultiChoice {\n            choice_type: MultiChoiceType::FullWeight,\n            min_voter_options: 1,\n            max_voter_options: 4,\n            max_winning_options: 4,\n        };\n        let choices = vec![\n            VoteChoice {\n                rank: 0,\n                weight_percentage: 100,\n            },\n            VoteChoice {\n                rank: 0,\n                weight_percentage: 100,\n            },\n            VoteChoice {\n                rank: 0,\n                weight_percentage: 100,\n            },\n        ];\n\n        let vote = Vote::Approve(choices.clone());\n\n        // Ensure\n        assert_eq!(proposal.options.len(), choices.len());\n\n        // Act\n        let result = proposal.assert_valid_vote(&vote);\n\n        // Assert\n        assert_eq!(result, Ok(()));\n    }\n\n    #[test]\n    pub fn test_assert_valid_vote_with_no_choices_for_multi_choice_error() {\n        // Arrange\n        let mut proposal = create_test_multi_option_proposal();\n        proposal.vote_type = VoteType::MultiChoice {\n            choice_type: MultiChoiceType::FullWeight,\n            min_voter_options: 1,\n            max_voter_options: 3,\n            max_winning_options: 3,\n        };\n\n        let choices = vec![\n            VoteChoice {\n                rank: 0,\n                weight_percentage: 0,\n            },\n            VoteChoice {\n                rank: 0,\n                weight_percentage: 0,\n            },\n            VoteChoice {\n                rank: 0,\n                weight_percentage: 0,\n            },\n        ];\n\n        let vote = Vote::Approve(choices.clone());\n\n        // Ensure\n        assert_eq!(proposal.options.len(), choices.len());\n\n        // Act\n        let result = proposal.assert_valid_vote(&vote);\n\n        // Assert\n        assert_eq!(\n            result,\n            Err(GovernanceError::AtLeastSingleChoiceIsRequired.into())\n        );\n    }\n\n    #[test]\n    pub fn test_assert_valid_vote_with_choice_weight_not_100_percent_error() {\n        // Arrange\n        let mut proposal = create_test_multi_option_proposal();\n        proposal.vote_type = VoteType::MultiChoice {\n            choice_type: MultiChoiceType::FullWeight,\n            min_voter_options: 1,\n            max_voter_options: 3,\n            max_winning_options: 3,\n        };\n\n        let choices = vec![\n            VoteChoice {\n                rank: 0,\n                weight_percentage: 50,\n            },\n            VoteChoice {\n                rank: 0,\n                weight_percentage: 50,\n            },\n            VoteChoice {\n                rank: 0,\n                weight_percentage: 0,\n            },\n        ];\n\n        let vote = Vote::Approve(choices.clone());\n\n        // Ensure\n        assert_eq!(proposal.options.len(), choices.len());\n\n        // Act\n        let result = proposal.assert_valid_vote(&vote);\n\n        // Assert\n        assert_eq!(\n            result,\n            Err(GovernanceError::ChoiceWeightMustBe100Percent.into())\n        );\n    }\n\n    #[test]\n    pub fn test_assert_valid_proposal_options_with_invalid_choice_number_for_multi_choice_vote_error(\n    ) {\n        // Arrange\n        let vote_type = VoteType::MultiChoice {\n            choice_type: MultiChoiceType::FullWeight,\n            min_voter_options: 1,\n            max_voter_options: 3,\n            max_winning_options: 3,\n        };\n\n        let options = vec![\"option 1\".to_string(), \"option 2\".to_string()];\n\n        // Act\n        let result = assert_valid_proposal_options(&options, &vote_type);\n\n        // Assert\n        assert_eq!(\n            result,\n            Err(GovernanceError::InvalidMultiChoiceProposalParameters.into())\n        );\n    }\n\n    #[test]\n    pub fn test_assert_valid_proposal_options_with_no_options_for_multi_choice_vote_error() {\n        // Arrange\n        let vote_type = VoteType::MultiChoice {\n            choice_type: MultiChoiceType::FullWeight,\n            min_voter_options: 1,\n            max_voter_options: 3,\n            max_winning_options: 3,\n        };\n\n        let options = vec![];\n\n        // Act\n        let result = assert_valid_proposal_options(&options, &vote_type);\n\n        // Assert\n        assert_eq!(result, Err(GovernanceError::InvalidProposalOptions.into()));\n    }\n\n    #[test]\n    pub fn test_assert_valid_proposal_options_with_no_options_for_single_choice_vote_error() {\n        // Arrange\n        let vote_type = VoteType::SingleChoice;\n\n        let options = vec![];\n\n        // Act\n        let result = assert_valid_proposal_options(&options, &vote_type);\n\n        // Assert\n        assert_eq!(result, Err(GovernanceError::InvalidProposalOptions.into()));\n    }\n\n    #[test]\n    pub fn test_assert_valid_proposal_options_for_multi_choice_vote() {\n        // Arrange\n        let vote_type = VoteType::MultiChoice {\n            choice_type: MultiChoiceType::FullWeight,\n            min_voter_options: 1,\n            max_voter_options: 3,\n            max_winning_options: 3,\n        };\n\n        let options = vec![\n            \"option 1\".to_string(),\n            \"option 2\".to_string(),\n            \"option 3\".to_string(),\n        ];\n\n        // Act\n        let result = assert_valid_proposal_options(&options, &vote_type);\n\n        // Assert\n        assert_eq!(result, Ok(()));\n    }\n\n    #[test]\n    pub fn test_assert_valid_proposal_options_for_multi_choice_vote_with_empty_option_error() {\n        // Arrange\n        let vote_type = VoteType::MultiChoice {\n            choice_type: MultiChoiceType::FullWeight,\n            min_voter_options: 1,\n            max_voter_options: 3,\n            max_winning_options: 3,\n        };\n\n        let options = vec![\n            \"\".to_string(),\n            \"option 2\".to_string(),\n            \"option 3\".to_string(),\n        ];\n\n        // Act\n        let result = assert_valid_proposal_options(&options, &vote_type);\n\n        // Assert\n        assert_eq!(result, Err(GovernanceError::InvalidProposalOptions.into()));\n    }\n\n    #[test]\n    pub fn test_assert_valid_vote_for_multi_weighted_choice() {\n        // Multi weighted choice may be weighted but sum of choices has to be 100%\n        // Arrange\n        let mut proposal = create_test_multi_option_proposal();\n        proposal.vote_type = VoteType::MultiChoice {\n            choice_type: MultiChoiceType::Weighted,\n            min_voter_options: 1,\n            max_voter_options: 3,\n            max_winning_options: 3,\n        };\n\n        let choices = vec![\n            VoteChoice {\n                rank: 0,\n                weight_percentage: 42,\n            },\n            VoteChoice {\n                rank: 0,\n                weight_percentage: 42,\n            },\n            VoteChoice {\n                rank: 0,\n                weight_percentage: 16,\n            },\n        ];\n        let vote = Vote::Approve(choices.clone());\n\n        // Ensure\n        assert_eq!(proposal.options.len(), choices.len());\n\n        // Act\n        let result = proposal.assert_valid_vote(&vote);\n\n        // Assert\n        assert_eq!(result, Ok(()));\n    }\n\n    #[test]\n    pub fn test_assert_valid_full_vote_for_multi_weighted_choice() {\n        // Multi weighted choice may be weighted to 100% and 0% rest\n        // Arrange\n        let mut proposal = create_test_multi_option_proposal();\n        proposal.vote_type = VoteType::MultiChoice {\n            choice_type: MultiChoiceType::Weighted,\n            min_voter_options: 1,\n            max_voter_options: 3,\n            max_winning_options: 3,\n        };\n\n        let choices = vec![\n            VoteChoice {\n                rank: 0,\n                weight_percentage: 0,\n            },\n            VoteChoice {\n                rank: 0,\n                weight_percentage: 100,\n            },\n            VoteChoice {\n                rank: 0,\n                weight_percentage: 0,\n            },\n        ];\n        let vote = Vote::Approve(choices.clone());\n\n        // Ensure\n        assert_eq!(proposal.options.len(), choices.len());\n\n        // Act\n        let result = proposal.assert_valid_vote(&vote);\n\n        // Assert\n        assert_eq!(result, Ok(()));\n    }\n\n    #[test]\n    pub fn test_assert_valid_vote_with_total_vote_weight_above_100_percent_for_multi_weighted_choice_error(\n    ) {\n        // Arrange\n        let mut proposal = create_test_multi_option_proposal();\n        proposal.vote_type = VoteType::MultiChoice {\n            choice_type: MultiChoiceType::Weighted,\n            min_voter_options: 1,\n            max_voter_options: 2,\n            max_winning_options: 2,\n        };\n\n        let choices = vec![\n            VoteChoice {\n                rank: 0,\n                weight_percentage: 34,\n            },\n            VoteChoice {\n                rank: 0,\n                weight_percentage: 34,\n            },\n            VoteChoice {\n                rank: 0,\n                weight_percentage: 34,\n            },\n        ];\n        let vote = Vote::Approve(choices.clone());\n\n        // Ensure\n        assert_eq!(proposal.options.len(), choices.len());\n\n        // Act\n        let result = proposal.assert_valid_vote(&vote);\n\n        // Assert\n        assert_eq!(\n            result,\n            Err(GovernanceError::TotalVoteWeightMustBe100Percent.into())\n        );\n    }\n\n    #[test]\n    pub fn test_assert_valid_vote_with_over_percentage_for_multi_weighted_choice_error() {\n        // Multi weighted choice does not permit vote with sum weight over 100%\n        // Arrange\n        let mut proposal = create_test_multi_option_proposal();\n        proposal.vote_type = VoteType::MultiChoice {\n            choice_type: MultiChoiceType::Weighted,\n            min_voter_options: 1,\n            max_voter_options: 3,\n            max_winning_options: 3,\n        };\n\n        let choices = vec![\n            VoteChoice {\n                rank: 0,\n                weight_percentage: 34,\n            },\n            VoteChoice {\n                rank: 0,\n                weight_percentage: 34,\n            },\n            VoteChoice {\n                rank: 0,\n                weight_percentage: 34,\n            },\n        ];\n        let vote = Vote::Approve(choices.clone());\n\n        // Ensure\n        assert_eq!(proposal.options.len(), choices.len());\n\n        // Act\n        let result = proposal.assert_valid_vote(&vote);\n\n        // Assert\n        assert_eq!(\n            result,\n            Err(GovernanceError::TotalVoteWeightMustBe100Percent.into())\n        );\n    }\n\n    #[test]\n    pub fn test_assert_valid_vote_with_overflow_weight_for_multi_weighted_choice_error() {\n        // Multi weighted choice does not permit vote with sum weight over 100%\n        // Arrange\n        let mut proposal = create_test_multi_option_proposal();\n        proposal.vote_type = VoteType::MultiChoice {\n            choice_type: MultiChoiceType::Weighted,\n            min_voter_options: 1,\n            max_voter_options: 3,\n            max_winning_options: 3,\n        };\n\n        let choices = vec![\n            VoteChoice {\n                rank: 0,\n                weight_percentage: 100,\n            },\n            VoteChoice {\n                rank: 0,\n                weight_percentage: 100,\n            },\n            VoteChoice {\n                rank: 0,\n                weight_percentage: 100,\n            },\n        ];\n        let vote = Vote::Approve(choices.clone());\n\n        // Ensure\n        assert_eq!(proposal.options.len(), choices.len());\n\n        // Act\n        let result = proposal.assert_valid_vote(&vote);\n\n        // Assert\n        assert_eq!(\n            result,\n            Err(GovernanceError::TotalVoteWeightMustBe100Percent.into())\n        );\n    }\n\n    #[test]\n    pub fn test_assert_valid_proposal_options_with_invalid_choice_number_for_multi_weighted_choice_vote_error(\n    ) {\n        // Arrange\n        let vote_type = VoteType::MultiChoice {\n            choice_type: MultiChoiceType::Weighted,\n            min_voter_options: 1,\n            max_voter_options: 3,\n            max_winning_options: 3,\n        };\n\n        let options = vec![\"option 1\".to_string(), \"option 2\".to_string()];\n\n        // Act\n        let result = assert_valid_proposal_options(&options, &vote_type);\n\n        // Assert\n        assert_eq!(\n            result,\n            Err(GovernanceError::InvalidMultiChoiceProposalParameters.into())\n        );\n    }\n\n    #[test]\n    pub fn test_assert_valid_proposal_options_with_no_options_for_multi_weighted_choice_vote_error()\n    {\n        // Arrange\n        let vote_type = VoteType::MultiChoice {\n            choice_type: MultiChoiceType::Weighted,\n            min_voter_options: 1,\n            max_voter_options: 3,\n            max_winning_options: 3,\n        };\n\n        let options = vec![];\n\n        // Act\n        let result = assert_valid_proposal_options(&options, &vote_type);\n\n        // Assert\n        assert_eq!(result, Err(GovernanceError::InvalidProposalOptions.into()));\n    }\n\n    #[test]\n    pub fn test_assert_valid_proposal_options_for_multi_weighted_choice_vote() {\n        // Arrange\n        let vote_type = VoteType::MultiChoice {\n            choice_type: MultiChoiceType::Weighted,\n            min_voter_options: 1,\n            max_voter_options: 3,\n            max_winning_options: 3,\n        };\n\n        let options = vec![\n            \"option 1\".to_string(),\n            \"option 2\".to_string(),\n            \"option 3\".to_string(),\n        ];\n\n        // Act\n        let result = assert_valid_proposal_options(&options, &vote_type);\n\n        // Assert\n        assert_eq!(result, Ok(()));\n    }\n\n    #[test]\n    pub fn test_assert_valid_proposal_options_for_multi_weighted_choice_vote_with_empty_option_error(\n    ) {\n        // Arrange\n        let vote_type = VoteType::MultiChoice {\n            choice_type: MultiChoiceType::Weighted,\n            min_voter_options: 1,\n            max_voter_options: 3,\n            max_winning_options: 3,\n        };\n\n        let options = vec![\n            \"\".to_string(),\n            \"option 2\".to_string(),\n            \"option 3\".to_string(),\n        ];\n\n        // Act\n        let result = assert_valid_proposal_options(&options, &vote_type);\n\n        // Assert\n        assert_eq!(result, Err(GovernanceError::InvalidProposalOptions.into()));\n    }\n\n    #[test]\n    pub fn test_assert_more_than_ten_proposal_options_for_multi_weighted_choice_error() {\n        // Arrange\n        let vote_type = VoteType::MultiChoice {\n            choice_type: MultiChoiceType::Weighted,\n            min_voter_options: 1,\n            max_voter_options: 3,\n            max_winning_options: 3,\n        };\n\n        let options = vec![\n            \"option 1\".to_string(),\n            \"option 2\".to_string(),\n            \"option 3\".to_string(),\n            \"option 4\".to_string(),\n            \"option 5\".to_string(),\n            \"option 6\".to_string(),\n            \"option 7\".to_string(),\n            \"option 8\".to_string(),\n            \"option 9\".to_string(),\n            \"option 10\".to_string(),\n            \"option 11\".to_string(),\n        ];\n\n        // Act\n        let result = assert_valid_proposal_options(&options, &vote_type);\n\n        // Assert\n        assert_eq!(result, Err(GovernanceError::InvalidProposalOptions.into()));\n    }\n\n    #[test]\n    fn test_proposal_v1_to_v2_serialisation_roundtrip() {\n        // Arrange\n\n        let proposal_v1_source = ProposalV1 {\n            account_type: GovernanceAccountType::ProposalV1,\n            governance: Pubkey::new_unique(),\n            governing_token_mint: Pubkey::new_unique(),\n            state: ProposalState::Executing,\n            token_owner_record: Pubkey::new_unique(),\n            signatories_count: 5,\n            signatories_signed_off_count: 4,\n            yes_votes_count: 100,\n            no_votes_count: 80,\n            instructions_executed_count: 7,\n            instructions_count: 8,\n            instructions_next_index: 9,\n            draft_at: 200,\n            signing_off_at: Some(201),\n            voting_at: Some(202),\n            voting_at_slot: Some(203),\n            voting_completed_at: Some(204),\n            executing_at: Some(205),\n            closed_at: Some(206),\n            execution_flags: InstructionExecutionFlags::None,\n            max_vote_weight: Some(250),\n            vote_threshold: Some(VoteThreshold::YesVotePercentage(65)),\n            name: \"proposal\".to_string(),\n            description_link: \"proposal-description\".to_string(),\n        };\n\n        let mut account_data = vec![];\n        proposal_v1_source.serialize(&mut account_data).unwrap();\n\n        let program_id = Pubkey::new_unique();\n\n        let info_key = Pubkey::new_unique();\n        let mut lamports = 10u64;\n\n        let account_info = AccountInfo::new(\n            &info_key,\n            false,\n            false,\n            &mut lamports,\n            &mut account_data[..],\n            &program_id,\n            false,\n            Epoch::default(),\n        );\n\n        // Act\n\n        let proposal_v2 = get_proposal_data(&program_id, &account_info).unwrap();\n\n        proposal_v2\n            .serialize(&mut account_info.data.borrow_mut()[..])\n            .unwrap();\n\n        // Assert\n        let proposal_v1_target =\n            get_account_data::<ProposalV1>(&program_id, &account_info).unwrap();\n\n        assert_eq!(proposal_v1_source, proposal_v1_target)\n    }",
    "pub fn get_proposal_deposit_address(\n    program_id: &Pubkey,\n    proposal: &Pubkey,\n    proposal_deposit_payer: &Pubkey,\n) -> Pubkey {\n    Pubkey::find_program_address(\n        &get_proposal_deposit_address_seeds(proposal, proposal_deposit_payer),\n        program_id,\n    )\n    .0\n}\n\n/// Deserializes ProposalDeposit account and checks owner program and account\n/// type\npub fn get_proposal_deposit_data(\n    program_id: &Pubkey,\n    proposal_deposit_info: &AccountInfo,\n) -> Result<ProposalDeposit, ProgramError> {\n    get_account_data::<ProposalDeposit>(program_id, proposal_deposit_info)\n}",
    "pub fn get_proposal_deposit_data_for_proposal_and_deposit_payer(\n    program_id: &Pubkey,\n    proposal_deposit_info: &AccountInfo,\n    proposal: &Pubkey,\n    proposal_deposit_payer: &Pubkey,\n) -> Result<ProposalDeposit, ProgramError> {\n    let proposal_deposit_data = get_proposal_deposit_data(program_id, proposal_deposit_info)?;\n\n    if proposal_deposit_data.proposal != *proposal {\n        return Err(GovernanceError::InvalidProposalForProposalDeposit.into());\n    }\n\n    if proposal_deposit_data.deposit_payer != *proposal_deposit_payer {\n        return Err(GovernanceError::InvalidDepositPayerForProposalDeposit.into());\n    }\n\n    Ok(proposal_deposit_data)\n}",
    "pub fn get_proposal_transaction_data(\n    program_id: &Pubkey,\n    proposal_transaction_info: &AccountInfo,\n) -> Result<ProposalTransactionV2, ProgramError> {\n    let account_type: GovernanceAccountType =\n        get_account_type(program_id, proposal_transaction_info)?;\n\n    // If the account is V1 version then translate to V2\n    if account_type == GovernanceAccountType::ProposalInstructionV1 {\n        let proposal_transaction_data_v1 =\n            get_account_data::<ProposalInstructionV1>(program_id, proposal_transaction_info)?;\n\n        return Ok(ProposalTransactionV2 {\n            account_type,\n            proposal: proposal_transaction_data_v1.proposal,\n            option_index: 0, // V1 has a single implied option at index 0\n            transaction_index: proposal_transaction_data_v1.instruction_index,\n            legacy: proposal_transaction_data_v1.legacy,\n            instructions: vec![proposal_transaction_data_v1.instruction],\n            executed_at: proposal_transaction_data_v1.executed_at,\n            execution_status: proposal_transaction_data_v1.execution_status,\n            reserved_v2: [0; 8],\n        });\n    }\n\n    get_account_data::<ProposalTransactionV2>(program_id, proposal_transaction_info)\n}",
    "pub fn get_proposal_transaction_data_for_proposal(\n    program_id: &Pubkey,\n    proposal_transaction_info: &AccountInfo,\n    proposal: &Pubkey,\n) -> Result<ProposalTransactionV2, ProgramError> {\n    let proposal_transaction_data =\n        get_proposal_transaction_data(program_id, proposal_transaction_info)?;\n\n    if proposal_transaction_data.proposal != *proposal {\n        return Err(GovernanceError::InvalidProposalForProposalTransaction.into());\n    }\n\n    Ok(proposal_transaction_data)\n}",
    "pub fn is_realm_account_type(account_type: &GovernanceAccountType) -> bool {\n    match account_type {\n        GovernanceAccountType::RealmV1 | GovernanceAccountType::RealmV2 => true,\n        GovernanceAccountType::GovernanceV2\n        | GovernanceAccountType::ProgramGovernanceV2\n        | GovernanceAccountType::MintGovernanceV2\n        | GovernanceAccountType::TokenGovernanceV2\n        | GovernanceAccountType::Uninitialized\n        | GovernanceAccountType::RealmConfig\n        | GovernanceAccountType::TokenOwnerRecordV1\n        | GovernanceAccountType::TokenOwnerRecordV2\n        | GovernanceAccountType::GovernanceV1\n        | GovernanceAccountType::ProgramGovernanceV1\n        | GovernanceAccountType::MintGovernanceV1\n        | GovernanceAccountType::TokenGovernanceV1\n        | GovernanceAccountType::ProposalV1\n        | GovernanceAccountType::ProposalV2\n        | GovernanceAccountType::SignatoryRecordV1\n        | GovernanceAccountType::SignatoryRecordV2\n        | GovernanceAccountType::ProposalInstructionV1\n        | GovernanceAccountType::ProposalTransactionV2\n        | GovernanceAccountType::VoteRecordV1\n        | GovernanceAccountType::VoteRecordV2\n        | GovernanceAccountType::ProgramMetadata\n        | GovernanceAccountType::ProposalDeposit\n        | GovernanceAccountType::RequiredSignatory => false,\n    }\n}\n\nimpl RealmV2 {\n    /// Asserts the given mint is either Community or Council mint of the Realm\n    pub fn assert_is_valid_governing_token_mint(\n        &self,\n        governing_token_mint: &Pubkey,\n    ) -> Result<(), ProgramError> {\n        if self.community_mint == *governing_token_mint {\n            return Ok(());\n        }\n\n        if self.config.council_mint == Some(*governing_token_mint) {\n            return Ok(());\n        }\n\n        Err(GovernanceError::InvalidGoverningTokenMint.into())\n    }",
    "pub fn get_proposal_governing_token_mint_for_vote(\n        &self,\n        vote_governing_token_mint: &Pubkey,\n        vote_kind: &VoteKind,\n    ) -> Result<Pubkey, ProgramError> {\n        match vote_kind {\n            VoteKind::Electorate => Ok(*vote_governing_token_mint),\n            VoteKind::Veto => {\n                // When Community veto Council proposal then return council_token_mint as the\n                // Proposal governing_token_mint\n                if self.community_mint == *vote_governing_token_mint {\n                    return Ok(self.config.council_mint.unwrap());\n                }\n\n                // When Council veto Community proposal then return community_token_mint as the\n                // Proposal governing_token_mint\n                if self.config.council_mint == Some(*vote_governing_token_mint) {\n                    return Ok(self.community_mint);\n                }\n\n                Err(GovernanceError::InvalidGoverningTokenMint.into())\n            }",
    "pub fn assert_is_valid_governing_token_mint_and_holding(\n        &self,\n        program_id: &Pubkey,\n        realm: &Pubkey,\n        governing_token_mint: &Pubkey,\n        governing_token_holding: &Pubkey,\n    ) -> Result<(), ProgramError> {\n        self.assert_is_valid_governing_token_mint(governing_token_mint)?;\n\n        let governing_token_holding_address =\n            get_governing_token_holding_address(program_id, realm, governing_token_mint);\n\n        if governing_token_holding_address != *governing_token_holding {\n            return Err(GovernanceError::InvalidGoverningTokenHoldingAccount.into());\n        }\n\n        Ok(())\n    }",
    "pub fn assert_create_authority_can_create_governance(\n        &self,\n        program_id: &Pubkey,\n        realm: &Pubkey,\n        token_owner_record_info: &AccountInfo,\n        create_authority_info: &AccountInfo,\n        account_info_iter: &mut Iter<AccountInfo>,\n    ) -> Result<(), ProgramError> {\n        // Check if create_authority_info is realm_authority and if yes then it must\n        // signed the transaction\n        if self.authority == Some(*create_authority_info.key) {\n            return if !create_authority_info.is_signer {\n                Err(GovernanceError::RealmAuthorityMustSign.into())\n            }",
    "pub fn assert_is_valid_realm(\n    program_id: &Pubkey,\n    realm_info: &AccountInfo,\n) -> Result<(), ProgramError> {\n    assert_is_valid_account_of_types(program_id, realm_info, is_realm_account_type)\n}",
    "pub fn get_realm_data(\n    program_id: &Pubkey,\n    realm_info: &AccountInfo,\n) -> Result<RealmV2, ProgramError> {\n    let account_type: GovernanceAccountType = get_account_type(program_id, realm_info)?;\n\n    // If the account is V1 version then translate to V2\n    if account_type == GovernanceAccountType::RealmV1 {\n        let realm_data_v1 = get_account_data::<RealmV1>(program_id, realm_info)?;\n\n        return Ok(RealmV2 {\n            account_type,\n            community_mint: realm_data_v1.community_mint,\n            config: realm_data_v1.config,\n            reserved: realm_data_v1.reserved,\n            legacy1: 0,\n            authority: realm_data_v1.authority,\n            name: realm_data_v1.name,\n            // Add the extra reserved_v2 padding\n            reserved_v2: [0; 128],\n        });\n    }\n\n    get_account_data::<RealmV2>(program_id, realm_info)\n}",
    "pub fn get_realm_data_for_authority(\n    program_id: &Pubkey,\n    realm_info: &AccountInfo,\n    realm_authority: &Pubkey,\n) -> Result<RealmV2, ProgramError> {\n    let realm_data = get_realm_data(program_id, realm_info)?;\n\n    if realm_data.authority.is_none() {\n        return Err(GovernanceError::RealmHasNoAuthority.into());\n    }\n\n    if realm_data.authority.unwrap() != *realm_authority {\n        return Err(GovernanceError::InvalidAuthorityForRealm.into());\n    }\n\n    Ok(realm_data)\n}",
    "pub fn get_realm_data_for_governing_token_mint(\n    program_id: &Pubkey,\n    realm_info: &AccountInfo,\n    governing_token_mint: &Pubkey,\n) -> Result<RealmV2, ProgramError> {\n    let realm_data = get_realm_data(program_id, realm_info)?;\n\n    realm_data.assert_is_valid_governing_token_mint(governing_token_mint)?;\n\n    Ok(realm_data)\n}",
    "pub fn get_realm_address_seeds(name: &str) -> [&[u8]; 2] {\n    [PROGRAM_AUTHORITY_SEED, name.as_bytes()]\n}\n\n/// Returns Realm PDA address\npub fn get_realm_address(program_id: &Pubkey, name: &str) -> Pubkey {\n    Pubkey::find_program_address(&get_realm_address_seeds(name), program_id).0\n}\n\n/// Returns Realm Token Holding PDA seeds\npub fn get_governing_token_holding_address_seeds<'a>(\n    realm: &'a Pubkey,\n    governing_token_mint: &'a Pubkey,\n) -> [&'a [u8]; 3] {\n    [\n        PROGRAM_AUTHORITY_SEED,\n        realm.as_ref(),\n        governing_token_mint.as_ref(),\n    ]\n}\n\n/// Returns Realm Token Holding PDA address\npub fn get_governing_token_holding_address(\n    program_id: &Pubkey,\n    realm: &Pubkey,\n    governing_token_mint: &Pubkey,\n) -> Pubkey {\n    Pubkey::find_program_address(\n        &get_governing_token_holding_address_seeds(realm, governing_token_mint),\n        program_id,\n    )\n    .0\n}\n\n/// Asserts given realm config args are correct\npub fn assert_valid_realm_config_args(\n    realm_config_args: &RealmConfigArgs,\n) -> Result<(), ProgramError> {\n    match realm_config_args.community_mint_max_voter_weight_source {\n        MintMaxVoterWeightSource::SupplyFraction(fraction) => {\n            if !(1..=MintMaxVoterWeightSource::SUPPLY_FRACTION_BASE).contains(&fraction) {\n                return Err(GovernanceError::InvalidMaxVoterWeightSupplyFraction.into());\n            }\n        }\n        MintMaxVoterWeightSource::Absolute(value) => {\n            if value == 0 {\n                return Err(GovernanceError::InvalidMaxVoterWeightAbsoluteValue.into());\n            }\n        }\n    }\n\n    Ok(())\n}",
    "pub fn get_token_config(\n        &self,\n        realm_data: &RealmV2,\n        governing_token_mint: &Pubkey,\n    ) -> Result<&GoverningTokenConfig, ProgramError> {\n        let token_config = if *governing_token_mint == realm_data.community_mint {\n            &self.community_token_config\n        } else if Some(*governing_token_mint) == realm_data.config.council_mint {\n            &self.council_token_config\n        } else {\n            return Err(GovernanceError::InvalidGoverningTokenMint.into());\n        };\n\n        Ok(token_config)\n    }",
    "pub fn get_token_config_mut(\n        &mut self,\n        realm_data: &RealmV2,\n        governing_token_mint: &Pubkey,\n    ) -> Result<&mut GoverningTokenConfig, ProgramError> {\n        let token_config = if *governing_token_mint == realm_data.community_mint {\n            &mut self.community_token_config\n        } else if Some(*governing_token_mint) == realm_data.config.council_mint {\n            &mut self.council_token_config\n        } else {\n            return Err(GovernanceError::InvalidGoverningTokenMint.into());\n        };\n\n        Ok(token_config)\n    }",
    "pub fn assert_can_revoke_governing_token(\n        &self,\n        realm_data: &RealmV2,\n        governing_token_mint: &Pubkey,\n    ) -> Result<(), ProgramError> {\n        let governing_token_type = &self\n            .get_token_config(realm_data, governing_token_mint)?\n            .token_type;\n\n        match governing_token_type {\n            GoverningTokenType::Membership => Ok(()),\n            GoverningTokenType::Liquid | GoverningTokenType::Dormant => {\n                Err(GovernanceError::CannotRevokeGoverningTokens.into())\n            }",
    "pub fn assert_can_deposit_governing_token(\n        &self,\n        realm_data: &RealmV2,\n        governing_token_mint: &Pubkey,\n    ) -> Result<(), ProgramError> {\n        let governing_token_type = &self\n            .get_token_config(realm_data, governing_token_mint)?\n            .token_type;\n\n        match governing_token_type {\n            GoverningTokenType::Membership | GoverningTokenType::Liquid => Ok(()),\n            // Note: Preventing deposits of the Dormant type tokens is not a direct security concern\n            // It only makes the intention of not using deposited tokens as governance power\n            // stronger\n            GoverningTokenType::Dormant => Err(GovernanceError::CannotDepositDormantTokens.into()),\n        }\n    }\n\n    /// Asserts the given governing token can be withdrawn\n    pub fn assert_can_withdraw_governing_token(\n        &self,\n        realm_data: &RealmV2,\n        governing_token_mint: &Pubkey,\n    ) -> Result<(), ProgramError> {\n        let governing_token_type = &self\n            .get_token_config(realm_data, governing_token_mint)?\n            .token_type;\n\n        match governing_token_type {\n            GoverningTokenType::Dormant | GoverningTokenType::Liquid => Ok(()),\n            GoverningTokenType::Membership => {\n                Err(GovernanceError::CannotWithdrawMembershipTokens.into())\n            }",
    "pub fn assert_can_change_config(\n        &self,\n        realm_config_args: &RealmConfigArgs,\n    ) -> Result<(), ProgramError> {\n        // Existing community token type can't be changed to Membership because it would\n        // give the Realm authority the right to burn members tokens which should not be\n        // the case because the tokens belong to the members On the other had\n        // for the Council token it's acceptable and in fact desired change because\n        // council tokens denote membership which should be controlled by the\n        // Realm\n        if self.community_token_config.token_type != GoverningTokenType::Membership\n            && realm_config_args.community_token_config_args.token_type\n                == GoverningTokenType::Membership\n        {\n            return Err(GovernanceError::CannotChangeCommunityTokenTypeToMembership.into());\n        }\n\n        Ok(())\n    }",
    "pub fn get_realm_config_data(\n    program_id: &Pubkey,\n    realm_config_info: &AccountInfo,\n) -> Result<RealmConfigAccount, ProgramError> {\n    get_account_data::<RealmConfigAccount>(program_id, realm_config_info)\n}",
    "pub fn get_realm_config_data_for_realm(\n    program_id: &Pubkey,\n    realm_config_info: &AccountInfo,\n    realm: &Pubkey,\n) -> Result<RealmConfigAccount, ProgramError> {\n    let realm_config_data = if realm_config_info.data_is_empty() {\n        // If RealmConfigAccount doesn't exist yet then validate its PDA\n        // PDA validation is required because RealmConfigAccount might not exist for\n        // legacy Realms and then its absence is used as default\n        // RealmConfigAccount value with no plugins and Liquid governance tokens\n        let realm_config_address = get_realm_config_address(program_id, realm);\n\n        if realm_config_address != *realm_config_info.key {\n            return Err(GovernanceError::InvalidRealmConfigAddress.into());\n        }\n\n        RealmConfigAccount {\n            account_type: GovernanceAccountType::RealmConfig,\n            realm: *realm,\n            community_token_config: GoverningTokenConfig::default(),\n            council_token_config: GoverningTokenConfig::default(),\n            reserved: Reserved110::default(),\n        }\n    } else {\n        let realm_config_data = get_realm_config_data(program_id, realm_config_info)?;\n\n        if realm_config_data.realm != *realm {\n            return Err(GovernanceError::InvalidRealmConfigForRealm.into());\n        }\n\n        realm_config_data\n    };\n\n    Ok(realm_config_data)\n}",
    "pub fn get_realm_config_address_seeds(realm: &Pubkey) -> [&[u8]; 2] {\n    [b\"realm-config\", realm.as_ref()]\n}\n\n/// Returns RealmConfig PDA address\npub fn get_realm_config_address(program_id: &Pubkey, realm: &Pubkey) -> Pubkey {\n    Pubkey::find_program_address(&get_realm_config_address_seeds(realm), program_id).0\n}\n/// Resolves GoverningTokenConfig from GoverningTokenConfigArgs and instruction\n/// accounts\npub fn resolve_governing_token_config(\n    account_info_iter: &mut Iter<AccountInfo>,\n    governing_token_config_args: &GoverningTokenConfigArgs,\n    existing_governing_token_config: Option<GoverningTokenConfig>,\n) -> Result<GoverningTokenConfig, ProgramError> {\n    let voter_weight_addin = if governing_token_config_args.use_voter_weight_addin {\n        let voter_weight_addin_info = next_account_info(account_info_iter)?;\n        Some(*voter_weight_addin_info.key)\n    }",
    "pub fn get_required_signatory_data_for_governance(\n    program_id: &Pubkey,\n    required_signatory_info: &AccountInfo,\n    governance: &Pubkey,\n) -> Result<RequiredSignatory, ProgramError> {\n    let required_signatory_data =\n        get_account_data::<RequiredSignatory>(program_id, required_signatory_info)?;\n\n    if required_signatory_data.governance != *governance {\n        return Err(GovernanceError::InvalidGovernanceForRequiredSignatory.into());\n    }\n\n    Ok(required_signatory_data)\n}",
    "pub fn assert_can_sign_off(&self, signatory_info: &AccountInfo) -> Result<(), ProgramError> {\n        if self.signed_off {\n            return Err(GovernanceError::SignatoryAlreadySignedOff.into());\n        }\n\n        if !signatory_info.is_signer {\n            return Err(GovernanceError::SignatoryMustSign.into());\n        }\n\n        Ok(())\n    }",
    "pub fn assert_can_remove_signatory(&self) -> Result<(), ProgramError> {\n        if self.signed_off {\n            return Err(GovernanceError::SignatoryAlreadySignedOff.into());\n        }\n\n        Ok(())\n    }",
    "pub fn get_signatory_record_data(\n    program_id: &Pubkey,\n    signatory_record_info: &AccountInfo,\n) -> Result<SignatoryRecordV2, ProgramError> {\n    let account_type: GovernanceAccountType = get_account_type(program_id, signatory_record_info)?;\n\n    // If the account is V1 version then translate to V2\n    if account_type == GovernanceAccountType::SignatoryRecordV1 {\n        let signatory_record_data_v1 =\n            get_account_data::<SignatoryRecordV1>(program_id, signatory_record_info)?;\n\n        return Ok(SignatoryRecordV2 {\n            account_type,\n\n            proposal: signatory_record_data_v1.proposal,\n            signatory: signatory_record_data_v1.signatory,\n            signed_off: signatory_record_data_v1.signed_off,\n\n            // Add the extra reserved_v2 padding\n            reserved_v2: [0; 8],\n        });\n    }\n\n    get_account_data::<SignatoryRecordV2>(program_id, signatory_record_info)\n}",
    "pub fn get_signatory_record_data_for_seeds(\n    program_id: &Pubkey,\n    signatory_record_info: &AccountInfo,\n    proposal: &Pubkey,\n    signatory: &Pubkey,\n) -> Result<SignatoryRecordV2, ProgramError> {\n    let (signatory_record_address, _) = Pubkey::find_program_address(\n        &get_signatory_record_address_seeds(proposal, signatory),\n        program_id,\n    );\n\n    if signatory_record_address != *signatory_record_info.key {\n        return Err(GovernanceError::InvalidSignatoryAddress.into());\n    }\n\n    get_signatory_record_data(program_id, signatory_record_info)\n}",
    "pub fn is_expired(&self, current_unix_timestamp: UnixTimestamp) -> bool {\n        // If the expiry is None then the lock never expires\n        self.expiry.is_some() && Some(current_unix_timestamp) > self.expiry\n    }\n}\n\n/// Governance Token Owner Record\n/// Account PDA seeds: ['governance', realm, token_mint, token_owner ]\n#[derive(Clone, Debug, PartialEq, Eq, BorshDeserialize, BorshSerialize, BorshSchema)]\npub struct TokenOwnerRecordV2 {\n    /// Governance account type\n    pub account_type: GovernanceAccountType,\n\n    /// The Realm the TokenOwnerRecord belongs to\n    pub realm: Pubkey,\n\n    /// Governing Token Mint the TokenOwnerRecord holds deposit for\n    pub governing_token_mint: Pubkey,\n\n    /// The owner (either single or multisig) of the deposited governing SPL\n    /// Tokens This is who can authorize a withdrawal of the tokens\n    pub governing_token_owner: Pubkey,\n\n    /// The amount of governing tokens deposited into the Realm\n    /// This amount is the voter weight used when voting on proposals\n    pub governing_token_deposit_amount: u64,\n\n    /// The number of votes cast by TokenOwner but not relinquished yet\n    /// Every time a vote is cast this number is increased and it's always\n    /// decreased when relinquishing a vote regardless of the vote state\n    pub unrelinquished_votes_count: u64,\n\n    /// The number of outstanding proposals the TokenOwner currently owns\n    /// The count is increased when TokenOwner creates a proposal\n    /// and decreased  once it's either voted on (Succeeded or Defeated) or\n    /// Cancelled By default it's restricted to 1 outstanding Proposal per\n    /// token owner\n    pub outstanding_proposal_count: u8,\n\n    /// Version of the account layout\n    /// Note: In future versions (>program V3) we should introduce\n    /// GovernanceAccountType::TokenOwnerRecord(version:u8) as a way to version\n    /// this account (and all other accounts too) It can't be done in\n    /// program V3  because it would require to fetch another\n    /// GovernanceAccountType by the UI and the RPC is already overloaded with\n    /// all the existing types The new account type and versioning scheme\n    /// can be introduced once we migrate UI to use indexer to fetch all the\n    /// accounts Once the new versioning scheme is introduced this field can\n    /// be migrated and removed\n    ///\n    /// The other issues which need to be addressed before we can cleanup the\n    /// account versioning code:\n    /// 1) Remove the specific governance accounts (ProgramGovernance,\n    ///    TokenGovernance, MintGovernance) The only reason they exist is the UI\n    ///    which can't handle the generic use case for those assets\n    /// 2) For account layout breaking changes all plugins would have to be\n    ///    upgraded\n    /// 3) For account layout changes the Holaplex indexer would have to be\n    ///    upgraded\n    /// 4) We should migrate the UI to use the indexer for fetching data and\n    ///    stop using getProgramAccounts\n    /// 5) The UI would have to be upgraded to support account migration to the\n    ///    latest version\n    /// 6) The client sdk is already messy because of the different\n    ///    program/account versions and it should be cleaned up before we add\n    ///    even more versions.\n    pub version: u8,\n\n    /// Reserved space for future versions\n    pub reserved: [u8; 6],\n\n    /// A single account that is allowed to operate governance with the\n    /// deposited governing tokens It can be delegated to by the\n    /// governing_token_owner or current governance_delegate\n    pub governance_delegate: Option<Pubkey>,\n\n    /// Reserved space for versions v2 and onwards\n    /// Note: V1 accounts must be resized before using this space\n    pub reserved_v2: [u8; 124],\n\n    /// A list of locks which can be issued by external authorities\n    /// to prevent token withdrawals\n    pub locks: Vec<TokenOwnerRecordLock>,\n}\n\n/// The current version of TokenOwnerRecord account layout\n/// Note: It's the version of the account layout and not the version of the\n/// program or the account type\n///\n/// program V1,V2 -> account layout version 0\n/// program V3 -> account layout version 1\npub const TOKEN_OWNER_RECORD_LAYOUT_VERSION: u8 = 1;\n\nimpl AccountMaxSize for TokenOwnerRecordV2 {\n    fn get_max_size(&self) -> Option<usize> {\n        Some(282 + self.locks.len() * 42)\n    }",
    "pub fn assert_token_owner_or_delegate_is_signer(\n        &self,\n        governance_authority_info: &AccountInfo,\n    ) -> Result<(), ProgramError> {\n        if governance_authority_info.is_signer {\n            if &self.governing_token_owner == governance_authority_info.key {\n                return Ok(());\n            }\n\n            if let Some(governance_delegate) = self.governance_delegate {\n                if &governance_delegate == governance_authority_info.key {\n                    return Ok(());\n                }\n            };\n        }\n\n        Err(GovernanceError::GoverningTokenOwnerOrDelegateMustSign.into())\n    }",
    "pub fn assert_can_create_proposal(\n        &self,\n        realm_data: &RealmV2,\n        config: &GovernanceConfig,\n        voter_weight: u64,\n    ) -> Result<(), ProgramError> {\n        let min_weight_to_create_proposal =\n            if self.governing_token_mint == realm_data.community_mint {\n                config.min_community_weight_to_create_proposal\n            } else if Some(self.governing_token_mint) == realm_data.config.council_mint {\n                config.min_council_weight_to_create_proposal\n            } else {\n                return Err(GovernanceError::InvalidGoverningTokenMint.into());\n            };\n\n        // If the weight threshold is set to u64::MAX then it indicates explicitly\n        // Disabled value which should prevent any possibility of using it\n        if min_weight_to_create_proposal == u64::MAX {\n            return Err(GovernanceError::VoterWeightThresholdDisabled.into());\n        }\n\n        if voter_weight < min_weight_to_create_proposal {\n            return Err(GovernanceError::NotEnoughTokensToCreateProposal.into());\n        }\n\n        // The number of outstanding proposals is currently restricted to 10\n        // If there is a need to change it in the future then it should be added to\n        // realm or governance config\n        if self.outstanding_proposal_count >= 10 {\n            return Err(GovernanceError::TooManyOutstandingProposals.into());\n        }\n\n        Ok(())\n    }",
    "pub fn assert_can_create_governance(\n        &self,\n        realm_data: &RealmV2,\n        voter_weight: u64,\n    ) -> Result<(), ProgramError> {\n        let min_weight_to_create_governance =\n            if self.governing_token_mint == realm_data.community_mint {\n                realm_data.config.min_community_weight_to_create_governance\n            } else if Some(self.governing_token_mint) == realm_data.config.council_mint {\n                // For council tokens it's enough to be in possession of any number of tokens\n                1\n            } else {\n                return Err(GovernanceError::InvalidGoverningTokenMint.into());\n            };\n\n        // If the weight threshold is set to u64::MAX then it indicates explicitly\n        // Disabled value which should prevent any possibility of using it\n        if min_weight_to_create_governance == u64::MAX {\n            return Err(GovernanceError::VoterWeightThresholdDisabled.into());\n        }\n\n        if voter_weight < min_weight_to_create_governance {\n            return Err(GovernanceError::NotEnoughTokensToCreateGovernance.into());\n        }\n\n        Ok(())\n    }",
    "pub fn assert_can_withdraw_governing_tokens(\n        &self,\n        current_unix_timestamp: UnixTimestamp,\n    ) -> Result<(), ProgramError> {\n        if self.unrelinquished_votes_count > 0 {\n            return Err(\n                GovernanceError::AllVotesMustBeRelinquishedToWithdrawGoverningTokens.into(),\n            );\n        }\n\n        if self.outstanding_proposal_count > 0 {\n            return Err(\n                GovernanceError::AllProposalsMustBeFinalisedToWithdrawGoverningTokens.into(),\n            );\n        }\n\n        if self\n            .locks\n            .iter()\n            .any(|lock| !lock.is_expired(current_unix_timestamp))\n        {\n            return Err(GovernanceError::TokenOwnerRecordLocked.into());\n        }\n\n        Ok(())\n    }",
    "pub fn decrease_outstanding_proposal_count(&mut self) {\n        // Previous versions didn't use the count and it can be already 0\n        // TODO: Remove this check once all outstanding proposals on mainnet are\n        // resolved\n        if self.outstanding_proposal_count != 0 {\n            self.outstanding_proposal_count =\n                self.outstanding_proposal_count.checked_sub(1).unwrap();\n        }\n    }\n\n    /// Resolves voter's weight using either the amount deposited into the realm\n    /// or weight provided by voter weight addin (if configured)\n    #[allow(clippy::too_many_arguments)]\n    pub fn resolve_voter_weight(\n        &self,\n        account_info_iter: &mut Iter<AccountInfo>,\n        realm_data: &RealmV2,\n        realm_config_data: &RealmConfigAccount,\n        weight_action: VoterWeightAction,\n        weight_action_target: &Pubkey,\n    ) -> Result<u64, ProgramError> {\n        // if the Realm is configured to use voter weight plugin for our\n        // governing_token_mint then use the externally provided voter_weight\n        // instead of governing_token_deposit_amount\n        if let Some(voter_weight_addin) = realm_config_data\n            .get_token_config(realm_data, &self.governing_token_mint)?\n            .voter_weight_addin\n        {\n            let voter_weight_record_info = next_account_info(account_info_iter)?;\n\n            let voter_weight_record_data = get_voter_weight_record_data_for_token_owner_record(\n                &voter_weight_addin,\n                voter_weight_record_info,\n                self,\n            )?;\n\n            assert_is_valid_voter_weight(\n                &voter_weight_record_data,\n                weight_action,\n                weight_action_target,\n            )?;\n\n            Ok(voter_weight_record_data.voter_weight)\n        }",
    "pub fn remove_expired_locks(&mut self, current_unix_timestamp: UnixTimestamp) {\n        self.locks\n            .retain(|lock| !lock.is_expired(current_unix_timestamp));\n    }\n\n    /// Removes a lock by its id and authority\n    pub fn remove_lock(\n        &mut self,\n        lock_id: u8,\n        lock_authority: &Pubkey,\n    ) -> Result<(), ProgramError> {\n        if let Some(lock_index) = self\n            .locks\n            .iter()\n            .position(|lock| lock.lock_id == lock_id && lock.authority == *lock_authority)\n        {\n            self.locks.remove(lock_index);\n            Ok(())\n        }",
    "pub fn upsert_lock(&mut self, lock: TokenOwnerRecordLock) {\n        if let Some(lock_index) = self.locks.iter().position(|existing_lock| {\n            existing_lock.lock_id == lock.lock_id && existing_lock.authority == lock.authority\n        }) {\n            self.locks[lock_index] = lock;\n        } else {\n            self.locks.push(lock);\n        }\n    }\n\n    /// Serializes TokenOwnerRecord and resizes it if required\n    /// If the account is TokenOwnerRecordV1 and needs to be resized\n    /// then its type is changed to TokenOwnerRecordV2 to preserve the extra\n    /// data\n    pub fn serialize_with_resize<'a>(\n        mut self,\n        token_owner_record_info: &AccountInfo<'a>,\n        payer_info: &AccountInfo<'a>,\n        system_info: &AccountInfo<'a>,\n        rent: &Rent,\n    ) -> Result<(), ProgramError> {\n        let token_owner_record_data_max_size = self.get_max_size().unwrap();\n        if token_owner_record_info.data_len() < token_owner_record_data_max_size {\n            extend_account_size(\n                token_owner_record_info,\n                payer_info,\n                token_owner_record_data_max_size,\n                rent,\n                system_info,\n            )?;\n\n            // When the account is resized we have to change the type to V2 to preserve\n            // the extra data\n            if self.account_type == GovernanceAccountType::TokenOwnerRecordV1 {\n                self.account_type = GovernanceAccountType::TokenOwnerRecordV2;\n            }\n        }\n\n        self.serialize(&mut token_owner_record_info.data.borrow_mut()[..])\n    }",
    "pub fn get_token_owner_record_address(\n    program_id: &Pubkey,\n    realm: &Pubkey,\n    governing_token_mint: &Pubkey,\n    governing_token_owner: &Pubkey,\n) -> Pubkey {\n    Pubkey::find_program_address(\n        &get_token_owner_record_address_seeds(realm, governing_token_mint, governing_token_owner),\n        program_id,\n    )\n    .0\n}\n\n/// Returns TokenOwnerRecord PDA seeds\npub fn get_token_owner_record_address_seeds<'a>(\n    realm: &'a Pubkey,\n    governing_token_mint: &'a Pubkey,\n    governing_token_owner: &'a Pubkey,\n) -> [&'a [u8]; 4] {\n    [\n        PROGRAM_AUTHORITY_SEED,\n        realm.as_ref(),\n        governing_token_mint.as_ref(),\n        governing_token_owner.as_ref(),\n    ]\n}\n\n/// Deserializes TokenOwnerRecord account and checks owner program\npub fn get_token_owner_record_data(\n    program_id: &Pubkey,\n    token_owner_record_info: &AccountInfo,\n) -> Result<TokenOwnerRecordV2, ProgramError> {\n    let account_type: GovernanceAccountType =\n        get_account_type(program_id, token_owner_record_info)?;\n\n    // If the account is V1 version then translate to V2\n    let mut token_owner_record_data = if account_type == GovernanceAccountType::TokenOwnerRecordV1 {\n        let token_owner_record_data_v1 =\n            get_account_data::<TokenOwnerRecordV1>(program_id, token_owner_record_info)?;\n\n        TokenOwnerRecordV2 {\n            account_type,\n            realm: token_owner_record_data_v1.realm,\n            governing_token_mint: token_owner_record_data_v1.governing_token_mint,\n            governing_token_owner: token_owner_record_data_v1.governing_token_owner,\n            governing_token_deposit_amount: token_owner_record_data_v1\n                .governing_token_deposit_amount,\n            unrelinquished_votes_count: token_owner_record_data_v1.unrelinquished_votes_count,\n            outstanding_proposal_count: token_owner_record_data_v1.outstanding_proposal_count,\n            version: token_owner_record_data_v1.version,\n            reserved: token_owner_record_data_v1.reserved,\n            governance_delegate: token_owner_record_data_v1.governance_delegate,\n\n            // Add the extra reserved_v2 padding\n            reserved_v2: [0; 124],\n            locks: vec![],\n        }\n    } else {\n        get_account_data::<TokenOwnerRecordV2>(program_id, token_owner_record_info)?\n    };\n\n    // If the deserialized account uses the old account layout indicated by the\n    // version value then migrate the data to version 1\n    if token_owner_record_data.version < 1 {\n        token_owner_record_data.version = 1;\n\n        // In previous versions unrelinquished_votes_count was u32 followed by\n        // total_votes_count:u32 In program V3 unrelinquished_votes_count was\n        // changed to u64 by extending it into the space previously used by\n        // total_votes_count:u32 Since total_votes_count could have some value\n        // we have to zero the upper 4 bytes of unrelinquished_votes_count\n        token_owner_record_data.unrelinquished_votes_count &= u32::MAX as u64;\n    }\n\n    Ok(token_owner_record_data)\n}",
    "pub fn get_token_owner_record_data_for_seeds(\n    program_id: &Pubkey,\n    token_owner_record_info: &AccountInfo,\n    token_owner_record_seeds: &[&[u8]],\n) -> Result<TokenOwnerRecordV2, ProgramError> {\n    let (token_owner_record_address, _) =\n        Pubkey::find_program_address(token_owner_record_seeds, program_id);\n\n    if token_owner_record_address != *token_owner_record_info.key {\n        return Err(GovernanceError::InvalidTokenOwnerRecordAccountAddress.into());\n    }\n\n    get_token_owner_record_data(program_id, token_owner_record_info)\n}",
    "pub fn get_token_owner_record_data_for_realm(\n    program_id: &Pubkey,\n    token_owner_record_info: &AccountInfo,\n    realm: &Pubkey,\n) -> Result<TokenOwnerRecordV2, ProgramError> {\n    let token_owner_record_data = get_token_owner_record_data(program_id, token_owner_record_info)?;\n\n    if token_owner_record_data.realm != *realm {\n        return Err(GovernanceError::InvalidRealmForTokenOwnerRecord.into());\n    }\n\n    Ok(token_owner_record_data)\n}",
    "pub fn get_token_owner_record_data_for_realm_and_governing_mint(\n    program_id: &Pubkey,\n    token_owner_record_info: &AccountInfo,\n    realm: &Pubkey,\n    governing_token_mint: &Pubkey,\n) -> Result<TokenOwnerRecordV2, ProgramError> {\n    let token_owner_record_data =\n        get_token_owner_record_data_for_realm(program_id, token_owner_record_info, realm)?;\n\n    if token_owner_record_data.governing_token_mint != *governing_token_mint {\n        return Err(GovernanceError::InvalidGoverningMintForTokenOwnerRecord.into());\n    }\n\n    Ok(token_owner_record_data)\n}",
    "pub fn get_token_owner_record_data_for_proposal_owner(\n    program_id: &Pubkey,\n    token_owner_record_info: &AccountInfo,\n    proposal_owner: &Pubkey,\n) -> Result<TokenOwnerRecordV2, ProgramError> {\n    if token_owner_record_info.key != proposal_owner {\n        return Err(GovernanceError::InvalidProposalOwnerAccount.into());\n    }\n\n    get_token_owner_record_data(program_id, token_owner_record_info)\n}",
    "pub fn get_choice_weight(&self, voter_weight: u64) -> Result<u64, ProgramError> {\n        Ok(match self.weight_percentage {\n            // Avoid any rounding errors for full weight\n            100 => voter_weight,\n            // Note: The total weight for all choices might not equal voter_weight due to rounding\n            // errors\n            0..=99 => (voter_weight as u128)\n                .checked_mul(self.weight_percentage as u128)\n                .unwrap()\n                .checked_div(100)\n                .unwrap() as u64,\n            _ => return Err(GovernanceError::InvalidVoteChoiceWeightPercentage.into()),\n        })\n    }",
    "pub fn get_vote_kind(vote: &Vote) -> VoteKind {\n    match vote {\n        Vote::Approve(_) | Vote::Deny | Vote::Abstain => VoteKind::Electorate,\n        Vote::Veto => VoteKind::Veto,\n    }\n}\n\n/// Proposal VoteRecord\n#[derive(Clone, Debug, PartialEq, Eq, BorshDeserialize, BorshSerialize, BorshSchema)]\npub struct VoteRecordV2 {\n    /// Governance account type\n    pub account_type: GovernanceAccountType,\n\n    /// Proposal account\n    pub proposal: Pubkey,\n\n    /// The user who casted this vote\n    /// This is the Governing Token Owner who deposited governing tokens into\n    /// the Realm\n    pub governing_token_owner: Pubkey,\n\n    /// Indicates whether the vote was relinquished by voter\n    pub is_relinquished: bool,\n\n    /// The weight of the user casting the vote\n    pub voter_weight: u64,\n\n    /// Voter's vote\n    pub vote: Vote,\n\n    /// Reserved space for versions v2 and onwards\n    /// Note: V1 accounts must be resized before using this space\n    pub reserved_v2: [u8; 8],\n}\n\nimpl AccountMaxSize for VoteRecordV2 {}\n\nimpl IsInitialized for VoteRecordV2 {\n    fn is_initialized(&self) -> bool {\n        self.account_type == GovernanceAccountType::VoteRecordV2\n    }\n}\nimpl VoteRecordV2 {\n    /// Checks the vote can be relinquished\n    pub fn assert_can_relinquish_vote(&self) -> Result<(), ProgramError> {\n        if self.is_relinquished {\n            return Err(GovernanceError::VoteAlreadyRelinquished.into());\n        }\n\n        Ok(())\n    }",
    "pub fn get_vote_record_data(\n    program_id: &Pubkey,\n    vote_record_info: &AccountInfo,\n) -> Result<VoteRecordV2, ProgramError> {\n    let account_type: GovernanceAccountType = get_account_type(program_id, vote_record_info)?;\n\n    // If the account is V1 version then translate to V2\n    if account_type == GovernanceAccountType::VoteRecordV1 {\n        let vote_record_data_v1 = get_account_data::<VoteRecordV1>(program_id, vote_record_info)?;\n\n        let (vote, voter_weight) = match vote_record_data_v1.vote_weight {\n            VoteWeightV1::Yes(weight) => (\n                Vote::Approve(vec![VoteChoice {\n                    rank: 0,\n                    weight_percentage: 100,\n                }]),\n                weight,\n            ),\n            VoteWeightV1::No(weight) => (Vote::Deny, weight),\n        };\n\n        return Ok(VoteRecordV2 {\n            account_type,\n            proposal: vote_record_data_v1.proposal,\n            governing_token_owner: vote_record_data_v1.governing_token_owner,\n            is_relinquished: vote_record_data_v1.is_relinquished,\n            voter_weight,\n            vote,\n            reserved_v2: [0; 8],\n        });\n    }\n\n    get_account_data::<VoteRecordV2>(program_id, vote_record_info)\n}",
    "pub fn get_vote_record_data_for_proposal_and_token_owner_record(\n    program_id: &Pubkey,\n    vote_record_info: &AccountInfo,\n    realm_data: &RealmV2,\n    proposal: &Pubkey,\n    proposal_data: &ProposalV2,\n    token_owner_record_data: &TokenOwnerRecordV2,\n) -> Result<VoteRecordV2, ProgramError> {\n    let vote_record_data = get_vote_record_data(program_id, vote_record_info)?;\n\n    if vote_record_data.proposal != *proposal {\n        return Err(GovernanceError::InvalidProposalForVoterRecord.into());\n    }\n\n    if vote_record_data.governing_token_owner != token_owner_record_data.governing_token_owner {\n        return Err(GovernanceError::InvalidGoverningTokenOwnerForVoteRecord.into());\n    }\n\n    // Assert governing_token_mint between Proposal and TokenOwnerRecord match for\n    // the deserialized VoteRecord For Approve, Deny and Abstain votes\n    // Proposal.governing_token_mint must equal\n    // TokenOwnerRecord.governing_token_mint For Veto vote it must be the\n    // governing_token_mint of the opposite voting population\n    let proposal_governing_token_mint = realm_data.get_proposal_governing_token_mint_for_vote(\n        &token_owner_record_data.governing_token_mint,\n        &get_vote_kind(&vote_record_data.vote),\n    )?;\n\n    if proposal_data.governing_token_mint != proposal_governing_token_mint {\n        return Err(GovernanceError::InvalidGoverningMintForProposal.into());\n    }\n\n    Ok(vote_record_data)\n}",
    "pub fn get_program_data_address(program: &Pubkey) -> Pubkey {\n    Pubkey::find_program_address(&[program.as_ref()], &bpf_loader_upgradeable::id()).0\n}\n\n/// Returns upgrade_authority from the given Upgradable Loader Account\npub fn get_program_upgrade_authority(\n    upgradable_loader_state: &UpgradeableLoaderState,\n) -> Result<Option<Pubkey>, ProgramError> {\n    let upgrade_authority = match upgradable_loader_state {\n        UpgradeableLoaderState::ProgramData {\n            slot: _,\n            upgrade_authority_address,\n        } => *upgrade_authority_address,\n        _ => return Err(ProgramError::InvalidAccountData),\n    };\n\n    Ok(upgrade_authority)\n}",
    "pub fn assert_program_upgrade_authority_is_signer(\n    program_address: &Pubkey,\n    program_data_info: &AccountInfo,\n    program_upgrade_authority_info: &AccountInfo,\n) -> Result<(), ProgramError> {\n    if program_data_info.owner != &bpf_loader_upgradeable::id() {\n        return Err(ProgramError::IncorrectProgramId);\n    }\n    let program_data_address = get_program_data_address(program_address);\n\n    if program_data_address != *program_data_info.key {\n        return Err(GovernanceError::InvalidProgramDataAccountAddress.into());\n    }\n\n    let upgrade_authority = if let UpgradeableLoaderState::ProgramData {\n        slot: _,\n        upgrade_authority_address,\n    } = deserialize(&program_data_info.data.borrow())\n        .map_err(|_| GovernanceError::InvalidProgramDataAccountData)?\n    {\n        upgrade_authority_address\n    } else {\n        None\n    };\n\n    let upgrade_authority = upgrade_authority.ok_or(GovernanceError::ProgramNotUpgradable)?;\n\n    if upgrade_authority != *program_upgrade_authority_info.key {\n        return Err(GovernanceError::InvalidUpgradeAuthority.into());\n    }\n    if !program_upgrade_authority_info.is_signer {\n        return Err(GovernanceError::UpgradeAuthorityMustSign.into());\n    }\n\n    Ok(())\n}",
    "pub fn assert_is_valid_spl_token_account(account_info: &AccountInfo) -> Result<(), ProgramError> {\n    if account_info.data_is_empty() {\n        return Err(GovernanceError::SplTokenAccountDoesNotExist.into());\n    }\n\n    if account_info.owner != &spl_token::id() {\n        return Err(GovernanceError::SplTokenAccountWithInvalidOwner.into());\n    }\n\n    if account_info.data_len() != Account::LEN {\n        return Err(GovernanceError::SplTokenInvalidTokenAccountData.into());\n    }\n\n    // TokenAccount layout:\n    //  mint(32)\n    //  owner(32)\n    //  amount(8)\n    //  delegate(36)\n    //  state(1)\n    //  ...\n    let data = account_info.try_borrow_data()?;\n    let state = array_ref![data, 108, 1];\n\n    if state == &[0] {\n        return Err(GovernanceError::SplTokenAccountNotInitialized.into());\n    }\n\n    Ok(())\n}",
    "pub fn is_spl_token_account(account_info: &AccountInfo) -> bool {\n    assert_is_valid_spl_token_account(account_info).is_ok()\n}",
    "pub fn assert_is_valid_spl_token_mint(mint_info: &AccountInfo) -> Result<(), ProgramError> {\n    if mint_info.data_is_empty() {\n        return Err(GovernanceError::SplTokenMintDoesNotExist.into());\n    }\n\n    if mint_info.owner != &spl_token::id() {\n        return Err(GovernanceError::SplTokenMintWithInvalidOwner.into());\n    }\n\n    if mint_info.data_len() != Mint::LEN {\n        return Err(GovernanceError::SplTokenInvalidMintAccountData.into());\n    }\n\n    // In token program [36, 8, 1, is_initialized(1), 36] is the layout\n    let data = mint_info.try_borrow_data()?;\n    let is_initialized = array_ref![data, 45, 1];\n\n    if is_initialized == &[0] {\n        return Err(GovernanceError::SplTokenMintNotInitialized.into());\n    }\n\n    Ok(())\n}",
    "pub fn is_spl_token_mint(mint_info: &AccountInfo) -> bool {\n    assert_is_valid_spl_token_mint(mint_info).is_ok()\n}",
    "pub fn get_spl_token_mint(token_account_info: &AccountInfo) -> Result<Pubkey, ProgramError> {\n    assert_is_valid_spl_token_account(token_account_info)?;\n\n    // TokeAccount layout:   mint(32), owner(32), amount(8), ...\n    let data = token_account_info.try_borrow_data()?;\n    let mint_data = array_ref![data, 0, 32];\n    Ok(Pubkey::new_from_array(*mint_data))\n}",
    "pub fn get_spl_token_owner(token_account_info: &AccountInfo) -> Result<Pubkey, ProgramError> {\n    assert_is_valid_spl_token_account(token_account_info)?;\n\n    // TokeAccount layout:   mint(32), owner(32), amount(8)\n    let data = token_account_info.try_borrow_data()?;\n    let owner_data = array_ref![data, 32, 32];\n    Ok(Pubkey::new_from_array(*owner_data))\n}",
    "pub fn get_spl_token_mint_supply(mint_info: &AccountInfo) -> Result<u64, ProgramError> {\n    assert_is_valid_spl_token_mint(mint_info)?;\n    // In token program, 36, 8, 1, 1 is the layout, where the first 8 is supply u64.\n    // so we start at 36.\n    let data = mint_info.try_borrow_data().unwrap();\n    let bytes = array_ref![data, 36, 8];\n\n    Ok(u64::from_le_bytes(*bytes))\n}",
    "pub fn get_spl_token_mint_authority(\n    mint_info: &AccountInfo,\n) -> Result<COption<Pubkey>, ProgramError> {\n    assert_is_valid_spl_token_mint(mint_info)?;\n    // In token program, 36, 8, 1, 1 is the layout, where the first 36 is authority.\n    let data = mint_info.try_borrow_data().unwrap();\n    let bytes = array_ref![data, 0, 36];\n\n    unpack_coption_pubkey(bytes)\n}",
    "pub fn assert_spl_token_mint_authority_is_signer(\n    mint_info: &AccountInfo,\n    mint_authority_info: &AccountInfo,\n) -> Result<(), ProgramError> {\n    let mint_authority = get_spl_token_mint_authority(mint_info)?;\n\n    if mint_authority.is_none() {\n        return Err(GovernanceError::MintHasNoAuthority.into());\n    }\n\n    if !mint_authority.contains(mint_authority_info.key) {\n        return Err(GovernanceError::InvalidMintAuthority.into());\n    }\n\n    if !mint_authority_info.is_signer {\n        return Err(GovernanceError::MintAuthorityMustSign.into());\n    }\n\n    Ok(())\n}",
    "pub fn assert_spl_token_owner_is_signer(\n    token_info: &AccountInfo,\n    token_owner_info: &AccountInfo,\n) -> Result<(), ProgramError> {\n    let token_owner = get_spl_token_owner(token_info)?;\n\n    if token_owner != *token_owner_info.key {\n        return Err(GovernanceError::InvalidTokenOwner.into());\n    }\n\n    if !token_owner_info.is_signer {\n        return Err(GovernanceError::TokenOwnerMustSign.into());\n    }\n\n    Ok(())\n}",
    "pub fn get_governance_authority(&self) -> &Keypair {\n        self.governance_authority\n            .as_ref()\n            .unwrap_or(&self.token_owner)\n    }",
    "pub fn clone_governance_delegate(&self) -> Keypair {\n        clone_keypair(&self.governance_delegate)\n    }",
    "pub fn get_default_governance_config(&mut self) -> GovernanceConfig {\n        GovernanceConfig {\n            community_vote_threshold: VoteThreshold::YesVotePercentage(60),\n            min_community_weight_to_create_proposal: 5,\n            transactions_hold_up_time: 10,\n            voting_base_time: 10,\n            community_vote_tipping: spl_governance::state::enums::VoteTipping::Strict,\n            council_vote_threshold: VoteThreshold::YesVotePercentage(80),\n            council_veto_vote_threshold: VoteThreshold::YesVotePercentage(55),\n            min_council_weight_to_create_proposal: 2,\n            council_vote_tipping: spl_governance::state::enums::VoteTipping::Strict,\n            community_veto_vote_threshold: VoteThreshold::YesVotePercentage(80),\n            voting_cool_off_time: 0,\n            deposit_exempt_proposal_count: DEFAULT_DEPOSIT_EXEMPT_PROPOSAL_COUNT,\n        }\n    }\n\n    #[allow(dead_code)]\n    pub async fn with_governance(\n        &mut self,\n        realm_cookie: &RealmCookie,\n        token_owner_record_cookie: &TokenOwnerRecordCookie,\n    ) -> Result<GovernanceCookie, ProgramError> {\n        let config = self.get_default_governance_config();\n        self.with_governance_using_config(realm_cookie, token_owner_record_cookie, &config)\n            .await\n    }\n\n    #[allow(dead_code)]\n    pub async fn with_governance_using_config(\n        &mut self,\n        realm_cookie: &RealmCookie,\n        token_owner_record_cookie: &TokenOwnerRecordCookie,\n        governance_config: &GovernanceConfig,\n    ) -> Result<GovernanceCookie, ProgramError> {\n        let voter_weight_record = token_owner_record_cookie\n            .voter_weight_record\n            .as_ref()\n            .map(|voter_weight_record| voter_weight_record.address);\n\n        self.with_governance_impl(\n            realm_cookie,\n            Some(&token_owner_record_cookie.address),\n            &token_owner_record_cookie.token_owner,\n            voter_weight_record,\n            governance_config,\n            None,\n        )\n        .await\n    }\n\n    #[allow(dead_code)]\n    #[allow(clippy::too_many_arguments)]\n    pub async fn with_governance_impl(\n        &mut self,\n        realm_cookie: &RealmCookie,\n        token_owner_record: Option<&Pubkey>,\n        create_authority: &Keypair,\n        voter_weight_record: Option<Pubkey>,\n        governance_config: &GovernanceConfig,\n        signers_override: Option<&[&Keypair]>,\n    ) -> Result<GovernanceCookie, ProgramError> {\n        let governance_seed = Pubkey::new_unique();\n\n        let mut create_governance_ix = create_governance(\n            &self.program_id,\n            &realm_cookie.address,\n            &governance_seed,\n            token_owner_record.unwrap_or(&Pubkey::new_unique()),\n            &self.bench.payer.pubkey(),\n            &create_authority.pubkey(),\n            voter_weight_record,\n            governance_config.clone(),\n        );\n\n        let account = GovernanceV2 {\n            account_type: GovernanceAccountType::GovernanceV2,\n            realm: realm_cookie.address,\n            governance_seed,\n            config: governance_config.clone(),\n            reserved1: 0,\n            reserved_v2: Reserved119::default(),\n            required_signatories_count: 0,\n            active_proposal_count: 0,\n        };\n\n        let default_signers = &[create_authority];\n        let signers = signers_override.unwrap_or(default_signers);\n\n        if signers.is_empty() {\n            create_governance_ix.accounts[6].is_signer = false;\n        }\n\n        self.bench\n            .process_transaction(&[create_governance_ix], Some(signers))\n            .await?;\n\n        let governance_address =\n            get_governance_address(&self.program_id, &realm_cookie.address, &governance_seed);\n\n        Ok(GovernanceCookie {\n            address: governance_address,\n            account,\n            next_proposal_index: 0,\n        })\n    }",
    "pub fn remove_realm_config_account(&mut self, realm_config_address: &Pubkey) {\n        self.bench.remove_account(realm_config_address);\n    }\n\n    #[allow(dead_code)]\n    pub async fn get_governance_account(&mut self, governance_address: &Pubkey) -> GovernanceV2 {\n        self.bench\n            .get_borsh_account::<GovernanceV2>(governance_address)\n            .await\n    }\n\n    #[allow(dead_code)]\n    pub async fn get_proposal_account(&mut self, proposal_address: &Pubkey) -> ProposalV2 {\n        self.bench\n            .get_borsh_account::<ProposalV2>(proposal_address)\n            .await\n    }\n\n    #[allow(dead_code)]\n    pub async fn get_vote_record_account(&mut self, vote_record_address: &Pubkey) -> VoteRecordV2 {\n        self.bench\n            .get_borsh_account::<VoteRecordV2>(vote_record_address)\n            .await\n    }\n\n    #[allow(dead_code)]\n    pub async fn get_proposal_transaction_account(\n        &mut self,\n        proposal_transaction_address: &Pubkey,\n    ) -> ProposalTransactionV2 {\n        self.bench\n            .get_borsh_account::<ProposalTransactionV2>(proposal_transaction_address)\n            .await\n    }\n\n    #[allow(dead_code)]\n    pub async fn get_required_signatory_account(\n        &mut self,\n        required_signatory_address: &Pubkey,\n    ) -> RequiredSignatory {\n        self.bench\n            .get_borsh_account::<RequiredSignatory>(required_signatory_address)\n            .await\n    }\n\n    #[allow(dead_code)]\n    pub async fn get_signatory_record_account(\n        &mut self,\n        proposal_address: &Pubkey,\n    ) -> SignatoryRecordV2 {\n        self.bench\n            .get_borsh_account::<SignatoryRecordV2>(proposal_address)\n            .await\n    }\n\n    #[allow(dead_code)]\n    async fn get_packed_account<T: Pack + IsInitialized>(&mut self, address: &Pubkey) -> T {\n        self.bench\n            .context\n            .banks_client\n            .get_packed_account_data::<T>(*address)\n            .await\n            .unwrap()\n    }",
    "pub fn get_unique_name(&mut self, prefix: &str) -> String {\n        self.next_id += 1;\n\n        format!(\"{}.{}\", prefix, self.next_id)\n    }",
    "pub fn remove_account(&mut self, address: &Pubkey) {\n        let data =\n            AccountSharedData::create(0, vec![], system_program::id(), false, Epoch::default());\n\n        self.context.set_account(address, &data);\n    }\n\n    #[allow(dead_code)]\n    pub async fn get_account(&mut self, address: &Pubkey) -> Option<Account> {\n        self.context\n            .banks_client\n            .get_account(*address)\n            .await\n            .unwrap()\n    }",
    "pub fn map_transaction_error(transport_error: TransportError) -> ProgramError {\n    match transport_error {\n        TransportError::TransactionError(TransactionError::InstructionError(\n            _,\n            InstructionError::Custom(error_index),\n        )) => ProgramError::Custom(error_index),\n        TransportError::TransactionError(TransactionError::InstructionError(\n            _,\n            instruction_error,\n        )) => match instruction_error {\n            // In solana-sdk v1.19.0, there is a ProgramError for\n            // InstructionError::IncorrectAuthority. This results in the error mapping\n            // returning two different values: one for sdk < v1.19 and another for sdk >= v1.19.0.\n            // To avoid this situation, handle InstructionError::IncorrectAuthority earlier.\n            // Can be removed when Solana v1.19.0 becomes a stable channel (also need to update the\n            // test assert for\n            // `test_create_program_governance_with_incorrect_upgrade_authority_error`)\n            InstructionError::IncorrectAuthority => {\n                ProgramInstructionError::IncorrectAuthority.into()\n            }",
    "pub fn clone_keypair(source: &Keypair) -> Keypair {\n    Keypair::from_bytes(&source.to_bytes()).unwrap()\n}",
    "pub fn dispose_account(\n    account_info: &AccountInfo,\n    beneficiary_info: &AccountInfo,\n) -> Result<(), ProgramError> {\n    let account_lamports = account_info.lamports();\n    **account_info.lamports.borrow_mut() = 0;\n\n    **beneficiary_info.lamports.borrow_mut() = beneficiary_info\n        .lamports()\n        .checked_add(account_lamports)\n        .unwrap();\n\n    account_info.assign(&system_program::id());\n    account_info.realloc(0, false)\n}",
    "pub fn new() -> Self {\n        Self::default()\n    }",
    "pub fn is_initialized(&self) -> bool {\n        !(self.buffer_size == 0 && self.sequence_number == 0 && self.active_index == 0)\n    }",
    "pub fn initialize(&mut self) -> Result<Node, ConcurrentMerkleTreeError> {\n        check_bounds(MAX_DEPTH, MAX_BUFFER_SIZE);\n        if self.is_initialized() {\n            return Err(ConcurrentMerkleTreeError::TreeAlreadyInitialized);\n        }\n        let mut rightmost_proof = Path::default();\n        let empty_node_cache = [Node::default(); MAX_DEPTH];\n        for (i, node) in rightmost_proof.proof.iter_mut().enumerate() {\n            *node = empty_node_cached::<MAX_DEPTH>(i as u32, &empty_node_cache);\n        }\n        let mut path = [Node::default(); MAX_DEPTH];\n        for (i, node) in path.iter_mut().enumerate() {\n            *node = empty_node_cached::<MAX_DEPTH>(i as u32, &empty_node_cache);\n        }\n        self.change_logs[0].root = empty_node(MAX_DEPTH as u32);\n        self.change_logs[0].path = path;\n        self.sequence_number = 0;\n        self.active_index = 0;\n        self.buffer_size = 1;\n        self.rightmost_proof = rightmost_proof;\n        Ok(self.change_logs[0].root)\n    }",
    "pub fn initialize_with_root(\n        &mut self,\n        args: &InitializeWithRootArgs,\n    ) -> Result<Node, ConcurrentMerkleTreeError> {\n        check_bounds(MAX_DEPTH, MAX_BUFFER_SIZE);\n        check_leaf_index(args.index, MAX_DEPTH)?;\n\n        if self.is_initialized() {\n            return Err(ConcurrentMerkleTreeError::TreeAlreadyInitialized);\n        }\n        let mut proof: [Node; MAX_DEPTH] = [Node::default(); MAX_DEPTH];\n        proof.copy_from_slice(&args.proof_vec);\n        let rightmost_proof = Path {\n            proof,\n            index: args.index + 1,\n            leaf: args.rightmost_leaf,\n            _padding: 0,\n        };\n        self.change_logs[0].root = args.root;\n        self.sequence_number = 1;\n        self.active_index = 0;\n        self.buffer_size = 1;\n        self.rightmost_proof = rightmost_proof;\n        if args.root != recompute(args.rightmost_leaf, &proof, args.index) {\n            solana_logging!(\"Proof failed to verify\");\n            return Err(ConcurrentMerkleTreeError::InvalidProof);\n        }\n        Ok(args.root)\n    }",
    "pub fn prove_tree_is_empty(&self) -> Result<(), ConcurrentMerkleTreeError> {\n        if !self.is_initialized() {\n            return Err(ConcurrentMerkleTreeError::TreeNotInitialized);\n        }\n        let empty_node_cache = [EMPTY; MAX_DEPTH];\n        if self.get_root() != empty_node_cached::<MAX_DEPTH>(MAX_DEPTH as u32, &empty_node_cache) {\n            return Err(ConcurrentMerkleTreeError::TreeNonEmpty);\n        }\n        Ok(())\n    }",
    "pub fn get_root(&self) -> [u8; 32] {\n        self.get_change_log().root\n    }\n\n    /// Returns the most recent changelog\n    pub fn get_change_log(&self) -> Box<ChangeLog<MAX_DEPTH>> {\n        if !self.is_initialized() {\n            solana_logging!(\"Tree is not initialized, returning default change log\");\n            return Box::<ChangeLog<MAX_DEPTH>>::default();\n        }\n        Box::new(self.change_logs[self.active_index as usize])\n    }",
    "pub fn prove_leaf(&self, args: &ProveLeafArgs) -> Result<(), ConcurrentMerkleTreeError> {\n        check_bounds(MAX_DEPTH, MAX_BUFFER_SIZE);\n        check_leaf_index(args.index, MAX_DEPTH)?;\n        if !self.is_initialized() {\n            return Err(ConcurrentMerkleTreeError::TreeNotInitialized);\n        }\n\n        if args.index > self.rightmost_proof.index {\n            solana_logging!(\n                \"Received an index larger than the rightmost index {} > {}\",\n                args.index,\n                self.rightmost_proof.index\n            );\n            Err(ConcurrentMerkleTreeError::LeafIndexOutOfBounds)\n        }",
    "pub fn append(&mut self, mut node: Node) -> Result<Node, ConcurrentMerkleTreeError> {\n        check_bounds(MAX_DEPTH, MAX_BUFFER_SIZE);\n        if !self.is_initialized() {\n            return Err(ConcurrentMerkleTreeError::TreeNotInitialized);\n        }\n        if node == EMPTY {\n            return Err(ConcurrentMerkleTreeError::CannotAppendEmptyNode);\n        }\n        if self.rightmost_proof.index >= 1 << MAX_DEPTH {\n            return Err(ConcurrentMerkleTreeError::TreeFull);\n        }\n        if self.rightmost_proof.index == 0 {\n            return self.initialize_tree_from_append(node, self.rightmost_proof.proof);\n        }\n        let leaf = node;\n        let intersection = self.rightmost_proof.index.trailing_zeros() as usize;\n        let mut change_list = [EMPTY; MAX_DEPTH];\n        let mut intersection_node = self.rightmost_proof.leaf;\n        let empty_node_cache = [Node::default(); MAX_DEPTH];\n\n        for (i, cl_item) in change_list.iter_mut().enumerate().take(MAX_DEPTH) {\n            *cl_item = node;\n            match i {\n                i if i < intersection => {\n                    // Compute proof to the appended node from empty nodes\n                    let sibling = empty_node_cached::<MAX_DEPTH>(i as u32, &empty_node_cache);\n                    hash_to_parent(\n                        &mut intersection_node,\n                        &self.rightmost_proof.proof[i],\n                        ((self.rightmost_proof.index - 1) >> i) & 1 == 0,\n                    );\n                    hash_to_parent(&mut node, &sibling, true);\n                    self.rightmost_proof.proof[i] = sibling;\n                }\n                i if i == intersection => {\n                    // Compute the where the new node intersects the main tree\n                    hash_to_parent(&mut node, &intersection_node, false);\n                    self.rightmost_proof.proof[intersection] = intersection_node;\n                }\n                _ => {\n                    // Update the change list path up to the root\n                    hash_to_parent(\n                        &mut node,\n                        &self.rightmost_proof.proof[i],\n                        ((self.rightmost_proof.index - 1) >> i) & 1 == 0,\n                    );\n                }\n            }\n        }\n\n        self.update_internal_counters();\n        self.change_logs[self.active_index as usize] =\n            ChangeLog::<MAX_DEPTH>::new(node, change_list, self.rightmost_proof.index);\n        self.rightmost_proof.index += 1;\n        self.rightmost_proof.leaf = leaf;\n        Ok(node)\n    }",
    "pub fn fill_empty_or_append(\n        &mut self,\n        args: &FillEmptyOrAppendArgs,\n    ) -> Result<Node, ConcurrentMerkleTreeError> {\n        check_bounds(MAX_DEPTH, MAX_BUFFER_SIZE);\n        check_leaf_index(args.index, MAX_DEPTH)?;\n        if !self.is_initialized() {\n            return Err(ConcurrentMerkleTreeError::TreeNotInitialized);\n        }\n\n        let mut proof: [Node; MAX_DEPTH] = [Node::default(); MAX_DEPTH];\n        fill_in_proof::<MAX_DEPTH>(&args.proof_vec, &mut proof);\n\n        log_compute!();\n        match self.try_apply_proof(\n            args.current_root,\n            EMPTY,\n            args.leaf,\n            &mut proof,\n            args.index,\n            false,\n        ) {\n            Ok(new_root) => Ok(new_root),\n            Err(error) => match error {\n                ConcurrentMerkleTreeError::LeafContentsModified => self.append(args.leaf),\n                _ => Err(error),\n            },\n        }\n    }\n\n    /// This method will update the leaf at `index`.\n    ///\n    /// However if the proof cannot be verified, this method will fail.\n    pub fn set_leaf(&mut self, args: &SetLeafArgs) -> Result<Node, ConcurrentMerkleTreeError> {\n        check_bounds(MAX_DEPTH, MAX_BUFFER_SIZE);\n        check_leaf_index(args.index, MAX_DEPTH)?;\n        if !self.is_initialized() {\n            return Err(ConcurrentMerkleTreeError::TreeNotInitialized);\n        }\n\n        if args.index > self.rightmost_proof.index {\n            Err(ConcurrentMerkleTreeError::LeafIndexOutOfBounds)\n        }",
    "pub fn get_seq(&self) -> u64 {\n        self.sequence_number\n    }\n\n    /// Modifies the `proof` for leaf at `leaf_index`\n    /// in place by fast-forwarding the given `proof` through the\n    /// `changelog`s, starting at index `changelog_buffer_index`\n    /// Returns false if the leaf was updated in the change log\n    #[inline(always)]\n    fn fast_forward_proof(\n        &self,\n        leaf: &mut Node,\n        proof: &mut [Node; MAX_DEPTH],\n        leaf_index: u32,\n        mut changelog_buffer_index: u64,\n        use_full_buffer: bool,\n    ) -> bool {\n        solana_logging!(\n            \"Fast-forwarding proof, starting index {}\",\n            changelog_buffer_index\n        );\n        let mask: usize = MAX_BUFFER_SIZE - 1;\n\n        let mut updated_leaf = *leaf;\n        log_compute!();\n        // Modifies proof by iterating through the change log\n        loop {\n            // If use_full_buffer is false, this loop will terminate if the initial value of\n            // changelog_buffer_index is the active index\n            if !use_full_buffer && changelog_buffer_index == self.active_index {\n                break;\n            }\n            changelog_buffer_index = (changelog_buffer_index + 1) & mask as u64;\n            self.change_logs[changelog_buffer_index as usize].update_proof_or_leaf(\n                leaf_index,\n                proof,\n                &mut updated_leaf,\n            );\n            // If use_full_buffer is true, this loop will do 1 full pass of the change logs\n            if use_full_buffer && changelog_buffer_index == self.active_index {\n                break;\n            }\n        }\n        log_compute!();\n        let proof_leaf_unchanged = updated_leaf == *leaf;\n        *leaf = updated_leaf;\n        proof_leaf_unchanged\n    }\n\n    #[inline(always)]\n    fn find_root_in_changelog(&self, current_root: Node) -> Option<u64> {\n        let mask: usize = MAX_BUFFER_SIZE - 1;\n        for i in 0..self.buffer_size {\n            let j = self.active_index.wrapping_sub(i) & mask as u64;\n            if self.change_logs[j as usize].root == current_root {\n                return Some(j);\n            }\n        }\n        None\n    }\n\n    #[inline(always)]\n    fn check_valid_leaf(\n        &self,\n        current_root: Node,\n        leaf: Node,\n        proof: &mut [Node; MAX_DEPTH],\n        leaf_index: u32,\n        allow_inferred_proof: bool,\n    ) -> Result<bool, ConcurrentMerkleTreeError> {\n        let mask: usize = MAX_BUFFER_SIZE - 1;\n        let (changelog_index, use_full_buffer) = match self.find_root_in_changelog(current_root) {\n            Some(matching_changelog_index) => (matching_changelog_index, false),\n            None => {\n                if allow_inferred_proof {\n                    solana_logging!(\"Failed to find root in change log -> replaying full buffer\");\n                    (\n                        self.active_index.wrapping_sub(self.buffer_size - 1) & mask as u64,\n                        true,\n                    )\n                }",
    "pub fn check_valid_proof(\n        &self,\n        leaf: Node,\n        proof: &[Node; MAX_DEPTH],\n        leaf_index: u32,\n    ) -> bool {\n        if !self.is_initialized() {\n            solana_logging!(\"Tree is not initialized, returning false\");\n            return false;\n        }\n        if check_leaf_index(leaf_index, MAX_DEPTH).is_err() {\n            solana_logging!(\"Leaf index out of bounds for max_depth\");\n            return false;\n        }\n        recompute(leaf, proof, leaf_index) == self.get_root()\n    }",
    "pub fn recompute(leaf: Node, proof: &[Node], index: u32) -> Node {\n    let mut current_node = leaf;\n    for (depth, sibling) in proof.iter().enumerate() {\n        hash_to_parent(&mut current_node, sibling, index >> depth & 1 == 0);\n    }\n    current_node\n}\n\n/// Computes the parent node of `node` and `sibling` and copies the result into\n/// `node`\n#[inline(always)]\npub fn hash_to_parent(node: &mut Node, sibling: &Node, is_left: bool) {\n    let parent = if is_left {\n        hashv(&[node, sibling])\n    }",
    "pub fn empty_node(level: u32) -> Node {\n    empty_node_cached::<0>(level, &[])\n}",
    "pub fn f32_normal_cdf(argument: f32) -> f32 {\n    const PI: f32 = std::f32::consts::PI;\n\n    let mod_argument = if argument < 0.0 {\n        -1.0 * argument\n    } else {\n        argument\n    };\n    let tabulation_numerator: f32 =\n        (1.0 / (1.0 * (2.0 * PI).sqrt())) * (-1.0 * (mod_argument * mod_argument) / 2.0).exp();\n    let tabulation_denominator: f32 =\n        0.226 + 0.64 * mod_argument + 0.33 * (mod_argument * mod_argument + 3.0).sqrt();\n    let y: f32 = 1.0 - tabulation_numerator / tabulation_denominator;\n    if argument < 0.0 {\n        1.0 - y\n    } else {\n        y\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use {super::*, proptest::prelude::*};\n\n    fn check_square_root(radicand: u128) {\n        let root = sqrt(radicand).unwrap();\n        let lower_bound = root.saturating_sub(1).checked_pow(2).unwrap();\n        let upper_bound = root.checked_add(1).unwrap().checked_pow(2).unwrap();\n        assert!(radicand <= upper_bound);\n        assert!(radicand >= lower_bound);\n    }\n\n    #[test]\n    fn test_square_root_min_max() {\n        let test_roots = [0, u64::MAX];\n        for i in test_roots.iter() {\n            check_square_root(*i as u128);\n        }\n    }\n\n    proptest! {\n        #[test]\n        fn test_square_root(a in 0..u64::MAX) {\n            check_square_root(a as u128);\n        }\n    }\n\n    fn check_normal_cdf_f32(argument: f32) {\n        let result = f32_normal_cdf(argument);\n        let check_result = 0.5 * (1.0 + libm::erff(argument / std::f32::consts::SQRT_2));\n        let abs_difference: f32 = (result - check_result).abs();\n        assert!(abs_difference <= 0.000_2);\n    }\n\n    #[test]\n    fn test_normal_cdf_f32_min_max() {\n        let test_arguments: [f32; 2] = [f32::MIN, f32::MAX];\n        for i in test_arguments.iter() {\n            check_normal_cdf_f32(*i)\n        }",
    "pub fn new(value: u128) -> Option<Self> {\n        let value = InnerUint::from(value).checked_mul(one())?;\n        Some(Self { value })\n    }",
    "pub fn to_imprecise(&self) -> Option<u128> {\n        self.value\n            .checked_add(Self::rounding_correction())?\n            .checked_div(one())\n            .map(|v| v.as_u128())\n    }",
    "pub fn almost_eq(&self, rhs: &Self, precision: InnerUint) -> bool {\n        let (difference, _) = self.unsigned_sub(rhs);\n        difference.value < precision\n    }\n\n    /// Checks that a number is less than another\n    pub fn less_than(&self, rhs: &Self) -> bool {\n        self.value < rhs.value\n    }\n\n    /// Checks that a number is greater than another\n    pub fn greater_than(&self, rhs: &Self) -> bool {\n        self.value > rhs.value\n    }\n\n    /// Checks that a number is less than another\n    pub fn less_than_or_equal(&self, rhs: &Self) -> bool {\n        self.value <= rhs.value\n    }\n\n    /// Checks that a number is greater than another\n    pub fn greater_than_or_equal(&self, rhs: &Self) -> bool {\n        self.value >= rhs.value\n    }\n\n    /// Floors a precise value to a precision of ONE\n    pub fn floor(&self) -> Option<Self> {\n        let value = self.value.checked_div(one())?.checked_mul(one())?;\n        Some(Self { value })\n    }",
    "pub fn ceiling(&self) -> Option<Self> {\n        let value = self\n            .value\n            .checked_add(one().checked_sub(InnerUint::from(1))?)?\n            .checked_div(one())?\n            .checked_mul(one())?;\n        Some(Self { value })\n    }",
    "pub fn checked_div(&self, rhs: &Self) -> Option<Self> {\n        if *rhs == Self::zero() {\n            return None;\n        }\n        match self.value.checked_mul(one()) {\n            Some(v) => {\n                let value = v\n                    .checked_add(Self::rounding_correction())?\n                    .checked_div(rhs.value)?;\n                Some(Self { value })\n            }",
    "pub fn checked_mul(&self, rhs: &Self) -> Option<Self> {\n        match self.value.checked_mul(rhs.value) {\n            Some(v) => {\n                let value = v\n                    .checked_add(Self::rounding_correction())?\n                    .checked_div(one())?;\n                Some(Self { value })\n            }",
    "pub fn checked_add(&self, rhs: &Self) -> Option<Self> {\n        let value = self.value.checked_add(rhs.value)?;\n        Some(Self { value })\n    }",
    "pub fn checked_sub(&self, rhs: &Self) -> Option<Self> {\n        let value = self.value.checked_sub(rhs.value)?;\n        Some(Self { value })\n    }",
    "pub fn unsigned_sub(&self, rhs: &Self) -> (Self, bool) {\n        match self.value.checked_sub(rhs.value) {\n            None => {\n                let value = rhs.value.checked_sub(self.value).unwrap();\n                (Self { value }, true)\n            }",
    "pub fn checked_pow(&self, exponent: u128) -> Option<Self> {\n        // For odd powers, start with a multiplication by base since we halve the\n        // exponent at the start\n        let value = if exponent.checked_rem(2)? == 0 {\n            one()\n        }",
    "pub fn sqrt(&self) -> Option<Self> {\n        if self.less_than(&Self::minimum_sqrt_base())\n            || self.greater_than(&Self::maximum_sqrt_base())\n        {\n            return None;\n        }\n        let two = PreciseNumber::new(2)?;\n        let one = PreciseNumber::new(1)?;\n        // A good initial guess is the average of the interval that contains the\n        // input number.  For all numbers, that will be between 1 and the given number.\n        let guess = self.checked_add(&one)?.checked_div(&two)?;\n        self.newtonian_root_approximation(&two, guess, Self::MAX_APPROXIMATION_ITERATIONS)\n    }",
    "pub fn precise_sqrt(radicand: u64) -> Instruction {\n    Instruction {\n        program_id: id(),\n        accounts: vec![],\n        data: borsh::to_vec(&MathInstruction::PreciseSquareRoot { radicand }).unwrap(),\n    }\n}\n\n/// Create U64 SquareRoot instruction\npub fn sqrt_u64(radicand: u64) -> Instruction {\n    Instruction {\n        program_id: id(),\n        accounts: vec![],\n        data: borsh::to_vec(&MathInstruction::SquareRootU64 { radicand }).unwrap(),\n    }\n}\n\n/// Create U128 SquareRoot instruction\npub fn sqrt_u128(radicand: u128) -> Instruction {\n    Instruction {\n        program_id: id(),\n        accounts: vec![],\n        data: borsh::to_vec(&MathInstruction::SquareRootU128 { radicand }).unwrap(),\n    }\n}\n\n/// Create U64 Multiplication instruction\npub fn u64_multiply(multiplicand: u64, multiplier: u64) -> Instruction {\n    Instruction {\n        program_id: id(),\n        accounts: vec![],\n        data: borsh::to_vec(&MathInstruction::U64Multiply {\n            multiplicand,\n            multiplier,\n        })\n        .unwrap(),\n    }\n}\n\n/// Create U64 Division instruction\npub fn u64_divide(dividend: u64, divisor: u64) -> Instruction {\n    Instruction {\n        program_id: id(),\n        accounts: vec![],\n        data: borsh::to_vec(&MathInstruction::U64Divide { dividend, divisor }).unwrap(),\n    }\n}\n\n/// Create F32 Multiplication instruction\npub fn f32_multiply(multiplicand: f32, multiplier: f32) -> Instruction {\n    Instruction {\n        program_id: id(),\n        accounts: vec![],\n        data: borsh::to_vec(&MathInstruction::F32Multiply {\n            multiplicand,\n            multiplier,\n        })\n        .unwrap(),\n    }\n}\n\n/// Create F32 Division instruction\npub fn f32_divide(dividend: f32, divisor: f32) -> Instruction {\n    Instruction {\n        program_id: id(),\n        accounts: vec![],\n        data: borsh::to_vec(&MathInstruction::F32Divide { dividend, divisor }).unwrap(),\n    }\n}\n\n/// Create F32 Exponentiate instruction\npub fn f32_exponentiate(base: f32, exponent: f32) -> Instruction {\n    Instruction {\n        program_id: id(),\n        accounts: vec![],\n        data: borsh::to_vec(&MathInstruction::F32Exponentiate { base, exponent }).unwrap(),\n    }\n}\n\n/// Create F32 Natural Log instruction\npub fn f32_natural_log(argument: f32) -> Instruction {\n    Instruction {\n        program_id: id(),\n        accounts: vec![],\n        data: borsh::to_vec(&MathInstruction::F32NaturalLog { argument }).unwrap(),\n    }\n}\n\n/// Create F32 Normal CDF instruction\npub fn f32_normal_cdf(argument: f32) -> Instruction {\n    Instruction {\n        program_id: id(),\n        accounts: vec![],\n        data: borsh::to_vec(&MathInstruction::F32NormalCDF { argument }).unwrap(),\n    }\n}\n\n/// Create F64Pow instruction\npub fn f64_pow(base: f64, exponent: f64) -> Instruction {\n    Instruction {\n        program_id: id(),\n        accounts: vec![],\n        data: borsh::to_vec(&MathInstruction::F64Pow { base, exponent }).unwrap(),\n    }\n}\n\n/// Create U128 Multiplication instruction\npub fn u128_multiply(multiplicand: u128, multiplier: u128) -> Instruction {\n    Instruction {\n        program_id: id(),\n        accounts: vec![],\n        data: borsh::to_vec(&MathInstruction::U128Multiply {\n            multiplicand,\n            multiplier,\n        })\n        .unwrap(),\n    }\n}\n\n/// Create U128 Division instruction\npub fn u128_divide(dividend: u128, divisor: u128) -> Instruction {\n    Instruction {\n        program_id: id(),\n        accounts: vec![],\n        data: borsh::to_vec(&MathInstruction::U128Divide { dividend, divisor }).unwrap(),\n    }\n}\n\n/// Create F64 Multiplication instruction\npub fn f64_multiply(multiplicand: f64, multiplier: f64) -> Instruction {\n    Instruction {\n        program_id: id(),\n        accounts: vec![],\n        data: borsh::to_vec(&MathInstruction::F64Multiply {\n            multiplicand,\n            multiplier,\n        })\n        .unwrap(),\n    }\n}\n\n/// Create F64 Division instruction\npub fn f64_divide(dividend: f64, divisor: f64) -> Instruction {\n    Instruction {\n        program_id: id(),\n        accounts: vec![],\n        data: borsh::to_vec(&MathInstruction::F64Divide { dividend, divisor }).unwrap(),\n    }\n}\n\n/// Create Noop instruction\npub fn noop() -> Instruction {\n    Instruction {\n        program_id: id(),\n        accounts: vec![],\n        data: borsh::to_vec(&MathInstruction::Noop).unwrap(),\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_precise_sqrt() {\n        let instruction = precise_sqrt(u64::MAX);\n        assert_eq!(0, instruction.accounts.len());\n        assert_eq!(\n            instruction.data,\n            borsh::to_vec(&MathInstruction::PreciseSquareRoot { radicand: u64::MAX }).unwrap()\n        );\n        assert_eq!(instruction.program_id, crate::id());\n    }\n\n    #[test]\n    fn test_sqrt_u64() {\n        let instruction = sqrt_u64(u64::MAX);\n        assert_eq!(0, instruction.accounts.len());\n        assert_eq!(\n            instruction.data,\n            borsh::to_vec(&MathInstruction::SquareRootU64 { radicand: u64::MAX }).unwrap()\n        );\n        assert_eq!(instruction.program_id, crate::id());\n    }\n\n    #[test]\n    fn test_sqrt_u128() {\n        let instruction = sqrt_u128(u128::MAX);\n        assert_eq!(0, instruction.accounts.len());\n        assert_eq!(\n            instruction.data,\n            borsh::to_vec(&MathInstruction::SquareRootU128 {\n                radicand: u128::MAX\n            })\n            .unwrap()\n        );\n        assert_eq!(instruction.program_id, crate::id());\n    }\n\n    #[test]\n    fn test_u64_multiply() {\n        let instruction = u64_multiply(u64::MAX, u64::MAX);\n        assert_eq!(0, instruction.accounts.len());\n        assert_eq!(\n            instruction.data,\n            borsh::to_vec(&MathInstruction::U64Multiply {\n                multiplicand: u64::MAX,\n                multiplier: u64::MAX\n            })\n            .unwrap()\n        );\n        assert_eq!(instruction.program_id, crate::id());\n    }\n\n    #[test]\n    fn test_u64_divide() {\n        let instruction = u64_divide(u64::MAX, u64::MAX);\n        assert_eq!(0, instruction.accounts.len());\n        assert_eq!(\n            instruction.data,\n            borsh::to_vec(&MathInstruction::U64Divide {\n                dividend: u64::MAX,\n                divisor: u64::MAX\n            })\n            .unwrap()\n        );\n        assert_eq!(instruction.program_id, crate::id());\n    }\n\n    #[test]\n    fn test_f32_multiply() {\n        let instruction = f32_multiply(f32::MAX, f32::MAX);\n        assert_eq!(0, instruction.accounts.len());\n        assert_eq!(\n            instruction.data,\n            borsh::to_vec(&MathInstruction::F32Multiply {\n                multiplicand: f32::MAX,\n                multiplier: f32::MAX\n            })\n            .unwrap()\n        );\n        assert_eq!(instruction.program_id, crate::id());\n    }\n\n    #[test]\n    fn test_f32_divide() {\n        let instruction = f32_divide(f32::MAX, f32::MAX);\n        assert_eq!(0, instruction.accounts.len());\n        assert_eq!(\n            instruction.data,\n            borsh::to_vec(&MathInstruction::F32Divide {\n                dividend: f32::MAX,\n                divisor: f32::MAX\n            })\n            .unwrap()\n        );\n        assert_eq!(instruction.program_id, crate::id());\n    }\n\n    #[test]\n    fn test_f32_exponentiate() {\n        let instruction = f32_exponentiate(f32::MAX, f32::MAX);\n        assert_eq!(0, instruction.accounts.len());\n        assert_eq!(\n            instruction.data,\n            borsh::to_vec(&MathInstruction::F32Exponentiate {\n                base: f32::MAX,\n                exponent: f32::MAX\n            })\n            .unwrap()\n        );\n        assert_eq!(instruction.program_id, crate::id())\n    }",
    "pub fn process_instruction(\n    _program_id: &Pubkey,\n    _accounts: &[AccountInfo],\n    input: &[u8],\n) -> ProgramResult {\n    let instruction = MathInstruction::try_from_slice(input).unwrap();\n    match instruction {\n        MathInstruction::PreciseSquareRoot { radicand } => {\n            msg!(\"Calculating square root using PreciseNumber\");\n            let radicand = PreciseNumber::new(radicand as u128).unwrap();\n            sol_log_compute_units();\n            let result = radicand.sqrt().unwrap().to_imprecise().unwrap() as u64;\n            sol_log_compute_units();\n            msg!(\"{}\", result);\n            Ok(())\n        }",
    "pub fn recompute(mut leaf: Node, proof: &[Node], index: u32) -> Node {\n    for (i, s) in proof.iter().enumerate() {\n        if index >> i & 1 == 0 {\n            let res = hashv(&[&leaf, s.as_ref()]);\n            leaf.copy_from_slice(res.as_ref());\n        } else {\n            let res = hashv(&[s.as_ref(), &leaf]);\n            leaf.copy_from_slice(res.as_ref());\n        }\n    }\n    leaf\n}\n\n// Off-chain implementation to keep track of nodes\npub struct MerkleTree {\n    pub leaf_nodes: Vec<Rc<RefCell<TreeNode>>>,\n    pub root: Node,\n}\n\nimpl MerkleTree {\n    /// Calculates updated root from the passed leaves\n    pub fn new(leaves: &[Node]) -> Self {\n        let mut leaf_nodes = vec![];\n        for (i, node) in leaves.iter().enumerate() {\n            let mut tree_node = TreeNode::new_empty(0, i as u128);\n            tree_node.node = *node;\n            leaf_nodes.push(Rc::new(RefCell::new(tree_node)));\n        }\n        let root = MerkleTree::build_root(leaf_nodes.as_slice());\n        Self { leaf_nodes, root }\n    }\n\n    /// Builds root from stack of leaves\n    pub fn build_root(leaves: &[Rc<RefCell<TreeNode>>]) -> Node {\n        let mut tree = VecDeque::from_iter(leaves.iter().map(Rc::clone));\n        let mut seq_num = leaves.len() as u128;\n        while tree.len() > 1 {\n            let left = tree.pop_front().unwrap();\n            let level = left.borrow().level;\n            let right = if level != tree[0].borrow().level {\n                let node = Rc::new(RefCell::new(TreeNode::new_empty(level, seq_num)));\n                seq_num += 1;\n                node\n            } else {\n                tree.pop_front().unwrap()\n            }",
    "pub fn get_proof_of_leaf(&self, idx: usize) -> Vec<Node> {\n        let mut proof = vec![];\n        let mut node = self.leaf_nodes[idx].clone();\n        loop {\n            let ref_node = node.clone();\n            if ref_node.borrow().parent.is_none() {\n                break;\n            }\n            let parent = ref_node.borrow().parent.as_ref().unwrap().clone();\n            if parent.borrow().left.as_ref().unwrap().borrow().id == ref_node.borrow().id {\n                proof.push(parent.borrow().right.as_ref().unwrap().borrow().node);\n            } else {\n                proof.push(parent.borrow().left.as_ref().unwrap().borrow().node);\n            }\n            node = parent;\n        }\n        proof\n    }\n\n    /// Updates root from an updated leaf node set at index: `idx`\n    fn update_root_from_leaf(&mut self, leaf_idx: usize) {\n        let mut node = self.leaf_nodes[leaf_idx].clone();\n        loop {\n            let ref_node = node.clone();\n            if ref_node.borrow().parent.is_none() {\n                self.root = ref_node.borrow().node;\n                break;\n            }\n            let parent = ref_node.borrow().parent.as_ref().unwrap().clone();\n            let hash = if parent.borrow().left.as_ref().unwrap().borrow().id == ref_node.borrow().id\n            {\n                hashv(&[\n                    &ref_node.borrow().node,\n                    &parent.borrow().right.as_ref().unwrap().borrow().node,\n                ])\n            }",
    "pub fn get_node(&self, idx: usize) -> Node {\n        self.leaf_nodes[idx].borrow().node\n    }\n\n    pub fn get_root(&self) -> Node {\n        self.root\n    }\n\n    pub fn add_leaf(&mut self, leaf: Node, leaf_idx: usize) {\n        self.leaf_nodes[leaf_idx].borrow_mut().node = leaf;\n        self.update_root_from_leaf(leaf_idx)\n    }",
    "pub fn remove_leaf(&mut self, leaf_idx: usize) {\n        self.leaf_nodes[leaf_idx].borrow_mut().node = EMPTY;\n        self.update_root_from_leaf(leaf_idx)\n    }",
    "pub fn load(accounts: &'a [AccountInfo<'info>]) -> Result<Self, ProgramError> {\n        let account_iter = &mut accounts.iter();\n        let ctx = Self {\n            mint: next_account_info(account_iter)?,\n            payer: next_account_info(account_iter)?,\n            upstream_authority: next_account_info(account_iter)?,\n            system_program: next_account_info(account_iter)?,\n            token_program: next_account_info(account_iter)?,\n        };\n        assert_with_msg(\n            ctx.mint.data_is_empty(),\n            ProgramError::InvalidAccountData,\n            \"Mint account must be uninitialized\",\n        )?;\n        assert_with_msg(\n            ctx.mint.owner == &system_program::id(),\n            ProgramError::IllegalOwner,\n            \"Mint account must be owned by the System Program when uninitialized\",\n        )?;\n        assert_with_msg(\n            ctx.token_program.key == &spl_token::id(),\n            ProgramError::InvalidInstructionData,\n            \"Invalid key supplied for Token Program\",\n        )?;\n        assert_with_msg(\n            ctx.system_program.key == &system_program::id(),\n            ProgramError::InvalidInstructionData,\n            \"Invalid key supplied for System Program\",\n        )?;\n        assert_with_msg(\n            ctx.mint.is_writable,\n            ProgramError::InvalidInstructionData,\n            \"Mint account must be writable\",\n        )?;\n        assert_with_msg(\n            ctx.payer.is_writable,\n            ProgramError::InvalidInstructionData,\n            \"Payer account must be writable (lamport balance will change)\",\n        )?;\n        assert_with_msg(\n            ctx.payer.is_signer,\n            ProgramError::MissingRequiredSignature,\n            \"Payer must sign for initialization\",\n        )?;\n        Ok(ctx)\n    }",
    "pub fn load(accounts: &'a [AccountInfo<'info>]) -> Result<Self, ProgramError> {\n        let account_iter = &mut accounts.iter();\n        let ctx = Self {\n            token_account: next_account_info(account_iter)?,\n            owner: next_account_info(account_iter)?,\n            payer: next_account_info(account_iter)?,\n            upstream_authority: next_account_info(account_iter)?,\n            freeze_authority: next_account_info(account_iter)?,\n            mint: next_account_info(account_iter)?,\n            system_program: next_account_info(account_iter)?,\n            associated_token_program: next_account_info(account_iter)?,\n            token_program: next_account_info(account_iter)?,\n        };\n        assert_with_msg(\n            ctx.token_account.data_is_empty(),\n            ProgramError::InvalidAccountData,\n            \"Token account must be uninitialized\",\n        )?;\n        assert_with_msg(\n            ctx.token_account.owner == &system_program::id(),\n            ProgramError::IllegalOwner,\n            \"Token account must be owned by System Program when uninitialized\",\n        )?;\n        assert_with_msg(\n            ctx.mint.owner == ctx.token_program.key,\n            ProgramError::IllegalOwner,\n            \"Mint account must be owned by the Token Program\",\n        )?;\n        assert_with_msg(\n            ctx.token_program.key == &spl_token::id(),\n            ProgramError::InvalidInstructionData,\n            \"Invalid key supplied for Token Program\",\n        )?;\n        assert_with_msg(\n            ctx.system_program.key == &system_program::id(),\n            ProgramError::InvalidInstructionData,\n            \"Invalid key supplied for System Program\",\n        )?;\n        assert_with_msg(\n            ctx.associated_token_program.key == &spl_associated_token_account_client::program::id(),\n            ProgramError::InvalidInstructionData,\n            \"Invalid key supplied for Associataed Token Program\",\n        )?;\n        assert_with_msg(\n            ctx.token_account.is_writable,\n            ProgramError::InvalidInstructionData,\n            \"Token account must be writable\",\n        )?;\n        assert_with_msg(\n            ctx.payer.is_writable,\n            ProgramError::InvalidInstructionData,\n            \"Payer account must be writable (lamport balance will change)\",\n        )?;\n        assert_with_msg(\n            ctx.payer.is_signer,\n            ProgramError::MissingRequiredSignature,\n            \"Payer must sign for initialization\",\n        )?;\n        assert_with_msg(\n            ctx.upstream_authority.is_signer,\n            ProgramError::MissingRequiredSignature,\n            \"Freeze authority must sign for initialization\",\n        )?;\n        Ok(ctx)\n    }",
    "pub fn load(accounts: &'a [AccountInfo<'info>]) -> Result<Self, ProgramError> {\n        let account_iter = &mut accounts.iter();\n        let ctx = Self {\n            mint: next_account_info(account_iter)?,\n            token_account: next_account_info(account_iter)?,\n            upstream_authority: next_account_info(account_iter)?,\n            freeze_and_mint_authority: next_account_info(account_iter)?,\n            token_program: next_account_info(account_iter)?,\n        };\n        assert_with_msg(\n            ctx.mint.owner == ctx.token_program.key,\n            ProgramError::IllegalOwner,\n            \"Mint account must be owned by the Token Program\",\n        )?;\n        assert_with_msg(\n            ctx.token_account.owner == ctx.token_program.key,\n            ProgramError::IllegalOwner,\n            \"Token account must be owned by the Token Program\",\n        )?;\n        assert_with_msg(\n            ctx.token_program.key == &spl_token::id(),\n            ProgramError::InvalidInstructionData,\n            \"Invalid key supplied for Token Program\",\n        )?;\n        assert_with_msg(\n            ctx.mint.is_writable,\n            ProgramError::InvalidInstructionData,\n            \"Mint must be writable\",\n        )?;\n        assert_with_msg(\n            ctx.token_account.is_writable,\n            ProgramError::InvalidInstructionData,\n            \"Token Account must be writable\",\n        )?;\n        assert_with_msg(\n            ctx.upstream_authority.is_signer,\n            ProgramError::MissingRequiredSignature,\n            \"Freeze authority must sign for modification\",\n        )?;\n        Ok(ctx)\n    }",
    "pub fn load(accounts: &'a [AccountInfo<'info>]) -> Result<Self, ProgramError> {\n        let account_iter = &mut accounts.iter();\n        let ctx = Self {\n            mint: next_account_info(account_iter)?,\n            token_account: next_account_info(account_iter)?,\n            owner: next_account_info(account_iter)?,\n            upstream_authority: next_account_info(account_iter)?,\n            freeze_authority: next_account_info(account_iter)?,\n            token_program: next_account_info(account_iter)?,\n        };\n        assert_with_msg(\n            ctx.mint.owner == ctx.token_program.key,\n            ProgramError::IllegalOwner,\n            \"Mint account must be owned by the Token Program\",\n        )?;\n        assert_with_msg(\n            ctx.token_account.owner == ctx.token_program.key,\n            ProgramError::IllegalOwner,\n            \"Token account must be owned by the Token Program\",\n        )?;\n        assert_with_msg(\n            ctx.token_program.key == &spl_token::id(),\n            ProgramError::InvalidInstructionData,\n            \"Invalid key supplied for Token Program\",\n        )?;\n        assert_with_msg(\n            ctx.mint.is_writable,\n            ProgramError::InvalidInstructionData,\n            \"Mint must be writable\",\n        )?;\n        assert_with_msg(\n            ctx.token_account.is_writable,\n            ProgramError::InvalidInstructionData,\n            \"Token Account must be writable\",\n        )?;\n        assert_with_msg(\n            ctx.upstream_authority.is_signer,\n            ProgramError::MissingRequiredSignature,\n            \"Freeze authority must sign for modification\",\n        )?;\n        assert_with_msg(\n            ctx.owner.is_signer,\n            ProgramError::MissingRequiredSignature,\n            \"Owner must sign for modification\",\n        )?;\n        Ok(ctx)\n    }",
    "pub fn load(accounts: &'a [AccountInfo<'info>]) -> Result<Self, ProgramError> {\n        let account_iter = &mut accounts.iter();\n        let ctx = Self {\n            src_account: next_account_info(account_iter)?,\n            dst_account: next_account_info(account_iter)?,\n            mint: next_account_info(account_iter)?,\n            owner: next_account_info(account_iter)?,\n            upstream_authority: next_account_info(account_iter)?,\n            freeze_authority: next_account_info(account_iter)?,\n            token_program: next_account_info(account_iter)?,\n        };\n        assert_with_msg(\n            ctx.mint.owner == &spl_token::id(),\n            ProgramError::IllegalOwner,\n            \"Mint account must be owned by the Token Program\",\n        )?;\n        assert_with_msg(\n            ctx.src_account.owner == &spl_token::id(),\n            ProgramError::IllegalOwner,\n            \"Source token account must be owned by the Token Program\",\n        )?;\n        assert_with_msg(\n            ctx.dst_account.owner == &spl_token::id(),\n            ProgramError::IllegalOwner,\n            \"Destination token account must be owned by the Token Program\",\n        )?;\n        assert_with_msg(\n            ctx.token_program.key == &spl_token::id(),\n            ProgramError::InvalidInstructionData,\n            \"Invalid key supplied for Token Program\",\n        )?;\n        assert_with_msg(\n            ctx.src_account.is_writable,\n            ProgramError::InvalidInstructionData,\n            \"Source token account must be writable\",\n        )?;\n        assert_with_msg(\n            ctx.dst_account.is_writable,\n            ProgramError::InvalidInstructionData,\n            \"Destination token account must be writable\",\n        )?;\n        assert_with_msg(\n            ctx.owner.is_signer,\n            ProgramError::MissingRequiredSignature,\n            \"Owner must sign for modification\",\n        )?;\n        assert_with_msg(\n            ctx.upstream_authority.is_signer,\n            ProgramError::MissingRequiredSignature,\n            \"Freeze authority must sign for modification\",\n        )?;\n        Ok(ctx)\n    }",
    "pub fn load(accounts: &'a [AccountInfo<'info>]) -> Result<Self, ProgramError> {\n        let account_iter = &mut accounts.iter();\n        let ctx = Self {\n            token_account: next_account_info(account_iter)?,\n            dst_account: next_account_info(account_iter)?,\n            mint: next_account_info(account_iter)?,\n            owner: next_account_info(account_iter)?,\n            upstream_authority: next_account_info(account_iter)?,\n            freeze_authority: next_account_info(account_iter)?,\n            token_program: next_account_info(account_iter)?,\n        };\n        assert_with_msg(\n            ctx.mint.owner == ctx.token_program.key,\n            ProgramError::IllegalOwner,\n            \"Mint account must be owned by the Token Program\",\n        )?;\n        assert_with_msg(\n            ctx.token_account.owner == ctx.token_program.key,\n            ProgramError::IllegalOwner,\n            \"Token account must be owned by the Token Program\",\n        )?;\n        assert_with_msg(\n            ctx.dst_account.owner == &system_program::id(),\n            ProgramError::IllegalOwner,\n            \"Destination account must be owned by the System Program\",\n        )?;\n        assert_with_msg(\n            ctx.token_program.key == &spl_token::id(),\n            ProgramError::InvalidInstructionData,\n            \"Invalid key supplied for Token Program\",\n        )?;\n        assert_with_msg(\n            ctx.token_account.is_writable,\n            ProgramError::InvalidInstructionData,\n            \"Token Account must be writable\",\n        )?;\n        assert_with_msg(\n            ctx.dst_account.is_writable,\n            ProgramError::InvalidInstructionData,\n            \"Destination account must be writable\",\n        )?;\n        assert_with_msg(\n            ctx.owner.is_signer,\n            ProgramError::MissingRequiredSignature,\n            \"Owner must sign for close\",\n        )?;\n        assert_with_msg(\n            ctx.upstream_authority.is_signer,\n            ProgramError::MissingRequiredSignature,\n            \"Freeze authority must sign for close\",\n        )?;\n        Ok(ctx)\n    }",
    "pub fn load(accounts: &'a [AccountInfo<'info>]) -> Result<Self, ProgramError> {\n        let account_iter = &mut accounts.iter();\n        let ctx = Self {\n            mint: next_account_info(account_iter)?,\n            token_account: next_account_info(account_iter)?,\n            owner: next_account_info(account_iter)?,\n            upstream_authority: next_account_info(account_iter)?,\n            delegate: next_account_info(account_iter)?,\n            freeze_authority: next_account_info(account_iter)?,\n            token_program: next_account_info(account_iter)?,\n        };\n        assert_with_msg(\n            ctx.mint.owner == &spl_token::id(),\n            ProgramError::IllegalOwner,\n            \"Mint account must be owned by the Token Program\",\n        )?;\n        assert_with_msg(\n            ctx.token_account.owner == ctx.token_program.key,\n            ProgramError::IllegalOwner,\n            \"Token account must be owned by the Token Program\",\n        )?;\n        assert_with_msg(\n            ctx.token_account.is_writable,\n            ProgramError::InvalidInstructionData,\n            \"Token Account must be writable\",\n        )?;\n        assert_with_msg(\n            ctx.token_program.key == &spl_token::id(),\n            ProgramError::InvalidInstructionData,\n            \"Invalid key supplied for Token Program\",\n        )?;\n        assert_with_msg(\n            ctx.upstream_authority.is_signer,\n            ProgramError::MissingRequiredSignature,\n            \"Freeze authority must sign for modification\",\n        )?;\n        assert_with_msg(\n            ctx.owner.is_signer,\n            ProgramError::MissingRequiredSignature,\n            \"Owner must sign for modification\",\n        )?;\n        Ok(ctx)\n    }",
    "pub fn load(accounts: &'a [AccountInfo<'info>]) -> Result<Self, ProgramError> {\n        let account_iter = &mut accounts.iter();\n        let ctx = Self {\n            mint: next_account_info(account_iter)?,\n            token_account: next_account_info(account_iter)?,\n            owner: next_account_info(account_iter)?,\n            upstream_authority: next_account_info(account_iter)?,\n            freeze_authority: next_account_info(account_iter)?,\n            token_program: next_account_info(account_iter)?,\n        };\n        assert_with_msg(\n            ctx.mint.owner == &spl_token::id(),\n            ProgramError::IllegalOwner,\n            \"Mint account must be owned by the Token Program\",\n        )?;\n        assert_with_msg(\n            ctx.token_account.owner == ctx.token_program.key,\n            ProgramError::IllegalOwner,\n            \"Token account must be owned by the Token Program\",\n        )?;\n        assert_with_msg(\n            ctx.token_account.is_writable,\n            ProgramError::InvalidInstructionData,\n            \"Token Account must be writable\",\n        )?;\n        assert_with_msg(\n            ctx.token_program.key == &spl_token::id(),\n            ProgramError::InvalidInstructionData,\n            \"Invalid key supplied for Token Program\",\n        )?;\n        assert_with_msg(\n            ctx.upstream_authority.is_signer,\n            ProgramError::MissingRequiredSignature,\n            \"Freeze authority must sign for modification\",\n        )?;\n        assert_with_msg(\n            ctx.owner.is_signer,\n            ProgramError::MissingRequiredSignature,\n            \"Owner must sign for modification\",\n        )?;\n        Ok(ctx)\n    }",
    "pub fn create_initialize_mint_instruction(\n    mint: &Pubkey,\n    payer: &Pubkey,\n    upstream_authority: &Pubkey,\n    decimals: u8,\n) -> Result<Instruction, ProgramError> {\n    Ok(Instruction {\n        program_id: crate::id(),\n        accounts: vec![\n            AccountMeta::new(*mint, true),\n            AccountMeta::new(*payer, true),\n            AccountMeta::new_readonly(*upstream_authority, false),\n            AccountMeta::new_readonly(system_program::id(), false),\n            AccountMeta::new_readonly(spl_token::id(), false),\n        ],\n        data: borsh::to_vec(&ManagedTokenInstruction::InitializeMint { decimals })?,\n    })\n}",
    "pub fn create_initialize_account_instruction(\n    mint: &Pubkey,\n    owner: &Pubkey,\n    payer: &Pubkey,\n    upstream_authority: &Pubkey,\n) -> Result<Instruction, ProgramError> {\n    let account = get_associated_token_address(owner, mint);\n    let (freeze_authority, _) = get_authority(upstream_authority);\n    Ok(Instruction {\n        program_id: crate::id(),\n        accounts: vec![\n            AccountMeta::new(account, false),\n            AccountMeta::new_readonly(*owner, false),\n            AccountMeta::new(*payer, true),\n            AccountMeta::new_readonly(*upstream_authority, true),\n            AccountMeta::new_readonly(freeze_authority, false),\n            AccountMeta::new_readonly(*mint, false),\n            AccountMeta::new_readonly(system_program::id(), false),\n            AccountMeta::new_readonly(spl_associated_token_account_client::program::id(), false),\n            AccountMeta::new_readonly(spl_token::id(), false),\n        ],\n        data: borsh::to_vec(&ManagedTokenInstruction::InitializeAccount)?,\n    })\n}",
    "pub fn create_mint_to_instruction(\n    mint: &Pubkey,\n    owner: &Pubkey,\n    upstream_authority: &Pubkey,\n    amount: u64,\n) -> Result<Instruction, ProgramError> {\n    let account = get_associated_token_address(owner, mint);\n    let (authority, _) = get_authority(upstream_authority);\n    Ok(Instruction {\n        program_id: crate::id(),\n        accounts: vec![\n            AccountMeta::new(*mint, false),\n            AccountMeta::new(account, false),\n            AccountMeta::new_readonly(*upstream_authority, true),\n            AccountMeta::new_readonly(authority, false),\n            AccountMeta::new_readonly(spl_token::id(), false),\n        ],\n        data: borsh::to_vec(&ManagedTokenInstruction::MintTo { amount })?,\n    })\n}",
    "pub fn create_transfer_instruction(\n    src: &Pubkey,\n    dst: &Pubkey,\n    mint: &Pubkey,\n    upstream_authority: &Pubkey,\n    amount: u64,\n) -> Result<Instruction, ProgramError> {\n    let src_account = get_associated_token_address(src, mint);\n    let dst_account = get_associated_token_address(dst, mint);\n    let (freeze_authority, _) = get_authority(upstream_authority);\n    Ok(Instruction {\n        program_id: crate::id(),\n        accounts: vec![\n            AccountMeta::new(src_account, false),\n            AccountMeta::new(dst_account, false),\n            AccountMeta::new_readonly(*mint, false),\n            AccountMeta::new_readonly(*src, true),\n            AccountMeta::new_readonly(*upstream_authority, true),\n            AccountMeta::new_readonly(freeze_authority, false),\n            AccountMeta::new_readonly(spl_token::id(), false),\n        ],\n        data: borsh::to_vec(&ManagedTokenInstruction::Transfer { amount })?,\n    })\n}",
    "pub fn create_transfer_with_delegate_instruction(\n    src: &Pubkey,\n    dst: &Pubkey,\n    delegate: &Pubkey,\n    mint: &Pubkey,\n    upstream_authority: &Pubkey,\n    amount: u64,\n) -> Result<Instruction, ProgramError> {\n    let src_account = get_associated_token_address(src, mint);\n    let dst_account = get_associated_token_address(dst, mint);\n    let (freeze_authority, _) = get_authority(upstream_authority);\n    Ok(Instruction {\n        program_id: crate::id(),\n        accounts: vec![\n            AccountMeta::new(src_account, false),\n            AccountMeta::new(dst_account, false),\n            AccountMeta::new_readonly(*mint, false),\n            AccountMeta::new_readonly(*delegate, true),\n            AccountMeta::new_readonly(*upstream_authority, true),\n            AccountMeta::new_readonly(freeze_authority, false),\n            AccountMeta::new_readonly(spl_token::id(), false),\n        ],\n        data: borsh::to_vec(&ManagedTokenInstruction::Transfer { amount })?,\n    })\n}",
    "pub fn create_burn_instruction(\n    mint: &Pubkey,\n    owner: &Pubkey,\n    upstream_authority: &Pubkey,\n    amount: u64,\n) -> Result<Instruction, ProgramError> {\n    let account = get_associated_token_address(owner, mint);\n    let (freeze_authority, _) = get_authority(upstream_authority);\n    Ok(Instruction {\n        program_id: crate::id(),\n        accounts: vec![\n            AccountMeta::new(*mint, false),\n            AccountMeta::new(account, false),\n            AccountMeta::new_readonly(*owner, true),\n            AccountMeta::new_readonly(*upstream_authority, true),\n            AccountMeta::new_readonly(freeze_authority, false),\n            AccountMeta::new_readonly(spl_token::id(), false),\n        ],\n        data: borsh::to_vec(&ManagedTokenInstruction::Burn { amount })?,\n    })\n}",
    "pub fn create_close_account_instruction(\n    mint: &Pubkey,\n    owner: &Pubkey,\n    upstream_authority: &Pubkey,\n) -> Result<Instruction, ProgramError> {\n    let account = get_associated_token_address(owner, mint);\n    let (freeze_authority, _) = get_authority(upstream_authority);\n    Ok(Instruction {\n        program_id: crate::id(),\n        accounts: vec![\n            AccountMeta::new(account, false),\n            AccountMeta::new(*owner, false),\n            AccountMeta::new_readonly(*mint, false),\n            AccountMeta::new_readonly(*owner, true),\n            AccountMeta::new_readonly(*upstream_authority, true),\n            AccountMeta::new_readonly(freeze_authority, false),\n            AccountMeta::new_readonly(spl_token::id(), false),\n        ],\n        data: borsh::to_vec(&ManagedTokenInstruction::CloseAccount)?,\n    })\n}",
    "pub fn create_approve_instruction(\n    mint: &Pubkey,\n    owner: &Pubkey,\n    delegate: &Pubkey,\n    upstream_authority: &Pubkey,\n    amount: u64,\n) -> Result<Instruction, ProgramError> {\n    let (freeze_authority, _) = get_authority(upstream_authority);\n    let account = get_associated_token_address(owner, mint);\n    Ok(Instruction {\n        program_id: crate::id(),\n        accounts: vec![\n            AccountMeta::new_readonly(*mint, false),\n            AccountMeta::new(account, false),\n            AccountMeta::new_readonly(*owner, true),\n            AccountMeta::new_readonly(*upstream_authority, true),\n            AccountMeta::new_readonly(*delegate, false),\n            AccountMeta::new_readonly(freeze_authority, false),\n            AccountMeta::new_readonly(spl_token::id(), false),\n        ],\n        data: borsh::to_vec(&ManagedTokenInstruction::Approve { amount })?,\n    })\n}",
    "pub fn create_revoke_instruction(\n    mint: &Pubkey,\n    owner: &Pubkey,\n    upstream_authority: &Pubkey,\n) -> Result<Instruction, ProgramError> {\n    let (freeze_authority, _) = get_authority(upstream_authority);\n    let account = get_associated_token_address(owner, mint);\n    Ok(Instruction {\n        program_id: crate::id(),\n        accounts: vec![\n            AccountMeta::new_readonly(*mint, false),\n            AccountMeta::new(account, false),\n            AccountMeta::new_readonly(*owner, true),\n            AccountMeta::new_readonly(*upstream_authority, true),\n            AccountMeta::new_readonly(freeze_authority, false),\n            AccountMeta::new_readonly(spl_token::id(), false),\n        ],\n        data: borsh::to_vec(&ManagedTokenInstruction::Revoke)?,\n    })\n}",
    "pub fn assert_with_msg(v: bool, err: impl Into<ProgramError>, msg: &str) -> ProgramResult {\n    if v {\n        Ok(())\n    }",
    "pub fn process_instruction(\n    _program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    instruction_data: &[u8],\n) -> ProgramResult {\n    let instruction = ManagedTokenInstruction::try_from_slice(instruction_data)?;\n    match instruction {\n        ManagedTokenInstruction::InitializeMint { decimals } => {\n            msg!(\"ManagedTokenInstruction::InitializeMint\");\n            process_initialize_mint(accounts, decimals)\n        }",
    "pub fn process_initialize_mint(accounts: &[AccountInfo], decimals: u8) -> ProgramResult {\n    let InitializeMint {\n        mint,\n        payer,\n        upstream_authority,\n        system_program,\n        token_program,\n    } = InitializeMint::load(accounts)?;\n    let space = spl_token::state::Mint::LEN;\n    invoke(\n        &system_instruction::create_account(\n            payer.key,\n            mint.key,\n            Rent::get()?.minimum_balance(space),\n            space as u64,\n            token_program.key,\n        ),\n        &[payer.clone(), mint.clone(), system_program.clone()],\n    )?;\n    let (authority, _) = get_authority(upstream_authority.key);\n    initialize_mint(&authority, &authority, mint, token_program, decimals)\n}",
    "pub fn process_initialize_account(accounts: &[AccountInfo]) -> ProgramResult {\n    let InitializeAccount {\n        token_account,\n        owner,\n        payer,\n        upstream_authority,\n        freeze_authority,\n        mint,\n        system_program,\n        associated_token_program,\n        token_program,\n    } = InitializeAccount::load(accounts)?;\n    invoke(\n        &create_associated_token_account(payer.key, owner.key, mint.key, token_program.key),\n        &[\n            associated_token_program.clone(),\n            payer.clone(),\n            owner.clone(),\n            token_account.clone(),\n            mint.clone(),\n            system_program.clone(),\n            token_program.clone(),\n        ],\n    )?;\n    let seeds = get_authority_seeds_checked(upstream_authority.key, freeze_authority.key)?;\n    freeze(freeze_authority, mint, token_account, token_program, &seeds)\n}",
    "pub fn process_transfer(accounts: &[AccountInfo], amount: u64) -> ProgramResult {\n    let Transfer {\n        src_account,\n        dst_account,\n        mint,\n        owner,\n        upstream_authority,\n        freeze_authority,\n        token_program,\n    } = Transfer::load(accounts)?;\n    let seeds = get_authority_seeds_checked(upstream_authority.key, freeze_authority.key)?;\n    thaw(freeze_authority, mint, src_account, token_program, &seeds)?;\n    thaw(freeze_authority, mint, dst_account, token_program, &seeds)?;\n    transfer(src_account, dst_account, owner, token_program, amount)?;\n    freeze(freeze_authority, mint, dst_account, token_program, &seeds)?;\n    freeze(freeze_authority, mint, src_account, token_program, &seeds)\n}",
    "pub fn process_mint_to(accounts: &[AccountInfo], amount: u64) -> ProgramResult {\n    let Mint {\n        mint,\n        token_account,\n        upstream_authority,\n        freeze_and_mint_authority: authority,\n        token_program,\n    } = Mint::load(accounts)?;\n    let authority_seeds = get_authority_seeds_checked(upstream_authority.key, authority.key)?;\n    thaw(\n        authority,\n        mint,\n        token_account,\n        token_program,\n        &authority_seeds,\n    )?;\n    mint_to(\n        mint,\n        token_account,\n        authority,\n        token_program,\n        amount,\n        &authority_seeds,\n    )?;\n    freeze(\n        authority,\n        mint,\n        token_account,\n        token_program,\n        &authority_seeds,\n    )\n}",
    "pub fn process_burn(accounts: &[AccountInfo], amount: u64) -> ProgramResult {\n    let Burn {\n        mint,\n        token_account,\n        owner,\n        upstream_authority,\n        freeze_authority,\n        token_program,\n    } = Burn::load(accounts)?;\n    let seeds = get_authority_seeds_checked(upstream_authority.key, freeze_authority.key)?;\n    thaw(freeze_authority, mint, token_account, token_program, &seeds)?;\n    burn(mint, token_account, owner, token_program, amount)?;\n    freeze(freeze_authority, mint, token_account, token_program, &seeds)\n}",
    "pub fn process_close(accounts: &[AccountInfo]) -> ProgramResult {\n    let Close {\n        token_account,\n        dst_account,\n        mint,\n        owner,\n        upstream_authority,\n        freeze_authority,\n        token_program,\n    } = Close::load(accounts)?;\n    let seeds = get_authority_seeds_checked(upstream_authority.key, freeze_authority.key)?;\n    thaw(freeze_authority, mint, token_account, token_program, &seeds)?;\n    close(token_account, dst_account, owner, token_program)\n}",
    "pub fn process_approve(accounts: &[AccountInfo], amount: u64) -> ProgramResult {\n    let Approve {\n        mint,\n        token_account,\n        owner,\n        upstream_authority,\n        delegate,\n        freeze_authority,\n        token_program,\n    } = Approve::load(accounts)?;\n    let seeds = get_authority_seeds_checked(upstream_authority.key, freeze_authority.key)?;\n    thaw(freeze_authority, mint, token_account, token_program, &seeds)?;\n    approve(token_account, owner, delegate, token_program, amount)?;\n    freeze(freeze_authority, mint, token_account, token_program, &seeds)\n}",
    "pub fn process_revoke(accounts: &[AccountInfo]) -> ProgramResult {\n    let Revoke {\n        mint,\n        token_account,\n        owner,\n        upstream_authority,\n        freeze_authority,\n        token_program,\n    } = Revoke::load(accounts)?;\n    let seeds = get_authority_seeds_checked(upstream_authority.key, freeze_authority.key)?;\n    thaw(freeze_authority, mint, token_account, token_program, &seeds)?;\n    revoke(token_account, owner, token_program)?;\n    freeze(freeze_authority, mint, token_account, token_program, &seeds)\n}",
    "pub fn sol(amount: f64) -> u64 {\n    (amount * LAMPORTS_PER_SOL as f64) as u64\n}\n\nasync fn process_transaction(\n    client: &mut BanksClient,\n    instructions: Vec<Instruction>,\n    signers: Vec<&Keypair>,\n) -> Result<Signature, BanksClientError> {\n    let mut tx = Transaction::new_with_payer(&instructions, Some(&signers[0].pubkey()));\n    tx.partial_sign(&signers, client.get_latest_blockhash().await?);\n    let sig = tx.signatures[0];\n    client\n        .process_transaction_with_commitment(tx, CommitmentLevel::Confirmed)\n        .await?;\n    Ok(sig)\n}",
    "pub fn process_instruction(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    instruction_data: &[u8],\n) -> ProgramResult {\n    msg!(\"Entrypoint\");\n    if let Err(error) = Processor::process_instruction(program_id, accounts, instruction_data) {\n        // catch the error so we can print it\n        error.print::<NameServiceError>();\n        return Err(error);\n    }\n    Ok(())\n}",
    "pub fn create(\n    name_service_program_id: Pubkey,\n    instruction_data: NameRegistryInstruction,\n    name_account_key: Pubkey,\n    payer_key: Pubkey,\n    name_owner: Pubkey,\n    name_class_opt: Option<Pubkey>,\n    name_parent_opt: Option<Pubkey>,\n    name_parent_owner_opt: Option<Pubkey>,\n) -> Result<Instruction, ProgramError> {\n    let data = borsh::to_vec(&instruction_data).unwrap();\n    let mut accounts = vec![\n        AccountMeta::new_readonly(system_program::id(), false),\n        AccountMeta::new(payer_key, true),\n        AccountMeta::new(name_account_key, false),\n        AccountMeta::new_readonly(name_owner, false),\n    ];\n    if let Some(name_class) = name_class_opt {\n        accounts.push(AccountMeta::new_readonly(name_class, true));\n    } else {\n        accounts.push(AccountMeta::new_readonly(Pubkey::default(), false));\n    }\n    if let Some(name_parent) = name_parent_opt {\n        accounts.push(AccountMeta::new_readonly(name_parent, false));\n    } else {\n        accounts.push(AccountMeta::new_readonly(Pubkey::default(), false));\n    }\n    if let Some(key) = name_parent_owner_opt {\n        accounts.push(AccountMeta::new_readonly(key, true));\n    }\n\n    Ok(Instruction {\n        program_id: name_service_program_id,\n        accounts,\n        data,\n    })\n}",
    "pub fn update(\n    name_service_program_id: Pubkey,\n    offset: u32,\n    data: Vec<u8>,\n    name_account_key: Pubkey,\n    name_update_signer: Pubkey,\n    name_parent: Option<Pubkey>,\n) -> Result<Instruction, ProgramError> {\n    let instruction_data = NameRegistryInstruction::Update { offset, data };\n    let data = borsh::to_vec(&instruction_data).unwrap();\n    let mut accounts = vec![\n        AccountMeta::new(name_account_key, false),\n        AccountMeta::new_readonly(name_update_signer, true),\n    ];\n\n    if let Some(name_parent_key) = name_parent {\n        accounts.push(AccountMeta::new(name_parent_key, false))\n    }",
    "pub fn transfer(\n    name_service_program_id: Pubkey,\n    new_owner: Pubkey,\n    name_account_key: Pubkey,\n    name_owner_key: Pubkey,\n    name_class_opt: Option<Pubkey>,\n) -> Result<Instruction, ProgramError> {\n    let instruction_data = NameRegistryInstruction::Transfer { new_owner };\n    let data = borsh::to_vec(&instruction_data).unwrap();\n    let mut accounts = vec![\n        AccountMeta::new(name_account_key, false),\n        AccountMeta::new_readonly(name_owner_key, true),\n    ];\n\n    if let Some(key) = name_class_opt {\n        accounts.push(AccountMeta::new_readonly(key, true));\n    }\n\n    Ok(Instruction {\n        program_id: name_service_program_id,\n        accounts,\n        data,\n    })\n}",
    "pub fn delete(\n    name_service_program_id: Pubkey,\n    name_account_key: Pubkey,\n    name_owner_key: Pubkey,\n    refund_target: Pubkey,\n) -> Result<Instruction, ProgramError> {\n    let instruction_data = NameRegistryInstruction::Delete;\n    let data = borsh::to_vec(&instruction_data).unwrap();\n    let accounts = vec![\n        AccountMeta::new(name_account_key, false),\n        AccountMeta::new_readonly(name_owner_key, true),\n        AccountMeta::new(refund_target, false),\n    ];\n\n    Ok(Instruction {\n        program_id: name_service_program_id,\n        accounts,\n        data,\n    })\n}",
    "pub fn realloc(\n    name_service_program_id: Pubkey,\n    payer_key: Pubkey,\n    name_account_key: Pubkey,\n    name_owner_key: Pubkey,\n    space: u32,\n) -> Result<Instruction, ProgramError> {\n    let instruction_data = NameRegistryInstruction::Realloc { space };\n    let data = borsh::to_vec(&instruction_data).unwrap();\n    let accounts = vec![\n        AccountMeta::new_readonly(system_program::id(), false),\n        AccountMeta::new(payer_key, true),\n        AccountMeta::new(name_account_key, false),\n        AccountMeta::new_readonly(name_owner_key, true),\n    ];\n\n    Ok(Instruction {\n        program_id: name_service_program_id,\n        accounts,\n        data,\n    })\n}",
    "pub fn process_create(\n        program_id: &Pubkey,\n        accounts: &[AccountInfo],\n        hashed_name: Vec<u8>,\n        lamports: u64,\n        space: u32,\n    ) -> ProgramResult {\n        let accounts_iter = &mut accounts.iter();\n\n        let system_program = next_account_info(accounts_iter)?;\n        let payer_account = next_account_info(accounts_iter)?;\n        let name_account = next_account_info(accounts_iter)?;\n        let name_owner = next_account_info(accounts_iter)?;\n        let name_class = next_account_info(accounts_iter)?;\n        let parent_name_account = next_account_info(accounts_iter)?;\n        let parent_name_owner = next_account_info(accounts_iter).ok();\n\n        let (name_account_key, seeds) = get_seeds_and_key(\n            program_id,\n            hashed_name,\n            Some(name_class.key),\n            Some(parent_name_account.key),\n        );\n\n        // Verifications\n        if name_account_key != *name_account.key {\n            msg!(\"The given name account is incorrect.\");\n            return Err(ProgramError::InvalidArgument);\n        }\n        if name_account.data.borrow().len() > 0 {\n            let name_record_header =\n                NameRecordHeader::unpack_from_slice(&name_account.data.borrow())?;\n            if name_record_header.owner != Pubkey::default() {\n                msg!(\"The given name account already exists.\");\n                return Err(ProgramError::InvalidArgument);\n            }\n        }\n        if *name_class.key != Pubkey::default() && !name_class.is_signer {\n            msg!(\"The given name class is not a signer.\");\n            return Err(ProgramError::InvalidArgument);\n        }\n        if *parent_name_account.key != Pubkey::default() {\n            if !parent_name_owner.unwrap().is_signer {\n                msg!(\"The given parent name account owner is not a signer.\");\n                return Err(ProgramError::InvalidArgument);\n            } else {\n                let parent_name_record_header =\n                    NameRecordHeader::unpack_from_slice(&parent_name_account.data.borrow())?;\n                if &parent_name_record_header.owner != parent_name_owner.unwrap().key {\n                    msg!(\"The given parent name account owner is not correct.\");\n                    return Err(ProgramError::InvalidArgument);\n                }\n            }\n        }\n        if name_owner.key == &Pubkey::default() {\n            msg!(\"The owner cannot be `Pubkey::default()`.\");\n            return Err(ProgramError::InvalidArgument);\n        }\n\n        if name_account.data.borrow().len() == 0 {\n            // Issue the name registry account\n            // The creation is done in three steps: transfer, allocate and assign, because\n            // one cannot `system_instruction::create` an account to which lamports have\n            // been transferred before.\n            invoke(\n                &system_instruction::transfer(payer_account.key, &name_account_key, lamports),\n                &[\n                    payer_account.clone(),\n                    name_account.clone(),\n                    system_program.clone(),\n                ],\n            )?;\n\n            invoke_signed(\n                &system_instruction::allocate(\n                    &name_account_key,\n                    NameRecordHeader::LEN.saturating_add(space as usize) as u64,\n                ),\n                &[name_account.clone(), system_program.clone()],\n                &[&seeds.chunks(32).collect::<Vec<&[u8]>>()],\n            )?;\n\n            invoke_signed(\n                &system_instruction::assign(name_account.key, program_id),\n                &[name_account.clone(), system_program.clone()],\n                &[&seeds.chunks(32).collect::<Vec<&[u8]>>()],\n            )?;\n        }\n\n        let name_state = NameRecordHeader {\n            parent_name: *parent_name_account.key,\n            owner: *name_owner.key,\n            class: *name_class.key,\n        };\n\n        name_state.pack_into_slice(&mut name_account.data.borrow_mut());\n\n        Ok(())\n    }",
    "pub fn process_update(accounts: &[AccountInfo], offset: u32, data: Vec<u8>) -> ProgramResult {\n        let accounts_iter = &mut accounts.iter();\n\n        let name_account = next_account_info(accounts_iter)?;\n        let name_update_signer = next_account_info(accounts_iter)?;\n        let parent_name = next_account_info(accounts_iter).ok();\n\n        let name_record_header = NameRecordHeader::unpack_from_slice(&name_account.data.borrow())?;\n\n        // Verifications\n        let is_parent_owner = if let Some(parent_name) = parent_name {\n            if name_record_header.parent_name != *parent_name.key {\n                msg!(\"Invalid parent name account\");\n                return Err(ProgramError::InvalidArgument);\n            }\n            let parent_name_record_header =\n                NameRecordHeader::unpack_from_slice(&parent_name.data.borrow())?;\n            parent_name_record_header.owner == *name_update_signer.key\n        } else {\n            false\n        };\n        if !name_update_signer.is_signer {\n            msg!(\"The given name class or owner is not a signer.\");\n            return Err(ProgramError::InvalidArgument);\n        }\n        if name_record_header.class != Pubkey::default()\n            && *name_update_signer.key != name_record_header.class\n        {\n            msg!(\"The given name class account is incorrect.\");\n            return Err(ProgramError::InvalidArgument);\n        }\n        if name_record_header.class == Pubkey::default()\n            && *name_update_signer.key != name_record_header.owner\n            && !is_parent_owner\n        {\n            msg!(\"The given name owner account is incorrect.\");\n            return Err(ProgramError::InvalidArgument);\n        }\n\n        write_data(\n            name_account,\n            &data,\n            NameRecordHeader::LEN.saturating_add(offset as usize),\n        );\n\n        Ok(())\n    }",
    "pub fn process_transfer(accounts: &[AccountInfo], new_owner: Pubkey) -> ProgramResult {\n        let accounts_iter = &mut accounts.iter();\n\n        let name_account = next_account_info(accounts_iter)?;\n        let name_owner = next_account_info(accounts_iter)?;\n        let name_class_opt = next_account_info(accounts_iter).ok();\n        let parent_name = next_account_info(accounts_iter).ok();\n\n        let mut name_record_header =\n            NameRecordHeader::unpack_from_slice(&name_account.data.borrow())?;\n\n        // Verifications\n        let is_parent_owner = if let Some(parent_name) = parent_name {\n            if name_record_header.parent_name != *parent_name.key {\n                msg!(\"Invalid parent name account\");\n                return Err(ProgramError::InvalidArgument);\n            }\n            let parent_name_record_header =\n                NameRecordHeader::unpack_from_slice(&parent_name.data.borrow())?;\n            parent_name_record_header.owner == *name_owner.key\n        } else {\n            false\n        };\n        if !name_owner.is_signer\n            || (name_record_header.owner != *name_owner.key && !is_parent_owner)\n        {\n            msg!(\"The given name owner is incorrect or not a signer.\");\n            return Err(ProgramError::InvalidArgument);\n        }\n        if name_record_header.class != Pubkey::default()\n            && (name_class_opt.is_none()\n                || name_record_header.class != *name_class_opt.unwrap().key\n                || !name_class_opt.unwrap().is_signer)\n        {\n            msg!(\"The given name class account is incorrect or not a signer.\");\n            return Err(ProgramError::InvalidArgument);\n        }\n\n        name_record_header.owner = new_owner;\n        name_record_header\n            .pack_into_slice(&mut name_account.data.borrow_mut()[..NameRecordHeader::LEN]);\n\n        Ok(())\n    }",
    "pub fn process_delete(accounts: &[AccountInfo]) -> ProgramResult {\n        let accounts_iter = &mut accounts.iter();\n\n        let name_account = next_account_info(accounts_iter)?;\n        let name_owner = next_account_info(accounts_iter)?;\n        let refund_target = next_account_info(accounts_iter)?;\n\n        let name_record_header = NameRecordHeader::unpack_from_slice(&name_account.data.borrow())?;\n\n        // Verifications\n        if !name_owner.is_signer || name_record_header.owner != *name_owner.key {\n            msg!(\"The given name owner is incorrect or not a signer.\");\n            return Err(ProgramError::InvalidArgument);\n        }\n\n        // Overwrite the data with zeroes\n        write_data(name_account, &vec![0; name_account.data_len()], 0);\n\n        // Close the account by transferring the rent sol\n        let source_amount: &mut u64 = &mut name_account.lamports.borrow_mut();\n        let dest_amount: &mut u64 = &mut refund_target.lamports.borrow_mut();\n        *dest_amount = dest_amount.saturating_add(*source_amount);\n        *source_amount = 0;\n\n        Ok(())\n    }",
    "pub fn process_instruction(\n        program_id: &Pubkey,\n        accounts: &[AccountInfo],\n        instruction_data: &[u8],\n    ) -> ProgramResult {\n        msg!(\"Beginning processing\");\n        let instruction = NameRegistryInstruction::try_from_slice(instruction_data)\n            .map_err(|_| ProgramError::InvalidInstructionData)?;\n        msg!(\"Instruction unpacked\");\n\n        match instruction {\n            NameRegistryInstruction::Create {\n                hashed_name,\n                lamports,\n                space,\n            } => {\n                msg!(\"Instruction: Create\");\n                Processor::process_create(program_id, accounts, hashed_name, lamports, space)?;\n            }\n            NameRegistryInstruction::Update { offset, data } => {\n                msg!(\"Instruction: Update Data\");\n                Processor::process_update(accounts, offset, data)?;\n            }\n            NameRegistryInstruction::Transfer { new_owner } => {\n                msg!(\"Instruction: Transfer Ownership\");\n                Processor::process_transfer(accounts, new_owner)?;\n            }\n            NameRegistryInstruction::Delete => {\n                msg!(\"Instruction: Delete Name\");\n                Processor::process_delete(accounts)?;\n            }\n            NameRegistryInstruction::Realloc { space } => {\n                msg!(\"Instruction: Realloc Name Record\");\n                Processor::process_realloc(accounts, space)?;\n            }\n        }\n        Ok(())\n    }",
    "pub fn write_data(account: &AccountInfo, input: &[u8], offset: usize) {\n    let mut account_data = account.data.borrow_mut();\n    account_data[offset..offset.saturating_add(input.len())].copy_from_slice(input);\n}\n\n////////////////////////////////////////////////////////////\n\npub const HASH_PREFIX: &str = \"SPL Name Service\";\n\n////////////////////////////////////////////////////////////\n\npub fn get_seeds_and_key(\n    program_id: &Pubkey,\n    hashed_name: Vec<u8>, // Hashing is done off-chain\n    name_class_opt: Option<&Pubkey>,\n    parent_name_address_opt: Option<&Pubkey>,\n) -> (Pubkey, Vec<u8>) {\n    // let hashed_name: Vec<u8> = hashv(&[\n    //     (HASH_PREFIX.to_owned() + name).as_bytes()\n    // ]).0.to_vec();\n    let mut seeds_vec: Vec<u8> = hashed_name;\n\n    let name_class = name_class_opt.cloned().unwrap_or_default();\n\n    for b in name_class.to_bytes() {\n        seeds_vec.push(b);\n    }\n\n    let parent_name_address = parent_name_address_opt.cloned().unwrap_or_default();\n\n    for b in parent_name_address.to_bytes() {\n        seeds_vec.push(b);\n    }\n\n    let (name_account_key, bump) =\n        Pubkey::find_program_address(&seeds_vec.chunks(32).collect::<Vec<&[u8]>>(), program_id);\n    seeds_vec.push(bump);\n\n    (name_account_key, seeds_vec)\n}",
    "pub fn process(program_id: &Pubkey, accounts: &[AccountInfo], input: &[u8]) -> ProgramResult {\n        let instruction = StatelessOfferInstruction::try_from_slice(input)?;\n        match instruction {\n            StatelessOfferInstruction::AcceptOffer {\n                has_metadata,\n                maker_size,\n                taker_size,\n                bump_seed,\n            } => {\n                msg!(\"Instruction: accept offer\");\n                process_accept_offer(\n                    program_id,\n                    accounts,\n                    has_metadata,\n                    maker_size,\n                    taker_size,\n                    bump_seed,\n                )\n            }",
    "pub fn assert_is_ata(ata: &AccountInfo, wallet: &Pubkey, mint: &Pubkey) -> ProgramResult {\n    assert_owned_by(ata, &spl_token::id())?;\n    let ata_account: Account = assert_initialized(ata)?;\n    assert_keys_equal(ata_account.owner, *wallet)?;\n    assert_keys_equal(get_associated_token_address(wallet, mint), *ata.key)?;\n    Ok(())\n}",
    "pub fn assert_keys_equal(key1: Pubkey, key2: Pubkey) -> ProgramResult {\n    if key1 != key2 {\n        Err(UtilError::PublicKeyMismatch.into())\n    }",
    "pub fn assert_owned_by(account: &AccountInfo, owner: &Pubkey) -> ProgramResult {\n    if account.owner != owner {\n        Err(UtilError::IncorrectOwner.into())\n    }",
    "pub fn process_initialize_collection(\n    _program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    data: InitializeGroup,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n\n    let collection_info = next_account_info(account_info_iter)?;\n    let mint_info = next_account_info(account_info_iter)?;\n    let mint_authority_info = next_account_info(account_info_iter)?;\n\n    check_mint_and_metadata(mint_info, mint_authority_info)?;\n\n    // Initialize the collection\n    let mut buffer = collection_info.try_borrow_mut_data()?;\n    let mut state = TlvStateMut::unpack(&mut buffer)?;\n    let (collection, _) = state.init_value::<TokenGroup>(false)?;\n    *collection = TokenGroup::new(mint_info.key, data.update_authority, data.max_size.into());\n\n    Ok(())\n}",
    "pub fn process_initialize_collection_member(\n    _program_id: &Pubkey,\n    accounts: &[AccountInfo],\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n\n    let member_info = next_account_info(account_info_iter)?;\n    let mint_info = next_account_info(account_info_iter)?;\n    let mint_authority_info = next_account_info(account_info_iter)?;\n    let collection_info = next_account_info(account_info_iter)?;\n    let collection_update_authority_info = next_account_info(account_info_iter)?;\n\n    check_mint_and_metadata(mint_info, mint_authority_info)?;\n\n    if member_info.key == collection_info.key {\n        return Err(TokenGroupError::MemberAccountIsGroupAccount.into());\n    }\n\n    let mut buffer = collection_info.try_borrow_mut_data()?;\n    let mut state = TlvStateMut::unpack(&mut buffer)?;\n    let collection = state.get_first_value_mut::<TokenGroup>()?;\n\n    check_update_authority(\n        collection_update_authority_info,\n        &collection.update_authority,\n    )?;\n    let member_number = collection.increment_size()?;\n\n    let mut buffer = member_info.try_borrow_mut_data()?;\n    let mut state = TlvStateMut::unpack(&mut buffer)?;\n\n    // This program uses `allow_repetition: true` because the same mint can be\n    // a member of multiple collections.\n    let (member, _) = state.init_value::<TokenGroupMember>(/* allow_repetition */ true)?;\n    *member = TokenGroupMember::new(mint_info.key, collection_info.key, member_number);\n\n    Ok(())\n}",
    "pub fn process(program_id: &Pubkey, accounts: &[AccountInfo], input: &[u8]) -> ProgramResult {\n    let instruction = TokenGroupInstruction::unpack(input)?;\n    match instruction {\n        TokenGroupInstruction::InitializeGroup(data) => {\n            msg!(\"Instruction: InitializeCollection\");\n            process_initialize_collection(program_id, accounts, data)\n        }",
    "pub fn process_instruction(\n    _program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    input: &[u8],\n) -> ProgramResult {\n    msg!(\"Flash Loan Receiver invoked.\");\n    let account_info_iter = &mut accounts.iter();\n    let destination_liq_info = next_account_info(account_info_iter)?;\n    let source_liq_info = next_account_info(account_info_iter)?;\n    let spl_token_program_info = next_account_info(account_info_iter)?;\n    let user_transfer_authority_info = next_account_info(account_info_iter)?;\n\n    let (tag, rest) = input\n        .split_first()\n        .ok_or(ProgramError::InvalidInstructionData)?;\n\n    if *tag != 0 {\n        msg!(\n            \"Expecting the 0th instruction to be called. Instead {}th was called.\",\n            tag\n        );\n        return Err(ProgramError::InvalidInstructionData);\n    }\n\n    let amount = unpack_amount(rest)?;\n\n    invoke(\n        &spl_token::instruction::transfer(\n            spl_token_program_info.key,\n            destination_liq_info.key,\n            source_liq_info.key,\n            user_transfer_authority_info.key,\n            &[],\n            amount,\n        )?,\n        &[\n            source_liq_info.clone(),\n            destination_liq_info.clone(),\n            user_transfer_authority_info.clone(),\n            spl_token_program_info.clone(),\n        ],\n    )?;\n    Ok(())\n}",
    "pub fn unpack(input: &[u8]) -> Result<Self, ProgramError> {\n        let (&tag, rest) = input\n            .split_first()\n            .ok_or(LendingError::InstructionUnpackError)?;\n        Ok(match tag {\n            0 => {\n                let (owner, rest) = Self::unpack_pubkey(rest)?;\n                let (quote_currency, _rest) = Self::unpack_bytes32(rest)?;\n                Self::InitLendingMarket {\n                    owner,\n                    quote_currency: *quote_currency,\n                }\n            }\n            1 => {\n                let (new_owner, _rest) = Self::unpack_pubkey(rest)?;\n                Self::SetLendingMarketOwner { new_owner }\n            }\n            2 => {\n                let (liquidity_amount, rest) = Self::unpack_u64(rest)?;\n                let config = Self::unpack_reserve_config(rest)?;\n                Self::InitReserve {\n                    liquidity_amount,\n                    config,\n                }\n            }\n            3 => Self::RefreshReserve,\n            4 => {\n                let (liquidity_amount, _rest) = Self::unpack_u64(rest)?;\n                Self::DepositReserveLiquidity { liquidity_amount }\n            }\n            5 => {\n                let (collateral_amount, _rest) = Self::unpack_u64(rest)?;\n                Self::RedeemReserveCollateral { collateral_amount }\n            }\n            6 => Self::InitObligation,\n            7 => Self::RefreshObligation,\n            8 => {\n                let (collateral_amount, _rest) = Self::unpack_u64(rest)?;\n                Self::DepositObligationCollateral { collateral_amount }\n            }\n            9 => {\n                let (collateral_amount, _rest) = Self::unpack_u64(rest)?;\n                Self::WithdrawObligationCollateral { collateral_amount }\n            }\n            10 => {\n                let (liquidity_amount, rest) = Self::unpack_u64(rest)?;\n                let (slippage_limit, _rest) = Self::unpack_u64(rest).unwrap_or((0, &[]));\n                Self::BorrowObligationLiquidity {\n                    liquidity_amount,\n                    slippage_limit,\n                }\n            }\n            11 => {\n                let (liquidity_amount, _rest) = Self::unpack_u64(rest)?;\n                Self::RepayObligationLiquidity { liquidity_amount }\n            }\n            12 => {\n                let (liquidity_amount, _rest) = Self::unpack_u64(rest)?;\n                Self::LiquidateObligation { liquidity_amount }\n            }\n            13 => {\n                let (amount, _rest) = Self::unpack_u64(rest)?;\n                Self::FlashLoan { amount }\n            }\n            14 => {\n                let new_config = Self::unpack_reserve_config(rest)?;\n                Self::ModifyReserveConfig { new_config }\n            }\n            _ => {\n                msg!(\"Instruction cannot be unpacked\");\n                return Err(LendingError::InstructionUnpackError.into());\n            }\n        })\n    }",
    "pub fn process_instruction(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    input: &[u8],\n) -> ProgramResult {\n    let instruction = LendingInstruction::unpack(input)?;\n    match instruction {\n        LendingInstruction::InitLendingMarket {\n            owner,\n            quote_currency,\n        } => {\n            msg!(\"Instruction: Init Lending Market\");\n            process_init_lending_market(program_id, owner, quote_currency, accounts)\n        }",
    "pub fn one() -> Self {\n        Self(Self::wad())\n    }",
    "pub fn zero() -> Self {\n        Self(U192::zero())\n    }",
    "pub fn from_percent(percent: u8) -> Self {\n        Self(U192::from(percent as u64 * PERCENT_SCALER))\n    }",
    "pub fn to_scaled_val(&self) -> Result<u128, ProgramError> {\n        Ok(u128::try_from(self.0).map_err(|_| LendingError::MathOverflow)?)\n    }",
    "pub fn from_scaled_val(scaled_val: u128) -> Self {\n        Self(U192::from(scaled_val))\n    }",
    "pub fn try_round_u64(&self) -> Result<u64, ProgramError> {\n        let rounded_val = Self::half_wad()\n            .checked_add(self.0)\n            .ok_or(LendingError::MathOverflow)?\n            .checked_div(Self::wad())\n            .ok_or(LendingError::MathOverflow)?;\n        Ok(u64::try_from(rounded_val).map_err(|_| LendingError::MathOverflow)?)\n    }",
    "pub fn try_ceil_u64(&self) -> Result<u64, ProgramError> {\n        let ceil_val = Self::wad()\n            .checked_sub(U192::from(1u64))\n            .ok_or(LendingError::MathOverflow)?\n            .checked_add(self.0)\n            .ok_or(LendingError::MathOverflow)?\n            .checked_div(Self::wad())\n            .ok_or(LendingError::MathOverflow)?;\n        Ok(u64::try_from(ceil_val).map_err(|_| LendingError::MathOverflow)?)\n    }",
    "pub fn try_floor_u64(&self) -> Result<u64, ProgramError> {\n        let ceil_val = self\n            .0\n            .checked_div(Self::wad())\n            .ok_or(LendingError::MathOverflow)?;\n        Ok(u64::try_from(ceil_val).map_err(|_| LendingError::MathOverflow)?)\n    }",
    "pub fn one() -> Self {\n        Self(Self::wad())\n    }",
    "pub fn zero() -> Self {\n        Self(U128::from(0))\n    }",
    "pub fn from_percent(percent: u8) -> Self {\n        Self(U128::from(percent as u64 * PERCENT_SCALER))\n    }",
    "pub fn to_scaled_val(&self) -> u128 {\n        self.0.as_u128()\n    }",
    "pub fn from_scaled_val(scaled_val: u64) -> Self {\n        Self(U128::from(scaled_val))\n    }",
    "pub fn try_pow(&self, mut exp: u64) -> Result<Rate, ProgramError> {\n        let mut base = *self;\n        let mut ret = if exp % 2 != 0 {\n            base\n        } else {\n            Rate(Self::wad())\n        }",
    "pub fn new(slot: Slot) -> Self {\n        Self { slot, stale: true }\n    }\n\n    /// Return slots elapsed since given slot\n    pub fn slots_elapsed(&self, slot: Slot) -> Result<u64, ProgramError> {\n        let slots_elapsed = slot\n            .checked_sub(self.slot)\n            .ok_or(LendingError::MathOverflow)?;\n        Ok(slots_elapsed)\n    }",
    "pub fn update_slot(&mut self, slot: Slot) {\n        self.slot = slot;\n        self.stale = false;\n    }\n\n    /// Set stale to true\n    pub fn mark_stale(&mut self) {\n        self.stale = true;\n    }\n\n    /// Check if marked stale or last update slot is too long ago\n    pub fn is_stale(&self, slot: Slot) -> Result<bool, ProgramError> {\n        Ok(self.stale || self.slots_elapsed(slot)? >= STALE_AFTER_SLOTS_ELAPSED)\n    }",
    "pub fn new(params: InitLendingMarketParams) -> Self {\n        let mut lending_market = Self::default();\n        Self::init(&mut lending_market, params);\n        lending_market\n    }\n\n    /// Initialize a lending market\n    pub fn init(&mut self, params: InitLendingMarketParams) {\n        self.version = PROGRAM_VERSION;\n        self.bump_seed = params.bump_seed;\n        self.owner = params.owner;\n        self.quote_currency = params.quote_currency;\n        self.token_program_id = params.token_program_id;\n        self.oracle_program_id = params.oracle_program_id;\n    }\n}\n\n/// Initialize a lending market\npub struct InitLendingMarketParams {\n    /// Bump seed for derived authority address\n    pub bump_seed: u8,\n    /// Owner authority which can add new reserves\n    pub owner: Pubkey,\n    /// Currency market prices are quoted in\n    /// e.g. \"USD\" null padded\n    /// (`*b\"USD\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\"`) or\n    /// a SPL token mint pubkey\n    pub quote_currency: [u8; 32],\n    /// Token program id\n    pub token_program_id: Pubkey,\n    /// Oracle (Pyth) program id\n    pub oracle_program_id: Pubkey,\n}\n\nimpl Sealed for LendingMarket {}\nimpl IsInitialized for LendingMarket {\n    fn is_initialized(&self) -> bool {\n        self.version != UNINITIALIZED_VERSION\n    }\n}\n\nconst LENDING_MARKET_LEN: usize = 258; // 1 + 1 + 32 + 32 + 32 + 32 + 128\nimpl Pack for LendingMarket {\n    const LEN: usize = LENDING_MARKET_LEN;\n\n    fn pack_into_slice(&self, output: &mut [u8]) {\n        let output = array_mut_ref![output, 0, LENDING_MARKET_LEN];\n        #[allow(clippy::ptr_offset_with_cast)]\n        let (\n            version,\n            bump_seed,\n            owner,\n            quote_currency,\n            token_program_id,\n            oracle_program_id,\n            _padding,\n        ) = mut_array_refs![\n            output,\n            1,\n            1,\n            PUBKEY_BYTES,\n            32,\n            PUBKEY_BYTES,\n            PUBKEY_BYTES,\n            128\n        ];\n\n        *version = self.version.to_le_bytes();\n        *bump_seed = self.bump_seed.to_le_bytes();\n        owner.copy_from_slice(self.owner.as_ref());\n        quote_currency.copy_from_slice(self.quote_currency.as_ref());\n        token_program_id.copy_from_slice(self.token_program_id.as_ref());\n        oracle_program_id.copy_from_slice(self.oracle_program_id.as_ref());\n    }\n\n    /// Unpacks a byte buffer into a\n    /// [LendingMarketInfo](struct.LendingMarketInfo.html)\n    fn unpack_from_slice(input: &[u8]) -> Result<Self, ProgramError> {\n        let input = array_ref![input, 0, LENDING_MARKET_LEN];\n        #[allow(clippy::ptr_offset_with_cast)]\n        let (\n            version,\n            bump_seed,\n            owner,\n            quote_currency,\n            token_program_id,\n            oracle_program_id,\n            _padding,\n        ) = array_refs![\n            input,\n            1,\n            1,\n            PUBKEY_BYTES,\n            32,\n            PUBKEY_BYTES,\n            PUBKEY_BYTES,\n            128\n        ];\n\n        let version = u8::from_le_bytes(*version);\n        if version > PROGRAM_VERSION {\n            msg!(\"Lending market version does not match lending program version\");\n            return Err(ProgramError::InvalidAccountData);\n        }\n\n        Ok(Self {\n            version,\n            bump_seed: u8::from_le_bytes(*bump_seed),\n            owner: Pubkey::new_from_array(*owner),\n            quote_currency: *quote_currency,\n            token_program_id: Pubkey::new_from_array(*token_program_id),\n            oracle_program_id: Pubkey::new_from_array(*oracle_program_id),\n        })\n    }",
    "pub fn new(params: InitObligationParams) -> Self {\n        let mut obligation = Self::default();\n        Self::init(&mut obligation, params);\n        obligation\n    }\n\n    /// Initialize an obligation\n    pub fn init(&mut self, params: InitObligationParams) {\n        self.version = PROGRAM_VERSION;\n        self.last_update = LastUpdate::new(params.current_slot);\n        self.lending_market = params.lending_market;\n        self.owner = params.owner;\n        self.deposits = params.deposits;\n        self.borrows = params.borrows;\n    }\n\n    /// Calculate the current ratio of borrowed value to deposited value\n    pub fn loan_to_value(&self) -> Result<Decimal, ProgramError> {\n        self.borrowed_value.try_div(self.deposited_value)\n    }",
    "pub fn repay(&mut self, settle_amount: Decimal, liquidity_index: usize) -> ProgramResult {\n        let liquidity = &mut self.borrows[liquidity_index];\n        if settle_amount == liquidity.borrowed_amount_wads {\n            self.borrows.remove(liquidity_index);\n        } else {\n            liquidity.repay(settle_amount)?;\n        }\n        Ok(())\n    }",
    "pub fn withdraw(&mut self, withdraw_amount: u64, collateral_index: usize) -> ProgramResult {\n        let collateral = &mut self.deposits[collateral_index];\n        if withdraw_amount == collateral.deposited_amount {\n            self.deposits.remove(collateral_index);\n        } else {\n            collateral.withdraw(withdraw_amount)?;\n        }\n        Ok(())\n    }",
    "pub fn max_withdraw_value(\n        &self,\n        withdraw_collateral_ltv: Rate,\n    ) -> Result<Decimal, ProgramError> {\n        if self.allowed_borrow_value <= self.borrowed_value {\n            return Ok(Decimal::zero());\n        }\n        if withdraw_collateral_ltv == Rate::zero() {\n            return Ok(self.deposited_value);\n        }\n        self.allowed_borrow_value\n            .try_sub(self.borrowed_value)?\n            .try_div(withdraw_collateral_ltv)\n    }",
    "pub fn remaining_borrow_value(&self) -> Result<Decimal, ProgramError> {\n        self.allowed_borrow_value.try_sub(self.borrowed_value)\n    }",
    "pub fn max_liquidation_amount(\n        &self,\n        liquidity: &ObligationLiquidity,\n    ) -> Result<Decimal, ProgramError> {\n        let max_liquidation_value = self\n            .borrowed_value\n            .try_mul(Rate::from_percent(LIQUIDATION_CLOSE_FACTOR))?\n            .min(liquidity.market_value);\n        let max_liquidation_pct = max_liquidation_value.try_div(liquidity.market_value)?;\n        liquidity.borrowed_amount_wads.try_mul(max_liquidation_pct)\n    }",
    "pub fn find_collateral_in_deposits(\n        &self,\n        deposit_reserve: Pubkey,\n    ) -> Result<(&ObligationCollateral, usize), ProgramError> {\n        if self.deposits.is_empty() {\n            msg!(\"Obligation has no deposits\");\n            return Err(LendingError::ObligationDepositsEmpty.into());\n        }\n        let collateral_index = self\n            ._find_collateral_index_in_deposits(deposit_reserve)\n            .ok_or(LendingError::InvalidObligationCollateral)?;\n        Ok((&self.deposits[collateral_index], collateral_index))\n    }",
    "pub fn find_or_add_collateral_to_deposits(\n        &mut self,\n        deposit_reserve: Pubkey,\n    ) -> Result<&mut ObligationCollateral, ProgramError> {\n        if let Some(collateral_index) = self._find_collateral_index_in_deposits(deposit_reserve) {\n            return Ok(&mut self.deposits[collateral_index]);\n        }\n        if self.deposits.len() + self.borrows.len() >= MAX_OBLIGATION_RESERVES {\n            msg!(\n                \"Obligation cannot have more than {} deposits and borrows combined\",\n                MAX_OBLIGATION_RESERVES\n            );\n            return Err(LendingError::ObligationReserveLimit.into());\n        }\n        let collateral = ObligationCollateral::new(deposit_reserve);\n        self.deposits.push(collateral);\n        Ok(self.deposits.last_mut().unwrap())\n    }",
    "pub fn find_liquidity_in_borrows(\n        &self,\n        borrow_reserve: Pubkey,\n    ) -> Result<(&ObligationLiquidity, usize), ProgramError> {\n        if self.borrows.is_empty() {\n            msg!(\"Obligation has no borrows\");\n            return Err(LendingError::ObligationBorrowsEmpty.into());\n        }\n        let liquidity_index = self\n            ._find_liquidity_index_in_borrows(borrow_reserve)\n            .ok_or(LendingError::InvalidObligationLiquidity)?;\n        Ok((&self.borrows[liquidity_index], liquidity_index))\n    }",
    "pub fn find_or_add_liquidity_to_borrows(\n        &mut self,\n        borrow_reserve: Pubkey,\n    ) -> Result<&mut ObligationLiquidity, ProgramError> {\n        if let Some(liquidity_index) = self._find_liquidity_index_in_borrows(borrow_reserve) {\n            return Ok(&mut self.borrows[liquidity_index]);\n        }\n        if self.deposits.len() + self.borrows.len() >= MAX_OBLIGATION_RESERVES {\n            msg!(\n                \"Obligation cannot have more than {} deposits and borrows combined\",\n                MAX_OBLIGATION_RESERVES\n            );\n            return Err(LendingError::ObligationReserveLimit.into());\n        }\n        let liquidity = ObligationLiquidity::new(borrow_reserve);\n        self.borrows.push(liquidity);\n        Ok(self.borrows.last_mut().unwrap())\n    }",
    "pub fn new(deposit_reserve: Pubkey) -> Self {\n        Self {\n            deposit_reserve,\n            deposited_amount: 0,\n            market_value: Decimal::zero(),\n        }\n    }\n\n    /// Increase deposited collateral\n    pub fn deposit(&mut self, collateral_amount: u64) -> ProgramResult {\n        self.deposited_amount = self\n            .deposited_amount\n            .checked_add(collateral_amount)\n            .ok_or(LendingError::MathOverflow)?;\n        Ok(())\n    }",
    "pub fn withdraw(&mut self, collateral_amount: u64) -> ProgramResult {\n        self.deposited_amount = self\n            .deposited_amount\n            .checked_sub(collateral_amount)\n            .ok_or(LendingError::MathOverflow)?;\n        Ok(())\n    }",
    "pub fn new(borrow_reserve: Pubkey) -> Self {\n        Self {\n            borrow_reserve,\n            cumulative_borrow_rate_wads: Decimal::one(),\n            borrowed_amount_wads: Decimal::zero(),\n            market_value: Decimal::zero(),\n        }\n    }\n\n    /// Decrease borrowed liquidity\n    pub fn repay(&mut self, settle_amount: Decimal) -> ProgramResult {\n        self.borrowed_amount_wads = self.borrowed_amount_wads.try_sub(settle_amount)?;\n        Ok(())\n    }",
    "pub fn borrow(&mut self, borrow_amount: Decimal) -> ProgramResult {\n        self.borrowed_amount_wads = self.borrowed_amount_wads.try_add(borrow_amount)?;\n        Ok(())\n    }",
    "pub fn accrue_interest(&mut self, cumulative_borrow_rate_wads: Decimal) -> ProgramResult {\n        match cumulative_borrow_rate_wads.cmp(&self.cumulative_borrow_rate_wads) {\n            Ordering::Less => {\n                msg!(\"Interest rate cannot be negative\");\n                return Err(LendingError::NegativeInterestRate.into());\n            }\n            Ordering::Equal => {}\n            Ordering::Greater => {\n                let compounded_interest_rate: Rate = cumulative_borrow_rate_wads\n                    .try_div(self.cumulative_borrow_rate_wads)?\n                    .try_into()?;\n\n                self.borrowed_amount_wads = self\n                    .borrowed_amount_wads\n                    .try_mul(compounded_interest_rate)?;\n                self.cumulative_borrow_rate_wads = cumulative_borrow_rate_wads;\n            }\n        }\n\n        Ok(())\n    }",
    "pub fn new(params: InitReserveParams) -> Self {\n        let mut reserve = Self::default();\n        Self::init(&mut reserve, params);\n        reserve\n    }\n\n    /// Initialize a reserve\n    pub fn init(&mut self, params: InitReserveParams) {\n        self.version = PROGRAM_VERSION;\n        self.last_update = LastUpdate::new(params.current_slot);\n        self.lending_market = params.lending_market;\n        self.liquidity = params.liquidity;\n        self.collateral = params.collateral;\n        self.config = params.config;\n    }\n\n    /// Record deposited liquidity and return amount of collateral tokens to\n    /// mint\n    pub fn deposit_liquidity(&mut self, liquidity_amount: u64) -> Result<u64, ProgramError> {\n        let collateral_amount = self\n            .collateral_exchange_rate()?\n            .liquidity_to_collateral(liquidity_amount)?;\n\n        self.liquidity.deposit(liquidity_amount)?;\n        self.collateral.mint(collateral_amount)?;\n\n        Ok(collateral_amount)\n    }",
    "pub fn redeem_collateral(&mut self, collateral_amount: u64) -> Result<u64, ProgramError> {\n        let collateral_exchange_rate = self.collateral_exchange_rate()?;\n        let liquidity_amount =\n            collateral_exchange_rate.collateral_to_liquidity(collateral_amount)?;\n\n        self.collateral.burn(collateral_amount)?;\n        self.liquidity.withdraw(liquidity_amount)?;\n\n        Ok(liquidity_amount)\n    }",
    "pub fn current_borrow_rate(&self) -> Result<Rate, ProgramError> {\n        let utilization_rate = self.liquidity.utilization_rate()?;\n        let optimal_utilization_rate = Rate::from_percent(self.config.optimal_utilization_rate);\n        let low_utilization = utilization_rate < optimal_utilization_rate;\n        if low_utilization || self.config.optimal_utilization_rate == 100 {\n            let normalized_rate = utilization_rate.try_div(optimal_utilization_rate)?;\n            let min_rate = Rate::from_percent(self.config.min_borrow_rate);\n            let rate_range = Rate::from_percent(\n                self.config\n                    .optimal_borrow_rate\n                    .checked_sub(self.config.min_borrow_rate)\n                    .ok_or(LendingError::MathOverflow)?,\n            );\n\n            Ok(normalized_rate.try_mul(rate_range)?.try_add(min_rate)?)\n        }",
    "pub fn collateral_exchange_rate(&self) -> Result<CollateralExchangeRate, ProgramError> {\n        let total_liquidity = self.liquidity.total_supply()?;\n        self.collateral.exchange_rate(total_liquidity)\n    }",
    "pub fn accrue_interest(&mut self, current_slot: Slot) -> ProgramResult {\n        let slots_elapsed = self.last_update.slots_elapsed(current_slot)?;\n        if slots_elapsed > 0 {\n            let current_borrow_rate = self.current_borrow_rate()?;\n            self.liquidity\n                .compound_interest(current_borrow_rate, slots_elapsed)?;\n        }\n        Ok(())\n    }",
    "pub fn calculate_borrow(\n        &self,\n        amount_to_borrow: u64,\n        max_borrow_value: Decimal,\n    ) -> Result<CalculateBorrowResult, ProgramError> {\n        // @TODO: add lookup table https://git.io/JOCYq\n        let decimals = 10u64\n            .checked_pow(self.liquidity.mint_decimals as u32)\n            .ok_or(LendingError::MathOverflow)?;\n        if amount_to_borrow == u64::MAX {\n            let borrow_amount = max_borrow_value\n                .try_mul(decimals)?\n                .try_div(self.liquidity.market_price)?\n                .min(self.liquidity.available_amount.into());\n            let (borrow_fee, host_fee) = self\n                .config\n                .fees\n                .calculate_borrow_fees(borrow_amount, FeeCalculation::Inclusive)?;\n            let receive_amount = borrow_amount\n                .try_floor_u64()?\n                .checked_sub(borrow_fee)\n                .ok_or(LendingError::MathOverflow)?;\n\n            Ok(CalculateBorrowResult {\n                borrow_amount,\n                receive_amount,\n                borrow_fee,\n                host_fee,\n            })\n        }",
    "pub fn calculate_repay(\n        &self,\n        amount_to_repay: u64,\n        borrowed_amount: Decimal,\n    ) -> Result<CalculateRepayResult, ProgramError> {\n        let settle_amount = if amount_to_repay == u64::MAX {\n            borrowed_amount\n        } else {\n            Decimal::from(amount_to_repay).min(borrowed_amount)\n        }",
    "pub fn calculate_liquidation(\n        &self,\n        amount_to_liquidate: u64,\n        obligation: &Obligation,\n        liquidity: &ObligationLiquidity,\n        collateral: &ObligationCollateral,\n    ) -> Result<CalculateLiquidationResult, ProgramError> {\n        let bonus_rate = Rate::from_percent(self.config.liquidation_bonus).try_add(Rate::one())?;\n\n        let max_amount = if amount_to_liquidate == u64::MAX {\n            liquidity.borrowed_amount_wads\n        } else {\n            Decimal::from(amount_to_liquidate).min(liquidity.borrowed_amount_wads)\n        }",
    "pub fn new(params: NewReserveLiquidityParams) -> Self {\n        Self {\n            mint_pubkey: params.mint_pubkey,\n            mint_decimals: params.mint_decimals,\n            supply_pubkey: params.supply_pubkey,\n            fee_receiver: params.fee_receiver,\n            oracle_pubkey: params.oracle_pubkey,\n            available_amount: 0,\n            borrowed_amount_wads: Decimal::zero(),\n            cumulative_borrow_rate_wads: Decimal::one(),\n            market_price: params.market_price,\n        }\n    }\n\n    /// Calculate the total reserve supply including active loans\n    pub fn total_supply(&self) -> Result<Decimal, ProgramError> {\n        Decimal::from(self.available_amount).try_add(self.borrowed_amount_wads)\n    }",
    "pub fn deposit(&mut self, liquidity_amount: u64) -> ProgramResult {\n        self.available_amount = self\n            .available_amount\n            .checked_add(liquidity_amount)\n            .ok_or(LendingError::MathOverflow)?;\n        Ok(())\n    }",
    "pub fn withdraw(&mut self, liquidity_amount: u64) -> ProgramResult {\n        if liquidity_amount > self.available_amount {\n            msg!(\"Withdraw amount cannot exceed available amount\");\n            return Err(LendingError::InsufficientLiquidity.into());\n        }\n        self.available_amount = self\n            .available_amount\n            .checked_sub(liquidity_amount)\n            .ok_or(LendingError::MathOverflow)?;\n        Ok(())\n    }",
    "pub fn borrow(&mut self, borrow_decimal: Decimal) -> ProgramResult {\n        let borrow_amount = borrow_decimal.try_floor_u64()?;\n        if borrow_amount > self.available_amount {\n            msg!(\"Borrow amount cannot exceed available amount\");\n            return Err(LendingError::InsufficientLiquidity.into());\n        }\n\n        self.available_amount = self\n            .available_amount\n            .checked_sub(borrow_amount)\n            .ok_or(LendingError::MathOverflow)?;\n        self.borrowed_amount_wads = self.borrowed_amount_wads.try_add(borrow_decimal)?;\n\n        Ok(())\n    }",
    "pub fn repay(&mut self, repay_amount: u64, settle_amount: Decimal) -> ProgramResult {\n        self.available_amount = self\n            .available_amount\n            .checked_add(repay_amount)\n            .ok_or(LendingError::MathOverflow)?;\n        self.borrowed_amount_wads = self.borrowed_amount_wads.try_sub(settle_amount)?;\n\n        Ok(())\n    }",
    "pub fn utilization_rate(&self) -> Result<Rate, ProgramError> {\n        let total_supply = self.total_supply()?;\n        if total_supply == Decimal::zero() {\n            return Ok(Rate::zero());\n        }\n        self.borrowed_amount_wads.try_div(total_supply)?.try_into()\n    }",
    "pub fn new(params: NewReserveCollateralParams) -> Self {\n        Self {\n            mint_pubkey: params.mint_pubkey,\n            mint_total_supply: 0,\n            supply_pubkey: params.supply_pubkey,\n        }\n    }\n\n    /// Add collateral to total supply\n    pub fn mint(&mut self, collateral_amount: u64) -> ProgramResult {\n        self.mint_total_supply = self\n            .mint_total_supply\n            .checked_add(collateral_amount)\n            .ok_or(LendingError::MathOverflow)?;\n        Ok(())\n    }",
    "pub fn burn(&mut self, collateral_amount: u64) -> ProgramResult {\n        self.mint_total_supply = self\n            .mint_total_supply\n            .checked_sub(collateral_amount)\n            .ok_or(LendingError::MathOverflow)?;\n        Ok(())\n    }",
    "pub fn collateral_to_liquidity(&self, collateral_amount: u64) -> Result<u64, ProgramError> {\n        self.decimal_collateral_to_liquidity(collateral_amount.into())?\n            .try_floor_u64()\n    }",
    "pub fn decimal_collateral_to_liquidity(\n        &self,\n        collateral_amount: Decimal,\n    ) -> Result<Decimal, ProgramError> {\n        collateral_amount.try_div(self.0)\n    }",
    "pub fn liquidity_to_collateral(&self, liquidity_amount: u64) -> Result<u64, ProgramError> {\n        self.decimal_liquidity_to_collateral(liquidity_amount.into())?\n            .try_floor_u64()\n    }",
    "pub fn decimal_liquidity_to_collateral(\n        &self,\n        liquidity_amount: Decimal,\n    ) -> Result<Decimal, ProgramError> {\n        liquidity_amount.try_mul(self.0)\n    }",
    "pub fn validate(&self) -> ProgramResult {\n        if self.optimal_utilization_rate > 100 {\n            msg!(\"Optimal utilization rate must be in range [0, 100]\");\n            return Err(LendingError::InvalidConfig.into());\n        }\n        if self.loan_to_value_ratio >= 100 {\n            msg!(\"Loan to value ratio must be in range [0, 100)\");\n            return Err(LendingError::InvalidConfig.into());\n        }\n        if self.liquidation_bonus > 100 {\n            msg!(\"Liquidation bonus must be in range [0, 100]\");\n            return Err(LendingError::InvalidConfig.into());\n        }\n        if self.liquidation_threshold <= self.loan_to_value_ratio\n            || self.liquidation_threshold > 100\n        {\n            msg!(\"Liquidation threshold must be in range (LTV, 100]\");\n            return Err(LendingError::InvalidConfig.into());\n        }\n        if self.optimal_borrow_rate < self.min_borrow_rate {\n            msg!(\"Optimal borrow rate must be >= min borrow rate\");\n            return Err(LendingError::InvalidConfig.into());\n        }\n        if self.optimal_borrow_rate > self.max_borrow_rate {\n            msg!(\"Optimal borrow rate must be <= max borrow rate\");\n            return Err(LendingError::InvalidConfig.into());\n        }\n        if self.fees.borrow_fee_wad >= WAD {\n            msg!(\"Borrow fee must be in range [0, 1_000_000_000_000_000_000)\");\n            return Err(LendingError::InvalidConfig.into());\n        }\n        if self.fees.flash_loan_fee_wad >= WAD {\n            msg!(\"Flash loan fee must be in range [0, 1_000_000_000_000_000_000)\");\n            return Err(LendingError::InvalidConfig.into());\n        }\n        if self.fees.host_fee_percentage > 100 {\n            msg!(\"Host fee percentage must be in range [0, 100]\");\n            return Err(LendingError::InvalidConfig.into());\n        }\n\n        Ok(())\n    }",
    "pub fn calculate_borrow_fees(\n        &self,\n        borrow_amount: Decimal,\n        fee_calculation: FeeCalculation,\n    ) -> Result<(u64, u64), ProgramError> {\n        self.calculate_fees(borrow_amount, self.borrow_fee_wad, fee_calculation)\n    }",
    "pub fn calculate_flash_loan_fees(\n        &self,\n        flash_loan_amount: Decimal,\n    ) -> Result<(u64, u64), ProgramError> {\n        self.calculate_fees(\n            flash_loan_amount,\n            self.flash_loan_fee_wad,\n            FeeCalculation::Exclusive,\n        )\n    }",
    "pub fn process_instruction(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    instruction_data: &[u8],\n) -> ProgramResult {\n    Processor::process(program_id, accounts, instruction_data)\n}",
    "pub fn process(\n        program_id: &Pubkey,\n        accounts: &[AccountInfo],\n        instruction_data: &[u8],\n    ) -> ProgramResult {\n        let instruction = FlashLoanReceiverInstruction::unpack(instruction_data)?;\n\n        match instruction {\n            FlashLoanReceiverInstruction::ReceiveFlashLoan { amount } => {\n                msg!(\"Instruction: Receive Flash Loan\");\n                Self::process_receive_flash_loan(accounts, amount, program_id)\n            }",
    "pub fn unpack(input: &[u8]) -> Result<Self, ProgramError> {\n        let (tag, rest) = input.split_first().ok_or(InvalidInstruction)?;\n\n        Ok(match tag {\n            0 => Self::ReceiveFlashLoan {\n                amount: Self::unpack_amount(rest)?,\n            },\n            _ => return Err(InvalidInstruction.into()),\n        })\n    }",
    "pub fn add_lending_market(test: &mut ProgramTest) -> TestLendingMarket {\n    let lending_market_pubkey = Pubkey::new_unique();\n    let (lending_market_authority, bump_seed) =\n        Pubkey::find_program_address(&[lending_market_pubkey.as_ref()], &spl_token_lending::id());\n\n    let lending_market_owner =\n        read_keypair_file(\"tests/fixtures/lending_market_owner.json\").unwrap();\n    let oracle_program_id = read_keypair_file(\"tests/fixtures/oracle_program_id.json\")\n        .unwrap()\n        .pubkey();\n\n    test.add_packable_account(\n        lending_market_pubkey,\n        u32::MAX as u64,\n        &LendingMarket::new(InitLendingMarketParams {\n            bump_seed,\n            owner: lending_market_owner.pubkey(),\n            quote_currency: QUOTE_CURRENCY,\n            token_program_id: spl_token::id(),\n            oracle_program_id,\n        }),\n        &spl_token_lending::id(),\n    );\n\n    TestLendingMarket {\n        pubkey: lending_market_pubkey,\n        owner: lending_market_owner,\n        authority: lending_market_authority,\n        quote_currency: QUOTE_CURRENCY,\n        oracle_program_id,\n    }\n}\n\n#[derive(Default)]\npub struct AddObligationArgs<'a> {\n    pub deposits: &'a [(&'a TestReserve, u64)],\n    pub borrows: &'a [(&'a TestReserve, u64)],\n    pub mark_fresh: bool,\n    pub slots_elapsed: u64,\n}\n\npub fn add_obligation(\n    test: &mut ProgramTest,\n    lending_market: &TestLendingMarket,\n    user_accounts_owner: &Keypair,\n    args: AddObligationArgs,\n) -> TestObligation {\n    let AddObligationArgs {\n        deposits,\n        borrows,\n        mark_fresh,\n        slots_elapsed,\n    } = args;\n\n    let obligation_keypair = Keypair::new();\n    let obligation_pubkey = obligation_keypair.pubkey();\n\n    let (obligation_deposits, test_deposits) = deposits\n        .iter()\n        .map(|(deposit_reserve, collateral_amount)| {\n            let mut collateral = ObligationCollateral::new(deposit_reserve.pubkey);\n            collateral.deposited_amount = *collateral_amount;\n\n            (\n                collateral,\n                TestObligationCollateral {\n                    obligation_pubkey,\n                    deposit_reserve: deposit_reserve.pubkey,\n                    deposited_amount: *collateral_amount,\n                },\n            )\n        }",
    "pub fn add_reserve(\n    test: &mut ProgramTest,\n    lending_market: &TestLendingMarket,\n    oracle: &TestOracle,\n    user_accounts_owner: &Keypair,\n    args: AddReserveArgs,\n) -> TestReserve {\n    let AddReserveArgs {\n        name,\n        config,\n        liquidity_amount,\n        liquidity_mint_pubkey,\n        liquidity_mint_decimals,\n        user_liquidity_amount,\n        borrow_amount,\n        initial_borrow_rate,\n        collateral_amount,\n        mark_fresh,\n        slots_elapsed,\n    } = args;\n\n    let is_native = if liquidity_mint_pubkey == spl_token::native_mint::id() {\n        COption::Some(1)\n    }",
    "pub fn add_account_for_program(\n    test: &mut ProgramTest,\n    program_derived_account: &Pubkey,\n    amount: u64,\n    mint_pubkey: &Pubkey,\n) -> Pubkey {\n    let program_owned_token_account = Keypair::new();\n    test.add_packable_account(\n        program_owned_token_account.pubkey(),\n        u32::MAX as u64,\n        &Token {\n            mint: *mint_pubkey,\n            owner: *program_derived_account,\n            amount,\n            state: AccountState::Initialized,\n            is_native: COption::None,\n            ..Token::default()\n        }",
    "pub fn add_usdc_mint(test: &mut ProgramTest) -> TestMint {\n    let authority = Keypair::new();\n    let pubkey = Pubkey::from_str(USDC_MINT).unwrap();\n    let decimals = 6;\n    test.add_packable_account(\n        pubkey,\n        u32::MAX as u64,\n        &Mint {\n            is_initialized: true,\n            mint_authority: COption::Some(authority.pubkey()),\n            decimals,\n            ..Mint::default()\n        }",
    "pub fn add_sol_oracle(test: &mut ProgramTest) -> TestOracle {\n    add_oracle(\n        test,\n        Pubkey::from_str(SOL_PYTH_PRODUCT).unwrap(),\n        Pubkey::from_str(SOL_PYTH_PRICE).unwrap(),\n        // Set SOL price to $20\n        Decimal::from(20u64),\n    )\n}",
    "pub fn add_usdc_oracle(test: &mut ProgramTest) -> TestOracle {\n    add_oracle(\n        test,\n        // Mock with SRM since Pyth doesn't have USDC yet\n        Pubkey::from_str(SRM_PYTH_PRODUCT).unwrap(),\n        Pubkey::from_str(SRM_PYTH_PRICE).unwrap(),\n        // Set USDC price to $1\n        Decimal::from(1u64),\n    )\n}",
    "pub fn new(size: usize, program_id: Pubkey) -> Self {\n        Self {\n            key: Pubkey::new_unique(),\n            lamports: 0,\n            data: vec![0; size],\n            program_id,\n            is_signer: false,\n        }\n    }\n\n    pub fn new_from_account_info(account_info: &AccountInfo) -> Self {\n        Self {\n            key: *account_info.key,\n            lamports: **account_info.lamports.borrow(),\n            data: account_info.data.borrow().to_vec(),\n            program_id: *account_info.owner,\n            is_signer: account_info.is_signer,\n        }\n    }\n\n    pub fn as_account_info(&mut self) -> AccountInfo {\n        AccountInfo::new(\n            &self.key,\n            self.is_signer,\n            false,\n            &mut self.lamports,\n            &mut self.data[..],\n            &self.program_id,\n            false,\n            Epoch::default(),\n        )\n    }",
    "pub fn do_process_instruction(instruction: Instruction, accounts: &[AccountInfo]) -> ProgramResult {\n    test_syscall_stubs();\n\n    // approximate the logic in the actual runtime which runs the instruction\n    // and only updates accounts if the instruction is successful\n    let mut account_data = accounts\n        .iter()\n        .map(NativeAccountData::new_from_account_info)\n        .collect::<Vec<_>>();\n    let account_infos = account_data\n        .iter_mut()\n        .map(NativeAccountData::as_account_info)\n        .collect::<Vec<_>>();\n    let res = if instruction.program_id == spl_token_swap::id() {\n        spl_token_swap::processor::Processor::process(\n            &instruction.program_id,\n            &account_infos,\n            &instruction.data,\n        )\n    }",
    "pub fn create_mint(owner: &Pubkey) -> NativeAccountData {\n    let mut account_data = NativeAccountData::new(Mint::LEN, spl_token::id());\n    let mint = Mint {\n        is_initialized: true,\n        mint_authority: COption::Some(*owner),\n        ..Default::default()\n    }",
    "pub fn create_token_account(\n    mint_account: &mut NativeAccountData,\n    owner: &Pubkey,\n    amount: u64,\n) -> NativeAccountData {\n    let mut mint = Mint::unpack(&mint_account.data).unwrap();\n    let mut account_data = NativeAccountData::new(TokenAccount::LEN, spl_token::id());\n    let account = TokenAccount {\n        state: TokenAccountState::Initialized,\n        mint: mint_account.key,\n        owner: *owner,\n        amount,\n        ..Default::default()\n    }",
    "pub fn create_program_account(program_id: Pubkey) -> NativeAccountData {\n    let mut account_data = NativeAccountData::new(0, bpf_loader::id());\n    account_data.key = program_id;\n    account_data\n}\n\nimpl NativeTokenSwap {\n    pub fn new(\n        fees: Fees,\n        swap_curve: SwapCurve,\n        token_a_amount: u64,\n        token_b_amount: u64,\n    ) -> Self {\n        let mut user_account = NativeAccountData::new(0, system_program::id());\n        user_account.is_signer = true;\n        let mut swap_account =\n            NativeAccountData::new(SwapVersion::LATEST_LEN, spl_token_swap::id());\n        let (authority_key, bump_seed) = Pubkey::find_program_address(\n            &[&swap_account.key.to_bytes()[..]],\n            &spl_token_swap::id(),\n        );\n        let mut authority_account = create_program_account(authority_key);\n        let mut pool_token_program_account = create_program_account(spl_token::id());\n        let token_a_program_account = create_program_account(spl_token::id());\n        let token_b_program_account = create_program_account(spl_token::id());\n\n        let mut pool_mint_account = native_token::create_mint(&authority_account.key);\n        let mut pool_token_account =\n            native_token::create_token_account(&mut pool_mint_account, &user_account.key, 0);\n        let mut pool_fee_account =\n            native_token::create_token_account(&mut pool_mint_account, &user_account.key, 0);\n        let mut token_a_mint_account = native_token::create_mint(&user_account.key);\n        let mut token_a_account = native_token::create_token_account(\n            &mut token_a_mint_account,\n            &authority_account.key,\n            token_a_amount,\n        );\n        let mut token_b_mint_account = native_token::create_mint(&user_account.key);\n        let mut token_b_account = native_token::create_token_account(\n            &mut token_b_mint_account,\n            &authority_account.key,\n            token_b_amount,\n        );\n\n        let init_instruction = instruction::initialize(\n            &spl_token_swap::id(),\n            &spl_token::id(),\n            &swap_account.key,\n            &authority_account.key,\n            &token_a_account.key,\n            &token_b_account.key,\n            &pool_mint_account.key,\n            &pool_fee_account.key,\n            &pool_token_account.key,\n            fees.clone(),\n            swap_curve.clone(),\n        )\n        .unwrap();\n\n        do_process_instruction(\n            init_instruction,\n            &[\n                swap_account.as_account_info(),\n                authority_account.as_account_info(),\n                token_a_account.as_account_info(),\n                token_b_account.as_account_info(),\n                pool_mint_account.as_account_info(),\n                pool_fee_account.as_account_info(),\n                pool_token_account.as_account_info(),\n                pool_token_program_account.as_account_info(),\n            ],\n        )\n        .unwrap();\n\n        Self {\n            user_account,\n            bump_seed,\n            authority_account,\n            fees,\n            swap_curve,\n            swap_account,\n            pool_mint_account,\n            pool_fee_account,\n            pool_token_account,\n            token_a_account,\n            token_a_mint_account,\n            token_b_account,\n            token_b_mint_account,\n            pool_token_program_account,\n            token_a_program_account,\n            token_b_program_account,\n        }\n    }\n\n    pub fn create_pool_account(&mut self) -> NativeAccountData {\n        native_token::create_token_account(&mut self.pool_mint_account, &self.user_account.key, 0)\n    }",
    "pub fn create_token_a_account(&mut self, amount: u64) -> NativeAccountData {\n        native_token::create_token_account(\n            &mut self.token_a_mint_account,\n            &self.user_account.key,\n            amount,\n        )\n    }",
    "pub fn create_token_b_account(&mut self, amount: u64) -> NativeAccountData {\n        native_token::create_token_account(\n            &mut self.token_b_mint_account,\n            &self.user_account.key,\n            amount,\n        )\n    }",
    "pub fn swap_a_to_b(\n        &mut self,\n        token_a_account: &mut NativeAccountData,\n        token_b_account: &mut NativeAccountData,\n        instruction: Swap,\n    ) -> ProgramResult {\n        let mut user_transfer_account = NativeAccountData::new(0, system_program::id());\n        user_transfer_account.is_signer = true;\n        do_process_instruction(\n            approve(\n                &self.token_a_program_account.key,\n                &token_a_account.key,\n                &user_transfer_account.key,\n                &self.user_account.key,\n                &[],\n                instruction.amount_in,\n            )\n            .unwrap(),\n            &[\n                token_a_account.as_account_info(),\n                user_transfer_account.as_account_info(),\n                self.user_account.as_account_info(),\n            ],\n        )\n        .unwrap();\n        let swap_instruction = instruction::swap(\n            &spl_token_swap::id(),\n            &spl_token::id(),\n            &spl_token::id(),\n            &spl_token::id(),\n            &self.swap_account.key,\n            &self.authority_account.key,\n            &user_transfer_account.key,\n            &token_a_account.key,\n            &self.token_a_account.key,\n            &self.token_b_account.key,\n            &token_b_account.key,\n            &self.pool_mint_account.key,\n            &self.pool_fee_account.key,\n            &self.token_a_mint_account.key,\n            &self.token_b_mint_account.key,\n            Some(&self.pool_token_account.key),\n            instruction,\n        )\n        .unwrap();\n\n        do_process_instruction(\n            swap_instruction,\n            &[\n                self.swap_account.as_account_info(),\n                self.authority_account.as_account_info(),\n                user_transfer_account.as_account_info(),\n                token_a_account.as_account_info(),\n                self.token_a_account.as_account_info(),\n                self.token_b_account.as_account_info(),\n                token_b_account.as_account_info(),\n                self.pool_mint_account.as_account_info(),\n                self.pool_fee_account.as_account_info(),\n                self.token_a_mint_account.as_account_info(),\n                self.token_b_mint_account.as_account_info(),\n                self.token_a_program_account.as_account_info(),\n                self.token_b_program_account.as_account_info(),\n                self.pool_token_program_account.as_account_info(),\n                self.pool_token_account.as_account_info(),\n            ],\n        )\n    }",
    "pub fn swap_b_to_a(\n        &mut self,\n        token_b_account: &mut NativeAccountData,\n        token_a_account: &mut NativeAccountData,\n        instruction: Swap,\n    ) -> ProgramResult {\n        let mut user_transfer_account = NativeAccountData::new(0, system_program::id());\n        user_transfer_account.is_signer = true;\n        do_process_instruction(\n            approve(\n                &self.token_b_program_account.key,\n                &token_b_account.key,\n                &user_transfer_account.key,\n                &self.user_account.key,\n                &[],\n                instruction.amount_in,\n            )\n            .unwrap(),\n            &[\n                token_b_account.as_account_info(),\n                user_transfer_account.as_account_info(),\n                self.user_account.as_account_info(),\n            ],\n        )\n        .unwrap();\n\n        let swap_instruction = instruction::swap(\n            &spl_token_swap::id(),\n            &spl_token::id(),\n            &spl_token::id(),\n            &spl_token::id(),\n            &self.swap_account.key,\n            &self.authority_account.key,\n            &user_transfer_account.key,\n            &token_b_account.key,\n            &self.token_b_account.key,\n            &self.token_a_account.key,\n            &token_a_account.key,\n            &self.pool_mint_account.key,\n            &self.pool_fee_account.key,\n            &self.token_b_mint_account.key,\n            &self.token_a_mint_account.key,\n            Some(&self.pool_token_account.key),\n            instruction,\n        )\n        .unwrap();\n\n        do_process_instruction(\n            swap_instruction,\n            &[\n                self.swap_account.as_account_info(),\n                self.authority_account.as_account_info(),\n                user_transfer_account.as_account_info(),\n                token_b_account.as_account_info(),\n                self.token_b_account.as_account_info(),\n                self.token_a_account.as_account_info(),\n                token_a_account.as_account_info(),\n                self.pool_mint_account.as_account_info(),\n                self.pool_fee_account.as_account_info(),\n                self.token_b_mint_account.as_account_info(),\n                self.token_a_mint_account.as_account_info(),\n                self.token_b_program_account.as_account_info(),\n                self.token_a_program_account.as_account_info(),\n                self.pool_token_program_account.as_account_info(),\n                self.pool_token_account.as_account_info(),\n            ],\n        )\n    }",
    "pub fn deposit_all_token_types(\n        &mut self,\n        token_a_account: &mut NativeAccountData,\n        token_b_account: &mut NativeAccountData,\n        pool_account: &mut NativeAccountData,\n        mut instruction: DepositAllTokenTypes,\n    ) -> ProgramResult {\n        let mut user_transfer_account = NativeAccountData::new(0, system_program::id());\n        user_transfer_account.is_signer = true;\n        do_process_instruction(\n            approve(\n                &self.token_a_program_account.key,\n                &token_a_account.key,\n                &user_transfer_account.key,\n                &self.user_account.key,\n                &[],\n                instruction.maximum_token_a_amount,\n            )\n            .unwrap(),\n            &[\n                token_a_account.as_account_info(),\n                user_transfer_account.as_account_info(),\n                self.user_account.as_account_info(),\n            ],\n        )\n        .unwrap();\n\n        do_process_instruction(\n            approve(\n                &self.token_b_program_account.key,\n                &token_b_account.key,\n                &user_transfer_account.key,\n                &self.user_account.key,\n                &[],\n                instruction.maximum_token_b_amount,\n            )\n            .unwrap(),\n            &[\n                token_b_account.as_account_info(),\n                user_transfer_account.as_account_info(),\n                self.user_account.as_account_info(),\n            ],\n        )\n        .unwrap();\n\n        // special logic: if we only deposit 1 pool token, we can't withdraw it\n        // because we incur a withdrawal fee, so we hack it to not be 1\n        if instruction.pool_token_amount == 1 {\n            instruction.pool_token_amount = 2;\n        }\n\n        let deposit_instruction = instruction::deposit_all_token_types(\n            &spl_token_swap::id(),\n            &spl_token::id(),\n            &spl_token::id(),\n            &spl_token::id(),\n            &self.swap_account.key,\n            &self.authority_account.key,\n            &user_transfer_account.key,\n            &token_a_account.key,\n            &token_b_account.key,\n            &self.token_a_account.key,\n            &self.token_b_account.key,\n            &self.pool_mint_account.key,\n            &pool_account.key,\n            &self.token_a_mint_account.key,\n            &self.token_b_mint_account.key,\n            instruction,\n        )\n        .unwrap();\n\n        do_process_instruction(\n            deposit_instruction,\n            &[\n                self.swap_account.as_account_info(),\n                self.authority_account.as_account_info(),\n                user_transfer_account.as_account_info(),\n                token_a_account.as_account_info(),\n                token_b_account.as_account_info(),\n                self.token_a_account.as_account_info(),\n                self.token_b_account.as_account_info(),\n                self.pool_mint_account.as_account_info(),\n                pool_account.as_account_info(),\n                self.token_a_mint_account.as_account_info(),\n                self.token_b_mint_account.as_account_info(),\n                self.token_a_program_account.as_account_info(),\n                self.token_b_program_account.as_account_info(),\n                self.pool_token_program_account.as_account_info(),\n            ],\n        )\n    }",
    "pub fn withdraw_all_token_types(\n        &mut self,\n        pool_account: &mut NativeAccountData,\n        token_a_account: &mut NativeAccountData,\n        token_b_account: &mut NativeAccountData,\n        mut instruction: WithdrawAllTokenTypes,\n    ) -> ProgramResult {\n        let mut user_transfer_account = NativeAccountData::new(0, system_program::id());\n        user_transfer_account.is_signer = true;\n        let pool_token_amount = native_token::get_token_balance(pool_account);\n        // special logic to avoid withdrawing down to 1 pool token, which\n        // eventually causes an error on withdrawing all\n        if pool_token_amount.saturating_sub(instruction.pool_token_amount) == 1 {\n            instruction.pool_token_amount = pool_token_amount;\n        }\n        do_process_instruction(\n            approve(\n                &self.pool_token_program_account.key,\n                &pool_account.key,\n                &user_transfer_account.key,\n                &self.user_account.key,\n                &[],\n                instruction.pool_token_amount,\n            )\n            .unwrap(),\n            &[\n                pool_account.as_account_info(),\n                user_transfer_account.as_account_info(),\n                self.user_account.as_account_info(),\n            ],\n        )\n        .unwrap();\n\n        let withdraw_instruction = instruction::withdraw_all_token_types(\n            &spl_token_swap::id(),\n            &spl_token::id(),\n            &spl_token::id(),\n            &spl_token::id(),\n            &self.swap_account.key,\n            &self.authority_account.key,\n            &user_transfer_account.key,\n            &self.pool_mint_account.key,\n            &self.pool_fee_account.key,\n            &pool_account.key,\n            &self.token_a_account.key,\n            &self.token_b_account.key,\n            &token_a_account.key,\n            &token_b_account.key,\n            &self.token_a_mint_account.key,\n            &self.token_b_mint_account.key,\n            instruction,\n        )\n        .unwrap();\n\n        do_process_instruction(\n            withdraw_instruction,\n            &[\n                self.swap_account.as_account_info(),\n                self.authority_account.as_account_info(),\n                user_transfer_account.as_account_info(),\n                self.pool_mint_account.as_account_info(),\n                pool_account.as_account_info(),\n                self.token_a_account.as_account_info(),\n                self.token_b_account.as_account_info(),\n                token_a_account.as_account_info(),\n                token_b_account.as_account_info(),\n                self.pool_fee_account.as_account_info(),\n                self.token_a_mint_account.as_account_info(),\n                self.token_b_mint_account.as_account_info(),\n                self.pool_token_program_account.as_account_info(),\n                self.token_a_program_account.as_account_info(),\n                self.token_b_program_account.as_account_info(),\n            ],\n        )\n    }",
    "pub fn deposit_single_token_type_exact_amount_in(\n        &mut self,\n        source_token_account: &mut NativeAccountData,\n        trade_direction: TradeDirection,\n        pool_account: &mut NativeAccountData,\n        mut instruction: DepositSingleTokenTypeExactAmountIn,\n    ) -> ProgramResult {\n        let mut user_transfer_account = NativeAccountData::new(0, system_program::id());\n        user_transfer_account.is_signer = true;\n        let source_token_program = match trade_direction {\n            TradeDirection::AtoB => &mut self.token_a_program_account,\n            TradeDirection::BtoA => &mut self.token_b_program_account,\n        };\n        do_process_instruction(\n            approve(\n                &source_token_program.key,\n                &source_token_account.key,\n                &user_transfer_account.key,\n                &self.user_account.key,\n                &[],\n                instruction.source_token_amount,\n            )\n            .unwrap(),\n            &[\n                source_token_account.as_account_info(),\n                user_transfer_account.as_account_info(),\n                self.user_account.as_account_info(),\n            ],\n        )\n        .unwrap();\n\n        // special logic: if we only deposit 1 pool token, we can't withdraw it\n        // because we incur a withdrawal fee, so we hack it to not be 1\n        if instruction.minimum_pool_token_amount < 2 {\n            instruction.minimum_pool_token_amount = 2;\n        }\n\n        let source_token_mint_account = match trade_direction {\n            TradeDirection::AtoB => &mut self.token_a_mint_account,\n            TradeDirection::BtoA => &mut self.token_b_mint_account,\n        };\n\n        let deposit_instruction = instruction::deposit_single_token_type_exact_amount_in(\n            &spl_token_swap::id(),\n            &spl_token::id(),\n            &spl_token::id(),\n            &self.swap_account.key,\n            &self.authority_account.key,\n            &user_transfer_account.key,\n            &source_token_account.key,\n            &self.token_a_account.key,\n            &self.token_b_account.key,\n            &self.pool_mint_account.key,\n            &pool_account.key,\n            &source_token_mint_account.key,\n            instruction,\n        )\n        .unwrap();\n\n        do_process_instruction(\n            deposit_instruction,\n            &[\n                self.swap_account.as_account_info(),\n                self.authority_account.as_account_info(),\n                user_transfer_account.as_account_info(),\n                source_token_account.as_account_info(),\n                self.token_a_account.as_account_info(),\n                self.token_b_account.as_account_info(),\n                self.pool_mint_account.as_account_info(),\n                pool_account.as_account_info(),\n                source_token_mint_account.as_account_info(),\n                self.token_a_program_account.as_account_info(),\n                self.pool_token_program_account.as_account_info(),\n            ],\n        )\n    }",
    "pub fn withdraw_single_token_type_exact_amount_out(\n        &mut self,\n        pool_account: &mut NativeAccountData,\n        trade_direction: TradeDirection,\n        destination_token_account: &mut NativeAccountData,\n        mut instruction: WithdrawSingleTokenTypeExactAmountOut,\n    ) -> ProgramResult {\n        let mut user_transfer_account = NativeAccountData::new(0, system_program::id());\n        user_transfer_account.is_signer = true;\n        let pool_token_amount = native_token::get_token_balance(pool_account);\n        // special logic to avoid withdrawing down to 1 pool token, which\n        // eventually causes an error on withdrawing all\n        if pool_token_amount.saturating_sub(instruction.maximum_pool_token_amount) == 1 {\n            instruction.maximum_pool_token_amount = pool_token_amount;\n        }\n        do_process_instruction(\n            approve(\n                &self.pool_token_program_account.key,\n                &pool_account.key,\n                &user_transfer_account.key,\n                &self.user_account.key,\n                &[],\n                instruction.maximum_pool_token_amount,\n            )\n            .unwrap(),\n            &[\n                pool_account.as_account_info(),\n                user_transfer_account.as_account_info(),\n                self.user_account.as_account_info(),\n            ],\n        )\n        .unwrap();\n\n        let destination_token_program = match trade_direction {\n            TradeDirection::AtoB => &mut self.token_a_program_account,\n            TradeDirection::BtoA => &mut self.token_b_program_account,\n        };\n        let destination_token_mint_account = match trade_direction {\n            TradeDirection::AtoB => &mut self.token_a_mint_account,\n            TradeDirection::BtoA => &mut self.token_b_mint_account,\n        };\n        let withdraw_instruction = instruction::withdraw_single_token_type_exact_amount_out(\n            &spl_token_swap::id(),\n            &spl_token::id(),\n            &spl_token::id(),\n            &self.swap_account.key,\n            &self.authority_account.key,\n            &user_transfer_account.key,\n            &self.pool_mint_account.key,\n            &self.pool_fee_account.key,\n            &pool_account.key,\n            &self.token_a_account.key,\n            &self.token_b_account.key,\n            &destination_token_account.key,\n            &destination_token_mint_account.key,\n            instruction,\n        )\n        .unwrap();\n\n        do_process_instruction(\n            withdraw_instruction,\n            &[\n                self.swap_account.as_account_info(),\n                self.authority_account.as_account_info(),\n                user_transfer_account.as_account_info(),\n                self.pool_mint_account.as_account_info(),\n                pool_account.as_account_info(),\n                self.token_a_account.as_account_info(),\n                self.token_b_account.as_account_info(),\n                destination_token_account.as_account_info(),\n                self.pool_fee_account.as_account_info(),\n                destination_token_mint_account.as_account_info(),\n                self.pool_token_program_account.as_account_info(),\n                destination_token_program.as_account_info(),\n            ],\n        )\n    }",
    "pub fn withdraw_all(\n        &mut self,\n        pool_account: &mut NativeAccountData,\n        token_a_account: &mut NativeAccountData,\n        token_b_account: &mut NativeAccountData,\n    ) -> ProgramResult {\n        let pool_token_amount = native_token::get_token_balance(pool_account);\n        if pool_token_amount > 0 {\n            let instruction = WithdrawAllTokenTypes {\n                pool_token_amount,\n                minimum_token_a_amount: 0,\n                minimum_token_b_amount: 0,\n            };\n            self.withdraw_all_token_types(\n                pool_account,\n                token_a_account,\n                token_b_account,\n                instruction,\n            )\n        }",
    "pub fn validate_curve(&self, swap_curve: &SwapCurve) -> Result<(), ProgramError> {\n        if self\n            .valid_curve_types\n            .iter()\n            .any(|x| *x == swap_curve.curve_type)\n        {\n            Ok(())\n        }",
    "pub fn validate_fees(&self, fees: &Fees) -> Result<(), ProgramError> {\n        if fees.trade_fee_numerator >= self.fees.trade_fee_numerator\n            && fees.trade_fee_denominator == self.fees.trade_fee_denominator\n            && fees.owner_trade_fee_numerator >= self.fees.owner_trade_fee_numerator\n            && fees.owner_trade_fee_denominator == self.fees.owner_trade_fee_denominator\n            && fees.owner_withdraw_fee_numerator >= self.fees.owner_withdraw_fee_numerator\n            && fees.owner_withdraw_fee_denominator == self.fees.owner_withdraw_fee_denominator\n            && fees.host_fee_numerator == self.fees.host_fee_numerator\n            && fees.host_fee_denominator == self.fees.host_fee_denominator\n        {\n            Ok(())\n        }",
    "pub fn unpack(input: &[u8]) -> Result<Self, ProgramError> {\n        let (&tag, rest) = input.split_first().ok_or(SwapError::InvalidInstruction)?;\n        Ok(match tag {\n            0 => {\n                if rest.len() >= Fees::LEN {\n                    let (fees, rest) = rest.split_at(Fees::LEN);\n                    let fees = Fees::unpack_unchecked(fees)?;\n                    let swap_curve = SwapCurve::unpack_unchecked(rest)?;\n                    Self::Initialize(Initialize { fees, swap_curve })\n                }",
    "pub fn pack(&self) -> Vec<u8> {\n        let mut buf = Vec::with_capacity(size_of::<Self>());\n        match self {\n            Self::Initialize(Initialize { fees, swap_curve }) => {\n                buf.push(0);\n                let mut fees_slice = [0u8; Fees::LEN];\n                Pack::pack_into_slice(fees, &mut fees_slice[..]);\n                buf.extend_from_slice(&fees_slice);\n                let mut swap_curve_slice = [0u8; SwapCurve::LEN];\n                Pack::pack_into_slice(swap_curve, &mut swap_curve_slice[..]);\n                buf.extend_from_slice(&swap_curve_slice);\n            }\n            Self::Swap(Swap {\n                amount_in,\n                minimum_amount_out,\n            }) => {\n                buf.push(1);\n                buf.extend_from_slice(&amount_in.to_le_bytes());\n                buf.extend_from_slice(&minimum_amount_out.to_le_bytes());\n            }\n            Self::DepositAllTokenTypes(DepositAllTokenTypes {\n                pool_token_amount,\n                maximum_token_a_amount,\n                maximum_token_b_amount,\n            }) => {\n                buf.push(2);\n                buf.extend_from_slice(&pool_token_amount.to_le_bytes());\n                buf.extend_from_slice(&maximum_token_a_amount.to_le_bytes());\n                buf.extend_from_slice(&maximum_token_b_amount.to_le_bytes());\n            }\n            Self::WithdrawAllTokenTypes(WithdrawAllTokenTypes {\n                pool_token_amount,\n                minimum_token_a_amount,\n                minimum_token_b_amount,\n            }) => {\n                buf.push(3);\n                buf.extend_from_slice(&pool_token_amount.to_le_bytes());\n                buf.extend_from_slice(&minimum_token_a_amount.to_le_bytes());\n                buf.extend_from_slice(&minimum_token_b_amount.to_le_bytes());\n            }\n            Self::DepositSingleTokenTypeExactAmountIn(DepositSingleTokenTypeExactAmountIn {\n                source_token_amount,\n                minimum_pool_token_amount,\n            }) => {\n                buf.push(4);\n                buf.extend_from_slice(&source_token_amount.to_le_bytes());\n                buf.extend_from_slice(&minimum_pool_token_amount.to_le_bytes());\n            }\n            Self::WithdrawSingleTokenTypeExactAmountOut(\n                WithdrawSingleTokenTypeExactAmountOut {\n                    destination_token_amount,\n                    maximum_pool_token_amount,\n                },\n            ) => {\n                buf.push(5);\n                buf.extend_from_slice(&destination_token_amount.to_le_bytes());\n                buf.extend_from_slice(&maximum_pool_token_amount.to_le_bytes());\n            }\n        }\n        buf\n    }\n}\n\n/// Creates an 'initialize' instruction.\npub fn initialize(\n    program_id: &Pubkey,\n    token_program_id: &Pubkey,\n    swap_pubkey: &Pubkey,\n    authority_pubkey: &Pubkey,\n    token_a_pubkey: &Pubkey,\n    token_b_pubkey: &Pubkey,\n    pool_pubkey: &Pubkey,\n    fee_pubkey: &Pubkey,\n    destination_pubkey: &Pubkey,\n    fees: Fees,\n    swap_curve: SwapCurve,\n) -> Result<Instruction, ProgramError> {\n    let init_data = SwapInstruction::Initialize(Initialize { fees, swap_curve });\n    let data = init_data.pack();\n\n    let accounts = vec![\n        AccountMeta::new(*swap_pubkey, true),\n        AccountMeta::new_readonly(*authority_pubkey, false),\n        AccountMeta::new_readonly(*token_a_pubkey, false),\n        AccountMeta::new_readonly(*token_b_pubkey, false),\n        AccountMeta::new(*pool_pubkey, false),\n        AccountMeta::new_readonly(*fee_pubkey, false),\n        AccountMeta::new(*destination_pubkey, false),\n        AccountMeta::new_readonly(*token_program_id, false),\n    ];\n\n    Ok(Instruction {\n        program_id: *program_id,\n        accounts,\n        data,\n    })\n}",
    "pub fn deposit_all_token_types(\n    program_id: &Pubkey,\n    token_a_program_id: &Pubkey,\n    token_b_program_id: &Pubkey,\n    pool_token_program_id: &Pubkey,\n    swap_pubkey: &Pubkey,\n    authority_pubkey: &Pubkey,\n    user_transfer_authority_pubkey: &Pubkey,\n    deposit_token_a_pubkey: &Pubkey,\n    deposit_token_b_pubkey: &Pubkey,\n    swap_token_a_pubkey: &Pubkey,\n    swap_token_b_pubkey: &Pubkey,\n    pool_mint_pubkey: &Pubkey,\n    destination_pubkey: &Pubkey,\n    token_a_mint_pubkey: &Pubkey,\n    token_b_mint_pubkey: &Pubkey,\n    instruction: DepositAllTokenTypes,\n) -> Result<Instruction, ProgramError> {\n    let data = SwapInstruction::DepositAllTokenTypes(instruction).pack();\n\n    let accounts = vec![\n        AccountMeta::new_readonly(*swap_pubkey, false),\n        AccountMeta::new_readonly(*authority_pubkey, false),\n        AccountMeta::new_readonly(*user_transfer_authority_pubkey, true),\n        AccountMeta::new(*deposit_token_a_pubkey, false),\n        AccountMeta::new(*deposit_token_b_pubkey, false),\n        AccountMeta::new(*swap_token_a_pubkey, false),\n        AccountMeta::new(*swap_token_b_pubkey, false),\n        AccountMeta::new(*pool_mint_pubkey, false),\n        AccountMeta::new(*destination_pubkey, false),\n        AccountMeta::new_readonly(*token_a_mint_pubkey, false),\n        AccountMeta::new_readonly(*token_b_mint_pubkey, false),\n        AccountMeta::new_readonly(*token_a_program_id, false),\n        AccountMeta::new_readonly(*token_b_program_id, false),\n        AccountMeta::new_readonly(*pool_token_program_id, false),\n    ];\n\n    Ok(Instruction {\n        program_id: *program_id,\n        accounts,\n        data,\n    })\n}",
    "pub fn withdraw_all_token_types(\n    program_id: &Pubkey,\n    pool_token_program_id: &Pubkey,\n    token_a_program_id: &Pubkey,\n    token_b_program_id: &Pubkey,\n    swap_pubkey: &Pubkey,\n    authority_pubkey: &Pubkey,\n    user_transfer_authority_pubkey: &Pubkey,\n    pool_mint_pubkey: &Pubkey,\n    fee_account_pubkey: &Pubkey,\n    source_pubkey: &Pubkey,\n    swap_token_a_pubkey: &Pubkey,\n    swap_token_b_pubkey: &Pubkey,\n    destination_token_a_pubkey: &Pubkey,\n    destination_token_b_pubkey: &Pubkey,\n    token_a_mint_pubkey: &Pubkey,\n    token_b_mint_pubkey: &Pubkey,\n    instruction: WithdrawAllTokenTypes,\n) -> Result<Instruction, ProgramError> {\n    let data = SwapInstruction::WithdrawAllTokenTypes(instruction).pack();\n\n    let accounts = vec![\n        AccountMeta::new_readonly(*swap_pubkey, false),\n        AccountMeta::new_readonly(*authority_pubkey, false),\n        AccountMeta::new_readonly(*user_transfer_authority_pubkey, true),\n        AccountMeta::new(*pool_mint_pubkey, false),\n        AccountMeta::new(*source_pubkey, false),\n        AccountMeta::new(*swap_token_a_pubkey, false),\n        AccountMeta::new(*swap_token_b_pubkey, false),\n        AccountMeta::new(*destination_token_a_pubkey, false),\n        AccountMeta::new(*destination_token_b_pubkey, false),\n        AccountMeta::new(*fee_account_pubkey, false),\n        AccountMeta::new_readonly(*token_a_mint_pubkey, false),\n        AccountMeta::new_readonly(*token_b_mint_pubkey, false),\n        AccountMeta::new_readonly(*pool_token_program_id, false),\n        AccountMeta::new_readonly(*token_a_program_id, false),\n        AccountMeta::new_readonly(*token_b_program_id, false),\n    ];\n\n    Ok(Instruction {\n        program_id: *program_id,\n        accounts,\n        data,\n    })\n}",
    "pub fn deposit_single_token_type_exact_amount_in(\n    program_id: &Pubkey,\n    source_token_program_id: &Pubkey,\n    pool_token_program_id: &Pubkey,\n    swap_pubkey: &Pubkey,\n    authority_pubkey: &Pubkey,\n    user_transfer_authority_pubkey: &Pubkey,\n    source_token_pubkey: &Pubkey,\n    swap_token_a_pubkey: &Pubkey,\n    swap_token_b_pubkey: &Pubkey,\n    pool_mint_pubkey: &Pubkey,\n    destination_pubkey: &Pubkey,\n    source_mint_pubkey: &Pubkey,\n    instruction: DepositSingleTokenTypeExactAmountIn,\n) -> Result<Instruction, ProgramError> {\n    let data = SwapInstruction::DepositSingleTokenTypeExactAmountIn(instruction).pack();\n\n    let accounts = vec![\n        AccountMeta::new_readonly(*swap_pubkey, false),\n        AccountMeta::new_readonly(*authority_pubkey, false),\n        AccountMeta::new_readonly(*user_transfer_authority_pubkey, true),\n        AccountMeta::new(*source_token_pubkey, false),\n        AccountMeta::new(*swap_token_a_pubkey, false),\n        AccountMeta::new(*swap_token_b_pubkey, false),\n        AccountMeta::new(*pool_mint_pubkey, false),\n        AccountMeta::new(*destination_pubkey, false),\n        AccountMeta::new_readonly(*source_mint_pubkey, false),\n        AccountMeta::new_readonly(*source_token_program_id, false),\n        AccountMeta::new_readonly(*pool_token_program_id, false),\n    ];\n\n    Ok(Instruction {\n        program_id: *program_id,\n        accounts,\n        data,\n    })\n}",
    "pub fn withdraw_single_token_type_exact_amount_out(\n    program_id: &Pubkey,\n    pool_token_program_id: &Pubkey,\n    destination_token_program_id: &Pubkey,\n    swap_pubkey: &Pubkey,\n    authority_pubkey: &Pubkey,\n    user_transfer_authority_pubkey: &Pubkey,\n    pool_mint_pubkey: &Pubkey,\n    fee_account_pubkey: &Pubkey,\n    pool_token_source_pubkey: &Pubkey,\n    swap_token_a_pubkey: &Pubkey,\n    swap_token_b_pubkey: &Pubkey,\n    destination_pubkey: &Pubkey,\n    destination_mint_pubkey: &Pubkey,\n    instruction: WithdrawSingleTokenTypeExactAmountOut,\n) -> Result<Instruction, ProgramError> {\n    let data = SwapInstruction::WithdrawSingleTokenTypeExactAmountOut(instruction).pack();\n\n    let accounts = vec![\n        AccountMeta::new_readonly(*swap_pubkey, false),\n        AccountMeta::new_readonly(*authority_pubkey, false),\n        AccountMeta::new_readonly(*user_transfer_authority_pubkey, true),\n        AccountMeta::new(*pool_mint_pubkey, false),\n        AccountMeta::new(*pool_token_source_pubkey, false),\n        AccountMeta::new(*swap_token_a_pubkey, false),\n        AccountMeta::new(*swap_token_b_pubkey, false),\n        AccountMeta::new(*destination_pubkey, false),\n        AccountMeta::new(*fee_account_pubkey, false),\n        AccountMeta::new_readonly(*destination_mint_pubkey, false),\n        AccountMeta::new_readonly(*pool_token_program_id, false),\n        AccountMeta::new_readonly(*destination_token_program_id, false),\n    ];\n\n    Ok(Instruction {\n        program_id: *program_id,\n        accounts,\n        data,\n    })\n}",
    "pub fn swap(\n    program_id: &Pubkey,\n    source_token_program_id: &Pubkey,\n    destination_token_program_id: &Pubkey,\n    pool_token_program_id: &Pubkey,\n    swap_pubkey: &Pubkey,\n    authority_pubkey: &Pubkey,\n    user_transfer_authority_pubkey: &Pubkey,\n    source_pubkey: &Pubkey,\n    swap_source_pubkey: &Pubkey,\n    swap_destination_pubkey: &Pubkey,\n    destination_pubkey: &Pubkey,\n    pool_mint_pubkey: &Pubkey,\n    pool_fee_pubkey: &Pubkey,\n    source_mint_pubkey: &Pubkey,\n    destination_mint_pubkey: &Pubkey,\n    host_fee_pubkey: Option<&Pubkey>,\n    instruction: Swap,\n) -> Result<Instruction, ProgramError> {\n    let data = SwapInstruction::Swap(instruction).pack();\n\n    let mut accounts = vec![\n        AccountMeta::new_readonly(*swap_pubkey, false),\n        AccountMeta::new_readonly(*authority_pubkey, false),\n        AccountMeta::new_readonly(*user_transfer_authority_pubkey, true),\n        AccountMeta::new(*source_pubkey, false),\n        AccountMeta::new(*swap_source_pubkey, false),\n        AccountMeta::new(*swap_destination_pubkey, false),\n        AccountMeta::new(*destination_pubkey, false),\n        AccountMeta::new(*pool_mint_pubkey, false),\n        AccountMeta::new(*pool_fee_pubkey, false),\n        AccountMeta::new_readonly(*source_mint_pubkey, false),\n        AccountMeta::new_readonly(*destination_mint_pubkey, false),\n        AccountMeta::new_readonly(*source_token_program_id, false),\n        AccountMeta::new_readonly(*destination_token_program_id, false),\n        AccountMeta::new_readonly(*pool_token_program_id, false),\n    ];\n    if let Some(host_fee_pubkey) = host_fee_pubkey {\n        accounts.push(AccountMeta::new(*host_fee_pubkey, false));\n    }\n\n    Ok(Instruction {\n        program_id: *program_id,\n        accounts,\n        data,\n    })\n}",
    "pub fn unpack_token_account(\n        account_info: &AccountInfo,\n        token_program_id: &Pubkey,\n    ) -> Result<Account, SwapError> {\n        if account_info.owner != token_program_id\n            && check_spl_token_program_account(account_info.owner).is_err()\n        {\n            Err(SwapError::IncorrectTokenProgramId)\n        }",
    "pub fn unpack_mint(\n        account_info: &AccountInfo,\n        token_program_id: &Pubkey,\n    ) -> Result<Mint, SwapError> {\n        if account_info.owner != token_program_id\n            && check_spl_token_program_account(account_info.owner).is_err()\n        {\n            Err(SwapError::IncorrectTokenProgramId)\n        }",
    "pub fn authority_id(\n        program_id: &Pubkey,\n        my_info: &Pubkey,\n        bump_seed: u8,\n    ) -> Result<Pubkey, SwapError> {\n        Pubkey::create_program_address(&[&my_info.to_bytes()[..32], &[bump_seed]], program_id)\n            .or(Err(SwapError::InvalidProgramAddress))\n    }",
    "pub fn process_initialize(\n        program_id: &Pubkey,\n        fees: Fees,\n        swap_curve: SwapCurve,\n        accounts: &[AccountInfo],\n        swap_constraints: &Option<SwapConstraints>,\n    ) -> ProgramResult {\n        let account_info_iter = &mut accounts.iter();\n        let swap_info = next_account_info(account_info_iter)?;\n        let authority_info = next_account_info(account_info_iter)?;\n        let token_a_info = next_account_info(account_info_iter)?;\n        let token_b_info = next_account_info(account_info_iter)?;\n        let pool_mint_info = next_account_info(account_info_iter)?;\n        let fee_account_info = next_account_info(account_info_iter)?;\n        let destination_info = next_account_info(account_info_iter)?;\n        let pool_token_program_info = next_account_info(account_info_iter)?;\n\n        let token_program_id = *pool_token_program_info.key;\n        if SwapVersion::is_initialized(&swap_info.data.borrow()) {\n            return Err(SwapError::AlreadyInUse.into());\n        }\n\n        let (swap_authority, bump_seed) =\n            Pubkey::find_program_address(&[&swap_info.key.to_bytes()], program_id);\n        if *authority_info.key != swap_authority {\n            return Err(SwapError::InvalidProgramAddress.into());\n        }\n        let token_a = Self::unpack_token_account(token_a_info, &token_program_id)?;\n        let token_b = Self::unpack_token_account(token_b_info, &token_program_id)?;\n        let fee_account = Self::unpack_token_account(fee_account_info, &token_program_id)?;\n        let destination = Self::unpack_token_account(destination_info, &token_program_id)?;\n        let pool_mint = {\n            let pool_mint_data = pool_mint_info.data.borrow();\n            let pool_mint = Self::unpack_mint_with_extensions(\n                &pool_mint_data,\n                pool_mint_info.owner,\n                &token_program_id,\n            )?;\n            if let Ok(extension) = pool_mint.get_extension::<MintCloseAuthority>() {\n                let close_authority: Option<Pubkey> = extension.close_authority.into();\n                if close_authority.is_some() {\n                    return Err(SwapError::InvalidCloseAuthority.into());\n                }\n            }\n            pool_mint.base\n        };\n        if *authority_info.key != token_a.owner {\n            return Err(SwapError::InvalidOwner.into());\n        }\n        if *authority_info.key != token_b.owner {\n            return Err(SwapError::InvalidOwner.into());\n        }\n        if *authority_info.key == destination.owner {\n            return Err(SwapError::InvalidOutputOwner.into());\n        }\n        if *authority_info.key == fee_account.owner {\n            return Err(SwapError::InvalidOutputOwner.into());\n        }\n        if COption::Some(*authority_info.key) != pool_mint.mint_authority {\n            return Err(SwapError::InvalidOwner.into());\n        }\n\n        if token_a.mint == token_b.mint {\n            return Err(SwapError::RepeatedMint.into());\n        }\n        swap_curve\n            .calculator\n            .validate_supply(token_a.amount, token_b.amount)?;\n        if token_a.delegate.is_some() {\n            return Err(SwapError::InvalidDelegate.into());\n        }\n        if token_b.delegate.is_some() {\n            return Err(SwapError::InvalidDelegate.into());\n        }\n        if token_a.close_authority.is_some() {\n            return Err(SwapError::InvalidCloseAuthority.into());\n        }\n        if token_b.close_authority.is_some() {\n            return Err(SwapError::InvalidCloseAuthority.into());\n        }\n\n        if pool_mint.supply != 0 {\n            return Err(SwapError::InvalidSupply.into());\n        }\n        if pool_mint.freeze_authority.is_some() {\n            return Err(SwapError::InvalidFreezeAuthority.into());\n        }\n        if *pool_mint_info.key != fee_account.mint {\n            return Err(SwapError::IncorrectPoolMint.into());\n        }\n\n        if let Some(swap_constraints) = swap_constraints {\n            let owner_key = swap_constraints\n                .owner_key\n                .unwrap()\n                .parse::<Pubkey>()\n                .map_err(|_| SwapError::InvalidOwner)?;\n            if fee_account.owner != owner_key {\n                return Err(SwapError::InvalidOwner.into());\n            }\n            swap_constraints.validate_curve(&swap_curve)?;\n            swap_constraints.validate_fees(&fees)?;\n        }\n        fees.validate()?;\n        swap_curve.calculator.validate()?;\n\n        let initial_amount = swap_curve.calculator.new_pool_supply();\n\n        Self::token_mint_to(\n            swap_info.key,\n            pool_token_program_info.clone(),\n            pool_mint_info.clone(),\n            destination_info.clone(),\n            authority_info.clone(),\n            bump_seed,\n            to_u64(initial_amount)?,\n        )?;\n\n        let obj = SwapVersion::SwapV1(SwapV1 {\n            is_initialized: true,\n            bump_seed,\n            token_program_id,\n            token_a: *token_a_info.key,\n            token_b: *token_b_info.key,\n            pool_mint: *pool_mint_info.key,\n            token_a_mint: token_a.mint,\n            token_b_mint: token_b.mint,\n            pool_fee_account: *fee_account_info.key,\n            fees,\n            swap_curve,\n        });\n        SwapVersion::pack(obj, &mut swap_info.data.borrow_mut())?;\n        Ok(())\n    }",
    "pub fn process_swap(\n        program_id: &Pubkey,\n        amount_in: u64,\n        minimum_amount_out: u64,\n        accounts: &[AccountInfo],\n    ) -> ProgramResult {\n        let account_info_iter = &mut accounts.iter();\n        let swap_info = next_account_info(account_info_iter)?;\n        let authority_info = next_account_info(account_info_iter)?;\n        let user_transfer_authority_info = next_account_info(account_info_iter)?;\n        let source_info = next_account_info(account_info_iter)?;\n        let swap_source_info = next_account_info(account_info_iter)?;\n        let swap_destination_info = next_account_info(account_info_iter)?;\n        let destination_info = next_account_info(account_info_iter)?;\n        let pool_mint_info = next_account_info(account_info_iter)?;\n        let pool_fee_account_info = next_account_info(account_info_iter)?;\n        let source_token_mint_info = next_account_info(account_info_iter)?;\n        let destination_token_mint_info = next_account_info(account_info_iter)?;\n        let source_token_program_info = next_account_info(account_info_iter)?;\n        let destination_token_program_info = next_account_info(account_info_iter)?;\n        let pool_token_program_info = next_account_info(account_info_iter)?;\n\n        if swap_info.owner != program_id {\n            return Err(ProgramError::IncorrectProgramId);\n        }\n        let token_swap = SwapVersion::unpack(&swap_info.data.borrow())?;\n\n        if *authority_info.key\n            != Self::authority_id(program_id, swap_info.key, token_swap.bump_seed())?\n        {\n            return Err(SwapError::InvalidProgramAddress.into());\n        }\n        if !(*swap_source_info.key == *token_swap.token_a_account()\n            || *swap_source_info.key == *token_swap.token_b_account())\n        {\n            return Err(SwapError::IncorrectSwapAccount.into());\n        }\n        if !(*swap_destination_info.key == *token_swap.token_a_account()\n            || *swap_destination_info.key == *token_swap.token_b_account())\n        {\n            return Err(SwapError::IncorrectSwapAccount.into());\n        }\n        if *swap_source_info.key == *swap_destination_info.key {\n            return Err(SwapError::InvalidInput.into());\n        }\n        if swap_source_info.key == source_info.key {\n            return Err(SwapError::InvalidInput.into());\n        }\n        if swap_destination_info.key == destination_info.key {\n            return Err(SwapError::InvalidInput.into());\n        }\n        if *pool_mint_info.key != *token_swap.pool_mint() {\n            return Err(SwapError::IncorrectPoolMint.into());\n        }\n        if *pool_fee_account_info.key != *token_swap.pool_fee_account() {\n            return Err(SwapError::IncorrectFeeAccount.into());\n        }\n        if *pool_token_program_info.key != *token_swap.token_program_id() {\n            return Err(SwapError::IncorrectTokenProgramId.into());\n        }\n\n        let source_account =\n            Self::unpack_token_account(swap_source_info, token_swap.token_program_id())?;\n        let dest_account =\n            Self::unpack_token_account(swap_destination_info, token_swap.token_program_id())?;\n        let pool_mint = Self::unpack_mint(pool_mint_info, token_swap.token_program_id())?;\n\n        // Take transfer fees into account for actual amount transferred in\n        let actual_amount_in = {\n            let source_mint_data = source_token_mint_info.data.borrow();\n            let source_mint = Self::unpack_mint_with_extensions(\n                &source_mint_data,\n                source_token_mint_info.owner,\n                token_swap.token_program_id(),\n            )?;\n\n            if let Ok(transfer_fee_config) = source_mint.get_extension::<TransferFeeConfig>() {\n                amount_in.saturating_sub(\n                    transfer_fee_config\n                        .calculate_epoch_fee(Clock::get()?.epoch, amount_in)\n                        .ok_or(SwapError::FeeCalculationFailure)?,\n                )\n            }",
    "pub fn process_deposit_all_token_types(\n        program_id: &Pubkey,\n        pool_token_amount: u64,\n        maximum_token_a_amount: u64,\n        maximum_token_b_amount: u64,\n        accounts: &[AccountInfo],\n    ) -> ProgramResult {\n        let account_info_iter = &mut accounts.iter();\n        let swap_info = next_account_info(account_info_iter)?;\n        let authority_info = next_account_info(account_info_iter)?;\n        let user_transfer_authority_info = next_account_info(account_info_iter)?;\n        let source_a_info = next_account_info(account_info_iter)?;\n        let source_b_info = next_account_info(account_info_iter)?;\n        let token_a_info = next_account_info(account_info_iter)?;\n        let token_b_info = next_account_info(account_info_iter)?;\n        let pool_mint_info = next_account_info(account_info_iter)?;\n        let dest_info = next_account_info(account_info_iter)?;\n        let token_a_mint_info = next_account_info(account_info_iter)?;\n        let token_b_mint_info = next_account_info(account_info_iter)?;\n        let token_a_program_info = next_account_info(account_info_iter)?;\n        let token_b_program_info = next_account_info(account_info_iter)?;\n        let pool_token_program_info = next_account_info(account_info_iter)?;\n\n        let token_swap = SwapVersion::unpack(&swap_info.data.borrow())?;\n        let calculator = &token_swap.swap_curve().calculator;\n        if !calculator.allows_deposits() {\n            return Err(SwapError::UnsupportedCurveOperation.into());\n        }\n        Self::check_accounts(\n            token_swap.as_ref(),\n            program_id,\n            swap_info,\n            authority_info,\n            token_a_info,\n            token_b_info,\n            pool_mint_info,\n            pool_token_program_info,\n            Some(source_a_info),\n            Some(source_b_info),\n            None,\n        )?;\n\n        let token_a = Self::unpack_token_account(token_a_info, token_swap.token_program_id())?;\n        let token_b = Self::unpack_token_account(token_b_info, token_swap.token_program_id())?;\n        let pool_mint = Self::unpack_mint(pool_mint_info, token_swap.token_program_id())?;\n        let current_pool_mint_supply = u128::from(pool_mint.supply);\n        let (pool_token_amount, pool_mint_supply) = if current_pool_mint_supply > 0 {\n            (u128::from(pool_token_amount), current_pool_mint_supply)\n        }",
    "pub fn process_withdraw_all_token_types(\n        program_id: &Pubkey,\n        pool_token_amount: u64,\n        minimum_token_a_amount: u64,\n        minimum_token_b_amount: u64,\n        accounts: &[AccountInfo],\n    ) -> ProgramResult {\n        let account_info_iter = &mut accounts.iter();\n        let swap_info = next_account_info(account_info_iter)?;\n        let authority_info = next_account_info(account_info_iter)?;\n        let user_transfer_authority_info = next_account_info(account_info_iter)?;\n        let pool_mint_info = next_account_info(account_info_iter)?;\n        let source_info = next_account_info(account_info_iter)?;\n        let token_a_info = next_account_info(account_info_iter)?;\n        let token_b_info = next_account_info(account_info_iter)?;\n        let dest_token_a_info = next_account_info(account_info_iter)?;\n        let dest_token_b_info = next_account_info(account_info_iter)?;\n        let pool_fee_account_info = next_account_info(account_info_iter)?;\n        let token_a_mint_info = next_account_info(account_info_iter)?;\n        let token_b_mint_info = next_account_info(account_info_iter)?;\n        let pool_token_program_info = next_account_info(account_info_iter)?;\n        let token_a_program_info = next_account_info(account_info_iter)?;\n        let token_b_program_info = next_account_info(account_info_iter)?;\n\n        let token_swap = SwapVersion::unpack(&swap_info.data.borrow())?;\n        Self::check_accounts(\n            token_swap.as_ref(),\n            program_id,\n            swap_info,\n            authority_info,\n            token_a_info,\n            token_b_info,\n            pool_mint_info,\n            pool_token_program_info,\n            Some(dest_token_a_info),\n            Some(dest_token_b_info),\n            Some(pool_fee_account_info),\n        )?;\n\n        let token_a = Self::unpack_token_account(token_a_info, token_swap.token_program_id())?;\n        let token_b = Self::unpack_token_account(token_b_info, token_swap.token_program_id())?;\n        let pool_mint = Self::unpack_mint(pool_mint_info, token_swap.token_program_id())?;\n\n        let calculator = &token_swap.swap_curve().calculator;\n\n        let withdraw_fee = match token_swap.check_pool_fee_info(pool_fee_account_info) {\n            Ok(_) => {\n                if *pool_fee_account_info.key == *source_info.key {\n                    // withdrawing from the fee account, don't assess withdraw fee\n                    0\n                } else {\n                    token_swap\n                        .fees()\n                        .owner_withdraw_fee(u128::from(pool_token_amount))\n                        .ok_or(SwapError::FeeCalculationFailure)?\n                }\n            }\n            Err(_) => 0,\n        };\n        let pool_token_amount = u128::from(pool_token_amount)\n            .checked_sub(withdraw_fee)\n            .ok_or(SwapError::CalculationFailure)?;\n\n        let results = calculator\n            .pool_tokens_to_trading_tokens(\n                pool_token_amount,\n                u128::from(pool_mint.supply),\n                u128::from(token_a.amount),\n                u128::from(token_b.amount),\n                RoundDirection::Floor,\n            )\n            .ok_or(SwapError::ZeroTradingTokens)?;\n        let token_a_amount = to_u64(results.token_a_amount)?;\n        let token_a_amount = std::cmp::min(token_a.amount, token_a_amount);\n        if token_a_amount < minimum_token_a_amount {\n            return Err(SwapError::ExceededSlippage.into());\n        }\n        if token_a_amount == 0 && token_a.amount != 0 {\n            return Err(SwapError::ZeroTradingTokens.into());\n        }\n        let token_b_amount = to_u64(results.token_b_amount)?;\n        let token_b_amount = std::cmp::min(token_b.amount, token_b_amount);\n        if token_b_amount < minimum_token_b_amount {\n            return Err(SwapError::ExceededSlippage.into());\n        }\n        if token_b_amount == 0 && token_b.amount != 0 {\n            return Err(SwapError::ZeroTradingTokens.into());\n        }\n\n        if withdraw_fee > 0 {\n            Self::token_transfer(\n                swap_info.key,\n                pool_token_program_info.clone(),\n                source_info.clone(),\n                pool_mint_info.clone(),\n                pool_fee_account_info.clone(),\n                user_transfer_authority_info.clone(),\n                token_swap.bump_seed(),\n                to_u64(withdraw_fee)?,\n                pool_mint.decimals,\n            )?;\n        }\n        Self::token_burn(\n            swap_info.key,\n            pool_token_program_info.clone(),\n            source_info.clone(),\n            pool_mint_info.clone(),\n            user_transfer_authority_info.clone(),\n            token_swap.bump_seed(),\n            to_u64(pool_token_amount)?,\n        )?;\n\n        if token_a_amount > 0 {\n            Self::token_transfer(\n                swap_info.key,\n                token_a_program_info.clone(),\n                token_a_info.clone(),\n                token_a_mint_info.clone(),\n                dest_token_a_info.clone(),\n                authority_info.clone(),\n                token_swap.bump_seed(),\n                token_a_amount,\n                Self::unpack_mint(token_a_mint_info, token_swap.token_program_id())?.decimals,\n            )?;\n        }\n        if token_b_amount > 0 {\n            Self::token_transfer(\n                swap_info.key,\n                token_b_program_info.clone(),\n                token_b_info.clone(),\n                token_b_mint_info.clone(),\n                dest_token_b_info.clone(),\n                authority_info.clone(),\n                token_swap.bump_seed(),\n                token_b_amount,\n                Self::unpack_mint(token_b_mint_info, token_swap.token_program_id())?.decimals,\n            )?;\n        }\n        Ok(())\n    }",
    "pub fn process_deposit_single_token_type_exact_amount_in(\n        program_id: &Pubkey,\n        source_token_amount: u64,\n        minimum_pool_token_amount: u64,\n        accounts: &[AccountInfo],\n    ) -> ProgramResult {\n        let account_info_iter = &mut accounts.iter();\n        let swap_info = next_account_info(account_info_iter)?;\n        let authority_info = next_account_info(account_info_iter)?;\n        let user_transfer_authority_info = next_account_info(account_info_iter)?;\n        let source_info = next_account_info(account_info_iter)?;\n        let swap_token_a_info = next_account_info(account_info_iter)?;\n        let swap_token_b_info = next_account_info(account_info_iter)?;\n        let pool_mint_info = next_account_info(account_info_iter)?;\n        let destination_info = next_account_info(account_info_iter)?;\n        let source_token_mint_info = next_account_info(account_info_iter)?;\n        let source_token_program_info = next_account_info(account_info_iter)?;\n        let pool_token_program_info = next_account_info(account_info_iter)?;\n\n        let token_swap = SwapVersion::unpack(&swap_info.data.borrow())?;\n        let calculator = &token_swap.swap_curve().calculator;\n        if !calculator.allows_deposits() {\n            return Err(SwapError::UnsupportedCurveOperation.into());\n        }\n        let source_account =\n            Self::unpack_token_account(source_info, token_swap.token_program_id())?;\n        let swap_token_a =\n            Self::unpack_token_account(swap_token_a_info, token_swap.token_program_id())?;\n        let swap_token_b =\n            Self::unpack_token_account(swap_token_b_info, token_swap.token_program_id())?;\n\n        let trade_direction = if source_account.mint == swap_token_a.mint {\n            TradeDirection::AtoB\n        } else if source_account.mint == swap_token_b.mint {\n            TradeDirection::BtoA\n        } else {\n            return Err(SwapError::IncorrectSwapAccount.into());\n        };\n\n        let (source_a_info, source_b_info) = match trade_direction {\n            TradeDirection::AtoB => (Some(source_info), None),\n            TradeDirection::BtoA => (None, Some(source_info)),\n        };\n\n        Self::check_accounts(\n            token_swap.as_ref(),\n            program_id,\n            swap_info,\n            authority_info,\n            swap_token_a_info,\n            swap_token_b_info,\n            pool_mint_info,\n            pool_token_program_info,\n            source_a_info,\n            source_b_info,\n            None,\n        )?;\n\n        let pool_mint = Self::unpack_mint(pool_mint_info, token_swap.token_program_id())?;\n        let pool_mint_supply = u128::from(pool_mint.supply);\n        let pool_token_amount = if pool_mint_supply > 0 {\n            token_swap\n                .swap_curve()\n                .deposit_single_token_type(\n                    u128::from(source_token_amount),\n                    u128::from(swap_token_a.amount),\n                    u128::from(swap_token_b.amount),\n                    pool_mint_supply,\n                    trade_direction,\n                    token_swap.fees(),\n                )\n                .ok_or(SwapError::ZeroTradingTokens)?\n        } else {\n            calculator.new_pool_supply()\n        }",
    "pub fn process_withdraw_single_token_type_exact_amount_out(\n        program_id: &Pubkey,\n        destination_token_amount: u64,\n        maximum_pool_token_amount: u64,\n        accounts: &[AccountInfo],\n    ) -> ProgramResult {\n        let account_info_iter = &mut accounts.iter();\n        let swap_info = next_account_info(account_info_iter)?;\n        let authority_info = next_account_info(account_info_iter)?;\n        let user_transfer_authority_info = next_account_info(account_info_iter)?;\n        let pool_mint_info = next_account_info(account_info_iter)?;\n        let source_info = next_account_info(account_info_iter)?;\n        let swap_token_a_info = next_account_info(account_info_iter)?;\n        let swap_token_b_info = next_account_info(account_info_iter)?;\n        let destination_info = next_account_info(account_info_iter)?;\n        let pool_fee_account_info = next_account_info(account_info_iter)?;\n        let destination_token_mint_info = next_account_info(account_info_iter)?;\n        let pool_token_program_info = next_account_info(account_info_iter)?;\n        let destination_token_program_info = next_account_info(account_info_iter)?;\n\n        let token_swap = SwapVersion::unpack(&swap_info.data.borrow())?;\n        let destination_account =\n            Self::unpack_token_account(destination_info, token_swap.token_program_id())?;\n        let swap_token_a =\n            Self::unpack_token_account(swap_token_a_info, token_swap.token_program_id())?;\n        let swap_token_b =\n            Self::unpack_token_account(swap_token_b_info, token_swap.token_program_id())?;\n\n        let trade_direction = if destination_account.mint == swap_token_a.mint {\n            TradeDirection::AtoB\n        } else if destination_account.mint == swap_token_b.mint {\n            TradeDirection::BtoA\n        } else {\n            return Err(SwapError::IncorrectSwapAccount.into());\n        };\n\n        let (destination_a_info, destination_b_info) = match trade_direction {\n            TradeDirection::AtoB => (Some(destination_info), None),\n            TradeDirection::BtoA => (None, Some(destination_info)),\n        };\n        Self::check_accounts(\n            token_swap.as_ref(),\n            program_id,\n            swap_info,\n            authority_info,\n            swap_token_a_info,\n            swap_token_b_info,\n            pool_mint_info,\n            pool_token_program_info,\n            destination_a_info,\n            destination_b_info,\n            Some(pool_fee_account_info),\n        )?;\n\n        let pool_mint = Self::unpack_mint(pool_mint_info, token_swap.token_program_id())?;\n        let pool_mint_supply = u128::from(pool_mint.supply);\n        let swap_token_a_amount = u128::from(swap_token_a.amount);\n        let swap_token_b_amount = u128::from(swap_token_b.amount);\n\n        let burn_pool_token_amount = token_swap\n            .swap_curve()\n            .withdraw_single_token_type_exact_out(\n                u128::from(destination_token_amount),\n                swap_token_a_amount,\n                swap_token_b_amount,\n                pool_mint_supply,\n                trade_direction,\n                token_swap.fees(),\n            )\n            .ok_or(SwapError::ZeroTradingTokens)?;\n\n        let withdraw_fee = match token_swap.check_pool_fee_info(pool_fee_account_info) {\n            Ok(_) => {\n                if *pool_fee_account_info.key == *source_info.key {\n                    // withdrawing from the fee account, don't assess withdraw fee\n                    0\n                } else {\n                    token_swap\n                        .fees()\n                        .owner_withdraw_fee(burn_pool_token_amount)\n                        .ok_or(SwapError::FeeCalculationFailure)?\n                }\n            }\n            Err(_) => 0,\n        };\n        let pool_token_amount = burn_pool_token_amount\n            .checked_add(withdraw_fee)\n            .ok_or(SwapError::CalculationFailure)?;\n\n        if to_u64(pool_token_amount)? > maximum_pool_token_amount {\n            return Err(SwapError::ExceededSlippage.into());\n        }\n        if pool_token_amount == 0 {\n            return Err(SwapError::ZeroTradingTokens.into());\n        }\n\n        if withdraw_fee > 0 {\n            Self::token_transfer(\n                swap_info.key,\n                pool_token_program_info.clone(),\n                source_info.clone(),\n                pool_mint_info.clone(),\n                pool_fee_account_info.clone(),\n                user_transfer_authority_info.clone(),\n                token_swap.bump_seed(),\n                to_u64(withdraw_fee)?,\n                pool_mint.decimals,\n            )?;\n        }\n        Self::token_burn(\n            swap_info.key,\n            pool_token_program_info.clone(),\n            source_info.clone(),\n            pool_mint_info.clone(),\n            user_transfer_authority_info.clone(),\n            token_swap.bump_seed(),\n            to_u64(burn_pool_token_amount)?,\n        )?;\n\n        match trade_direction {\n            TradeDirection::AtoB => {\n                Self::token_transfer(\n                    swap_info.key,\n                    destination_token_program_info.clone(),\n                    swap_token_a_info.clone(),\n                    destination_token_mint_info.clone(),\n                    destination_info.clone(),\n                    authority_info.clone(),\n                    token_swap.bump_seed(),\n                    destination_token_amount,\n                    Self::unpack_mint(destination_token_mint_info, token_swap.token_program_id())?\n                        .decimals,\n                )?;\n            }\n            TradeDirection::BtoA => {\n                Self::token_transfer(\n                    swap_info.key,\n                    destination_token_program_info.clone(),\n                    swap_token_b_info.clone(),\n                    destination_token_mint_info.clone(),\n                    destination_info.clone(),\n                    authority_info.clone(),\n                    token_swap.bump_seed(),\n                    destination_token_amount,\n                    Self::unpack_mint(destination_token_mint_info, token_swap.token_program_id())?\n                        .decimals,\n                )?;\n            }\n        }\n\n        Ok(())\n    }",
    "pub fn process(program_id: &Pubkey, accounts: &[AccountInfo], input: &[u8]) -> ProgramResult {\n        Self::process_with_constraints(program_id, accounts, input, &SWAP_CONSTRAINTS)\n    }",
    "pub fn process_with_constraints(\n        program_id: &Pubkey,\n        accounts: &[AccountInfo],\n        input: &[u8],\n        swap_constraints: &Option<SwapConstraints>,\n    ) -> ProgramResult {\n        let instruction = SwapInstruction::unpack(input)?;\n        match instruction {\n            SwapInstruction::Initialize(Initialize { fees, swap_curve }) => {\n                msg!(\"Instruction: Init\");\n                Self::process_initialize(program_id, fees, swap_curve, accounts, swap_constraints)\n            }",
    "pub fn new(\n            user_key: &Pubkey,\n            fees: Fees,\n            transfer_fees: SwapTransferFees,\n            swap_curve: SwapCurve,\n            token_a_amount: u64,\n            token_b_amount: u64,\n            pool_token_program_id: &Pubkey,\n            token_a_program_id: &Pubkey,\n            token_b_program_id: &Pubkey,\n        ) -> Self {\n            let swap_key = Pubkey::new_unique();\n            let swap_account = SolanaAccount::new(0, SwapVersion::LATEST_LEN, &SWAP_PROGRAM_ID);\n            let (authority_key, bump_seed) =\n                Pubkey::find_program_address(&[&swap_key.to_bytes()[..]], &SWAP_PROGRAM_ID);\n\n            let (pool_mint_key, mut pool_mint_account) = create_mint(\n                pool_token_program_id,\n                &authority_key,\n                None,\n                None,\n                &transfer_fees.pool_token,\n            );\n            let (pool_token_key, pool_token_account) = mint_token(\n                pool_token_program_id,\n                &pool_mint_key,\n                &mut pool_mint_account,\n                &authority_key,\n                user_key,\n                0,\n            );\n            let (pool_fee_key, pool_fee_account) = mint_token(\n                pool_token_program_id,\n                &pool_mint_key,\n                &mut pool_mint_account,\n                &authority_key,\n                user_key,\n                0,\n            );\n            let (token_a_mint_key, mut token_a_mint_account) = create_mint(\n                token_a_program_id,\n                user_key,\n                None,\n                None,\n                &transfer_fees.token_a,\n            );\n            let (token_a_key, token_a_account) = mint_token(\n                token_a_program_id,\n                &token_a_mint_key,\n                &mut token_a_mint_account,\n                user_key,\n                &authority_key,\n                token_a_amount,\n            );\n            let (token_b_mint_key, mut token_b_mint_account) = create_mint(\n                token_b_program_id,\n                user_key,\n                None,\n                None,\n                &transfer_fees.token_b,\n            );\n            let (token_b_key, token_b_account) = mint_token(\n                token_b_program_id,\n                &token_b_mint_key,\n                &mut token_b_mint_account,\n                user_key,\n                &authority_key,\n                token_b_amount,\n            );\n\n            SwapAccountInfo {\n                bump_seed,\n                authority_key,\n                fees,\n                transfer_fees,\n                swap_curve,\n                swap_key,\n                swap_account,\n                pool_mint_key,\n                pool_mint_account,\n                pool_fee_key,\n                pool_fee_account,\n                pool_token_key,\n                pool_token_account,\n                token_a_key,\n                token_a_account,\n                token_a_mint_key,\n                token_a_mint_account,\n                token_b_key,\n                token_b_account,\n                token_b_mint_key,\n                token_b_mint_account,\n                pool_token_program_id: *pool_token_program_id,\n                token_a_program_id: *token_a_program_id,\n                token_b_program_id: *token_b_program_id,\n            }\n        }\n\n        pub fn initialize_swap(&mut self) -> ProgramResult {\n            do_process_instruction(\n                initialize(\n                    &SWAP_PROGRAM_ID,\n                    &self.pool_token_program_id,\n                    &self.swap_key,\n                    &self.authority_key,\n                    &self.token_a_key,\n                    &self.token_b_key,\n                    &self.pool_mint_key,\n                    &self.pool_fee_key,\n                    &self.pool_token_key,\n                    self.fees.clone(),\n                    self.swap_curve.clone(),\n                )\n                .unwrap(),\n                vec![\n                    &mut self.swap_account,\n                    &mut SolanaAccount::default(),\n                    &mut self.token_a_account,\n                    &mut self.token_b_account,\n                    &mut self.pool_mint_account,\n                    &mut self.pool_fee_account,\n                    &mut self.pool_token_account,\n                    &mut SolanaAccount::default(),\n                ],\n            )\n        }",
    "pub fn setup_token_accounts(\n            &mut self,\n            mint_owner: &Pubkey,\n            account_owner: &Pubkey,\n            a_amount: u64,\n            b_amount: u64,\n            pool_amount: u64,\n        ) -> (\n            Pubkey,\n            SolanaAccount,\n            Pubkey,\n            SolanaAccount,\n            Pubkey,\n            SolanaAccount,\n        ) {\n            let (token_a_key, token_a_account) = mint_token(\n                &self.token_a_program_id,\n                &self.token_a_mint_key,\n                &mut self.token_a_mint_account,\n                mint_owner,\n                account_owner,\n                a_amount,\n            );\n            let (token_b_key, token_b_account) = mint_token(\n                &self.token_b_program_id,\n                &self.token_b_mint_key,\n                &mut self.token_b_mint_account,\n                mint_owner,\n                account_owner,\n                b_amount,\n            );\n            let (pool_key, pool_account) = mint_token(\n                &self.pool_token_program_id,\n                &self.pool_mint_key,\n                &mut self.pool_mint_account,\n                &self.authority_key,\n                account_owner,\n                pool_amount,\n            );\n            (\n                token_a_key,\n                token_a_account,\n                token_b_key,\n                token_b_account,\n                pool_key,\n                pool_account,\n            )\n        }",
    "pub fn swap(\n            &mut self,\n            user_key: &Pubkey,\n            user_source_key: &Pubkey,\n            user_source_account: &mut SolanaAccount,\n            swap_source_key: &Pubkey,\n            swap_destination_key: &Pubkey,\n            user_destination_key: &Pubkey,\n            user_destination_account: &mut SolanaAccount,\n            amount_in: u64,\n            minimum_amount_out: u64,\n        ) -> ProgramResult {\n            let user_transfer_key = Pubkey::new_unique();\n            let source_token_program_id = self.get_token_program_id(swap_source_key);\n            let destination_token_program_id = self.get_token_program_id(swap_destination_key);\n            // approve moving from user source account\n            do_process_instruction(\n                approve(\n                    source_token_program_id,\n                    user_source_key,\n                    &user_transfer_key,\n                    user_key,\n                    &[],\n                    amount_in,\n                )\n                .unwrap(),\n                vec![\n                    user_source_account,\n                    &mut SolanaAccount::default(),\n                    &mut SolanaAccount::default(),\n                ],\n            )\n            .unwrap();\n\n            let (source_mint_key, mut source_mint_account) = self.get_token_mint(swap_source_key);\n            let (destination_mint_key, mut destination_mint_account) =\n                self.get_token_mint(swap_destination_key);\n            let mut swap_source_account = self.get_token_account(swap_source_key).clone();\n            let mut swap_destination_account = self.get_token_account(swap_destination_key).clone();\n\n            // perform the swap\n            do_process_instruction(\n                swap(\n                    &SWAP_PROGRAM_ID,\n                    source_token_program_id,\n                    destination_token_program_id,\n                    &self.pool_token_program_id,\n                    &self.swap_key,\n                    &self.authority_key,\n                    &user_transfer_key,\n                    user_source_key,\n                    swap_source_key,\n                    swap_destination_key,\n                    user_destination_key,\n                    &self.pool_mint_key,\n                    &self.pool_fee_key,\n                    &source_mint_key,\n                    &destination_mint_key,\n                    None,\n                    Swap {\n                        amount_in,\n                        minimum_amount_out,\n                    },\n                )\n                .unwrap(),\n                vec![\n                    &mut self.swap_account,\n                    &mut SolanaAccount::default(),\n                    &mut SolanaAccount::default(),\n                    user_source_account,\n                    &mut swap_source_account,\n                    &mut swap_destination_account,\n                    user_destination_account,\n                    &mut self.pool_mint_account,\n                    &mut self.pool_fee_account,\n                    &mut source_mint_account,\n                    &mut destination_mint_account,\n                    &mut SolanaAccount::default(),\n                    &mut SolanaAccount::default(),\n                    &mut SolanaAccount::default(),\n                ],\n            )?;\n\n            self.set_token_account(swap_source_key, swap_source_account);\n            self.set_token_account(swap_destination_key, swap_destination_account);\n\n            Ok(())\n        }",
    "pub fn deposit_all_token_types(\n            &mut self,\n            depositor_key: &Pubkey,\n            depositor_token_a_key: &Pubkey,\n            depositor_token_a_account: &mut SolanaAccount,\n            depositor_token_b_key: &Pubkey,\n            depositor_token_b_account: &mut SolanaAccount,\n            depositor_pool_key: &Pubkey,\n            depositor_pool_account: &mut SolanaAccount,\n            pool_token_amount: u64,\n            maximum_token_a_amount: u64,\n            maximum_token_b_amount: u64,\n        ) -> ProgramResult {\n            let user_transfer_authority = Pubkey::new_unique();\n            let token_a_program_id = depositor_token_a_account.owner;\n            do_process_instruction(\n                approve(\n                    &token_a_program_id,\n                    depositor_token_a_key,\n                    &user_transfer_authority,\n                    depositor_key,\n                    &[],\n                    maximum_token_a_amount,\n                )\n                .unwrap(),\n                vec![\n                    depositor_token_a_account,\n                    &mut SolanaAccount::default(),\n                    &mut SolanaAccount::default(),\n                ],\n            )\n            .unwrap();\n\n            let token_b_program_id = depositor_token_b_account.owner;\n            do_process_instruction(\n                approve(\n                    &token_b_program_id,\n                    depositor_token_b_key,\n                    &user_transfer_authority,\n                    depositor_key,\n                    &[],\n                    maximum_token_b_amount,\n                )\n                .unwrap(),\n                vec![\n                    depositor_token_b_account,\n                    &mut SolanaAccount::default(),\n                    &mut SolanaAccount::default(),\n                ],\n            )\n            .unwrap();\n\n            let pool_token_program_id = depositor_pool_account.owner;\n            do_process_instruction(\n                deposit_all_token_types(\n                    &SWAP_PROGRAM_ID,\n                    &token_a_program_id,\n                    &token_b_program_id,\n                    &pool_token_program_id,\n                    &self.swap_key,\n                    &self.authority_key,\n                    &user_transfer_authority,\n                    depositor_token_a_key,\n                    depositor_token_b_key,\n                    &self.token_a_key,\n                    &self.token_b_key,\n                    &self.pool_mint_key,\n                    depositor_pool_key,\n                    &self.token_a_mint_key,\n                    &self.token_b_mint_key,\n                    DepositAllTokenTypes {\n                        pool_token_amount,\n                        maximum_token_a_amount,\n                        maximum_token_b_amount,\n                    },\n                )\n                .unwrap(),\n                vec![\n                    &mut self.swap_account,\n                    &mut SolanaAccount::default(),\n                    &mut SolanaAccount::default(),\n                    depositor_token_a_account,\n                    depositor_token_b_account,\n                    &mut self.token_a_account,\n                    &mut self.token_b_account,\n                    &mut self.pool_mint_account,\n                    depositor_pool_account,\n                    &mut self.token_a_mint_account,\n                    &mut self.token_b_mint_account,\n                    &mut SolanaAccount::default(),\n                    &mut SolanaAccount::default(),\n                    &mut SolanaAccount::default(),\n                ],\n            )\n        }",
    "pub fn withdraw_all_token_types(\n            &mut self,\n            user_key: &Pubkey,\n            pool_key: &Pubkey,\n            pool_account: &mut SolanaAccount,\n            token_a_key: &Pubkey,\n            token_a_account: &mut SolanaAccount,\n            token_b_key: &Pubkey,\n            token_b_account: &mut SolanaAccount,\n            pool_token_amount: u64,\n            minimum_token_a_amount: u64,\n            minimum_token_b_amount: u64,\n        ) -> ProgramResult {\n            let user_transfer_authority_key = Pubkey::new_unique();\n            let pool_token_program_id = pool_account.owner;\n            // approve user transfer authority to take out pool tokens\n            do_process_instruction(\n                approve(\n                    &pool_token_program_id,\n                    pool_key,\n                    &user_transfer_authority_key,\n                    user_key,\n                    &[],\n                    pool_token_amount,\n                )\n                .unwrap(),\n                vec![\n                    pool_account,\n                    &mut SolanaAccount::default(),\n                    &mut SolanaAccount::default(),\n                ],\n            )\n            .unwrap();\n\n            // withdraw token a and b correctly\n            let token_a_program_id = token_a_account.owner;\n            let token_b_program_id = token_b_account.owner;\n            do_process_instruction(\n                withdraw_all_token_types(\n                    &SWAP_PROGRAM_ID,\n                    &pool_token_program_id,\n                    &token_a_program_id,\n                    &token_b_program_id,\n                    &self.swap_key,\n                    &self.authority_key,\n                    &user_transfer_authority_key,\n                    &self.pool_mint_key,\n                    &self.pool_fee_key,\n                    pool_key,\n                    &self.token_a_key,\n                    &self.token_b_key,\n                    token_a_key,\n                    token_b_key,\n                    &self.token_a_mint_key,\n                    &self.token_b_mint_key,\n                    WithdrawAllTokenTypes {\n                        pool_token_amount,\n                        minimum_token_a_amount,\n                        minimum_token_b_amount,\n                    },\n                )\n                .unwrap(),\n                vec![\n                    &mut self.swap_account,\n                    &mut SolanaAccount::default(),\n                    &mut SolanaAccount::default(),\n                    &mut self.pool_mint_account,\n                    pool_account,\n                    &mut self.token_a_account,\n                    &mut self.token_b_account,\n                    token_a_account,\n                    token_b_account,\n                    &mut self.pool_fee_account,\n                    &mut self.token_a_mint_account,\n                    &mut self.token_b_mint_account,\n                    &mut SolanaAccount::default(),\n                    &mut SolanaAccount::default(),\n                    &mut SolanaAccount::default(),\n                ],\n            )\n        }",
    "pub fn deposit_single_token_type_exact_amount_in(\n            &mut self,\n            depositor_key: &Pubkey,\n            deposit_account_key: &Pubkey,\n            deposit_token_account: &mut SolanaAccount,\n            deposit_pool_key: &Pubkey,\n            deposit_pool_account: &mut SolanaAccount,\n            source_token_amount: u64,\n            minimum_pool_token_amount: u64,\n        ) -> ProgramResult {\n            let user_transfer_authority_key = Pubkey::new_unique();\n            let source_token_program_id = deposit_token_account.owner;\n            do_process_instruction(\n                approve(\n                    &source_token_program_id,\n                    deposit_account_key,\n                    &user_transfer_authority_key,\n                    depositor_key,\n                    &[],\n                    source_token_amount,\n                )\n                .unwrap(),\n                vec![\n                    deposit_token_account,\n                    &mut SolanaAccount::default(),\n                    &mut SolanaAccount::default(),\n                ],\n            )\n            .unwrap();\n\n            let source_mint_key =\n                StateWithExtensions::<Account>::unpack(&deposit_token_account.data)\n                    .unwrap()\n                    .base\n                    .mint;\n            let swap_source_key = self.get_swap_key(&source_mint_key);\n            let (source_mint_key, mut source_mint_account) = self.get_token_mint(swap_source_key);\n\n            let pool_token_program_id = deposit_pool_account.owner;\n            do_process_instruction(\n                deposit_single_token_type_exact_amount_in(\n                    &SWAP_PROGRAM_ID,\n                    &source_token_program_id,\n                    &pool_token_program_id,\n                    &self.swap_key,\n                    &self.authority_key,\n                    &user_transfer_authority_key,\n                    deposit_account_key,\n                    &self.token_a_key,\n                    &self.token_b_key,\n                    &self.pool_mint_key,\n                    deposit_pool_key,\n                    &source_mint_key,\n                    DepositSingleTokenTypeExactAmountIn {\n                        source_token_amount,\n                        minimum_pool_token_amount,\n                    },\n                )\n                .unwrap(),\n                vec![\n                    &mut self.swap_account,\n                    &mut SolanaAccount::default(),\n                    &mut SolanaAccount::default(),\n                    deposit_token_account,\n                    &mut self.token_a_account,\n                    &mut self.token_b_account,\n                    &mut self.pool_mint_account,\n                    deposit_pool_account,\n                    &mut source_mint_account,\n                    &mut SolanaAccount::default(),\n                    &mut SolanaAccount::default(),\n                ],\n            )\n        }",
    "pub fn withdraw_single_token_type_exact_amount_out(\n            &mut self,\n            user_key: &Pubkey,\n            pool_key: &Pubkey,\n            pool_account: &mut SolanaAccount,\n            destination_key: &Pubkey,\n            destination_account: &mut SolanaAccount,\n            destination_token_amount: u64,\n            maximum_pool_token_amount: u64,\n        ) -> ProgramResult {\n            let user_transfer_authority_key = Pubkey::new_unique();\n            let pool_token_program_id = pool_account.owner;\n            // approve user transfer authority to take out pool tokens\n            do_process_instruction(\n                approve(\n                    &pool_token_program_id,\n                    pool_key,\n                    &user_transfer_authority_key,\n                    user_key,\n                    &[],\n                    maximum_pool_token_amount,\n                )\n                .unwrap(),\n                vec![\n                    pool_account,\n                    &mut SolanaAccount::default(),\n                    &mut SolanaAccount::default(),\n                ],\n            )\n            .unwrap();\n\n            let destination_mint_key =\n                StateWithExtensions::<Account>::unpack(&destination_account.data)\n                    .unwrap()\n                    .base\n                    .mint;\n            let swap_destination_key = self.get_swap_key(&destination_mint_key);\n            let (destination_mint_key, mut destination_mint_account) =\n                self.get_token_mint(swap_destination_key);\n\n            let destination_token_program_id = destination_account.owner;\n            do_process_instruction(\n                withdraw_single_token_type_exact_amount_out(\n                    &SWAP_PROGRAM_ID,\n                    &pool_token_program_id,\n                    &destination_token_program_id,\n                    &self.swap_key,\n                    &self.authority_key,\n                    &user_transfer_authority_key,\n                    &self.pool_mint_key,\n                    &self.pool_fee_key,\n                    pool_key,\n                    &self.token_a_key,\n                    &self.token_b_key,\n                    destination_key,\n                    &destination_mint_key,\n                    WithdrawSingleTokenTypeExactAmountOut {\n                        destination_token_amount,\n                        maximum_pool_token_amount,\n                    },\n                )\n                .unwrap(),\n                vec![\n                    &mut self.swap_account,\n                    &mut SolanaAccount::default(),\n                    &mut SolanaAccount::default(),\n                    &mut self.pool_mint_account,\n                    pool_account,\n                    &mut self.token_a_account,\n                    &mut self.token_b_account,\n                    destination_account,\n                    &mut self.pool_fee_account,\n                    &mut destination_mint_account,\n                    &mut SolanaAccount::default(),\n                    &mut SolanaAccount::default(),\n                ],\n            )\n        }",
    "pub fn pack(src: Self, dst: &mut [u8]) -> Result<(), ProgramError> {\n        match src {\n            Self::SwapV1(swap_info) => {\n                dst[0] = 1;\n                SwapV1::pack(swap_info, &mut dst[1..])\n            }",
    "pub fn unpack(input: &[u8]) -> Result<Arc<dyn SwapState>, ProgramError> {\n        let (&version, rest) = input\n            .split_first()\n            .ok_or(ProgramError::InvalidAccountData)?;\n        match version {\n            1 => Ok(Arc::new(SwapV1::unpack(rest)?)),\n            _ => Err(ProgramError::UninitializedAccount),\n        }\n    }\n\n    /// Special check to be done before any instruction processing, works for\n    /// all versions\n    pub fn is_initialized(input: &[u8]) -> bool {\n        match Self::unpack(input) {\n            Ok(swap) => swap.is_initialized(),\n            Err(_) => false,\n        }\n    }\n}\n\n/// Program states.\n#[repr(C)]\n#[derive(Debug, Default, PartialEq)]\npub struct SwapV1 {\n    /// Initialized state.\n    pub is_initialized: bool,\n    /// Bump seed used in program address.\n    /// The program address is created deterministically with the bump seed,\n    /// swap program id, and swap account pubkey.  This program address has\n    /// authority over the swap's token A account, token B account, and pool\n    /// token mint.\n    pub bump_seed: u8,\n\n    /// Program ID of the tokens being exchanged.\n    pub token_program_id: Pubkey,\n\n    /// Token A\n    pub token_a: Pubkey,\n    /// Token B\n    pub token_b: Pubkey,\n\n    /// Pool tokens are issued when A or B tokens are deposited.\n    /// Pool tokens can be withdrawn back to the original A or B token.\n    pub pool_mint: Pubkey,\n\n    /// Mint information for token A\n    pub token_a_mint: Pubkey,\n    /// Mint information for token B\n    pub token_b_mint: Pubkey,\n\n    /// Pool token account to receive trading and / or withdrawal fees\n    pub pool_fee_account: Pubkey,\n\n    /// All fee information\n    pub fees: Fees,\n\n    /// Swap curve parameters, to be unpacked and used by the SwapCurve, which\n    /// calculates swaps, deposits, and withdrawals\n    pub swap_curve: SwapCurve,\n}\n\nimpl SwapState for SwapV1 {\n    fn is_initialized(&self) -> bool {\n        self.is_initialized\n    }\n\n    fn bump_seed(&self) -> u8 {\n        self.bump_seed\n    }\n\n    fn token_program_id(&self) -> &Pubkey {\n        &self.token_program_id\n    }\n\n    fn token_a_account(&self) -> &Pubkey {\n        &self.token_a\n    }\n\n    fn token_b_account(&self) -> &Pubkey {\n        &self.token_b\n    }\n\n    fn pool_mint(&self) -> &Pubkey {\n        &self.pool_mint\n    }\n\n    fn token_a_mint(&self) -> &Pubkey {\n        &self.token_a_mint\n    }\n\n    fn token_b_mint(&self) -> &Pubkey {\n        &self.token_b_mint\n    }\n\n    fn pool_fee_account(&self) -> &Pubkey {\n        &self.pool_fee_account\n    }\n\n    fn check_pool_fee_info(&self, pool_fee_info: &AccountInfo) -> Result<(), ProgramError> {\n        let data = &pool_fee_info.data.borrow();\n        let token_account =\n            StateWithExtensions::<Account>::unpack(data).map_err(|err| match err {\n                ProgramError::InvalidAccountData | ProgramError::UninitializedAccount => {\n                    SwapError::InvalidFeeAccount.into()\n                }",
    "pub fn swap(\n        &self,\n        source_amount: u128,\n        swap_source_amount: u128,\n        swap_destination_amount: u128,\n        trade_direction: TradeDirection,\n        fees: &Fees,\n    ) -> Option<SwapResult> {\n        // debit the fee to calculate the amount swapped\n        let trade_fee = fees.trading_fee(source_amount)?;\n        let owner_fee = fees.owner_trading_fee(source_amount)?;\n\n        let total_fees = trade_fee.checked_add(owner_fee)?;\n        let source_amount_less_fees = source_amount.checked_sub(total_fees)?;\n\n        let SwapWithoutFeesResult {\n            source_amount_swapped,\n            destination_amount_swapped,\n        } = self.calculator.swap_without_fees(\n            source_amount_less_fees,\n            swap_source_amount,\n            swap_destination_amount,\n            trade_direction,\n        )?;\n\n        let source_amount_swapped = source_amount_swapped.checked_add(total_fees)?;\n        Some(SwapResult {\n            new_swap_source_amount: swap_source_amount.checked_add(source_amount_swapped)?,\n            new_swap_destination_amount: swap_destination_amount\n                .checked_sub(destination_amount_swapped)?,\n            source_amount_swapped,\n            destination_amount_swapped,\n            trade_fee,\n            owner_fee,\n        })\n    }",
    "pub fn deposit_single_token_type(\n        &self,\n        source_amount: u128,\n        swap_token_a_amount: u128,\n        swap_token_b_amount: u128,\n        pool_supply: u128,\n        trade_direction: TradeDirection,\n        fees: &Fees,\n    ) -> Option<u128> {\n        if source_amount == 0 {\n            return Some(0);\n        }\n        // Get the trading fee incurred if *half* the source amount is swapped\n        // for the other side. Reference at:\n        // https://github.com/balancer-labs/balancer-core/blob/f4ed5d65362a8d6cec21662fb6eae233b0babc1f/contracts/BMath.sol#L117\n        let half_source_amount = std::cmp::max(1, source_amount.checked_div(2)?);\n        let trade_fee = fees.trading_fee(half_source_amount)?;\n        let owner_fee = fees.owner_trading_fee(half_source_amount)?;\n        let total_fees = trade_fee.checked_add(owner_fee)?;\n        let source_amount = source_amount.checked_sub(total_fees)?;\n        self.calculator.deposit_single_token_type(\n            source_amount,\n            swap_token_a_amount,\n            swap_token_b_amount,\n            pool_supply,\n            trade_direction,\n        )\n    }",
    "pub fn withdraw_single_token_type_exact_out(\n        &self,\n        source_amount: u128,\n        swap_token_a_amount: u128,\n        swap_token_b_amount: u128,\n        pool_supply: u128,\n        trade_direction: TradeDirection,\n        fees: &Fees,\n    ) -> Option<u128> {\n        if source_amount == 0 {\n            return Some(0);\n        }\n        // Since we want to get the amount required to get the exact amount out,\n        // we need the inverse trading fee incurred if *half* the source amount\n        // is swapped for the other side. Reference at:\n        // https://github.com/balancer-labs/balancer-core/blob/f4ed5d65362a8d6cec21662fb6eae233b0babc1f/contracts/BMath.sol#L117\n        let half_source_amount = source_amount.checked_add(1)?.checked_div(2)?; // round up\n        let pre_fee_source_amount = fees.pre_trading_fee_amount(half_source_amount)?;\n        let source_amount = source_amount\n            .checked_sub(half_source_amount)?\n            .checked_add(pre_fee_source_amount)?;\n        self.calculator.withdraw_single_token_type_exact_out(\n            source_amount,\n            swap_token_a_amount,\n            swap_token_b_amount,\n            pool_supply,\n            trade_direction,\n            RoundDirection::Ceiling,\n        )\n    }",
    "pub fn map_zero_to_none(x: u128) -> Option<u128> {\n    if x == 0 {\n        None\n    } else {\n        Some(x)\n    }",
    "pub fn opposite(&self) -> TradeDirection {\n        match self {\n            TradeDirection::AtoB => TradeDirection::BtoA,\n            TradeDirection::BtoA => TradeDirection::AtoB,\n        }\n    }\n}\n\n/// Encodes all results of swapping from a source token to a destination token\n#[derive(Debug, PartialEq)]\npub struct SwapWithoutFeesResult {\n    /// Amount of source token swapped\n    pub source_amount_swapped: u128,\n    /// Amount of destination token swapped\n    pub destination_amount_swapped: u128,\n}\n\n/// Encodes results of depositing both sides at once\n#[derive(Debug, PartialEq)]\npub struct TradingTokenResult {\n    /// Amount of token A\n    pub token_a_amount: u128,\n    /// Amount of token B\n    pub token_b_amount: u128,\n}\n\n/// Trait for packing of trait objects, required because structs that implement\n/// `Pack` cannot be used as trait objects (as `dyn Pack`).\npub trait DynPack {\n    /// Only required function is to pack given a trait object\n    fn pack_into_slice(&self, dst: &mut [u8]);\n}\n\n/// Trait representing operations required on a swap curve\npub trait CurveCalculator: Debug + DynPack {\n    /// Calculate how much destination token will be provided given an amount\n    /// of source token.\n    fn swap_without_fees(\n        &self,\n        source_amount: u128,\n        swap_source_amount: u128,\n        swap_destination_amount: u128,\n        trade_direction: TradeDirection,\n    ) -> Option<SwapWithoutFeesResult>;\n\n    /// Get the supply for a new pool\n    /// The default implementation is a Balancer-style fixed initial supply\n    fn new_pool_supply(&self) -> u128 {\n        INITIAL_SWAP_POOL_AMOUNT\n    }\n\n    /// Get the amount of trading tokens for the given amount of pool tokens,\n    /// provided the total trading tokens and supply of pool tokens.\n    fn pool_tokens_to_trading_tokens(\n        &self,\n        pool_tokens: u128,\n        pool_token_supply: u128,\n        swap_token_a_amount: u128,\n        swap_token_b_amount: u128,\n        round_direction: RoundDirection,\n    ) -> Option<TradingTokenResult>;\n\n    /// Get the amount of pool tokens for the deposited amount of token A or B.\n    ///\n    /// This is used for single-sided deposits.  It essentially performs a swap\n    /// followed by a deposit.  Because a swap is implicitly performed, this\n    /// will change the spot price of the pool.\n    ///\n    /// See more background for the calculation at:\n    ///\n    /// <https://balancer.finance/whitepaper/#single-asset-deposit-withdrawal>\n    fn deposit_single_token_type(\n        &self,\n        source_amount: u128,\n        swap_token_a_amount: u128,\n        swap_token_b_amount: u128,\n        pool_supply: u128,\n        trade_direction: TradeDirection,\n    ) -> Option<u128>;\n\n    /// Get the amount of pool tokens for the withdrawn amount of token A or B.\n    ///\n    /// This is used for single-sided withdrawals and owner trade fee\n    /// calculation. It essentially performs a withdrawal followed by a swap.\n    /// Because a swap is implicitly performed, this will change the spot price\n    /// of the pool.\n    ///\n    /// See more background for the calculation at:\n    ///\n    /// <https://balancer.finance/whitepaper/#single-asset-deposit-withdrawal>\n    fn withdraw_single_token_type_exact_out(\n        &self,\n        source_amount: u128,\n        swap_token_a_amount: u128,\n        swap_token_b_amount: u128,\n        pool_supply: u128,\n        trade_direction: TradeDirection,\n        round_direction: RoundDirection,\n    ) -> Option<u128>;\n\n    /// Validate that the given curve has no invalid parameters\n    fn validate(&self) -> Result<(), SwapError>;\n\n    /// Validate the given supply on initialization. This is useful for curves\n    /// that allow zero supply on one or both sides, since the standard constant\n    /// product curve must have a non-zero supply on both sides.\n    fn validate_supply(&self, token_a_amount: u64, token_b_amount: u64) -> Result<(), SwapError> {\n        if token_a_amount == 0 {\n            return Err(SwapError::EmptySupply);\n        }\n        if token_b_amount == 0 {\n            return Err(SwapError::EmptySupply);\n        }\n        Ok(())\n    }",
    "pub fn check_deposit_token_conversion(\n        curve: &dyn CurveCalculator,\n        source_token_amount: u128,\n        swap_source_amount: u128,\n        swap_destination_amount: u128,\n        trade_direction: TradeDirection,\n        pool_supply: u128,\n        epsilon_in_basis_points: u128,\n    ) {\n        let amount_to_swap = source_token_amount / 2;\n        let results = curve\n            .swap_without_fees(\n                amount_to_swap,\n                swap_source_amount,\n                swap_destination_amount,\n                trade_direction,\n            )\n            .unwrap();\n        let opposite_direction = trade_direction.opposite();\n        let (swap_token_a_amount, swap_token_b_amount) = match trade_direction {\n            TradeDirection::AtoB => (swap_source_amount, swap_destination_amount),\n            TradeDirection::BtoA => (swap_destination_amount, swap_source_amount),\n        };\n\n        // base amount\n        let pool_tokens_from_one_side = curve\n            .deposit_single_token_type(\n                source_token_amount,\n                swap_token_a_amount,\n                swap_token_b_amount,\n                pool_supply,\n                trade_direction,\n            )\n            .unwrap();\n\n        // perform both separately, updating amounts accordingly\n        let (swap_token_a_amount, swap_token_b_amount) = match trade_direction {\n            TradeDirection::AtoB => (\n                swap_source_amount + results.source_amount_swapped,\n                swap_destination_amount - results.destination_amount_swapped,\n            ),\n            TradeDirection::BtoA => (\n                swap_destination_amount - results.destination_amount_swapped,\n                swap_source_amount + results.source_amount_swapped,\n            ),\n        };\n        let pool_tokens_from_source = curve\n            .deposit_single_token_type(\n                source_token_amount - results.source_amount_swapped,\n                swap_token_a_amount,\n                swap_token_b_amount,\n                pool_supply,\n                trade_direction,\n            )\n            .unwrap();\n        let pool_tokens_from_destination = curve\n            .deposit_single_token_type(\n                results.destination_amount_swapped,\n                swap_token_a_amount,\n                swap_token_b_amount,\n                pool_supply + pool_tokens_from_source,\n                opposite_direction,\n            )\n            .unwrap();\n\n        let pool_tokens_total_separate = pool_tokens_from_source + pool_tokens_from_destination;\n\n        // slippage due to rounding or truncation errors\n        let epsilon = std::cmp::max(\n            1,\n            pool_tokens_total_separate * epsilon_in_basis_points / 10000,\n        );\n        let difference = if pool_tokens_from_one_side >= pool_tokens_total_separate {\n            pool_tokens_from_one_side - pool_tokens_total_separate\n        } else {\n            pool_tokens_total_separate - pool_tokens_from_one_side\n        };\n        assert!(\n            difference <= epsilon,\n            \"difference expected to be less than {}, actually {}\",\n            epsilon,\n            difference\n        );\n    }\n\n    /// Test function to check that withdrawing token A is the same as\n    /// withdrawing both and swapping one side.\n    /// Since calculations use unsigned integers, there will be truncation at\n    /// some point, meaning we can't have perfect equality.\n    /// We guarantee that the relative error between withdrawing one side and\n    /// performing a withdraw plus a swap will be at most some epsilon provided\n    /// by the curve. Most curves guarantee accuracy within 0.5%.\n    pub fn check_withdraw_token_conversion(\n        curve: &dyn CurveCalculator,\n        pool_token_amount: u128,\n        pool_token_supply: u128,\n        swap_token_a_amount: u128,\n        swap_token_b_amount: u128,\n        trade_direction: TradeDirection,\n        epsilon_in_basis_points: u128,\n    ) {\n        // withdraw the pool tokens\n        let withdraw_result = curve\n            .pool_tokens_to_trading_tokens(\n                pool_token_amount,\n                pool_token_supply,\n                swap_token_a_amount,\n                swap_token_b_amount,\n                RoundDirection::Floor,\n            )\n            .unwrap();\n\n        let new_swap_token_a_amount = swap_token_a_amount - withdraw_result.token_a_amount;\n        let new_swap_token_b_amount = swap_token_b_amount - withdraw_result.token_b_amount;\n\n        // swap one side of them\n        let source_token_amount = match trade_direction {\n            TradeDirection::AtoB => {\n                let results = curve\n                    .swap_without_fees(\n                        withdraw_result.token_a_amount,\n                        new_swap_token_a_amount,\n                        new_swap_token_b_amount,\n                        trade_direction,\n                    )\n                    .unwrap();\n                withdraw_result.token_b_amount + results.destination_amount_swapped\n            }\n            TradeDirection::BtoA => {\n                let results = curve\n                    .swap_without_fees(\n                        withdraw_result.token_b_amount,\n                        new_swap_token_b_amount,\n                        new_swap_token_a_amount,\n                        trade_direction,\n                    )\n                    .unwrap();\n                withdraw_result.token_a_amount + results.destination_amount_swapped\n            }\n        };\n\n        // see how many pool tokens it would cost to withdraw one side for the\n        // total amount of tokens, should be close!\n        let opposite_direction = trade_direction.opposite();\n        let pool_token_amount_from_single_side_withdraw = curve\n            .withdraw_single_token_type_exact_out(\n                source_token_amount,\n                swap_token_a_amount,\n                swap_token_b_amount,\n                pool_token_supply,\n                opposite_direction,\n                RoundDirection::Ceiling,\n            )\n            .unwrap();\n\n        // slippage due to rounding or truncation errors\n        let epsilon = std::cmp::max(1, pool_token_amount * epsilon_in_basis_points / 10000);\n        let difference = if pool_token_amount >= pool_token_amount_from_single_side_withdraw {\n            pool_token_amount - pool_token_amount_from_single_side_withdraw\n        } else {\n            pool_token_amount_from_single_side_withdraw - pool_token_amount\n        };\n        assert!(\n            difference <= epsilon,\n            \"difference expected to be less than {}, actually {}\",\n            epsilon,\n            difference\n        );\n    }\n\n    /// Test function checking that a swap never reduces the overall value of\n    /// the pool.\n    ///\n    /// Since curve calculations use unsigned integers, there is potential for\n    /// truncation at some point, meaning a potential for value to be lost in\n    /// either direction if too much is given to the swapper.\n    ///\n    /// This test guarantees that the relative change in value will be at most\n    /// 1 normalized token, and that the value will never decrease from a trade.\n    pub fn check_curve_value_from_swap(\n        curve: &dyn CurveCalculator,\n        source_token_amount: u128,\n        swap_source_amount: u128,\n        swap_destination_amount: u128,\n        trade_direction: TradeDirection,\n    ) {\n        let results = curve\n            .swap_without_fees(\n                source_token_amount,\n                swap_source_amount,\n                swap_destination_amount,\n                trade_direction,\n            )\n            .unwrap();\n\n        let (swap_token_a_amount, swap_token_b_amount) = match trade_direction {\n            TradeDirection::AtoB => (swap_source_amount, swap_destination_amount),\n            TradeDirection::BtoA => (swap_destination_amount, swap_source_amount),\n        };\n        let previous_value = curve\n            .normalized_value(swap_token_a_amount, swap_token_b_amount)\n            .unwrap();\n\n        let new_swap_source_amount = swap_source_amount\n            .checked_add(results.source_amount_swapped)\n            .unwrap();\n        let new_swap_destination_amount = swap_destination_amount\n            .checked_sub(results.destination_amount_swapped)\n            .unwrap();\n        let (swap_token_a_amount, swap_token_b_amount) = match trade_direction {\n            TradeDirection::AtoB => (new_swap_source_amount, new_swap_destination_amount),\n            TradeDirection::BtoA => (new_swap_destination_amount, new_swap_source_amount),\n        };\n\n        let new_value = curve\n            .normalized_value(swap_token_a_amount, swap_token_b_amount)\n            .unwrap();\n        assert!(new_value.greater_than_or_equal(&previous_value));\n\n        let epsilon = 1; // Extremely close!\n        let difference = new_value\n            .checked_sub(&previous_value)\n            .unwrap()\n            .to_imprecise()\n            .unwrap();\n        assert!(difference <= epsilon);\n    }\n\n    /// Test function checking that a deposit never reduces the value of pool\n    /// tokens.\n    ///\n    /// Since curve calculations use unsigned integers, there is potential for\n    /// truncation at some point, meaning a potential for value to be lost if\n    /// too much is given to the depositor.\n    pub fn check_pool_value_from_deposit(\n        curve: &dyn CurveCalculator,\n        pool_token_amount: u128,\n        pool_token_supply: u128,\n        swap_token_a_amount: u128,\n        swap_token_b_amount: u128,\n    ) {\n        let deposit_result = curve\n            .pool_tokens_to_trading_tokens(\n                pool_token_amount,\n                pool_token_supply,\n                swap_token_a_amount,\n                swap_token_b_amount,\n                RoundDirection::Ceiling,\n            )\n            .unwrap();\n        let new_swap_token_a_amount = swap_token_a_amount + deposit_result.token_a_amount;\n        let new_swap_token_b_amount = swap_token_b_amount + deposit_result.token_b_amount;\n        let new_pool_token_supply = pool_token_supply + pool_token_amount;\n\n        // the following inequality must hold:\n        // new_token_a / new_pool_token_supply >= token_a / pool_token_supply\n        // which reduces to:\n        // new_token_a * pool_token_supply >= token_a * new_pool_token_supply\n\n        // These numbers can be just slightly above u64 after the deposit, which\n        // means that their multiplication can be just above the range of u128.\n        // For ease of testing, we bump these up to U256.\n        let pool_token_supply = U256::from(pool_token_supply);\n        let new_pool_token_supply = U256::from(new_pool_token_supply);\n        let swap_token_a_amount = U256::from(swap_token_a_amount);\n        let new_swap_token_a_amount = U256::from(new_swap_token_a_amount);\n        let swap_token_b_amount = U256::from(swap_token_b_amount);\n        let new_swap_token_b_amount = U256::from(new_swap_token_b_amount);\n\n        assert!(\n            new_swap_token_a_amount * pool_token_supply\n                >= swap_token_a_amount * new_pool_token_supply\n        );\n        assert!(\n            new_swap_token_b_amount * pool_token_supply\n                >= swap_token_b_amount * new_pool_token_supply\n        );\n    }\n\n    /// Test function checking that a withdraw never reduces the value of pool\n    /// tokens.\n    ///\n    /// Since curve calculations use unsigned integers, there is potential for\n    /// truncation at some point, meaning a potential for value to be lost if\n    /// too much is given to the depositor.\n    pub fn check_pool_value_from_withdraw(\n        curve: &dyn CurveCalculator,\n        pool_token_amount: u128,\n        pool_token_supply: u128,\n        swap_token_a_amount: u128,\n        swap_token_b_amount: u128,\n    ) {\n        let withdraw_result = curve\n            .pool_tokens_to_trading_tokens(\n                pool_token_amount,\n                pool_token_supply,\n                swap_token_a_amount,\n                swap_token_b_amount,\n                RoundDirection::Floor,\n            )\n            .unwrap();\n        let new_swap_token_a_amount = swap_token_a_amount - withdraw_result.token_a_amount;\n        let new_swap_token_b_amount = swap_token_b_amount - withdraw_result.token_b_amount;\n        let new_pool_token_supply = pool_token_supply - pool_token_amount;\n\n        let value = curve\n            .normalized_value(swap_token_a_amount, swap_token_b_amount)\n            .unwrap();\n        // since we can get rounding issues on the pool value which make it seem that\n        // the value per token has gone down, we bump it up by an epsilon of 1\n        // to cover all cases\n        let new_value = curve\n            .normalized_value(new_swap_token_a_amount, new_swap_token_b_amount)\n            .unwrap();\n\n        // the following inequality must hold:\n        // new_pool_value / new_pool_token_supply >= pool_value / pool_token_supply\n        // which can also be written:\n        // new_pool_value * pool_token_supply >= pool_value * new_pool_token_supply\n\n        let pool_token_supply = PreciseNumber::new(pool_token_supply).unwrap();\n        let new_pool_token_supply = PreciseNumber::new(new_pool_token_supply).unwrap();\n        assert!(new_value\n            .checked_mul(&pool_token_supply)\n            .unwrap()\n            .greater_than_or_equal(&value.checked_mul(&new_pool_token_supply).unwrap()));\n    }\n\n    prop_compose! {\n        pub fn total_and_intermediate(max_value: u64)(total in 1..max_value)\n                        (intermediate in 1..total, total in Just(total))\n                        -> (u64, u64) {\n           (total, intermediate)\n       }",
    "pub fn trading_tokens_to_pool_tokens(\n    token_b_price: u64,\n    source_amount: u128,\n    swap_token_a_amount: u128,\n    swap_token_b_amount: u128,\n    pool_supply: u128,\n    trade_direction: TradeDirection,\n    round_direction: RoundDirection,\n) -> Option<u128> {\n    let token_b_price = U256::from(token_b_price);\n    let given_value = match trade_direction {\n        TradeDirection::AtoB => U256::from(source_amount),\n        TradeDirection::BtoA => U256::from(source_amount).checked_mul(token_b_price)?,\n    };\n    let total_value = U256::from(swap_token_b_amount)\n        .checked_mul(token_b_price)?\n        .checked_add(U256::from(swap_token_a_amount))?;\n    let pool_supply = U256::from(pool_supply);\n    match round_direction {\n        RoundDirection::Floor => Some(\n            pool_supply\n                .checked_mul(given_value)?\n                .checked_div(total_value)?\n                .as_u128(),\n        ),\n        RoundDirection::Ceiling => Some(\n            pool_supply\n                .checked_mul(given_value)?\n                .checked_ceil_div(total_value)?\n                .0\n                .as_u128(),\n        ),\n    }\n}\n\n/// ConstantPriceCurve struct implementing CurveCalculator\n#[derive(Clone, Debug, Default, PartialEq)]\npub struct ConstantPriceCurve {\n    /// Amount of token A required to get 1 token B\n    pub token_b_price: u64,\n}\n\nimpl CurveCalculator for ConstantPriceCurve {\n    /// Constant price curve always returns 1:1\n    fn swap_without_fees(\n        &self,\n        source_amount: u128,\n        _swap_source_amount: u128,\n        _swap_destination_amount: u128,\n        trade_direction: TradeDirection,\n    ) -> Option<SwapWithoutFeesResult> {\n        let token_b_price = self.token_b_price as u128;\n\n        let (source_amount_swapped, destination_amount_swapped) = match trade_direction {\n            TradeDirection::BtoA => (source_amount, source_amount.checked_mul(token_b_price)?),\n            TradeDirection::AtoB => {\n                let destination_amount_swapped = source_amount.checked_div(token_b_price)?;\n                let mut source_amount_swapped = source_amount;\n\n                // if there is a remainder from buying token B, floor\n                // token_a_amount to avoid taking too many tokens, but\n                // don't recalculate the fees\n                let remainder = source_amount_swapped.checked_rem(token_b_price)?;\n                if remainder > 0 {\n                    source_amount_swapped = source_amount.checked_sub(remainder)?;\n                }\n\n                (source_amount_swapped, destination_amount_swapped)\n            }",
    "pub fn swap(\n    source_amount: u128,\n    swap_source_amount: u128,\n    swap_destination_amount: u128,\n) -> Option<SwapWithoutFeesResult> {\n    let invariant = swap_source_amount.checked_mul(swap_destination_amount)?;\n\n    let new_swap_source_amount = swap_source_amount.checked_add(source_amount)?;\n    let (new_swap_destination_amount, new_swap_source_amount) =\n        invariant.checked_ceil_div(new_swap_source_amount)?;\n\n    let source_amount_swapped = new_swap_source_amount.checked_sub(swap_source_amount)?;\n    let destination_amount_swapped =\n        map_zero_to_none(swap_destination_amount.checked_sub(new_swap_destination_amount)?)?;\n\n    Some(SwapWithoutFeesResult {\n        source_amount_swapped,\n        destination_amount_swapped,\n    })\n}",
    "pub fn pool_tokens_to_trading_tokens(\n    pool_tokens: u128,\n    pool_token_supply: u128,\n    swap_token_a_amount: u128,\n    swap_token_b_amount: u128,\n    round_direction: RoundDirection,\n) -> Option<TradingTokenResult> {\n    let mut token_a_amount = pool_tokens\n        .checked_mul(swap_token_a_amount)?\n        .checked_div(pool_token_supply)?;\n    let mut token_b_amount = pool_tokens\n        .checked_mul(swap_token_b_amount)?\n        .checked_div(pool_token_supply)?;\n    let (token_a_amount, token_b_amount) = match round_direction {\n        RoundDirection::Floor => (token_a_amount, token_b_amount),\n        RoundDirection::Ceiling => {\n            let token_a_remainder = pool_tokens\n                .checked_mul(swap_token_a_amount)?\n                .checked_rem(pool_token_supply)?;\n            // Also check for 0 token A and B amount to avoid taking too much\n            // for tiny amounts of pool tokens.  For example, if someone asks\n            // for 1 pool token, which is worth 0.01 token A, we avoid the\n            // ceiling of taking 1 token A and instead return 0, for it to be\n            // rejected later in processing.\n            if token_a_remainder > 0 && token_a_amount > 0 {\n                token_a_amount += 1;\n            }\n            let token_b_remainder = pool_tokens\n                .checked_mul(swap_token_b_amount)?\n                .checked_rem(pool_token_supply)?;\n            if token_b_remainder > 0 && token_b_amount > 0 {\n                token_b_amount += 1;\n            }\n            (token_a_amount, token_b_amount)\n        }",
    "pub fn deposit_single_token_type(\n    source_amount: u128,\n    swap_token_a_amount: u128,\n    swap_token_b_amount: u128,\n    pool_supply: u128,\n    trade_direction: TradeDirection,\n    round_direction: RoundDirection,\n) -> Option<u128> {\n    let swap_source_amount = match trade_direction {\n        TradeDirection::AtoB => swap_token_a_amount,\n        TradeDirection::BtoA => swap_token_b_amount,\n    };\n    let swap_source_amount = PreciseNumber::new(swap_source_amount)?;\n    let source_amount = PreciseNumber::new(source_amount)?;\n    let ratio = source_amount.checked_div(&swap_source_amount)?;\n    let one = PreciseNumber::new(1)?;\n    let base = one.checked_add(&ratio)?;\n    let root = base.sqrt()?.checked_sub(&one)?;\n    let pool_supply = PreciseNumber::new(pool_supply)?;\n    let pool_tokens = pool_supply.checked_mul(&root)?;\n    match round_direction {\n        RoundDirection::Floor => pool_tokens.floor()?.to_imprecise(),\n        RoundDirection::Ceiling => pool_tokens.ceiling()?.to_imprecise(),\n    }\n}\n\n/// Get the amount of pool tokens for the withdrawn amount of token A or B.\n///\n/// The constant product implementation uses the Balancer formulas found at\n/// <https://balancer.finance/whitepaper/#single-asset-withdrawal>, specifically\n/// in the case for 2 tokens, each weighted at 1/2.\npub fn withdraw_single_token_type_exact_out(\n    source_amount: u128,\n    swap_token_a_amount: u128,\n    swap_token_b_amount: u128,\n    pool_supply: u128,\n    trade_direction: TradeDirection,\n    round_direction: RoundDirection,\n) -> Option<u128> {\n    let swap_source_amount = match trade_direction {\n        TradeDirection::AtoB => swap_token_a_amount,\n        TradeDirection::BtoA => swap_token_b_amount,\n    };\n    let swap_source_amount = PreciseNumber::new(swap_source_amount)?;\n    let source_amount = PreciseNumber::new(source_amount)?;\n    let ratio = source_amount.checked_div(&swap_source_amount)?;\n    let one = PreciseNumber::new(1)?;\n    let base = one\n        .checked_sub(&ratio)\n        .unwrap_or_else(|| PreciseNumber::new(0).unwrap());\n    let root = one.checked_sub(&base.sqrt()?)?;\n    let pool_supply = PreciseNumber::new(pool_supply)?;\n    let pool_tokens = pool_supply.checked_mul(&root)?;\n    match round_direction {\n        RoundDirection::Floor => pool_tokens.floor()?.to_imprecise(),\n        RoundDirection::Ceiling => pool_tokens.ceiling()?.to_imprecise(),\n    }\n}\n\n/// Calculates the total normalized value of the curve given the liquidity\n/// parameters.\n///\n/// The constant product implementation for this function gives the square root\n/// of the Uniswap invariant.\npub fn normalized_value(\n    swap_token_a_amount: u128,\n    swap_token_b_amount: u128,\n) -> Option<PreciseNumber> {\n    let swap_token_a_amount = PreciseNumber::new(swap_token_a_amount)?;\n    let swap_token_b_amount = PreciseNumber::new(swap_token_b_amount)?;\n    swap_token_a_amount\n        .checked_mul(&swap_token_b_amount)?\n        .sqrt()\n}",
    "pub fn calculate_fee(\n    token_amount: u128,\n    fee_numerator: u128,\n    fee_denominator: u128,\n) -> Option<u128> {\n    if fee_numerator == 0 || token_amount == 0 {\n        Some(0)\n    }",
    "pub fn owner_withdraw_fee(&self, pool_tokens: u128) -> Option<u128> {\n        calculate_fee(\n            pool_tokens,\n            u128::from(self.owner_withdraw_fee_numerator),\n            u128::from(self.owner_withdraw_fee_denominator),\n        )\n    }",
    "pub fn trading_fee(&self, trading_tokens: u128) -> Option<u128> {\n        calculate_fee(\n            trading_tokens,\n            u128::from(self.trade_fee_numerator),\n            u128::from(self.trade_fee_denominator),\n        )\n    }",
    "pub fn owner_trading_fee(&self, trading_tokens: u128) -> Option<u128> {\n        calculate_fee(\n            trading_tokens,\n            u128::from(self.owner_trade_fee_numerator),\n            u128::from(self.owner_trade_fee_denominator),\n        )\n    }",
    "pub fn pre_trading_fee_amount(&self, post_fee_amount: u128) -> Option<u128> {\n        if self.trade_fee_numerator == 0 || self.trade_fee_denominator == 0 {\n            pre_fee_amount(\n                post_fee_amount,\n                self.owner_trade_fee_numerator as u128,\n                self.owner_trade_fee_denominator as u128,\n            )\n        }",
    "pub fn host_fee(&self, owner_fee: u128) -> Option<u128> {\n        calculate_fee(\n            owner_fee,\n            u128::from(self.host_fee_numerator),\n            u128::from(self.host_fee_denominator),\n        )\n    }",
    "pub fn validate(&self) -> Result<(), SwapError> {\n        validate_fraction(self.trade_fee_numerator, self.trade_fee_denominator)?;\n        validate_fraction(\n            self.owner_trade_fee_numerator,\n            self.owner_trade_fee_denominator,\n        )?;\n        validate_fraction(\n            self.owner_withdraw_fee_numerator,\n            self.owner_withdraw_fee_denominator,\n        )?;\n        validate_fraction(self.host_fee_numerator, self.host_fee_denominator)?;\n        Ok(())\n    }",
    "pub fn values_sum_within_u64()(total in 1..u64::MAX)\n                        (amount in 1..total, total in Just(total))\n                        -> (u64, u64) {\n           (total - amount, amount)\n       }",
    "pub fn get_token_upgrade_authority_address(\n    original_mint: &Pubkey,\n    new_mint: &Pubkey,\n    program_id: &Pubkey,\n) -> Pubkey {\n    get_token_upgrade_authority_address_and_bump_seed(original_mint, new_mint, program_id).0\n}\n\npub(crate) fn get_token_upgrade_authority_address_and_bump_seed(\n    original_mint: &Pubkey,\n    new_mint: &Pubkey,\n    program_id: &Pubkey,\n) -> (Pubkey, u8) {\n    Pubkey::find_program_address(\n        &collect_token_upgrade_authority_seeds(original_mint, new_mint),\n        program_id,\n    )\n}",
    "pub fn get_wrapped_mint_address(\n    unwrapped_mint: &Pubkey,\n    wrapped_token_program_id: &Pubkey,\n) -> Pubkey {\n    get_wrapped_mint_address_with_seed(unwrapped_mint, wrapped_token_program_id).0\n}\n\nconst WRAPPED_MINT_AUTHORITY_SEED: &[u8] = br\"authority\";\n\npub(crate) fn get_wrapped_mint_authority_seeds(wrapped_mint: &Pubkey) -> [&[u8]; 2] {\n    [WRAPPED_MINT_AUTHORITY_SEED, wrapped_mint.as_ref()]\n}\n\npub(crate) fn _get_wrapped_mint_authority_signer_seeds<'a>(\n    wrapped_mint: &'a Pubkey,\n    bump_seed: &'a [u8],\n) -> [&'a [u8]; 3] {\n    [\n        WRAPPED_MINT_AUTHORITY_SEED,\n        wrapped_mint.as_ref(),\n        bump_seed,\n    ]\n}\n\npub(crate) fn get_wrapped_mint_authority_with_seed(wrapped_mint: &Pubkey) -> (Pubkey, u8) {\n    Pubkey::find_program_address(&get_wrapped_mint_authority_seeds(wrapped_mint), &id())\n}",
    "pub fn get_wrapped_mint_authority(wrapped_mint: &Pubkey) -> Pubkey {\n    get_wrapped_mint_authority_with_seed(wrapped_mint).0\n}\n\nconst WRAPPED_MINT_BACKPOINTER_SEED: &[u8] = br\"backpointer\";\n\npub(crate) fn get_wrapped_mint_backpointer_address_seeds(wrapped_mint: &Pubkey) -> [&[u8]; 2] {\n    [WRAPPED_MINT_BACKPOINTER_SEED, wrapped_mint.as_ref()]\n}\n\npub(crate) fn _get_wrapped_mint_backpointer_address_signer_seeds<'a>(\n    wrapped_mint: &'a Pubkey,\n    bump_seed: &'a [u8],\n) -> [&'a [u8]; 3] {\n    [\n        WRAPPED_MINT_BACKPOINTER_SEED,\n        wrapped_mint.as_ref(),\n        bump_seed,\n    ]\n}\n\npub(crate) fn get_wrapped_mint_backpointer_address_with_seed(\n    wrapped_mint: &Pubkey,\n) -> (Pubkey, u8) {\n    Pubkey::find_program_address(\n        &get_wrapped_mint_backpointer_address_seeds(wrapped_mint),\n        &id(),\n    )\n}"
  ],
  "cookbook": [
    "import { createSolanaClient } from \"gill\";\n\nconst { rpc, rpcSubscriptions } = createSolanaClient({\n  urlOrMoniker: \"devnet\", // or `mainnet`, `localnet`, etc\n});",
    "import { createSolanaRpc, createSolanaRpcSubscriptions, devnet } from \"gill\";\n\nconst rpc = createSolanaRpc(devnet(\"https://api.devnet.solana.com\"));\n\nconst rpcSubscriptions = createSolanaRpcSubscriptions(\n  devnet(\"wss://api.devnet.solana.com\"),\n);",
    "import {\n  address,\n  lamports,\n  airdropFactory,\n  createSolanaClient,\n  LAMPORTS_PER_SOL,\n} from \"gill\";\n\nconst { rpc, rpcSubscriptions, sendAndConfirmTransaction } = createSolanaClient(\n  {\n    urlOrMoniker: \"devnet\", // or `localnet`, etc\n  },\n);\n\nconst wallet = address(\"nick6zJc6HpW3kfBm4xS2dmbuVRyb5F3AnUvj5ymzR5\");\n\nconst { value: initialBalance } = await rpc.getBalance(wallet).send();\nconsole.log(\"Initial balance:\", initialBalance);\n\n/**\n * Note: the `devnet` and `testnet` clusters are subject to rate limits.\n * it is strongly recommended to use `localnet` and the local test validator\n */\nawait airdropFactory({ rpc, rpcSubscriptions })({\n  commitment: \"confirmed\",\n  lamports: lamports(LAMPORTS_PER_SOL), // request 1 SOL airdrop\n  recipientAddress: wallet,\n});\n\nconst { value: newBalance } = await rpc.getBalance(wallet).send();\nconsole.log(\"New balance:\", newBalance);",
    "import { clusterApiUrl, Connection, Keypair } from \"@solana/web3.js\";\n\n(async () => {\n  // Establish new connect to devnet - websocket client connected to devnet will also be registered here\n  const connection = new Connection(clusterApiUrl(\"devnet\"), \"confirmed\");\n\n  // Create a test wallet to listen to\n  const wallet = Keypair.generate();\n\n  // Register a callback to listen to the wallet (ws subscription)\n  connection.onAccountChange(\n    wallet.publicKey,\n    (updatedAccountInfo, context) =>\n      console.log(\"Updated account info: \", updatedAccountInfo),\n    \"confirmed\",\n  );\n})();",
    "import { generateKeyPairSigner } from \"gill\";\n\n// non-extractable and more secure keypair\nconst signer = await generateKeyPairSigner();\nconsole.log(\"address: \", signer.address);",
    "import { generateExtractableKeyPairSigner } from \"gill\";\n\n// extractable and less secure keypair\nconst extractableSigner = await generateExtractableKeyPairSigner();\nconsole.log(\"address: \", extractableSigner.address);",
    "import { createKeyPairSignerFromBytes } from \"gill\";\n\nconst keypairBytes = new Uint8Array([\n  174, 47, 154, 16, 202, 193, 206, 113, 199, 190, 53, 133, 169, 175, 31, 56,\n  222, 53, 138, 189, 224, 216, 117, 173, 10, 149, 53, 45, 73, 251, 237, 246, 15,\n  185, 186, 82, 177, 240, 148, 69, 241, 227, 167, 80, 141, 89, 240, 121, 121,\n  35, 172, 247, 68, 251, 226, 218, 48, 63, 176, 109, 168, 89, 238, 135,\n]);\n\nconst signer = await createKeyPairSignerFromBytes(keypairBytes);",
    "import { createKeypairSignerFromBase58 } from \"gill\";\n\nconst keypairBase58 =\n  \"5MaiiCavjCmn9Hs1o3eznqDEhRwxo7pXiAYez7keQUviUkauRiTMD8DrESdrNjN8zd9mTmVhRvBJeg5vhyvgrAhG\";\nconst signer = await createKeypairSignerFromBase58(keypairBase58);\nconsole.log(signer.address);\n// output: 5pVyoAeURQHNMVU7DmfMHvCDNmTEYXWfEwc136GYhTKG",
    "import { createKeyPairSignerFromBytes, address } from \"gill\";\n\nconst publicKey = address(\"24PNhTaNtomHhoy3fTRaMhAFCRj4uHqhZEEoWrKDbR5p\");\n\nconst keypairBytes = new Uint8Array([\n  174, 47, 154, 16, 202, 193, 206, 113, 199, 190, 53, 133, 169, 175, 31, 56,\n  222, 53, 138, 189, 224, 216, 117, 173, 10, 149, 53, 45, 73, 251, 237, 246, 15,\n  185, 186, 82, 177, 240, 148, 69, 241, 227, 167, 80, 141, 89, 240, 121, 121,\n  35, 172, 247, 68, 251, 226, 218, 48, 63, 176, 109, 168, 89, 238, 135,\n]);\n\nconst signer = await createKeyPairSignerFromBytes(keypairBytes);\n\nconsole.log(signer.address === publicKey);\n// output: true",
    "import { isAddress } from \"gill\";\n\n// Note that generateKeyPair() will always give a public key that is valid for users\n\n// Valid public key\nconst key = \"5oNDL3swdJJF1g9DzJiZ4ynHXgszjAEpUkxVYejchzrY\";\n\n// Lies on the ed25519 curve and is suitable for users\nconsole.log(\"Valid Address: \", isAddress(key));\n\n// Valid public key\nconst offCurveAddress = \"4BJXYkfvg37zEmBbsacZjeQDpTNx91KppxFJxRqrz48e\";\n\n// Not on the ed25519 curve, therefore not suitable for users\nconsole.log(\"Valid Off Curve Address: \", isAddress(offCurveAddress));\n\n// Not a valid public key\nconst errorPubkey = \"testPubkey\";\nconsole.log(\"Invalid Address: \", isAddress(errorPubkey));",
    "import * as bip39 from \"bip39\";\n\nconst mnemonic = bip39.generateMnemonic();",
    "import { Keypair } from \"@solana/web3.js\";\nimport * as bip39 from \"bip39\";\n\nconst mnemonic =\n  \"pill tomorrow foster begin walnut borrow virtual kick shift mutual shoe scatter\";\n\n// arguments: (mnemonic, password)\nconst seed = bip39.mnemonicToSeedSync(mnemonic, \"\");\nconst keypair = Keypair.fromSeed(seed.slice(0, 32));\n\nconsole.log(`${keypair.publicKey.toBase58()}`);\n\n// output: 5ZWj7a1f8tWkjBESHKgrLmXshuXxqeY9SYcfbshpAqPG",
    "import { Keypair } from \"@solana/web3.js\";\nimport { HDKey } from \"micro-ed25519-hdkey\";\nimport * as bip39 from \"bip39\";\n\nconst mnemonic =\n  \"neither lonely flavor argue grass remind eye tag avocado spot unusual intact\";\n\n// arguments: (mnemonic, password)\nconst seed = bip39.mnemonicToSeedSync(mnemonic, \"\");\nconst hd = HDKey.fromMasterSeed(seed.toString(\"hex\"));\n\nfor (let i = 0; i < 10; i++) {\n  const path = `m/44'/501'/${i}'/0'`;\n  const keypair = Keypair.fromSeed(hd.derive(path).privateKey);\n  console.log(`${path} => ${keypair.publicKey.toBase58()}`);\n}",
    "import {\n  generateKeyPair,\n  signBytes,\n  verifySignature,\n  getUtf8Encoder,\n  getBase58Decoder,\n} from \"@solana/kit\";\n\nconst keys = await generateKeyPair();\nconst message = getUtf8Encoder().encode(\"Hello, World!\");\nconst signedBytes = await signBytes(keys.privateKey, message);\n\nconst decoded = getBase58Decoder().decode(signedBytes);\nconsole.log(\"Signature:\", decoded);\n\nconst verified = await verifySignature(keys.publicKey, signedBytes, message);\nconsole.log(\"Verified:\", verified);",
    "npx create-solana-dapp <app-name>",
    "npm install --save \\\n    @solana/wallet-adapter-base \\\n    @solana/wallet-adapter-react \\\n    @solana/wallet-adapter-react-ui \\\n    @solana/wallet-adapter-wallets \\\n    @solana/web3.js@1 \\\n    react",
    "import React, { FC, useMemo } from 'react';\nimport { ConnectionProvider, WalletProvider } from '@solana/wallet-adapter-react';\nimport { WalletAdapterNetwork } from '@solana/wallet-adapter-base';\nimport { UnsafeBurnerWalletAdapter } from '@solana/wallet-adapter-wallets';\nimport {\n    WalletModalProvider,\n    WalletDisconnectButton,\n    WalletMultiButton\n} from '@solana/wallet-adapter-react-ui';\nimport { clusterApiUrl } from '@solana/web3.js';\n\n// Default styles that can be overridden by your app\nrequire('@solana/wallet-adapter-react-ui/styles.css');\n\nexport const Wallet: FC = () => {\n    // The network can be set to 'devnet', 'testnet', or 'mainnet-beta'.\n    const network = WalletAdapterNetwork.Devnet;\n\n    // You can also provide a custom RPC endpoint.\n    const endpoint = useMemo(() => clusterApiUrl(network), [network]);\n\n    const wallets = useMemo(\n        () => [\n            new UnsafeBurnerWalletAdapter(),\n        ],\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        [network]\n    );\n\n    return (\n        <ConnectionProvider endpoint={endpoint}>\n            <WalletProvider wallets={wallets} autoConnect>\n                <WalletModalProvider>\n                    <WalletMultiButton />\n                    <WalletDisconnectButton />\n                    { /* Your app's components go here, nested within the context providers. */ }\n                </WalletModalProvider>\n            </WalletProvider>\n        </ConnectionProvider>\n    );\n};",
    "import {\n  address,\n  lamports,\n  createTransaction,\n  createSolanaClient,\n  signTransactionMessageWithSigners,\n} from \"gill\";\nimport { loadKeypairSignerFromFile } from \"gill/node\";\nimport { getTransferSolInstruction } from \"gill/programs\";\n\nconst { rpc, sendAndConfirmTransaction } = createSolanaClient({\n  urlOrMoniker: \"devnet\",\n});\n\n// loads Signer from the default Solana CLI keypair path: `~/.config/solana/id.json`\nconst signer = await loadKeypairSignerFromFile();\n\nconst destination = address(\"nick6zJc6HpW3kfBm4xS2dmbuVRyb5F3AnUvj5ymzR5\");\n\nconst { value: latestBlockhash } = await rpc.getLatestBlockhash().send();\n\nconst tx = createTransaction({\n  version: \"legacy\",\n  feePayer: signer,\n  instructions: [\n    getTransferSolInstruction({\n      source: signer,\n      destination,\n      amount: lamports(1_000_000n),\n    }),\n  ],\n  latestBlockhash,\n});\n\nconst signedTransaction = await signTransactionMessageWithSigners(tx);\nawait sendAndConfirmTransaction(signedTransaction);",
    "import {\n  airdropFactory,\n  appendTransactionMessageInstructions,\n  compileTransactionMessage,\n  createSignerFromKeyPair,\n  createSolanaRpc,\n  createSolanaRpcSubscriptions,\n  createTransactionMessage,\n  devnet,\n  generateKeyPairSigner,\n  getBase64Decoder,\n  getCompiledTransactionMessageEncoder,\n  getComputeUnitEstimateForTransactionMessageFactory,\n  getSignatureFromTransaction,\n  lamports,\n  pipe,\n  prependTransactionMessageInstructions,\n  sendAndConfirmTransactionFactory,\n  setTransactionMessageFeePayerSigner,\n  setTransactionMessageLifetimeUsingBlockhash,\n  signTransactionMessageWithSigners,\n  type TransactionMessageBytesBase64,\n} from \"@solana/web3.js\";\nimport {\n  getSetComputeUnitLimitInstruction,\n  getSetComputeUnitPriceInstruction,\n} from \"@solana-program/compute-budget\";\nimport { getAddMemoInstruction } from \"@solana-program/memo\";\nimport { loadDefaultKeypairWithAirdrop } from \"./CreateKeypair\";\n\nasync function calculateCost(message: string) {\n  // Create an RPC.\n  const CLUSTER = \"devnet\";\n  const rpc = createSolanaRpc(devnet(`https://api.${CLUSTER}.solana.com`));\n  const rpcSubscriptions = createSolanaRpcSubscriptions(\n    devnet(`wss://api.${CLUSTER}.solana.com`),\n  );\n\n  // Create a utility that estimates a transaction message's compute consumption.\n  const getComputeUnitEstimate =\n    getComputeUnitEstimateForTransactionMessageFactory({ rpc });\n\n  // Create a transaction sending function.\n  const sendAndConfirmTransaction = sendAndConfirmTransactionFactory({\n    rpc,\n    rpcSubscriptions,\n  });\n\n  // Create an airdrop function.\n  const airdrop = airdropFactory({ rpc, rpcSubscriptions });\n\n  // Create and fund an account.\n  const signer = await generateKeyPairSigner();\n  console.log(\"Created an account with address\", signer.address);\n  console.log(\"Requesting airdrop\");\n  await airdrop({\n    commitment: \"confirmed\",\n    lamports: lamports(1000_000n),\n    recipientAddress: signer.address,\n  });\n  console.log(\"Airdrop confirmed\");\n\n  // Create a memo transaction.\n  console.log(\"Creating a memo transaction\");\n  const { value: latestBlockhash } = await rpc.getLatestBlockhash().send();\n  const transactionMessage = pipe(\n    createTransactionMessage({ version: \"legacy\" }),\n    m => setTransactionMessageFeePayerSigner(signer, m),\n    m => setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, m),\n    m =>\n      appendTransactionMessageInstructions(\n        [\n          getSetComputeUnitPriceInstruction({ microLamports: 5000n }),\n          getAddMemoInstruction({ memo: message }),\n        ],\n        m,\n      ),\n  );\n\n  // Figure out how many compute units to budget for this transaction\n  // so that you can right-size the compute budget to maximize the\n  // chance that it will be selected for inclusion into a block.\n  console.log(\"Estimating the compute consumption of the transaction\");\n  const estimatedComputeUnits =\n    await getComputeUnitEstimate(transactionMessage);\n  console.log(\n    `Transaction is estimated to consume ${estimatedComputeUnits} compute units`,\n  );\n\n  const budgetedTransactionMessage = prependTransactionMessageInstructions(\n    [getSetComputeUnitLimitInstruction({ units: estimatedComputeUnits })],\n    transactionMessage,\n  );\n\n  const base64EncodedMessage = pipe(\n    // Start with the message you want the fee for.\n    budgetedTransactionMessage,\n\n    // Compile it.\n    compileTransactionMessage,\n\n    // Convert the compiled message into a byte array.\n    getCompiledTransactionMessageEncoder().encode,\n\n    // Encode that byte array as a base64 string.\n    getBase64Decoder().decode,\n  ) as TransactionMessageBytesBase64;\n\n  const transactionCost = await rpc\n    .getFeeForMessage(base64EncodedMessage)\n    .send();\n\n  console.log(\n    \"Transaction is estimated to cost \" + transactionCost.value + \" lamports\",\n  );\n\n  // Sign and send the transaction.\n  console.log(\"Signing and sending the transaction\");\n  const signedTx = await signTransactionMessageWithSigners(\n    budgetedTransactionMessage,\n  );\n  const signature = getSignatureFromTransaction(signedTx);\n  console.log(\n    \"Sending transaction https://explorer.solana.com/tx/\" +\n      signature +\n      \"/?cluster=\" +\n      CLUSTER,\n  );\n  await sendAndConfirmTransaction(signedTx, { commitment: \"confirmed\" });\n  console.log(\"Transaction confirmed\");\n  // Transaction is estimated to consume 6236 compute units\n  // Transaction is estimated to cost 5032 lamports\n}\n\ncalculateCost(\"Hello, Fees!\");",
    "import {\n  getExplorerLink,\n  createTransaction,\n  createSolanaClient,\n  getSignatureFromTransaction,\n  signTransactionMessageWithSigners,\n} from \"gill\";\nimport { loadKeypairSignerFromFile } from \"gill/node\";\nimport { getAddMemoInstruction } from \"gill/programs\";\n\nconst { rpc, sendAndConfirmTransaction } = createSolanaClient({\n  urlOrMoniker: \"devnet\", // or `mainnet`, `localnet`, etc\n});\n\nconst { value: latestBlockhash } = await rpc.getLatestBlockhash().send();\n\n// load a Signer from the default Solana CLI keypair file\nconst signer = await loadKeypairSignerFromFile();\n\nconst transaction = createTransaction({\n  version: \"legacy\",\n  feePayer: signer,\n  instructions: [\n    getAddMemoInstruction({\n      memo: \"Memo message to send in this transaction\",\n    }),\n  ],\n  latestBlockhash,\n});\n\nconst signedTransaction = await signTransactionMessageWithSigners(transaction);\n\nconsole.log(\n  \"Sending transaction:\",\n  getExplorerLink({\n    cluster: \"devnet\",\n    transaction: getSignatureFromTransaction(signedTransaction),\n  }),\n);\n\nawait sendAndConfirmTransaction(signedTransaction);",
    "import {\n  getExplorerLink,\n  createTransaction,\n  createSolanaClient,\n  getSignatureFromTransaction,\n  signTransactionMessageWithSigners,\n} from \"gill\";\nimport { loadKeypairSignerFromFile } from \"gill/node\";\nimport {\n  getAddMemoInstruction,\n  getSetComputeUnitPriceInstruction,\n} from \"gill/programs\";\n\nconst { rpc, sendAndConfirmTransaction } = createSolanaClient({\n  urlOrMoniker: \"devnet\", // or `mainnet`, `localnet`, etc\n});\n\nconst { value: latestBlockhash } = await rpc.getLatestBlockhash().send();\n\n// load a Signer from the default Solana CLI keypair file\nconst signer = await loadKeypairSignerFromFile();\n\n// provide the `computeUnitPrice` value to set a priority fee\nconst transaction = createTransaction({\n  version: \"legacy\",\n  feePayer: signer,\n  instructions: [\n    getAddMemoInstruction({ memo: \"Memo message to send in this transaction\" }),\n  ],\n  latestBlockhash,\n  computeUnitPrice: 10_000, // set compute unit price of 10k micro-lamports per CU\n});\n\n// or you can manually add the compute unit price instruction to set a priority fee\nconst transaction2 = createTransaction({\n  version: \"legacy\",\n  feePayer: signer,\n  instructions: [\n    getAddMemoInstruction({ memo: \"Memo message to send in this transaction\" }),\n    getSetComputeUnitPriceInstruction({ microLamports: 10_000 }), // set compute unit price of 10k micro-lamports per CU\n  ],\n  latestBlockhash,\n});\n\nconst signedTransaction = await signTransactionMessageWithSigners(transaction);\n\nconsole.log(\n  \"Sending transaction:\",\n  getExplorerLink({\n    cluster: \"devnet\",\n    transaction: getSignatureFromTransaction(signedTransaction),\n  }),\n);\n\nawait sendAndConfirmTransaction(signedTransaction);",
    "// import { ... } from \"@solana/web3.js\"\n\nasync function buildOptimalTransaction(\n  connection: Connection,\n  instructions: Array<TransactionInstruction>,\n  signer: Signer,\n  lookupTables: Array<AddressLookupTableAccount>,\n) {\n  const [microLamports, units, recentBlockhash] = await Promise.all([\n    100 /* Get optimal priority fees - https://solana.com/developers/guides/advanced/how-to-use-priority-fees*/,\n    getSimulationComputeUnits(\n      connection,\n      instructions,\n      signer.publicKey,\n      lookupTables,\n    ),\n    connection.getLatestBlockhash(),\n  ]);\n\n  instructions.unshift(\n    ComputeBudgetProgram.setComputeUnitPrice({ microLamports }),\n  );\n  if (units) {\n    // probably should add some margin of error to units\n    instructions.unshift(ComputeBudgetProgram.setComputeUnitLimit({ units }));\n  }\n  return {\n    transaction: new VersionedTransaction(\n      new TransactionMessage({\n        instructions,\n        recentBlockhash: recentBlockhash.blockhash,\n        payerKey: signer.publicKey,\n      }).compileToV0Message(lookupTables),\n    ),\n    recentBlockhash,\n  };\n}",
    "import {\n  clusterApiUrl,\n  Connection,\n  Keypair,\n  Transaction,\n  SystemProgram,\n  LAMPORTS_PER_SOL,\n  Message,\n} from \"@solana/web3.js\";\nimport * as nacl from \"tweetnacl\";\nimport * as bs58 from \"bs58\";\n\n// To complete an offline transaction, I will separate them into four steps\n// 1. Create Transaction\n// 2. Sign Transaction\n// 3. Recover Transaction\n// 4. Send Transaction\n\n(async () => {\n  // create connection\n  const connection = new Connection(clusterApiUrl(\"devnet\"), \"confirmed\");\n\n  // create an example tx, alice transfer to bob and feePayer is `feePayer`\n  // alice and feePayer are signer in this tx\n  const feePayer = Keypair.generate();\n  await connection.confirmTransaction(\n    await connection.requestAirdrop(feePayer.publicKey, LAMPORTS_PER_SOL),\n  );\n  const alice = Keypair.generate();\n  await connection.confirmTransaction(\n    await connection.requestAirdrop(alice.publicKey, LAMPORTS_PER_SOL),\n  );\n  const bob = Keypair.generate();\n\n  // 1. Create Transaction\n  let tx = new Transaction().add(\n    SystemProgram.transfer({\n      fromPubkey: alice.publicKey,\n      toPubkey: bob.publicKey,\n      lamports: 0.1 * LAMPORTS_PER_SOL,\n    }),\n  );\n  tx.recentBlockhash = (await connection.getRecentBlockhash()).blockhash;\n  tx.feePayer = feePayer.publicKey;\n  let realDataNeedToSign = tx.serializeMessage(); // the real data singer need to sign.\n\n  // 2. Sign Transaction\n  // use any lib you like, the main idea is to use ed25519 to sign it.\n  // the return signature should be 64 bytes.\n  let feePayerSignature = nacl.sign.detached(\n    realDataNeedToSign,\n    feePayer.secretKey,\n  );\n  let aliceSignature = nacl.sign.detached(realDataNeedToSign, alice.secretKey);\n\n  // 3. Recover Transaction\n\n  // you can verify signatures before you recovering the transaction\n  let verifyFeePayerSignatureResult = nacl.sign.detached.verify(\n    realDataNeedToSign,\n    feePayerSignature,\n    feePayer.publicKey.toBytes(), // you should use the raw pubkey (32 bytes) to verify\n  );\n  console.log(`verify feePayer signature: ${verifyFeePayerSignatureResult}`);\n\n  let verifyAliceSignatureResult = nacl.sign.detached.verify(\n    realDataNeedToSign,\n    aliceSignature,\n    alice.publicKey.toBytes(),\n  );\n  console.log(`verify alice signature: ${verifyAliceSignatureResult}`);\n\n  // there are two ways you can recover the tx\n  // 3.a Recover Transaction (use populate then addSignature)\n  {\n    let recoverTx = Transaction.populate(Message.from(realDataNeedToSign));\n    recoverTx.addSignature(feePayer.publicKey, Buffer.from(feePayerSignature));\n    recoverTx.addSignature(alice.publicKey, Buffer.from(aliceSignature));\n\n    // 4. Send transaction\n    console.log(\n      `txhash: ${await connection.sendRawTransaction(recoverTx.serialize())}`,\n    );\n  }\n\n  // or\n\n  // 3.b. Recover Transaction (use populate with signature)\n  {\n    let recoverTx = Transaction.populate(Message.from(realDataNeedToSign), [\n      bs58.encode(feePayerSignature),\n      bs58.encode(aliceSignature),\n    ]);\n\n    // 4. Send transaction\n    console.log(\n      `txhash: ${await connection.sendRawTransaction(recoverTx.serialize())}`,\n    );\n  }\n\n  // if this process takes too long, your recent blockhash will expire (after 150 blocks).\n  // you can use `durable nonce` to get rid of it.\n})();",
    "import {\n  createTransferCheckedInstruction,\n  getAssociatedTokenAddress,\n  getMint,\n  getOrCreateAssociatedTokenAccount,\n} from \"@solana/spl-token\";\nimport {\n  clusterApiUrl,\n  Connection,\n  Keypair,\n  LAMPORTS_PER_SOL,\n  PublicKey,\n  SystemProgram,\n  Transaction,\n} from \"@solana/web3.js\";\nimport base58 from \"bs58\";\n\n/* The transaction:\n * - sends 0.01 SOL from Alice to Bob\n * - sends 1 token from Bob to Alice\n * - is partially signed by Bob, so Alice can approve + send it\n */\n\n(async () => {\n  const connection = new Connection(clusterApiUrl(\"devnet\"), \"confirmed\");\n\n  const alicePublicKey = new PublicKey(\n    \"5YNmS1R9nNSCDzb5a7mMJ1dwK9uHeAAF4CmPEwKgVWr8\",\n  );\n  const bobKeypair = Keypair.fromSecretKey(\n    base58.decode(\n      \"4NMwxzmYj2uvHuq8xoqhY8RXg63KSVJM1DXkpbmkUY7YQWuoyQgFnnzn6yo3CMnqZasnNPNuAT2TLwQsCaKkUddp\",\n    ),\n  );\n  const tokenAddress = new PublicKey(\n    \"Gh9ZwEmdLJ8DscKNTkTqPbNwLNNBjuSzaG9Vp2KGtKJr\",\n  );\n  const bobTokenAddress = await getAssociatedTokenAddress(\n    tokenAddress,\n    bobKeypair.publicKey,\n  );\n\n  // Alice may not have a token account, so Bob creates one if not\n  const aliceTokenAccount = await getOrCreateAssociatedTokenAccount(\n    connection,\n    bobKeypair, // Bob pays the fee to create it\n    tokenAddress, // which token the account is for\n    alicePublicKey, // who the token account is for\n  );\n\n  // Get the details about the token mint\n  const tokenMint = await getMint(connection, tokenAddress);\n\n  // Get a recent blockhash to include in the transaction\n  const { blockhash } = await connection.getLatestBlockhash(\"finalized\");\n\n  const transaction = new Transaction({\n    recentBlockhash: blockhash,\n    // Alice pays the transaction fee\n    feePayer: alicePublicKey,\n  });\n\n  // Transfer 0.01 SOL from Alice -> Bob\n  transaction.add(\n    SystemProgram.transfer({\n      fromPubkey: alicePublicKey,\n      toPubkey: bobKeypair.publicKey,\n      lamports: 0.01 * LAMPORTS_PER_SOL,\n    }),\n  );\n\n  // Transfer 1 token from Bob -> Alice\n  transaction.add(\n    createTransferCheckedInstruction(\n      bobTokenAddress, // source\n      tokenAddress, // mint\n      aliceTokenAccount.address, // destination\n      bobKeypair.publicKey, // owner of source account\n      1 * 10 ** tokenMint.decimals, // amount to transfer\n      tokenMint.decimals, // decimals of token\n    ),\n  );\n\n  // Partial sign as Bob\n  transaction.partialSign(bobKeypair);\n\n  // Serialize the transaction and convert to base64 to return it\n  const serializedTransaction = transaction.serialize({\n    // We will need Alice to deserialize and sign the transaction\n    requireAllSignatures: false,\n  });\n  const transactionBase64 = serializedTransaction.toString(\"base64\");\n  return transactionBase64;\n\n  // The caller of this can convert it back to a transaction object:\n  const recoveredTransaction = Transaction.from(\n    Buffer.from(transactionBase64, \"base64\"),\n  );\n})();",
    "import {\n  clusterApiUrl,\n  Connection,\n  Keypair,\n  Transaction,\n  NONCE_ACCOUNT_LENGTH,\n  SystemProgram,\n  LAMPORTS_PER_SOL,\n} from \"@solana/web3.js\";\n\n(async () => {\n  // Setup our connection and wallet\n  const connection = new Connection(clusterApiUrl(\"devnet\"), \"confirmed\");\n  const feePayer = Keypair.generate();\n\n  // Fund our wallet with 1 SOL\n  const airdropSignature = await connection.requestAirdrop(\n    feePayer.publicKey,\n    LAMPORTS_PER_SOL,\n  );\n  await connection.confirmTransaction(airdropSignature);\n\n  // you can use any keypair as nonce account authority,\n  // this uses the default Solana keypair file (id.json) as the nonce account authority\n  const nonceAccountAuth = await getKeypairFromFile();\n\n  let nonceAccount = Keypair.generate();\n  console.log(`nonce account: ${nonceAccount.publicKey.toBase58()}`);\n\n  let tx = new Transaction().add(\n    // create nonce account\n    SystemProgram.createAccount({\n      fromPubkey: feePayer.publicKey,\n      newAccountPubkey: nonceAccount.publicKey,\n      lamports:\n        await connection.getMinimumBalanceForRentExemption(\n          NONCE_ACCOUNT_LENGTH,\n        ),\n      space: NONCE_ACCOUNT_LENGTH,\n      programId: SystemProgram.programId,\n    }),\n    // init nonce account\n    SystemProgram.nonceInitialize({\n      noncePubkey: nonceAccount.publicKey, // nonce account pubkey\n      authorizedPubkey: nonceAccountAuth.publicKey, // nonce account authority (for advance and close)\n    }),\n  );\n\n  console.log(\n    `txhash: ${await sendAndConfirmTransaction(connection, tx, [feePayer, nonceAccount])}`,\n  );\n})();",
    "import {\n  clusterApiUrl,\n  Connection,\n  PublicKey,\n  Keypair,\n  NonceAccount,\n} from \"@solana/web3.js\";\n\n(async () => {\n  const connection = new Connection(clusterApiUrl(\"devnet\"), \"confirmed\");\n\n  const nonceAccountPubkey = new PublicKey(\n    \"7H18z3v3rZEoKiwY3kh8DLn9eFT6nFCQ2m4kiC7RZ3a4\",\n  );\n\n  let accountInfo = await connection.getAccountInfo(nonceAccountPubkey);\n  let nonceAccount = NonceAccount.fromAccountData(accountInfo.data);\n  console.log(`nonce: ${nonceAccount.nonce}`);\n  console.log(`authority: ${nonceAccount.authorizedPubkey.toBase58()}`);\n  console.log(`fee calculator: ${JSON.stringify(nonceAccount.feeCalculator)}`);\n})();",
    "import {\n  clusterApiUrl,\n  Connection,\n  PublicKey,\n  Keypair,\n  Transaction,\n  SystemProgram,\n  NonceAccount,\n  LAMPORTS_PER_SOL,\n} from \"@solana/web3.js\";\nimport * as bs58 from \"bs58\";\nimport { getKeypairFromFile } from \"@solana-developers/helpers\";\n\n(async () => {\n  // Setup our connection and wallet\n  const connection = new Connection(clusterApiUrl(\"devnet\"), \"confirmed\");\n  const feePayer = Keypair.generate();\n\n  // Fund our wallet with 1 SOL\n  const airdropSignature = await connection.requestAirdrop(\n    feePayer.publicKey,\n    LAMPORTS_PER_SOL,\n  );\n  await connection.confirmTransaction(airdropSignature);\n\n  // you can use any keypair as nonce account authority,\n  // but nonceAccountAuth must be the same as the one used in nonce account creation\n  // load default solana keypair for nonce account authority\n  const nonceAccountAuth = await getKeypairFromFile();\n\n  const nonceAccountPubkey = new PublicKey(\n    \"7H18z3v3rZEoKiwY3kh8DLn9eFT6nFCQ2m4kiC7RZ3a4\",\n  );\n  let nonceAccountInfo = await connection.getAccountInfo(nonceAccountPubkey);\n  let nonceAccount = NonceAccount.fromAccountData(nonceAccountInfo.data);\n\n  let tx = new Transaction().add(\n    // nonce advance must be the first instruction\n    SystemProgram.nonceAdvance({\n      noncePubkey: nonceAccountPubkey,\n      authorizedPubkey: nonceAccountAuth.publicKey,\n    }),\n    // after that, you do what you really want to do, here we append a transfer instruction as an example.\n    SystemProgram.transfer({\n      fromPubkey: feePayer.publicKey,\n      toPubkey: nonceAccountAuth.publicKey,\n      lamports: 1,\n    }),\n  );\n  // assign `nonce` as recentBlockhash\n  tx.recentBlockhash = nonceAccount.nonce;\n  tx.feePayer = feePayer.publicKey;\n  tx.sign(\n    feePayer,\n    nonceAccountAuth,\n  ); /* fee payer + nonce account authority + ... */\n\n  console.log(`txhash: ${await connection.sendRawTransaction(tx.serialize())}`);\n})();",
    "import {\n  createTransaction,\n  createSolanaClient,\n  signTransactionMessageWithSigners,\n  getMinimumBalanceForRentExemption,\n  generateKeyPairSigner,\n} from \"gill\";\nimport { loadKeypairSignerFromFile } from \"gill/node\";\nimport {\n  getCreateAccountInstruction,\n  SYSTEM_PROGRAM_ADDRESS,\n} from \"gill/programs\";\n\nconst { rpc, sendAndConfirmTransaction } = createSolanaClient({\n  urlOrMoniker: \"devnet\",\n});\n\nconst { value: latestBlockhash } = await rpc.getLatestBlockhash().send();\n\nconst signer = await loadKeypairSignerFromFile();\n\nconst newAccount = await generateKeyPairSigner();\n\nconst space = 0n; // any extra space in the account\n\nconst rentLamports = getMinimumBalanceForRentExemption(space);\n// const rentLamports = await rpc.getMinimumBalanceForRentExemption(space).send();\n\nconst tx = createTransaction({\n  version: \"legacy\",\n  feePayer: signer,\n  instructions: [\n    getCreateAccountInstruction({\n      lamports: rentLamports,\n      newAccount: newAccount,\n      payer: signer,\n      space: space,\n      // \"wallet\" accounts are owned by the system program\n      programAddress: SYSTEM_PROGRAM_ADDRESS,\n    }),\n  ],\n  latestBlockhash,\n});\n\nconst signedTransaction = await signTransactionMessageWithSigners(tx);\nawait sendAndConfirmTransaction(signedTransaction);",
    "import { getMinimumBalanceForRentExemption } from \"gill\";\n\n// allocate 1.5k bytes of extra space in the account for data\nconst space = 1500n;\n\nconst lamports = getMinimumBalanceForRentExemption(space);\nconsole.log(\"Minimum balance for rent exemption:\", lamports);",
    "import { createSolanaClient } from \"gill\";\n\nconst { rpc } = createSolanaClient({\n  urlOrMoniker: \"devnet\", // or `mainnet`, `localnet`, etc\n});\n\n// allocate 1.5k bytes of extra space in the account for data\nconst space = 1500n;\n\nconst lamports = await rpc.getMinimumBalanceForRentExemption(space).send();\nconsole.log(\"Minimum balance for rent exemption:\", lamports);",
    "import { PublicKey } from \"@solana/web3.js\";\n\nconst programId = new PublicKey(\"G1DCNUQTSGHehwdLCAmRyAG8hf51eCHrLNUqkgGKYASj\");\n\nlet [pda, bump] = PublicKey.findProgramAddressSync(\n  [Buffer.from(\"test\")],\n  programId,\n);\nconsole.log(`bump: ${bump}, pubkey: ${pda.toBase58()}`);\n// you will find the result is different from `createProgramAddress`.\n// It is expected because the real seed we used to calculate is [\"test\" + bump]",
    "use solana_program::{\n    account_info::next_account_info, account_info::AccountInfo, entrypoint,\n    entrypoint::ProgramResult, program::invoke_signed, pubkey::Pubkey, system_instruction, sysvar::{rent::Rent, Sysvar}\n};\n\nentrypoint!(process_instruction);\n\nfn process_instruction(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    instruction_data: &[u8],\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n\n    let payer_account_info = next_account_info(account_info_iter)?;\n    let pda_account_info = next_account_info(account_info_iter)?;\n    let rent_sysvar_account_info = &Rent::from_account_info(next_account_info(account_info_iter)?)?;\n\n    // find space and minimum rent required for account\n    let space = instruction_data[0];\n    let bump = instruction_data[1];\n    let rent_lamports = rent_sysvar_account_info.minimum_balance(space.into());\n\n    invoke_signed(\n        &system_instruction::create_account(\n            &payer_account_info.key,\n            &pda_account_info.key,\n            rent_lamports,\n            space.into(),\n            program_id\n        ),\n        &[\n            payer_account_info.clone(),\n            pda_account_info.clone()\n        ],\n        &[&[&payer_account_info.key.as_ref(), &[bump]]]\n    )?;\n\n    Ok(())\n}",
    "import {\n  clusterApiUrl,\n  Connection,\n  Keypair,\n  Transaction,\n  SystemProgram,\n  PublicKey,\n  TransactionInstruction,\n  LAMPORTS_PER_SOL,\n  SYSVAR_RENT_PUBKEY,\n} from \"@solana/web3.js\";\n\n(async () => {\n  // program id\n  const programId = new PublicKey(\n    \"7ZP42kRwUQ2zgbqXoaXzAFaiQnDyp6swNktTSv8mNQGN\",\n  );\n\n  // connection\n  const connection = new Connection(clusterApiUrl(\"devnet\"), \"confirmed\");\n\n  // setup fee payer\n  const feePayer = Keypair.generate();\n  const feePayerAirdropSignature = await connection.requestAirdrop(\n    feePayer.publicKey,\n    LAMPORTS_PER_SOL,\n  );\n  await connection.confirmTransaction(feePayerAirdropSignature);\n\n  // setup pda\n  let [pda, bump] = await PublicKey.findProgramAddress(\n    [feePayer.publicKey.toBuffer()],\n    programId,\n  );\n  console.log(`bump: ${bump}, pubkey: ${pda.toBase58()}`);\n\n  const data_size = 0;\n\n  let tx = new Transaction().add(\n    new TransactionInstruction({\n      keys: [\n        {\n          pubkey: feePayer.publicKey,\n          isSigner: true,\n          isWritable: true,\n        },\n        {\n          pubkey: pda,\n          isSigner: false,\n          isWritable: true,\n        },\n        {\n          pubkey: SYSVAR_RENT_PUBKEY,\n          isSigner: false,\n          isWritable: false,\n        },\n        {\n          pubkey: SystemProgram.programId,\n          isSigner: false,\n          isWritable: false,\n        },\n      ],\n      data: Buffer.from(new Uint8Array([data_size, bump])),\n      programId: programId,\n    }),\n  );\n\n  console.log(`txhash: ${await connection.sendTransaction(tx, [feePayer])}`);\n})();",
    "use solana_program::{\n    account_info::next_account_info, account_info::AccountInfo, entrypoint,\n    entrypoint::ProgramResult, program::invoke_signed, pubkey::Pubkey, system_instruction,\n};\n\nentrypoint!(process_instruction);\n\nfn process_instruction(\n    _program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    instruction_data: &[u8],\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n\n    let pda_account_info = next_account_info(account_info_iter)?;\n    let to_account_info = next_account_info(account_info_iter)?;\n    let system_program_account_info = next_account_info(account_info_iter)?;\n\n    // pass bump seed for saving compute budget\n    let bump_seed = instruction_data[0];\n\n    invoke_signed(\n        &system_instruction::transfer(\n            &pda_account_info.key,\n            &to_account_info.key,\n            100_000_000, // 0.1 SOL\n        ),\n        &[\n            pda_account_info.clone(),\n            to_account_info.clone(),\n            system_program_account_info.clone(),\n        ],\n        &[&[b\"escrow\", &[bump_seed]]],\n    )?;\n\n    Ok(())\n}\n",
    "use solana_program::{\n    account_info::next_account_info, account_info::AccountInfo, entrypoint,\n    entrypoint::ProgramResult, pubkey::Pubkey,\n};\n\nentrypoint!(process_instruction);\n\nfn process_instruction(\n    _program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    _instruction_data: &[u8],\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n\n    let source_account_info = next_account_info(account_info_iter)?;\n    let dest_account_info = next_account_info(account_info_iter)?;\n\n    let dest_starting_lamports = dest_account_info.lamports();\n    **dest_account_info.lamports.borrow_mut() = dest_starting_lamports\n        .checked_add(source_account_info.lamports())\n        .unwrap();\n    **source_account_info.lamports.borrow_mut() = 0;\n\n    source_account_info.assign(&system_program::ID);\n    source_account_info.realloc(0, false).map_err(Into::into)\n\n    Ok(())\n}",
    "import { createSolanaClient, LAMPORTS_PER_SOL, address } from \"gill\";\n\nconst { rpc } = createSolanaClient({\n  urlOrMoniker: \"devnet\", // or `mainnet`, `localnet`, etc\n});\n\nconst wallet = address(\"nicktrLHhYzLmoVbuZQzHUTicd2sfP571orwo9jfc8c\");\nconst { value: balance } = await rpc.getBalance(wallet).send();\nconsole.log(`Balance: ${Number(balance) / LAMPORTS_PER_SOL} SOL`);",
    "/// Transfers lamports from one account (must be program owned)\n/// to another account. The recipient can be any account\nfn transfer_service_fee_lamports(\n    from_account: &AccountInfo,\n    to_account: &AccountInfo,\n    amount_of_lamports: u64,\n) -> ProgramResult {\n    // Does the from account have enough lamports to transfer?\n    if **from_account.try_borrow_lamports()? < amount_of_lamports {\n        return Err(CustomError::InsufficientFundsForTransaction.into());\n    }\n    // Debit from_account and credit to_account\n    **from_account.try_borrow_mut_lamports()? -= amount_of_lamports;\n    **to_account.try_borrow_mut_lamports()? += amount_of_lamports;\n    Ok(())\n}\n\n/// Primary function handler associated with instruction sent\n/// to your program\nfn instruction_handler(accounts: &[AccountInfo]) -> ProgramResult {\n    // Get the 'from' and 'to' accounts\n    let account_info_iter = &mut accounts.iter();\n    let from_account = next_account_info(account_info_iter)?;\n    let to_service_account = next_account_info(account_info_iter)?;\n\n    // Extract a service 'fee' of 5 lamports for performing this instruction\n    transfer_service_fee_lamports(from_account, to_service_account, 5u64)?;\n\n    // Perform the primary instruction\n    // ... etc.\n\n    Ok(())\n}",
    "use borsh::{BorshDeserialize, BorshSerialize};\nuse solana_program::{\n    account_info::{next_account_info, AccountInfo},\n    clock::Clock,\n    entrypoint,\n    entrypoint::ProgramResult,\n    msg,\n    pubkey::Pubkey,\n    sysvar::Sysvar,\n};\n\nentrypoint!(process_instruction);\n\n#[derive(BorshSerialize, BorshDeserialize, Debug)]\npub struct HelloState {\n    is_initialized: bool,\n}\n\n// Accounts required\n/// 1. [signer, writable] Payer\n/// 2. [writable] Hello state account\n/// 3. [] Clock sys var\npub fn process_instruction(\n    _program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    _instruction_data: &[u8],\n) -> ProgramResult {\n    let accounts_iter = &mut accounts.iter();\n    // Payer account\n    let _payer_account = next_account_info(accounts_iter)?;\n    // Hello state account\n    let hello_state_account = next_account_info(accounts_iter)?;\n    // Clock sysvar\n    let sysvar_clock_pubkey = next_account_info(accounts_iter)?;\n\n    let mut hello_state = HelloState::try_from_slice(&hello_state_account.data.borrow())?;\n    hello_state.is_initialized = true;\n    hello_state.serialize(&mut &mut hello_state_account.data.borrow_mut()[..])?;\n    msg!(\"Account initialized :)\");\n\n    // Type casting [AccountInfo] to [Clock]\n    let clock = Clock::from_account_info(&sysvar_clock_pubkey)?;\n    // Getting timestamp\n    let current_timestamp = clock.unix_timestamp;\n    msg!(\"Current Timestamp: {}\", current_timestamp);\n\n    Ok(())\n}",
    "import {\n  clusterApiUrl,\n  Connection,\n  Keypair,\n  LAMPORTS_PER_SOL,\n  PublicKey,\n  SystemProgram,\n  SYSVAR_CLOCK_PUBKEY,\n  Transaction,\n  TransactionInstruction,\n  sendAndConfirmTransaction,\n} from \"@solana/web3.js\";\n\n(async () => {\n  const programId = new PublicKey(\n    \"77ezihTV6mTh2Uf3ggwbYF2NyGJJ5HHah1GrdowWJVD3\",\n  );\n\n  const connection = new Connection(clusterApiUrl(\"devnet\"), \"confirmed\");\n  const latestBlockHash = await connection.getLatestBlockhash();\n\n  // Airdropping 1 SOL\n  const feePayer = Keypair.generate();\n  await connection.confirmTransaction(\n    {\n      blockhash: latestBlockHash.blockhash,\n      lastValidBlockHeight: latestBlockHash.lastValidBlockHeight,\n      signature: await connection.requestAirdrop(\n        feePayer.publicKey,\n        LAMPORTS_PER_SOL,\n      ),\n    },\n    \"confirmed\",\n  );\n\n  // Hello state account\n  const helloAccount = Keypair.generate();\n\n  const accountSpace = 1; // because there exists just one boolean variable\n  const rentRequired =\n    await connection.getMinimumBalanceForRentExemption(accountSpace);\n\n  // Allocating space for hello state account\n  const allocateHelloAccountIx = SystemProgram.createAccount({\n    fromPubkey: feePayer.publicKey,\n    lamports: rentRequired,\n    newAccountPubkey: helloAccount.publicKey,\n    programId: programId,\n    space: accountSpace,\n  });\n\n  // Passing Clock Sys Var\n  const passClockIx = new TransactionInstruction({\n    programId: programId,\n    keys: [\n      {\n        isSigner: true,\n        isWritable: true,\n        pubkey: feePayer.publicKey,\n      },\n      {\n        isSigner: false,\n        isWritable: true,\n        pubkey: helloAccount.publicKey,\n      },\n      {\n        isSigner: false,\n        isWritable: false,\n        pubkey: SYSVAR_CLOCK_PUBKEY,\n      },\n    ],\n  });\n\n  const transaction = new Transaction();\n  transaction.add(allocateHelloAccountIx, passClockIx);\n\n  const txHash = await sendAndConfirmTransaction(connection, transaction, [\n    feePayer,\n    helloAccount,\n  ]);\n\n  console.log(`Transaction succeeded. TxHash: ${txHash}`);\n})();",
    "use borsh::{BorshDeserialize, BorshSerialize};\nuse solana_program::{\n    account_info::{next_account_info, AccountInfo},\n    clock::Clock,\n    entrypoint,\n    entrypoint::ProgramResult,\n    msg,\n    pubkey::Pubkey,\n    sysvar::Sysvar,\n};\n\nentrypoint!(process_instruction);\n\n#[derive(BorshSerialize, BorshDeserialize, Debug)]\npub struct HelloState {\n    is_initialized: bool,\n}\n\n// Accounts required\n/// 1. [signer, writable] Payer\n/// 2. [writable] Hello state account\npub fn process_instruction(\n    _program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    _instruction_data: &[u8],\n) -> ProgramResult {\n    let accounts_iter = &mut accounts.iter();\n    // Payer account\n    let _payer_account = next_account_info(accounts_iter)?;\n    // Hello state account\n    let hello_state_account = next_account_info(accounts_iter)?;\n\n    // Getting clock directly\n    let clock = Clock::get()?;\n\n    let mut hello_state = HelloState::try_from_slice(&hello_state_account.data.borrow())?;\n    hello_state.is_initialized = true;\n    hello_state.serialize(&mut &mut hello_state_account.data.borrow_mut()[..])?;\n    msg!(\"Account initialized :)\");\n\n    // Getting timestamp\n    let current_timestamp = clock.unix_timestamp;\n    msg!(\"Current Timestamp: {}\", current_timestamp);\n\n    Ok(())\n}",
    "import {\n  clusterApiUrl,\n  Connection,\n  Keypair,\n  LAMPORTS_PER_SOL,\n  PublicKey,\n  SystemProgram,\n  Transaction,\n  TransactionInstruction,\n} from \"@solana/web3.js\";\n\n(async () => {\n  const programId = new PublicKey(\n    \"4ZEdbCtb5UyCSiAMHV5eSHfyjq3QwbG3yXb6oHD7RYjk\",\n  );\n\n  const connection = new Connection(clusterApiUrl(\"devnet\"), \"confirmed\");\n  const latestBlockHash = await connection.getLatestBlockhash();\n\n  // Airdropping 1 SOL\n  const feePayer = Keypair.generate();\n  await connection.confirmTransaction(\n    {\n      blockhash: latestBlockHash.blockhash,\n      lastValidBlockHeight: latestBlockHash.lastValidBlockHeight,\n      signature: await connection.requestAirdrop(\n        feePayer.publicKey,\n        LAMPORTS_PER_SOL,\n      ),\n    },\n    \"confirmed\",\n  );\n\n  // Hello state account\n  const helloAccount = Keypair.generate();\n\n  const accountSpace = 1; // because there exists just one boolean variable\n  const rentRequired =\n    await connection.getMinimumBalanceForRentExemption(accountSpace);\n\n  // Allocating space for hello state account\n  const allocateHelloAccountIx = SystemProgram.createAccount({\n    fromPubkey: feePayer.publicKey,\n    lamports: rentRequired,\n    newAccountPubkey: helloAccount.publicKey,\n    programId: programId,\n    space: accountSpace,\n  });\n\n  const initIx = new TransactionInstruction({\n    programId: programId,\n    keys: [\n      {\n        isSigner: true,\n        isWritable: true,\n        pubkey: feePayer.publicKey,\n      },\n      {\n        isSigner: false,\n        isWritable: true,\n        pubkey: helloAccount.publicKey,\n      },\n    ],\n  });\n\n  const transaction = new Transaction();\n  transaction.add(allocateHelloAccountIx, initIx);\n\n  const txHash = await sendAndConfirmTransaction(connection, transaction, [\n    feePayer,\n    helloAccount,\n  ]);\n\n  console.log(`Transaction succeeded. TxHash: ${txHash}`);\n})();",
    "use {\n  crate::{\n      instruction::WhitelistInstruction,\n      state::WhiteListData,\n  },\n  borsh::{BorshDeserialize, BorshSerialize},\n  solana_program::{\n      account_info::{next_account_info, AccountInfo},\n      entrypoint::ProgramResult,\n      msg,\n      program::invoke_signed,\n      program::invoke,\n      program_error::ProgramError,\n      pubkey::Pubkey,\n      sysvar::Sysvar,\n      sysvar::rent::Rent,\n      system_instruction,\n  },\n  std::convert::TryInto,\n};\n\npub fn process_instruction(\n  _program_id: &Pubkey,\n  accounts: &[AccountInfo],\n  input: &[u8],\n) -> ProgramResult {\n  // Length = BOOL + VEC + Pubkey * n (n = number of keys)\n  const INITIAL_ACCOUNT_LEN: usize = 1 + 4 + 0 ;\n  msg!(\"input: {:?}\", input);\n\n  let instruction = WhitelistInstruction::try_from_slice(input)?;\n\n  let accounts_iter = &mut accounts.iter();\n\n  let funding_account = next_account_info(accounts_iter)?;\n  let pda_account = next_account_info(accounts_iter)?;\n  let system_program = next_account_info(accounts_iter)?;\n\n  match instruction {\n    WhitelistInstruction::Initialize => {\n      msg!(\"Initialize\");\n\n      let (pda, pda_bump) = Pubkey::find_program_address(\n          &[\n            b\"customaddress\",\n            &funding_account.key.to_bytes(),\n          ],\n          _program_id,\n      );\n\n      let signers_seeds: &[&[u8]; 3] = &[\n          b\"customaddress\",\n          &funding_account.key.to_bytes(),\n          &[pda_bump],\n      ];\n\n      if pda.ne(&pda_account.key) {\n          return Err(ProgramError::InvalidAccountData);\n      }\n\n      let lamports_required = Rent::get()?.minimum_balance(INITIAL_ACCOUNT_LEN);\n      let create_pda_account_ix = system_instruction::create_account(\n          &funding_account.key,\n          &pda_account.key,\n          lamports_required,\n          INITIAL_ACCOUNT_LEN.try_into().unwrap(),\n          &_program_id,\n      );\n\n      invoke_signed(\n          &create_pda_account_ix,\n          &[\n              funding_account.clone(),\n              pda_account.clone(),\n              system_program.clone(),\n          ],\n          &[signers_seeds],\n      )?;\n\n      let mut pda_account_state = WhiteListData::try_from_slice(&pda_account.data.borrow())?;\n\n      pda_account_state.is_initialized = true;\n      pda_account_state.white_list = Vec::new();\n      pda_account_state.serialize(&mut &mut pda_account.data.borrow_mut()[..])?;\n      Ok(())\n    }\n    WhitelistInstruction::AddKey { key } => {\n      msg!(\"AddKey\");\n\n      let mut pda_account_state = WhiteListData::try_from_slice(&pda_account.data.borrow())?;\n\n      if !pda_account_state.is_initialized {\n          return Err(ProgramError::InvalidAccountData);\n      }\n\n      let new_size = pda_account.data.borrow().len() + 32;\n\n      let rent = Rent::get()?;\n      let new_minimum_balance = rent.minimum_balance(new_size);\n\n      let lamports_diff = new_minimum_balance.saturating_sub(pda_account.lamports());\n      invoke(\n          &system_instruction::transfer(funding_account.key, pda_account.key, lamports_diff),\n          &[\n              funding_account.clone(),\n              pda_account.clone(),\n              system_program.clone(),\n          ],\n      )?;\n\n      pda_account.realloc(new_size, false)?;\n\n      pda_account_state.white_list.push(key);\n      pda_account_state.serialize(&mut &mut pda_account.data.borrow_mut()[..])?;\n\n      Ok(())\n    }\n  }\n}",
    "use solana_program::{\n    account_info::{next_account_info, AccountInfo},\n    entrypoint,\n    entrypoint::ProgramResult,\n    msg,\n    program::invoke,\n    program_error::ProgramError,\n    pubkey::Pubkey,\n};\nuse spl_token::instruction::transfer;\n\nentrypoint!(process_instruction);\n\n// Accounts required\n/// 1. [writable] Source Token Account\n/// 2. [writable] Destination Token Account\n/// 3. [signer] Source Token Account holder's PubKey\n/// 4. [] Token Program\npub fn process_instruction(\n    _program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    instruction_data: &[u8],\n) -> ProgramResult {\n    let accounts_iter = &mut accounts.iter();\n\n    // Accounts required for token transfer\n\n    // 1. Token account we hold\n    let source_token_account = next_account_info(accounts_iter)?;\n    // 2. Token account to send to\n    let destination_token_account = next_account_info(accounts_iter)?;\n    // 3. Our wallet address\n    let source_token_account_holder = next_account_info(accounts_iter)?;\n    // 4. Token Program\n    let token_program = next_account_info(accounts_iter)?;\n\n    // Parsing the token transfer amount from instruction data\n    // a. Getting the 0th to 8th index of the u8 byte array\n    // b. Converting the obtained non zero u8 to a proper u8 (as little endian integers)\n    // c. Converting the little endian integers to a u64 number\n    let token_transfer_amount = instruction_data\n        .get(..8)\n        .and_then(|slice| slice.try_into().ok())\n        .map(u64::from_le_bytes)\n        .ok_or(ProgramError::InvalidAccountData)?;\n\n    msg!(\n        \"Transferring {} tokens from {} to {}\",\n        token_transfer_amount,\n        source_token_account.key.to_string(),\n        destination_token_account.key.to_string()\n    );\n\n    // Creating a new TransactionInstruction\n    /*\n        Internal representation of the instruction's return value (Result<Instruction, ProgramError>)\n\n        Ok(Instruction {\n            program_id: *token_program_id, // PASSED FROM USER\n            accounts,\n            data,\n        })\n    */\n\n    let transfer_tokens_instruction = transfer(\n        &token_program.key,\n        &source_token_account.key,\n        &destination_token_account.key,\n        &source_token_account_holder.key,\n        &[&source_token_account_holder.key],\n        token_transfer_amount,\n    )?;\n\n    let required_accounts_for_transfer = [\n        source_token_account.clone(),\n        destination_token_account.clone(),\n        source_token_account_holder.clone(),\n    ];\n\n    // Passing the TransactionInstruction to send\n    invoke(\n        &transfer_tokens_instruction,\n        &required_accounts_for_transfer,\n    )?;\n\n    msg!(\"Transfer successful\");\n\n    Ok(())\n}",
    "import {\n  clusterApiUrl,\n  Connection,\n  Keypair,\n  LAMPORTS_PER_SOL,\n  PublicKey,\n  SystemProgram,\n  sendAndConfirmTransaction\n  Transaction,\n  TransactionInstruction,\n} from \"@solana/web3.js\";\nimport {\n  AccountLayout,\n  MintLayout,\n  Token,\n  TOKEN_PROGRAM_ID,\n  u64,\n} from \"@solana/spl-token\";\n\nimport * as BN from \"bn.js\";\n\n// Users\nconst PAYER_KEYPAIR = Keypair.generate();\nconst RECEIVER_KEYPAIR = Keypair.generate().publicKey;\n\n// Mint and token accounts\nconst TOKEN_MINT_ACCOUNT = Keypair.generate();\nconst SOURCE_TOKEN_ACCOUNT = Keypair.generate();\nconst DESTINATION_TOKEN_ACCOUNT = Keypair.generate();\n\n// Numbers\nconst DEFAULT_DECIMALS_COUNT = 9;\nconst TOKEN_TRANSFER_AMOUNT = 50 * 10 ** DEFAULT_DECIMALS_COUNT;\nconst TOKEN_TRANSFER_AMOUNT_BUFFER = Buffer.from(\n  Uint8Array.of(...new BN(TOKEN_TRANSFER_AMOUNT).toArray(\"le\", 8))\n);\n\n(async () => {\n  const connection = new Connection(clusterApiUrl(\"devnet\"), \"confirmed\");\n  const programId = new PublicKey(\n    \"EfYK91eN3AqTwY1C34W6a33qGAtQ8HJYVhNv7cV4uMZj\"\n  );\n\n  const mintDataSpace = MintLayout.span;\n  const mintRentRequired = await connection.getMinimumBalanceForRentExemption(\n    mintDataSpace\n  );\n\n  const tokenDataSpace = AccountLayout.span;\n  const tokenRentRequired = await connection.getMinimumBalanceForRentExemption(\n    tokenDataSpace\n  );\n\n  // Airdropping 1 SOL\n  const feePayer = Keypair.generate();\n  await connection.confirmTransaction({\n      blockhash: latestBlockHash.blockhash,\n      lastValidBlockHeight: latestBlockHash.lastValidBlockHeight,\n      signature: await connection.requestAirdrop(feePayer.publicKey, LAMPORTS_PER_SOL),\n    },\n    'confirmed',\n  );\n\n\n  // Allocating space and rent for mint account\n  const createMintAccountIx = SystemProgram.createAccount({\n    fromPubkey: PAYER_KEYPAIR.publicKey,\n    lamports: mintRentRequired,\n    newAccountPubkey: TOKEN_MINT_ACCOUNT.publicKey,\n    programId: TOKEN_PROGRAM_ID,\n    space: mintDataSpace,\n  });\n\n  // Initializing mint with decimals and authority\n  const initializeMintIx = Token.createInitMintInstruction(\n    TOKEN_PROGRAM_ID,\n    TOKEN_MINT_ACCOUNT.publicKey,\n    DEFAULT_DECIMALS_COUNT,\n    PAYER_KEYPAIR.publicKey, // mintAuthority\n    PAYER_KEYPAIR.publicKey // freezeAuthority\n  );\n\n  // Allocating space and rent for source token account\n  const createSourceTokenAccountIx = SystemProgram.createAccount({\n    fromPubkey: PAYER_KEYPAIR.publicKey,\n    newAccountPubkey: SOURCE_TOKEN_ACCOUNT.publicKey,\n    lamports: tokenRentRequired,\n    programId: TOKEN_PROGRAM_ID,\n    space: tokenDataSpace,\n  });\n\n  // Initializing token account with mint and owner\n  const initializeSourceTokenAccountIx = Token.createInitAccountInstruction(\n    TOKEN_PROGRAM_ID,\n    TOKEN_MINT_ACCOUNT.publicKey,\n    SOURCE_TOKEN_ACCOUNT.publicKey,\n    PAYER_KEYPAIR.publicKey\n  );\n\n  // Minting tokens to the source token account for transferring later to destination account\n  const mintTokensIx = Token.createMintToInstruction(\n    TOKEN_PROGRAM_ID,\n    TOKEN_MINT_ACCOUNT.publicKey,\n    SOURCE_TOKEN_ACCOUNT.publicKey,\n    PAYER_KEYPAIR.publicKey,\n    [PAYER_KEYPAIR],\n    TOKEN_TRANSFER_AMOUNT\n  );\n\n  // Allocating space and rent for destination token account\n  const createDestinationTokenAccountIx = SystemProgram.createAccount({\n    fromPubkey: PAYER_KEYPAIR.publicKey,\n    newAccountPubkey: DESTINATION_TOKEN_ACCOUNT.publicKey,\n    lamports: tokenRentRequired,\n    programId: TOKEN_PROGRAM_ID,\n    space: tokenDataSpace,\n  });\n\n  // Initializing token account with mint and owner\n  const initializeDestinationTokenAccountIx =\n    Token.createInitAccountInstruction(\n      TOKEN_PROGRAM_ID,\n      TOKEN_MINT_ACCOUNT.publicKey,\n      DESTINATION_TOKEN_ACCOUNT.publicKey,\n      RECEIVER_KEYPAIR\n    );\n\n  // Our program's CPI instruction (transfer)\n  const transferTokensIx = new TransactionInstruction({\n    programId: programId,\n    data: TOKEN_TRANSFER_AMOUNT_BUFFER,\n    keys: [\n      {\n        isSigner: false,\n        isWritable: true,\n        pubkey: SOURCE_TOKEN_ACCOUNT.publicKey,\n      },\n      {\n        isSigner: false,\n        isWritable: true,\n        pubkey: DESTINATION_TOKEN_ACCOUNT.publicKey,\n      },\n      {\n        isSigner: true,\n        isWritable: true,\n        pubkey: PAYER_KEYPAIR.publicKey,\n      },\n      {\n        isSigner: false,\n        isWritable: false,\n        pubkey: TOKEN_PROGRAM_ID,\n      },\n    ],\n  });\n\n  const transaction = new Transaction();\n  // Adding up all the above instructions\n  transaction.add(\n    createMintAccountIx,\n    initializeMintIx,\n    createSourceTokenAccountIx,\n    initializeSourceTokenAccountIx,\n    mintTokensIx,\n    createDestinationTokenAccountIx,\n    initializeDestinationTokenAccountIx,\n    transferTokensIx\n  );\n\n  const txHash = await sendAndConfirmTransaction(connection, transaction, [\n    PAYER_KEYPAIR,\n    TOKEN_MINT_ACCOUNT,\n    SOURCE_TOKEN_ACCOUNT,\n    DESTINATION_TOKEN_ACCOUNT,\n  ]);\n\n  console.log(`Token transfer CPI success: ${txHash}`);\n})();",
    "use solana_program::{\n    account_info::{next_account_info, AccountInfo},\n    entrypoint,\n    entrypoint::ProgramResult,\n    msg,\n    program::invoke,\n    program_error::ProgramError,\n    pubkey::Pubkey,\n    rent::Rent,\n    system_instruction::create_account,\n    sysvar::Sysvar,\n};\n\nentrypoint!(process_instruction);\n\n// Accounts required\n/// 1. [signer, writable] Payer Account\n/// 2. [signer, writable] General State Account\n/// 3. [] System Program\npub fn process_instruction(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    instruction_data: &[u8],\n) -> ProgramResult {\n    let accounts_iter = &mut accounts.iter();\n\n    // Accounts required for token transfer\n\n    // 1. Payer account for the state account creation\n    let payer_account = next_account_info(accounts_iter)?;\n    // 2. Token account we hold\n    let general_state_account = next_account_info(accounts_iter)?;\n    // 3. System Program\n    let system_program = next_account_info(accounts_iter)?;\n\n    msg!(\n        \"Creating account for {}\",\n        general_state_account.key.to_string()\n    );\n\n    // Parsing the token transfer amount from instruction data\n    // a. Getting the 0th to 8th index of the u8 byte array\n    // b. Converting the obtained non zero u8 to a proper u8 (as little endian integers)\n    // c. Converting the little endian integers to a u64 number\n    let account_span = instruction_data\n        .get(..8)\n        .and_then(|slice| slice.try_into().ok())\n        .map(u64::from_le_bytes)\n        .ok_or(ProgramError::InvalidAccountData)?;\n\n    let lamports_required = (Rent::get()?).minimum_balance(account_span as usize);\n\n    // Creating a new TransactionInstruction\n    /*\n        Internal representation of the instruction's return value (Instruction)\n\n        Instruction::new_with_bincode(\n            system_program::id(), // NOT PASSED FROM USER\n            &SystemInstruction::CreateAccount {\n                lamports,\n                space,\n                owner: *owner,\n            },\n            account_metas,\n        )\n    */\n\n    let create_account_instruction = create_account(\n        &payer_account.key,\n        &general_state_account.key,\n        lamports_required,\n        account_span,\n        program_id,\n    );\n\n    let required_accounts_for_create = [\n        payer_account.clone(),\n        general_state_account.clone(),\n        system_program.clone(),\n    ];\n\n    // Passing the TransactionInstruction to send (with the issued program_id)\n    invoke(&create_account_instruction, &required_accounts_for_create)?;\n\n    msg!(\"Transfer successful\");\n\n    Ok(())\n}",
    "import { clusterApiUrl, Connection, Keypair } from \"@solana/web3.js\";\nimport { LAMPORTS_PER_SOL, PublicKey, SystemProgram } from \"@solana/web3.js\";\nimport {\n  Transaction,\n  TransactionInstruction,\n  sendAndConfirmTransaction,\n} from \"@solana/web3.js\";\n\nimport * as BN from \"bn.js\";\n\n// Users\nconst PAYER_KEYPAIR = Keypair.generate();\nconst GENERAL_STATE_KEYPAIR = Keypair.generate();\n\nconst ACCOUNT_SPACE_BUFFER = Buffer.from(\n  Uint8Array.of(...new BN(100).toArray(\"le\", 8)),\n);\n\n(async () => {\n  const connection = new Connection(clusterApiUrl(\"devnet\"), \"confirmed\");\n  const latestBlockHash = await connection.getLatestBlockhash();\n  const programId = new PublicKey(\n    \"DkuQ5wsndkzXfgqDB6Lgf4sDjBi4gkLSak1dM5Mn2RuQ\",\n  );\n\n  // Airdropping 1 SOL\n  const feePayer = Keypair.generate();\n  await connection.confirmTransaction(\n    {\n      blockhash: latestBlockHash.blockhash,\n      lastValidBlockHeight: latestBlockHash.lastValidBlockHeight,\n      signature: await connection.requestAirdrop(\n        feePayer.publicKey,\n        LAMPORTS_PER_SOL,\n      ),\n    },\n    \"confirmed\",\n  );\n\n  // Our program's CPI instruction (create_account)\n  const createAccountIx = new TransactionInstruction({\n    programId: programId,\n    data: ACCOUNT_SPACE_BUFFER,\n    keys: [\n      {\n        isSigner: true,\n        isWritable: true,\n        pubkey: PAYER_KEYPAIR.publicKey,\n      },\n      {\n        isSigner: true,\n        isWritable: true,\n        pubkey: GENERAL_STATE_KEYPAIR.publicKey,\n      },\n      {\n        isSigner: false,\n        isWritable: false,\n        pubkey: SystemProgram.programId,\n      },\n    ],\n  });\n\n  const transaction = new Transaction();\n  // Adding up all the above instructions\n  transaction.add(createAccountIx);\n\n  const txHash = await sendAndConfirmTransaction(connection, transaction, [\n    PAYER_KEYPAIR,\n    GENERAL_STATE_KEYPAIR,\n  ]);\n\n  console.log(`Create Account CPI Success: ${txHash}`);\n})();",
    "use borsh::{BorshDeserialize, BorshSerialize};\nuse solana_program::{\n    account_info::{next_account_info, AccountInfo},\n    entrypoint,\n    entrypoint::ProgramResult,\n    program::invoke_signed,\n    program_error::ProgramError,\n    pubkey::Pubkey,\n    rent::Rent,\n    system_instruction,\n    sysvar::Sysvar,\n};\n\nentrypoint!(process_instruction);\n\n#[derive(BorshSerialize, BorshDeserialize, Debug)]\npub struct HelloState {\n    is_initialized: bool,\n}\n\n// Accounts required\n/// 1. [signer, writable] Funding account\n/// 2. [writable] PDA account\n/// 3. [] System Program\npub fn process_instruction(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    instruction_data: &[u8],\n) -> ProgramResult {\n    const ACCOUNT_DATA_LEN: usize = 1;\n\n    let accounts_iter = &mut accounts.iter();\n    // Getting required accounts\n    let funding_account = next_account_info(accounts_iter)?;\n    let pda_account = next_account_info(accounts_iter)?;\n    let system_program = next_account_info(accounts_iter)?;\n\n    // Getting PDA Bump from instruction data\n    let (pda_bump, _) = instruction_data\n        .split_first()\n        .ok_or(ProgramError::InvalidInstructionData)?;\n\n    // Checking if passed PDA and expected PDA are equal\n    let signers_seeds: &[&[u8]; 3] = &[\n        b\"customaddress\",\n        &funding_account.key.to_bytes(),\n        &[*pda_bump],\n    ];\n    let pda = Pubkey::create_program_address(signers_seeds, program_id)?;\n\n    if pda.ne(&pda_account.key) {\n        return Err(ProgramError::InvalidAccountData);\n    }\n\n    // Assessing required lamports and creating transaction instruction\n    let lamports_required = Rent::get()?.minimum_balance(ACCOUNT_DATA_LEN);\n    let create_pda_account_ix = system_instruction::create_account(\n        &funding_account.key,\n        &pda_account.key,\n        lamports_required,\n        ACCOUNT_DATA_LEN.try_into().unwrap(),\n        &program_id,\n    );\n    // Invoking the instruction but with PDAs as additional signer\n    invoke_signed(\n        &create_pda_account_ix,\n        &[\n            funding_account.clone(),\n            pda_account.clone(),\n            system_program.clone(),\n        ],\n        &[signers_seeds],\n    )?;\n\n    // Setting state for PDA\n    let mut pda_account_state = HelloState::try_from_slice(&pda_account.data.borrow())?;\n    pda_account_state.is_initialized = true;\n    pda_account_state.serialize(&mut &mut pda_account.data.borrow_mut()[..])?;\n\n    Ok(())\n}",
    "import {\n  clusterApiUrl,\n  Connection,\n  Keypair,\n  LAMPORTS_PER_SOL,\n  PublicKey,\n  sendAndConfirmTransaction,\n  SystemProgram,\n  Transaction,\n  TransactionInstruction,\n} from \"@solana/web3.js\";\n\nconst PAYER_KEYPAIR = Keypair.generate();\n\n(async () => {\n  const connection = new Connection(clusterApiUrl(\"devnet\"), \"confirmed\");\n  const latestBlockHash = await connection.getLatestBlockhash();\n  const programId = new PublicKey(\n    \"6eW5nnSosr2LpkUGCdznsjRGDhVb26tLmiM1P8RV1QQp\",\n  );\n\n  // Airdrop to Payer\n  await connection.confirmTransaction(\n    {\n      blockhash: latestBlockHash.blockhash,\n      lastValidBlockHeight: latestBlockHash.lastValidBlockHeight,\n      signature: await connection.requestAirdrop(\n        PAYER_KEYPAIR.publicKey,\n        LAMPORTS_PER_SOL,\n      ),\n    },\n    \"confirmed\",\n  );\n\n  const [pda, bump] = await PublicKey.findProgramAddress(\n    [Buffer.from(\"customaddress\"), PAYER_KEYPAIR.publicKey.toBuffer()],\n    programId,\n  );\n\n  console.log(`PDA Pubkey: ${pda.toString()}`);\n\n  const createPDAIx = new TransactionInstruction({\n    programId: programId,\n    data: Buffer.from(Uint8Array.of(bump)),\n    keys: [\n      {\n        isSigner: true,\n        isWritable: true,\n        pubkey: PAYER_KEYPAIR.publicKey,\n      },\n      {\n        isSigner: false,\n        isWritable: true,\n        pubkey: pda,\n      },\n      {\n        isSigner: false,\n        isWritable: false,\n        pubkey: SystemProgram.programId,\n      },\n    ],\n  });\n\n  const transaction = new Transaction();\n  transaction.add(createPDAIx);\n\n  const txHash = await sendAndConfirmTransaction(connection, transaction, [\n    PAYER_KEYPAIR,\n  ]);\n  console.log(`Created PDA successfully. Tx Hash: ${txHash}`);\n})();",
    "use borsh::{BorshDeserialize, BorshSerialize};\nuse solana_program::{\n    account_info::{next_account_info, AccountInfo},\n    entrypoint,\n    entrypoint::ProgramResult,\n    pubkey::Pubkey,\n};\n\nentrypoint!(process_instruction);\n\n#[derive(BorshSerialize, BorshDeserialize, Debug)]\npub struct HelloState {\n    is_initialized: bool,\n}\n\n// Accounts required\n/// 1. [signer] Payer\n/// 2. [writable] Hello state account\n/// 3. [] Rent account\n/// 4. [] System Program\npub fn process_instruction(\n    _program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    _instruction_data: &[u8],\n) -> ProgramResult {\n    // Fetching all the accounts as a iterator (facilitating for loops and iterations)\n    let accounts_iter = &mut accounts.iter();\n    // Payer account\n    let payer_account = next_account_info(accounts_iter)?;\n    // Hello state account\n    let hello_state_account = next_account_info(accounts_iter)?;\n    // Rent account\n    let rent_account = next_account_info(accounts_iter)?;\n    // System Program\n    let system_program = next_account_info(accounts_iter)?;\n\n    Ok(())\n}",
    "use anchor_lang::{\n    prelude::*,\n    solana_program::{\n        sysvar,\n        serialize_utils::{read_pubkey,read_u16}\n    }\n};\n\ndeclare_id!(\"8DJXJRV8DBFjJDYyU9cTHBVK1F1CTCi6JUBDVfyBxqsT\");\n\n#[program]\npub mod cookbook {\n    use super::*;\n\n    pub fn read_multiple_instruction<'info>(ctx: Context<ReadMultipleInstruction>, creator_bump: u8) -> Result<()> {\n        let instruction_sysvar_account = &ctx.accounts.instruction_sysvar_account;\n\n        let instruction_sysvar_account_info = instruction_sysvar_account.to_account_info();\n\n        let id = \"8DJXJRV8DBFjJDYyU9cTHBVK1F1CTCi6JUBDVfyBxqsT\";\n\n        let instruction_sysvar = instruction_sysvar_account_info.data.borrow();\n\n        let mut idx = 0;\n\n        let num_instructions = read_u16(&mut idx, &instruction_sysvar)\n        .map_err(|_| MyError::NoInstructionFound)?;\n\n        for index in 0..num_instructions {\n            let mut current = 2 + (index * 2) as usize;\n            let start = read_u16(&mut current, &instruction_sysvar).unwrap();\n\n            current = start as usize;\n            let num_accounts = read_u16(&mut current, &instruction_sysvar).unwrap();\n            current += (num_accounts as usize) * (1 + 32);\n            let program_id = read_pubkey(&mut current, &instruction_sysvar).unwrap();\n\n            if program_id != id\n            {\n                msg!(\"Transaction had ix with program id {}\", program_id);\n                return Err(MyError::SuspiciousTransaction.into());\n            }\n        }\n\n        Ok(())\n    }\n\n}\n\n#[derive(Accounts)]\n#[instruction(creator_bump:u8)]\npub struct ReadMultipleInstruction<'info> {\n    #[account(address = sysvar::instructions::id())]\n    instruction_sysvar_account: UncheckedAccount<'info>\n}\n\n#[error_code]\npub enum MyError {\n    #[msg(\"No instructions found\")]\n    NoInstructionFound,\n    #[msg(\"Suspicious transaction detected\")]\n    SuspiciousTransaction\n}",
    "use borsh::{BorshDeserialize, BorshSerialize};\nuse solana_program::{\n    account_info::{next_account_info, AccountInfo},\n    clock::Clock,\n    entrypoint,\n    entrypoint::ProgramResult,\n    msg,\n    program_error::ProgramError,\n    pubkey::Pubkey,\n    rent::Rent,\n    system_program::ID as SYSTEM_PROGRAM_ID,\n    sysvar::Sysvar,\n};\n\nentrypoint!(process_instruction);\n\n#[derive(BorshSerialize, BorshDeserialize, Debug)]\npub struct HelloState {\n    is_initialized: bool,\n}\n\n// Accounts required\n/// 1. [signer] Payer\n/// 2. [writable] Hello state account\n/// 3. [] System Program\npub fn process_instruction(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    _instruction_data: &[u8],\n) -> ProgramResult {\n    let accounts_iter = &mut accounts.iter();\n    // Payer account\n    let payer_account = next_account_info(accounts_iter)?;\n    // Hello state account\n    let hello_state_account = next_account_info(accounts_iter)?;\n    // System Program\n    let system_program = next_account_info(accounts_iter)?;\n\n    let rent = Rent::get()?;\n\n    // Checking if payer account is the signer\n    if !payer_account.is_signer {\n        return Err(ProgramError::MissingRequiredSignature);\n    }\n\n    // Checking if hello state account is rent exempt\n    if !rent.is_exempt(hello_state_account.lamports(), 1) {\n        return Err(ProgramError::AccountNotRentExempt);\n    }\n\n    // Checking if hello state account is writable\n    if !hello_state_account.is_writable {\n        return Err(ProgramError::InvalidAccountData);\n    }\n\n    // Checking if hello state account's owner is the current program\n    if hello_state_account.owner.ne(&program_id) {\n        return Err(ProgramError::IllegalOwner);\n    }\n\n    // Checking if the system program is valid\n    if system_program.key.ne(&SYSTEM_PROGRAM_ID) {\n        return Err(ProgramError::IncorrectProgramId);\n    }\n\n    let mut hello_state = HelloState::try_from_slice(&hello_state_account.data.borrow())?;\n\n    // Checking if the state has already been initialized\n    if hello_state.is_initialized {\n        return Err(ProgramError::AccountAlreadyInitialized);\n    }\n\n    hello_state.is_initialized = true;\n    hello_state.serialize(&mut &mut hello_state_account.data.borrow_mut()[..])?;\n    msg!(\"Account initialized :)\");\n\n    Ok(())\n}"
  ],
  "snippets_from_pdf": [
    "import { Connection, PublicKey } from \"@solana/web3.js\";\nimport { promises as fs } from \"fs\";\nimport path from \"path\";\nimport { URL } from \"url\";\nimport dotenv from \"dotenv\";\nimport axios from \"axios\";",
    "dotenv.config();\nconst __dirname = new URL(\".\", import.meta.url).pathname;",
    "const rpcUrl = process.env.RPC_URL;\nconst heliusEnrichedApiUrl = process.env.HELIUS_ENRICHED_URL;\nconst heliusApiKey = process.env.HELIUS_API_KEY;\nif (!rpcUrl || !heliusEnrichedApiUrl || !heliusApiKey) {\n  throw new Error(\n    \"RPC_URL or HELIUS_ENRICHED_URL or HELIUS_API_KEY is not d\n  );\n}",
    "const connection = new Connection(rpcUrl!);",
    "const getAllTransactionSignaturesForAddress = async (\n  collectionMint: PublicKey\n): Promise<string[]> => {\n  let lastReceivedTransactionSignature = \"\";",
    "const transactionSignatures: string[] = [];",
    "while (true) {\n    const signaturesForAddress = await connection.getSignature\n      collectionMint,",
    "{\n        before: lastReceivedTransactionSignature\n          ? lastReceivedTransactionSignature\n          : undefined,\n        limit: 1000,\n      }\n    );",
    "const signatures = signaturesForAddress.map(\n      (signatureObj) => signatureObj.signature\n    );",
    "transactionSignatures.push(...signatures);",
    "if (signaturesForAddress.length < 1000) {\n      break;\n    }\n  }",
    "return transactionSignatures;\n};",
    "const getParsedTransactions = async (transactionSignatures: s\n  const result = await axios.post(\n    `${heliusEnrichedApiUrl}/v0/transactions/?api-key=${heliu\n    {\n      transactions: transactionSignatures,\n    }\n  );",
    "return result.data;\n};",
    "const getAirdroppedAddresses = async (collectionMint: PublicKe\n  const airdroppedAddresses: string[] = [];",
    "const transactionSignatures = await getAllTransactionSignat\n    collectionMint\n  );",
    "const batchSize = 100; // 100 is the max batch size for Heli\n  for (let i = 0; i < transactionSignatures.length; i += batc\n    const parsedTransactions = await getParsedTransactions(\n      transactionSignatures.slice(i, i + batchSize)\n    );",
    "if (compressedEvents) {\n        for (let j = 0; j < compressedEvents.length; j++) {\n          const compressedEvent = compressedEvents[j];",
    "if (compressedEvent.type === \"COMPRESSED_NFT_MINT\") \n            return compressedEvent.newLeafOwner;\n          }\n        }\n      }\n    });",
    "airdroppedAddresses.push(...addresses);\n  }",
    "return airdroppedAddresses.filter((address) => !!address);\n};",
    "const main = async () => {\n  const collectionMint = new PublicKey(\n    \"AYED8JzJmMzq3rX61q1WsziKHtuUCLPEHK5673bWjnXr\"\n  );",
    "console.log(`Found ${airdroppedAddresses.length} airdropped",
    "await fs.writeFile(\n    `${path.join(\n      __dirname,\n      \"../../output\",\n      `${collectionMint.toBase58()}.csv`\n    )}`,\n    airdroppedAddresses.join(\"\\n\")\n  );\n};",
    "main();",
    "import axios from \"axios\";\nimport * as dotenv from \"dotenv\";\nimport { promises as fs } from \"fs\";\nimport path from \"path\";\nimport { URL } from \"url\";",
    "dotenv.config();\nconst __dirname = new URL(\".\", import.meta.url).pathname;",
    "const rpcUrl = process.env.RPC_URL;\nif (!rpcUrl) {\n  throw new Error(\"RPC_URL is not defined in environment varia\n}",
    "async function fetchCompressedNfts(walletAddress: string): Pro\n  const body = {\n    jsonrpc: '2.0',\n    id: 'fetch-solana-assets',\n    method: 'searchAssets',\n    params: {\n      ownerAddress: walletAddress,\n      tokenType: 'all',\n      displayOptions: {\n        showNativeBalance: true,\n        showInscription: true,\n        showCollectionMetadata: true,\n      },\n    },\n  };",
    "const maxRetries: number = 3;\n  let retryCount: number = 0;\n  let delayTime: number = 1000;",
    "while (retryCount < maxRetries) {\n    try {\n      const response = await axios.post(rpcUrl, body);\n      if (response.data && response.data.result) {\n        const items = response.data.result.items;\n        const compressedNfts = items.filter((item: any) => ite",
    "return compressedNfts;\n      }\n      return [];\n    } catch (error: any) {\n      if (error.response && error.response.status === 429) {\n        console.log(`Rate limit hit, retrying after ${delayTim\n        await delay(delayTime);\n        retryCount++;\n        delayTime *= 2;\n      } else {\n        console.error('Error fetching Solana assets:', error)",
    "throw new Error('Failed to fetch Solana assets');\n      }\n    }\n  }\n  throw new Error('Failed to fetch Solana assets after multipl\n}",
    "function delay(ms: number): Promise<void> {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}",
    "const main = async () => {\n  const walletAddress = 'YourWalletAddressHere';\n  try {\n    const compressedNfts = await fetchCompressedNfts(walletAdd\n    console.log(compressedNfts);\n    await fs.writeFile(\n      `${path.join(__dirname, \"../../output\", \"compressedNfts\n      JSON.stringify(compressedNfts, null, 2)\n    );\n    console.log('Compressed NFTs data saved successfully.');\n  } catch (error) {\n    console.error('Failed to fetch and save compressed NFTs:'\n  }\n};",
    "main();",
    "import { PublicKey } from \"@solana/web3.js\";\nimport axios from \"axios\";\nimport { promises as fs } from \"fs\";\nimport path from \"path\";\nimport { URL } from \"url\";\nimport dotenv from \"dotenv\";",
    "dotenv.config();\nconst __dirname = new URL(\".\", import.meta.url).pathname;",
    "const dasUrl = process.env.DAS_URL;",
    "if (!dasUrl) {\n  throw new Error(\"DAS_URL is not defined in environment varia\n}",
    "const getNftHoldersFromCollectionMint = async (\n  collectionMintAddress: PublicKey\n): Promise<string[]> => {\n  let page = 1;\n  const holderAddresses: string[] = [];",
    "while (true) {\n    const { data } = await axios.post(dasUrl, {\n      jsonrpc: \"2.0\",\n      id: \"my-id\",\n      method: \"getAssetsByGroup\",\n      params: {\n        groupKey: \"collection\",\n        groupValue: collectionMintAddress.toBase58(),\n        page,\n        limit: 1000,\n      },\n    });\n    if (data.result.total === 0) break;",
    "data.result.items.map((asset: any) =>\n      holderAddresses.push(asset.ownership.owner)\n    );\n    page++;\n  }\n  return holderAddresses;\n};",
    "const findMultipleAddresses = (addresses: string[]) => {\n  const visitedAddresses: string[] = [];\n  const multipleAddresses: string[] = [];",
    "for (let address of addresses) {\n    if (\n      visitedAddresses.includes(address) &&\n      !multipleAddresses.includes(address)\n    ) {\n      multipleAddresses.push(address);\n    } else {\n      visitedAddresses.push(address);\n    }\n  }",
    "return multipleAddresses;\n};",
    "const main = async () => {\n  const collectionMintAddress = new PublicKey(\n    \"J1S9H3QjnRtBbbuD4HjPV6RpRhwuk4zKbxsnCHuTgh9w\"\n  );",
    "const holderAddresses = await getNftHoldersFromCollectionMi\n    collectionMintAddress\n  );",
    "console.log(`Found ${multipleHolderAddresses.length} multipl",
    "await fs.writeFile(\n    `${path.join(\n      __dirname,\n      \"../../output\",\n      `multiples_${collectionMintAddress.toBase58()}.csv`\n    )}`,\n    multipleHolderAddresses.join(\"\\n\")",
    ");\n};",
    "main();",
    "import { PublicKey } from \"@solana/web3.js\";\nimport axios from \"axios\";\nimport { promises as fs } from \"fs\";\nimport path from \"path\";\nimport { URL } from \"url\";\nimport dotenv from \"dotenv\";",
    "dotenv.config();\nconst __dirname = new URL(\".\", import.meta.url).pathname;",
    "const dasUrl = process.env.DAS_URL;",
    "if (!dasUrl) {\n  throw new Error(\"DAS_URL is not defined in environment varia\n}",
    "const getNftHoldersFromCollectionMint = async (\n  collectionMintAddress: PublicKey\n): Promise<string[]> => {\n  let page = 1;\n  const holderAddresses: string[] = [];",
    "while (true) {\n    const { data } = await axios.post(dasUrl, {\n      jsonrpc: \"2.0\",\n      id: \"my-id\",\n      method: \"getAssetsByGroup\",\n      params: {\n        groupKey: \"collection\",",
    "groupValue: collectionMintAddress.toBase58(),\n        page,\n        limit: 1000,\n      },\n    });\n    if (data.result.total === 0) break;",
    "data.result.items.map((asset: any) =>\n      holderAddresses.push(asset.ownership.owner)\n    );\n    page++;\n  }\n  return holderAddresses;\n};",
    "const main = async () => {\n  const collectionMintAddress = new PublicKey(\n    \"J1S9H3QjnRtBbbuD4HjPV6RpRhwuk4zKbxsnCHuTgh9w\"\n  );",
    "const holderAddresses = await getNftHoldersFromCollectionMi\n    collectionMintAddress\n  );",
    "console.log(`Found ${holderAddresses.length} holders`);",
    "await fs.writeFile(\n    `${path.join(\n      __dirname,\n      \"../../output\",\n      `${collectionMintAddress.toBase58()}.csv`\n    )}`,\n    holderAddresses.join(\"\\n\")\n  );\n};",
    "main();",
    "import { Connection, PublicKey, type ParsedAccountData } from \nimport { promises as fs } from \"fs\";\nimport path from \"path\";\nimport { URL } from \"url\";\nimport dotenv from \"dotenv\";",
    "dotenv.config();\nconst __dirname = new URL(\".\", import.meta.url).pathname;",
    "const rpcUrl = process.env.RPC_URL;\nif (!rpcUrl) {\n  throw new Error(\"RPC_URL is not defined in environment varia\n}",
    "const main = async () => {\n  const connection = new Connection(rpcUrl!);",
    "const holderAddresses: string[] = [];",
    "const programAccounts = await connection.getParsedProgramAcc\n    new PublicKey(\"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA\n    {\n      filters: [\n        {\n          dataSize: 165,\n        },\n        {\n          memcmp: {\n            offset: 0,\n            bytes: tokenAddress,\n          },\n        },",
    "],\n    }\n  );",
    "for (const programAccount of programAccounts) {\n    const data = programAccount.account.data as ParsedAccountD\n    if (data.parsed.info.tokenAmount.uiAmount > 0) {\n      holderAddresses.push(data.parsed.info.owner);\n      // console.log(data.parsed.info.owner);\n    }\n  }",
    "await fs.writeFile(\n    `${path.join(__dirname, \"../../output\", `${tokenAddress}.c\n    holderAddresses.join(\"\\n\")\n  );\n};",
    "main();",
    "use anchor_lang::prelude::*;\nuse anchor_lang::system_program::{create_account, CreateAccou",
    "declare_id!(\"ARVNCsYKDQsCLHbwUTJLpFXVrJdjhWZStyzvxmKe2xHi\"); /",
    "#[program]\npub mod create_system_account {\n    use super::*;",
    "\"  New public key will be: {}\",\n            &ctx.accounts.new_account.key().to_string()\n        );",
    "// The minimum lamports for rent exemption\n        let lamports = (Rent::get()?).minimum_balance(0);",
    "create_account(\n            CpiContext::new(\n                ctx.accounts.system_program.to_account_info()\n                CreateAccount {\n                    from: ctx.accounts.payer.to_account_info(\n                    to: ctx.accounts.new_account.to_account_i\n                },\n            ),\n            lamports,                           // Lamports\n            0,                                  // Space\n            &ctx.accounts.system_program.key(), // Owner Prog\n        )?;",
    "msg!(\"Account created succesfully.\");\n        Ok(())\n    }\n}",
    "#[derive(Accounts)]\npub struct CreateSystemAccount<'info> {\n    #[account(mut)]\n    pub payer: Signer<'info>,\n    #[account(mut)]\n    pub new_account: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}",
    "#![allow(clippy::result_large_err)]\nuse anchor_lang::prelude::*;\nuse instructions::*;",
    "pub mod instructions;\npub mod state;",
    "declare_id!(\"GpVcgWdgVErgLqsn8VYUch6EqDerMgNqoLSmGyKrd6MR\");//",
    "#[program]\npub mod anchor_program_example {\n    use super::*;",
    "pub fn create_address_info(\n        ctx: Context<CreateAddressInfo>,\n        name: String,\n        house_number: u8,\n        street: String,\n        city: String,\n    ) -> Result<()> {\n        create::create_address_info(ctx, name, house_number, \n    }\n}",
    "use anchor_lang::prelude::*;",
    "declare_id!(\"ECWPhR3rJbaPfyNFgphnjxSEexbTArc7vxD8fnW6tgKw\"); /",
    "#[program]\npub mod anchor_program_example {\n    use super::*;",
    "pub fn check_accounts(_ctx: Context<CheckingAccounts>) -> \n        Ok(())\n    }\n}",
    "// Account validation in Anchor is done using the types and co\n// This is a simple example and does not include all possible \n#[derive(Accounts)]\npub struct CheckingAccounts<'info> {\n    payer: Signer<'info>, // checks account is signer",
    "/// CHECK: No checks performed, example of an unchecked ac\n    #[account(mut)]\n    account_to_create: UncheckedAccount<'info>,\n    /// CHECK: Perform owner check using constraint\n    #[account(\n        mut,\n        owner = id()\n    )]\n    account_to_change: UncheckedAccount<'info>,\n    system_program: Program<'info, System>, // checks account \n}",
    "use anchor_lang::prelude::*;\nmod instructions;\nmod state;\nuse instructions::*;",
    "declare_id!(\"99TQtoDdQ5NS2v5Ppha93aqEmv3vV9VZVfHTP5rGST3c\"); /",
    "pub mod close_account_program {\n    use super::*;",
    "pub fn create_user(ctx: Context<CreateUserContext>, name: \n        create_user::create_user(ctx, name)\n    }",
    "pub fn close_user(ctx: Context<CloseUserContext>) -> Resul\n        close_user::close_user(ctx)\n    }\n}",
    "use anchor_lang::prelude::*;",
    "declare_id!(\"BmDHboaj1kBUoinJKKSRqKfMeRKJqQqEbUj1VgzeQe4A\"); /",
    "#[program]\npub mod counter_anchor {\n    use super::*;",
    "pub fn initialize_counter(_ctx: Context<InitializeCounter>\n        Ok(())\n    }",
    "pub fn increment(ctx: Context<Increment>) -> Result<()> {\n        ctx.accounts.counter.count = ctx.accounts.counter.cou\n        Ok(())\n    }\n}",
    "#[derive(Accounts)]\npub struct InitializeCounter<'info> {",
    "#[account(\n        init,\n        space = 8 + Counter::INIT_SPACE,\n        payer = payer\n    )]\n    pub counter: Account<'info, Counter>,\n    pub system_program: Program<'info, System>,\n}",
    "#[derive(Accounts)]\npub struct Increment<'info> {\n    #[account(mut)]\n    pub counter: Account<'info, Counter>,\n}",
    "#[account]\n#[derive(InitSpace)]\npub struct Counter {\n    count: u64,\n}",
    "use anchor_lang::prelude::*;\nuse lever::cpi::accounts::SetPowerStatus;\nuse lever::program::Lever;\nuse lever::{self, PowerStatus};",
    "declare_id!(\"EJfTLXDCJTVwBgGpz9X2Me4CWHbvg8F8zsM7fiVJLLeR\");//",
    "mod hand {\n    use super::*;\n    pub fn pull_lever(ctx: Context<PullLever>, name: String) \n        // Hitting the switch_power method on the lever progra\n        //\n        lever::cpi::switch_power(\n            CpiContext::new(\n                ctx.accounts.lever_program.to_account_info(),\n                // Using the accounts context struct from the \n                //\n                SetPowerStatus {\n                    power: ctx.accounts.power.to_account_info\n                },\n            ),\n            name,\n        )\n    }\n}",
    "#[derive(Accounts)]\npub struct PullLever<'info> {\n    #[account(mut)]\n    pub power: Account<'info, PowerStatus>,\n    pub lever_program: Program<'info, Lever>,\n}",
    "use anchor_lang::prelude::*;",
    "declare_id!(\"CABVoybzrbAJSv7QhQd6GXNGKxDMRjw9niqFzizhk6uk\");",
    "#[program]\npub mod lever {",
    "use super::*;\n    pub fn initialize(_ctx: Context<InitializeLever>) -> Resul\n        Ok(())\n    }",
    "pub fn switch_power(ctx: Context<SetPowerStatus>, name: S\n        let power = &mut ctx.accounts.power;\n        power.is_on = !power.is_on;",
    "msg!(\"{} is pulling the power switch!\", &name);",
    "match power.is_on {\n            true => msg!(\"The power is now on.\"),\n            false => msg!(\"The power is now off!\"),\n        };",
    "Ok(())\n    }\n}",
    "#[derive(Accounts)]\npub struct InitializeLever<'info> {\n    #[account(init, payer = user, space = 8 + 8)]\n    pub power: Account<'info, PowerStatus>,\n    #[account(mut)]\n    pub user: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}",
    "#[derive(Accounts)]\npub struct SetPowerStatus<'info> {\n    #[account(mut)]\n    pub power: Account<'info, PowerStatus>,\n}",
    "#[account]\npub struct PowerStatus {",
    "pub is_on: bool,\n}",
    "use anchor_lang::prelude::*;",
    "declare_id!(\"2phbC62wekpw95XuBk4i1KX4uA8zBUWmYbiTMhicSuBV\");",
    "#[program]\npub mod hello_solana {\n    use super::*;",
    "pub fn hello(_ctx: Context<Hello>) -> Result<()> {\n        msg!(\"Hello, Solana!\");",
    "msg!(\"Our program's Program ID: {}\", &id());",
    "Ok(())\n    }\n}",
    "#[derive(Accounts)]\npub struct Hello {}",
    "use solana_program::{\n    account_info::AccountInfo, entrypoint, entrypoint::Program\n};",
    "//  is the \"process_instruction\" function.\n//\nentrypoint!(process_instruction);",
    "// Our entrypoint's parameters have to match the\n//  anatomy of a transaction instruction (see README).\n//\nfn process_instruction(\n    program_id: &Pubkey,\n    _accounts: &[AccountInfo],\n    _instruction_data: &[u8],\n) -> ProgramResult {\n    msg!(\"Hello, Solana!\");",
    "msg!(\"Our program's Program ID: {}\", &program_id);",
    "Ok(())\n}",
    "use anchor_lang::prelude::*;\nuse anchor_lang::solana_program;\nuse anchor_spl::token;\nuse std::convert::TryFrom;",
    "declare_id!(\"Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS\");",
    "#[derive(Debug)]\n#[account]\npub struct Counter {\n    authority: Pubkey,\n    value: u8,\n}",
    "let mut authority = &mut ctx.accounts.authority;\n    let mut counter = &mut ctx.accounts.counter;\n    let mut counter = counter;",
    "counter.authority = authority.key();",
    "counter.value = 0;",
    "msg!(\"{}\", \"Hello, Solana from Seahorse!\");",
    "Ok(())\n}",
    "pub fn increment_handler(mut ctx: Context<Increment>) -> Resul\n    let mut authority = &mut ctx.accounts.authority;\n    let mut counter = &mut ctx.accounts.counter;",
    "counter.value += 1;",
    "Ok(())\n}",
    "#[derive(Accounts)]\npub struct Initialize<'info> {\n    #[account(mut)]\n    pub authority: Signer<'info>,\n    #[account(\n        init,\n        payer = authority,\n        seeds = [\"new_delhi_hh\".as_bytes().as_ref(), authority\n        bump,\n        space = 8 + std::mem::size_of::<Counter>()\n    )]\n    pub counter: Box<Account<'info, Counter>>,\n    pub system_program: Program<'info, System>,\n}",
    "pub struct Increment<'info> {\n    #[account(mut)]\n    pub authority: Signer<'info>,\n    #[account(mut)]\n    pub counter: Box<Account<'info, Counter>>,\n}",
    "#[program]\npub mod hello_solana {\n    use super::*;",
    "pub fn initialize(ctx: Context<Initialize>) -> Result<()> \n        initialize_handler(ctx)\n    }",
    "pub fn increment(ctx: Context<Increment>) -> Result<()> {\n        increment_handler(ctx)\n    }\n}",
    "@program_id(\"F1ipperKF9EfD821ZbbYjS319LXYiBmjhzkkf5a26rC\")\ncontract hello_solana {\n    // The constructor is used to create a new account\n    // Here we create a new account that stores no data and o\n    @payer(payer) // The \"payer\" pays for the account creatio\n    constructor() {\n        // We get the program ID by calling 'this';\n        address programId = address(this);",
    "// Print messages to the program logs\n        print(\"Hello, Solana!\");\n        print(\"Our program's Program ID: {:}\".format(programId",
    "}\n}",
    "#![allow(clippy::result_large_err)]\nuse anchor_lang::prelude::*;\nuse instructions::*;\npub mod instructions;",
    "declare_id!(\"7Hm9nsYVuBZ9rf8z9AMUHreZRv8Q4vLhqwdVTCawRZtA\");",
    "#[program]\npub mod pda_rent_payer {\n    use super::*;",
    "pub fn init_rent_vault(ctx: Context<InitRentVault>, fund_l\n        init_rent_vault::init_rent_vault(ctx, fund_lamports)\n    }",
    "pub fn create_new_account(ctx: Context<CreateNewAccount>) \n        create_new_account::create_new_account(ctx)\n    }\n}",
    "use anchor_lang::prelude::*;",
    "declare_id!(\"DgoL5J44aspizyUs9fcnpGEUJjWTLJRCfx8eYtUMYczf\");",
    "#[program]\npub mod processing_instructions {\n    use super::*;",
    "// With Anchor, we just put instruction data in the functi\n    //\n    pub fn go_to_park(_ctx: Context<Park>, name: String, heig\n        msg!(\"Welcome to the park, {}!\", name);\n        if height > 5 {\n            msg!(\"You are tall enough to ride this ride. Cong\n        } else {\n            msg!(\"You are NOT tall enough to ride this ride. S\n        };",
    "Ok(())\n    }\n}",
    "#[derive(Accounts)]\npub struct Park {}",
    "use borsh::{BorshDeserialize, BorshSerialize};\nuse solana_program::{\n    account_info::AccountInfo, entrypoint, entrypoint::Program\n};",
    "entrypoint!(process_instruction);",
    "fn process_instruction(\n    _program_id: &Pubkey,\n    _accounts: &[AccountInfo],\n    instruction_data: &[u8],\n) -> ProgramResult {\n    // Attempt to serialize the BPF format to our struct",
    "msg!(\"Welcome to the park, {}!\", instruction_data_object.\n    if instruction_data_object.height > 5 {\n        msg!(\"You are tall enough to ride this ride. Congratul\n    } else {\n        msg!(\"You are NOT tall enough to ride this ride. Sorry\n    };",
    "Ok(())\n}",
    "#[derive(BorshSerialize, BorshDeserialize, Debug)]\npub struct InstructionData {\n    name: String,\n    height: u32,\n}",
    "use anchor_lang::prelude::*;",
    "use instructions::*;",
    "pub mod instructions;\npub mod state;",
    "declare_id!(\"oCCQRZyAbVxujyd8m57MPmDzZDmy2FoKW4ULS7KofCE\");",
    "#[program]\npub mod anchor_program_example {\n    use super::*;",
    "pub fn create_page_visits(ctx: Context<CreatePageVisits>) \n        create::create_page_visits(ctx)\n    }",
    "pub fn increment_page_visits(ctx: Context<IncrementPageVi\n        increment::increment_page_visits(ctx)\n    }\n}",
    "use anchor_lang::prelude::*;",
    "declare_id!(\"Fod47xKXjdHVQDzkFPBvfdWLm8gEAV4iMSXkfUzCHiSD\");",
    "#[program]\npub mod anchor_realloc {\n    use super::*;",
    "pub fn initialize(ctx: Context<Initialize>, input: String\n        ctx.accounts.message_account.message = input;\n        Ok(())\n    }",
    "pub fn update(ctx: Context<Update>, input: String) -> Res\n        ctx.accounts.message_account.message = input;\n        Ok(())\n    }\n}",
    "#[derive(Accounts)]\n#[instruction(input: String)]\npub struct Initialize<'info> {\n    #[account(mut)]\n    pub payer: Signer<'info>,",
    "#[account(\n        init,\n        payer = payer,\n        space = Message::required_space(input.len()),\n    )]\n    pub message_account: Account<'info, Message>,\n    pub system_program: Program<'info, System>,\n}",
    "#[derive(Accounts)]\n#[instruction(input: String)]\npub struct Update<'info> {\n    #[account(mut)]\n    pub payer: Signer<'info>,",
    "#[account(\n       mut, \n       realloc = Message::required_space(input.len()),\n       realloc::payer = payer,\n       realloc::zero = true,\n    )]\n    pub message_account: Account<'info, Message>,\n    pub system_program: Program<'info, System>,\n}",
    "#[account]\npub struct Message {\n    pub message: String,\n}",
    "impl Message {\n    pub fn required_space(input_len: usize) -> usize {\n        8 + // 8 byte discriminator\n        4 + // 4 byte for length of string\n        input_len\n    }\n}",
    "use anchor_lang::prelude::*;\nuse anchor_lang::system_program;",
    "declare_id!(\"ED6f4gweAE7hWPQPXMt4kWxzDJne8VQEm9zkb1tMpFNB\");",
    "#[program]\npub mod rent_example {\n    use super::*;",
    "pub fn create_system_account(\n        ctx: Context<CreateSystemAccount>,\n        address_data: AddressData,\n    ) -> Result<()> {\n        msg!(\"Program invoked. Creating a system account...\")\n        msg!(\n            \"  New public key will be: {}\",\n            &ctx.accounts.new_account.key().to_string()\n        );",
    "msg!(\"Account span: {}\", &account_span);\n        msg!(\"Lamports required: {}\", &lamports_required);",
    "system_program::create_account(\n            CpiContext::new(\n                ctx.accounts.system_program.to_account_info()\n                system_program::CreateAccount {\n                    from: ctx.accounts.payer.to_account_info(",
    "to: ctx.accounts.new_account.to_account_i\n                },\n            ),\n            lamports_required,\n            account_span as u64,\n            &ctx.accounts.system_program.key(),\n        )?;",
    "msg!(\"Account created succesfully.\");\n        Ok(())\n    }\n}",
    "#[derive(Accounts)]\npub struct CreateSystemAccount<'info> {\n    #[account(mut)]\n    pub payer: Signer<'info>,\n    #[account(mut)]\n    pub new_account: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}",
    "#[derive(AnchorSerialize, AnchorDeserialize, Debug)]\npub struct AddressData {\n    name: String,\n    address: String,\n}",
    "use anchor_lang::prelude::*;",
    "pub mod error;\npub mod instructions;",
    "pub mod state;",
    "use crate::instructions::{eat_food, get_on_ride, play_game};",
    "declare_id!(\"8t94SEJh9jVjDwV7cbiuT6BvEsHo4YHP9x9a5rYH1NpP\");",
    "#[program]\npub mod carnival {\n    use super::*;",
    "pub fn go_on_ride(\n        _ctx: Context<CarnivalContext>,\n        name: String,\n        height: u32,\n        ticket_count: u32,\n        ride_name: String,\n    ) -> Result<()> {\n        get_on_ride::get_on_ride(get_on_ride::GetOnRideInstruc\n            rider_name: name,\n            rider_height: height,\n            rider_ticket_count: ticket_count,\n            ride: ride_name,\n        })\n    }",
    "pub fn play_game(\n        _ctx: Context<CarnivalContext>,\n        name: String,\n        ticket_count: u32,\n        game_name: String,\n    ) -> Result<()> {\n        play_game::play_game(play_game::PlayGameInstructionDa\n            gamer_name: name,\n            gamer_ticket_count: ticket_count,\n            game: game_name,\n        })",
    "}",
    "pub fn eat_food(\n        _ctx: Context<CarnivalContext>,\n        name: String,\n        ticket_count: u32,\n        food_stand_name: String,\n    ) -> Result<()> {\n        eat_food::eat_food(eat_food::EatFoodInstructionData {\n            eater_name: name,\n            eater_ticket_count: ticket_count,\n            food_stand: food_stand_name,\n        })\n    }\n}",
    "#[derive(Accounts)]\npub struct CarnivalContext<'info> {\n    #[account(mut)]\n    pub payer: Signer<'info>,\n}",
    "use anchor_lang::prelude::*;\nuse anchor_lang::system_program;",
    "declare_id!(\"4fQVnLWKKKYxtxgGn7Haw8v2g2Hzbu8K61JvWKvqAi7W\");",
    "#[program]\npub mod transfer_sol {\n    use super::*;",
    "system_program::transfer(\n            CpiContext::new(\n                ctx.accounts.system_program.to_account_info()\n                system_program::Transfer {\n                    from: ctx.accounts.payer.to_account_info(\n                    to: ctx.accounts.recipient.to_account_info\n                },\n            ),\n            amount,\n        )?;",
    "Ok(())\n    }",
    "// Directly modifying lamports is only possible if the pro\n    pub fn transfer_sol_with_program(\n        ctx: Context<TransferSolWithProgram>,\n        amount: u64,\n    ) -> Result<()> {\n        **ctx.accounts.payer.try_borrow_mut_lamports()? -= amo\n        **ctx.accounts.recipient.try_borrow_mut_lamports()? +=\n        Ok(())\n    }\n}",
    "#[derive(Accounts)]\npub struct TransferSolWithCpi<'info> {\n    #[account(mut)]\n    payer: Signer<'info>,\n    #[account(mut)]\n    recipient: SystemAccount<'info>,\n    system_program: Program<'info, System>,\n}",
    "#[derive(Accounts)]\npub struct TransferSolWithProgram<'info> {\n    /// CHECK: Use owner constraint to check account is owned \n    #[account(",
    "mut,\n        owner = id() // value of declare_id!()\n    )]\n    payer: UncheckedAccount<'info>,\n    #[account(mut)]\n    recipient: SystemAccount<'info>,\n}",
    "pub mod dot;",
    "use anchor_lang::prelude::*;\nuse anchor_spl::{\n    associated_token::{self, AssociatedToken},\n    token::{self, Mint, Token, TokenAccount},\n};",
    "use dot::program::*;\nuse std::{cell::RefCell, rc::Rc};",
    "declare_id!(\"2RjL4mpTANyGxz7fLWEbQtmdEDti7c4CqsLR96mgvcaV\");",
    "pub mod seahorse_util {\n    use super::*;",
    "#[cfg(feature = \"pyth-sdk-solana\")]\n    pub use pyth_sdk_solana::{load_price_feed_from_account_inf\n    use std::{collections::HashMap, fmt::Debug, ops::Deref};",
    "pub struct Mutable<T>(Rc<RefCell<T>>);",
    "impl<T> Mutable<T> {",
    "pub fn new(obj: T) -> Self {\n            Self(Rc::new(RefCell::new(obj)))\n        }\n    }",
    "impl<T> Clone for Mutable<T> {\n        fn clone(&self) -> Self {\n            Self(self.0.clone())\n        }\n    }",
    "impl<T> Deref for Mutable<T> {\n        type Target = Rc<RefCell<T>>;",
    "fn deref(&self) -> &Self::Target {\n            &self.0\n        }\n    }",
    "impl<T: Debug> Debug for Mutable<T> {\n        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std\n            write!(f, \"{:?}\", self.0)\n        }\n    }",
    "impl<T: Default> Default for Mutable<T> {\n        fn default() -> Self {\n            Self::new(T::default())\n        }\n    }",
    "impl<T: Clone> Mutable<Vec<T>> {\n        pub fn wrapped_index(&self, mut index: i128) -> usize \n            if index >= 0 {\n                return index.try_into().unwrap();\n            }",
    "index += self.borrow().len() as i128;",
    "return index.try_into().unwrap();\n        }\n    }",
    "impl<T: Clone, const N: usize> Mutable<[T; N]> {\n        pub fn wrapped_index(&self, mut index: i128) -> usize \n            if index >= 0 {\n                return index.try_into().unwrap();\n            }",
    "index += self.borrow().len() as i128;",
    "return index.try_into().unwrap();\n        }\n    }",
    "#[derive(Clone)]\n    pub struct Empty<T: Clone> {\n        pub account: T,\n        pub bump: Option<u8>,\n    }",
    "impl<'info> ProgramsMap<'info> {\n        pub fn get(&self, name: &'static str) -> AccountInfo<\n            self.0.get(name).unwrap().clone()\n        }\n    }",
    "#[derive(Clone, Debug)]\n    pub struct WithPrograms<'info, 'entrypoint, A> {\n        pub account: &'entrypoint A,\n        pub programs: &'entrypoint ProgramsMap<'info>,\n    }",
    "impl<'info, 'entrypoint, A> Deref for WithPrograms<'info, \n        type Target = A;",
    "fn deref(&self) -> &Self::Target {\n            &self.account\n        }\n    }",
    "#[derive(Clone, Debug)]\n    pub struct CpiAccount<'info> {\n        #[doc = \"CHECK: CpiAccounts temporarily store Account\n        pub account_info: AccountInfo<'info>,\n        pub is_writable: bool,\n        pub is_signer: bool,\n        pub seeds: Option<Vec<Vec<u8>>>,\n    }",
    "#[macro_export]\n    macro_rules! seahorse_const {\n        ($ name : ident , $ value : expr) => {\n            macro_rules! $name {\n                () => {\n                    $value\n                };\n            }",
    "pub(crate) use $name;\n        };\n    }",
    "#[macro_export]\n    macro_rules! assign {\n        ($ lval : expr , $ rval : expr) => {{",
    "let temp = $rval;",
    "$lval = temp;\n        }};\n    }",
    "#[macro_export]\n    macro_rules! index_assign {\n        ($ lval : expr , $ idx : expr , $ rval : expr) => {\n            let temp_rval = $rval;\n            let temp_idx = $idx;",
    "$lval[temp_idx] = temp_rval;\n        };\n    }",
    "pub(crate) use assign;",
    "pub(crate) use index_assign;",
    "pub(crate) use seahorse_const;\n}",
    "#[program]\nmod seahorse {\n    use super::*;\n    use seahorse_util::*;\n    use std::collections::HashMap;",
    "#[derive(Accounts)]\n    pub struct InitMockAccount<'info> {\n        #[account(mut)]\n        pub signer: Signer<'info>,\n        # [account (init , space = std :: mem :: size_of :: < \n        pub mock_account: Box<Account<'info, dot::program::Moc\n        pub rent: Sysvar<'info, Rent>,\n        pub system_program: Program<'info, System>,\n    }",
    "pub fn init_mock_account(ctx: Context<InitMockAccount>) ->\n        let mut programs = HashMap::new();",
    "programs.insert(\n            \"system_program\",\n            ctx.accounts.system_program.to_account_info(),\n        );",
    "let programs_map = ProgramsMap(programs);\n        let signer = SeahorseSigner {\n            account: &ctx.accounts.signer,\n            programs: &programs_map,\n        };",
    "let mock_account = Empty {\n            account: dot::program::MockAccount::load(&mut ctx\n            bump: ctx.bumps.get(\"mock_account\").map(|bump| *b\n        };",
    "return Ok(());\n    }",
    "#[derive(Accounts)]\n    # [instruction (amount : u64)]\n    pub struct TransferSolWithCpi<'info> {\n        #[account(mut)]\n        pub sender: Signer<'info>,\n        #[account(mut)]\n        pub recipient: Box<Account<'info, dot::program::MockAc\n        pub system_program: Program<'info, System>,\n    }",
    "let mut programs = HashMap::new();",
    "programs.insert(\n            \"system_program\",\n            ctx.accounts.system_program.to_account_info(),\n        );",
    "let programs_map = ProgramsMap(programs);\n        let sender = SeahorseSigner {\n            account: &ctx.accounts.sender,\n            programs: &programs_map,\n        };",
    "dot::program::MockAccount::store(recipient);",
    "return Ok(());\n    }\n}",
    "use anchor_lang::prelude::*;",
    "declare_id!(\"FbeHkUEevbhKmdk5FE5orcTaJkCYn5drwZoZXaxQXXNn\");",
    "#[derive(Clone)]\npub struct SPLCompression;",
    "impl anchor_lang::Id for SPLCompression {\n    fn id() -> Pubkey {\n        spl_account_compression::id()\n    }",
    "}",
    "#[program]\npub mod cnft_burn {\n    use super::*;",
    "pub fn burn_cnft<'info>(\n        ctx: Context<'_, '_, '_, 'info, BurnCnft<'info>>,\n        root: [u8; 32],\n        data_hash: [u8; 32],\n        creator_hash: [u8; 32],\n        nonce: u64,\n        index: u32,\n    ) -> Result<()> {\n        let tree_config = ctx.accounts.tree_authority.to_acco\n        let leaf_owner = ctx.accounts.leaf_owner.to_account_i\n        let merkle_tree = ctx.accounts.merkle_tree.to_account_\n        let log_wrapper = ctx.accounts.log_wrapper.to_account_\n        let compression_program = ctx.accounts.compression_pro\n        let system_program = ctx.accounts.system_program.to_ac",
    "let cnft_burn_cpi = mpl_bubblegum::instructions::BurnC\n            &ctx.accounts.bubblegum_program,\n            mpl_bubblegum::instructions::BurnCpiAccounts {\n                tree_config: &tree_config,\n                leaf_owner: (&leaf_owner, true),\n                leaf_delegate: (&leaf_owner, false),\n                merkle_tree: &merkle_tree,\n                log_wrapper: &log_wrapper,\n                compression_program: &compression_program,\n                system_program: &system_program,\n            },\n            mpl_bubblegum::instructions::BurnInstructionArgs \n                root,\n                data_hash,\n                creator_hash,\n                nonce,\n                index,",
    "},\n        );",
    "cnft_burn_cpi.invoke_with_remaining_accounts(\n            ctx.remaining_accounts\n                .iter()\n                .map(|account| (account, false, false))\n                .collect::<Vec<_>>()\n                .as_slice(),\n        )?;",
    "Ok(())\n    }\n}",
    "#[derive(Accounts)]\npub struct BurnCnft<'info> {\n    #[account(mut)]\n    pub leaf_owner: Signer<'info>,\n    #[account(mut)]\n    #[account(\n        seeds = [merkle_tree.key().as_ref()],\n        bump,\n        seeds::program = bubblegum_program.key()\n    )]\n    /// CHECK: This account is modified in the downstream prog\n    pub tree_authority: UncheckedAccount<'info>,\n    #[account(mut)]\n    /// CHECK: This account is neither written to nor read fro\n    pub merkle_tree: UncheckedAccount<'info>,\n    /// CHECK: This account is neither written to nor read fro\n    pub log_wrapper: UncheckedAccount<'info>,\n    pub compression_program: Program<'info, SPLCompression>,\n    /// CHECK: This account is neither written to nor read fro\n    pub bubblegum_program: UncheckedAccount<'info>,\n    pub system_program: Program<'info, System>,\n}",
    "import \"solana\";",
    "@program_id(\"BvgEJTPXfriGPopjJr1nLc4vADXm7A7TqjLFVztpd19Q\")\ncontract compressed_nft {",
    "@payer(payer) // payer address\n    @seed(\"seed\") // hardcoded seed\n    constructor(\n        @bump bytes1 bump // bump seed for pda address\n    ) {\n        // Creating a dataAccount for the program, which is re\n        // However, this account is not used in the program\n    }",
    "// Mint a compressed NFT to an existing merkle tree, via a\n    // Reference: https://github.com/metaplex-foundation/meta\n    // Reference: https://github.com/metaplex-foundation/meta\n    @mutableAccount(tree_authority) // authority of the merkle\n    @account(leaf_owner) // owner of the new compressed NFT\n    @account(leaf_delegate) // delegate of the new compressed \n    @mutableAccount(merkle_tree)  // address of the merkle tre\n    @mutableSigner(payer) // payer\n    @mutableSigner(tree_delegate) // delegate of the merkle t\n    @account(noop_address)\n    @account(compression_pid)\n    @account(bubblegum_pid)\n    function mint(\n        string uri // uri of the new compressed NFT (metadata\n    ) external {\n        print(\"Minting Compressed NFT\");",
    "// Create a creator array with a single creator\n        Creator[] memory creators = new Creator[](1);",
    "// Set the creator to the payer\n        creators[0] = Creator({\n            creatorAddress: tx.accounts.payer.key,\n            verified: false,\n            share: 100\n        });",
    "// Create the metadata args, representing the metadata\n        // Solidity does not support optional arguments,\n        // So we have to explicitly declare if the optional a\n        // If not present, we comment them out, otherwise the \n        MetadataArgs memory args = MetadataArgs({\n            name: \"RGB\",\n            symbol: \"RGB\",\n            uri: uri,\n            sellerFeeBasisPoints: 0,\n            primarySaleHappened: false,\n            isMutable: true,\n            editionNoncePresent: false,\n            // editionNonce: 0,\n            tokenStandardPresent: true,\n            tokenStandard: TokenStandard.NonFungible,\n            collectionPresent: false,\n            // collection: Collection({\n            //     verified: false,\n            //     key: address(0)\n            // }),\n            usesPresent: false,\n            // uses: Uses({\n            //     useMethod: UseMethod.Burn,\n            //     remaining: 0,\n            //     total: 0\n            // }),\n            tokenProgramVersion: TokenProgramVersion.Original\n            creators: creators\n        });",
    "AccountMeta({pubkey: tx.accounts.tree_authority.ke\n            AccountMeta({pubkey: tx.accounts.leaf_owner.key, i\n            AccountMeta({pubkey: tx.accounts.leaf_delegate.key\n            AccountMeta({pubkey: tx.accounts.merkle_tree.key, \n            AccountMeta({pubkey: tx.accounts.payer.key, is_wri\n            AccountMeta({pubkey: tx.accounts.tree_delegate.key\n            AccountMeta({pubkey: tx.accounts.noop_address.key\n            AccountMeta({pubkey: tx.accounts.compression_pid.\n            AccountMeta({pubkey: address\"111111111111111111111\n        ];",
    "// Reference: https://github.com/metaplex-foundation/m\n        bytes8 discriminator = 0x9162c076b8937668;\n        bytes instructionData = abi.encode(discriminator, arg",
    "// Invoking the Bubblegum program\n        tx.accounts.bubblegum_pid.key.call{accounts: metas}(i\n    }",
    "// Reference: https://github.com/metaplex-foundation/meta\n    struct MetadataArgs {\n        string name;\n        string symbol;\n        string uri;\n        uint16 sellerFeeBasisPoints;\n        bool primarySaleHappened;\n        bool isMutable;\n        bool editionNoncePresent;\n        // uint8 editionNonce;\n        bool tokenStandardPresent;\n        TokenStandard tokenStandard;\n        bool collectionPresent;\n        // Collection collection;\n        bool usesPresent;\n        // Uses uses;\n        TokenProgramVersion tokenProgramVersion;\n        Creator[] creators;\n    }",
    "enum TokenStandard {\n        NonFungible,\n        FungibleAsset,\n        Fungible,\n        NonFungibleEdition\n    }",
    "enum TokenProgramVersion {\n        Original,\n        Token2022\n    }",
    "struct Creator {\n        address creatorAddress;\n        bool verified;\n        uint8 share;\n    }",
    "struct Collection {\n        bool verified;\n        address key;\n    }",
    "struct Uses {\n        UseMethod useMethod;\n        uint64 remaining;\n        uint64 total;\n    }",
    "enum UseMethod {\n        Burn,\n        Multiple,\n        Single\n    }",
    "}",
    "use anchor_lang::prelude::*;\nuse mpl_bubblegum::state::TreeConfig;\nuse solana_program::pubkey::Pubkey;\nuse spl_account_compression::{program::SplAccountCompression,",
    "declare_id!(\"CNftyK7T8udPwYRzZUMWzbh79rKrz9a5GwV2wv7iEHpk\");",
    "#[derive(Clone)]\npub struct MplBubblegum;",
    "impl anchor_lang::Id for MplBubblegum {\n    fn id() -> Pubkey {\n        mpl_bubblegum::id()\n    }\n}",
    "// first 8 bytes of SHA256(\"global:transfer\")\nconst TRANSFER_DISCRIMINATOR: &[u8; 8] = &[163, 52, 200, 231,",
    "#[program]\npub mod cnft_vault {",
    "use super::*;",
    "pub fn withdraw_cnft<'info>(\n        ctx: Context<'_, '_, '_, 'info, Withdraw<'info>>,\n        root: [u8; 32],\n        data_hash: [u8; 32],\n        creator_hash: [u8; 32],\n        nonce: u64,\n        index: u32,",
    ") -> Result<()> {\n        msg!(\n            \"attempting to send nft {} from tree {}\",\n            index,\n            ctx.accounts.merkle_tree.key()\n        );",
    "let mut accounts: Vec<solana_program::instruction::Acc\n            AccountMeta::new_readonly(ctx.accounts.tree_autho\n            AccountMeta::new_readonly(ctx.accounts.leaf_owner\n            AccountMeta::new_readonly(ctx.accounts.leaf_owner\n            AccountMeta::new_readonly(ctx.accounts.new_leaf_ow\n            AccountMeta::new(ctx.accounts.merkle_tree.key(), f\n            AccountMeta::new_readonly(ctx.accounts.log_wrappe\n            AccountMeta::new_readonly(ctx.accounts.compressio\n            AccountMeta::new_readonly(ctx.accounts.system_prog\n        ];",
    "let mut data: Vec<u8> = vec![];\n        data.extend(TRANSFER_DISCRIMINATOR);\n        data.extend(root);\n        data.extend(data_hash);\n        data.extend(creator_hash);\n        data.extend(nonce.to_le_bytes());\n        data.extend(index.to_le_bytes());",
    "let mut account_infos: Vec<AccountInfo> = vec![\n            ctx.accounts.tree_authority.to_account_info(),\n            ctx.accounts.leaf_owner.to_account_info(),\n            ctx.accounts.leaf_owner.to_account_info(),\n            ctx.accounts.new_leaf_owner.to_account_info(),\n            ctx.accounts.merkle_tree.to_account_info(),\n            ctx.accounts.log_wrapper.to_account_info(),\n            ctx.accounts.compression_program.to_account_info(\n            ctx.accounts.system_program.to_account_info(),\n        ];",
    "for acc in ctx.remaining_accounts.iter() {\n            accounts.push(AccountMeta::new_readonly(acc.key()\n            account_infos.push(acc.to_account_info());\n        }",
    "msg!(\"manual cpi call\");\n        solana_program::program::invoke_signed(\n            &solana_program::instruction::Instruction {\n                program_id: ctx.accounts.bubblegum_program.key\n                accounts,\n                data,\n            },\n            &account_infos[..],\n            &[&[b\"cNFT-vault\", &[*ctx.bumps.get(\"leaf_owner\")\n        )\n        .map_err(Into::into)\n    }",
    "#[allow(clippy::too_many_arguments)]\n    pub fn withdraw_two_cnfts<'info>(\n        ctx: Context<'_, '_, '_, 'info, WithdrawTwo<'info>>,\n        root1: [u8; 32],\n        data_hash1: [u8; 32],\n        creator_hash1: [u8; 32],\n        nonce1: u64,\n        index1: u32,\n        proof_1_length: u8,\n        root2: [u8; 32],\n        data_hash2: [u8; 32],\n        creator_hash2: [u8; 32],\n        nonce2: u64,\n        index2: u32,\n        _proof_2_length: u8, // we don't actually need this (\n    ) -> Result<()> {\n        let merkle_tree1 = ctx.accounts.merkle_tree1.key();\n        let merkle_tree2 = ctx.accounts.merkle_tree2.key();\n        msg!(\n            \"attempting to send nfts from trees {} and {}\",",
    "merkle_tree1,\n            merkle_tree2\n        );",
    "let mut accounts1: Vec<solana_program::instruction::Ac\n            AccountMeta::new_readonly(ctx.accounts.tree_autho\n            AccountMeta::new_readonly(ctx.accounts.leaf_owner\n            AccountMeta::new_readonly(ctx.accounts.leaf_owner\n            AccountMeta::new_readonly(ctx.accounts.new_leaf_ow\n            AccountMeta::new(ctx.accounts.merkle_tree1.key(), \n            AccountMeta::new_readonly(ctx.accounts.log_wrappe\n            AccountMeta::new_readonly(ctx.accounts.compressio\n            AccountMeta::new_readonly(ctx.accounts.system_prog\n        ];",
    "let mut accounts2: Vec<solana_program::instruction::Ac\n            AccountMeta::new_readonly(ctx.accounts.tree_autho\n            AccountMeta::new_readonly(ctx.accounts.leaf_owner\n            AccountMeta::new_readonly(ctx.accounts.leaf_owner\n            AccountMeta::new_readonly(ctx.accounts.new_leaf_ow\n            AccountMeta::new(ctx.accounts.merkle_tree2.key(), \n            AccountMeta::new_readonly(ctx.accounts.log_wrappe\n            AccountMeta::new_readonly(ctx.accounts.compressio\n            AccountMeta::new_readonly(ctx.accounts.system_prog\n        ];",
    "let mut data1: Vec<u8> = vec![];\n        data1.extend(TRANSFER_DISCRIMINATOR);\n        data1.extend(root1);\n        data1.extend(data_hash1);\n        data1.extend(creator_hash1);\n        data1.extend(nonce1.to_le_bytes());\n        data1.extend(index1.to_le_bytes());\n        let mut data2: Vec<u8> = vec![];\n        data2.extend(TRANSFER_DISCRIMINATOR);",
    "data2.extend(root2);\n        data2.extend(data_hash2);\n        data2.extend(creator_hash2);\n        data2.extend(nonce2.to_le_bytes());\n        data2.extend(index2.to_le_bytes());",
    "let mut account_infos1: Vec<AccountInfo> = vec![\n            ctx.accounts.tree_authority1.to_account_info(),\n            ctx.accounts.leaf_owner.to_account_info(),\n            ctx.accounts.leaf_owner.to_account_info(),\n            ctx.accounts.new_leaf_owner1.to_account_info(),\n            ctx.accounts.merkle_tree1.to_account_info(),\n            ctx.accounts.log_wrapper.to_account_info(),\n            ctx.accounts.compression_program.to_account_info(\n            ctx.accounts.system_program.to_account_info(),\n        ];\n        let mut account_infos2: Vec<AccountInfo> = vec![\n            ctx.accounts.tree_authority2.to_account_info(),\n            ctx.accounts.leaf_owner.to_account_info(),\n            ctx.accounts.leaf_owner.to_account_info(),\n            ctx.accounts.new_leaf_owner2.to_account_info(),\n            ctx.accounts.merkle_tree2.to_account_info(),\n            ctx.accounts.log_wrapper.to_account_info(),\n            ctx.accounts.compression_program.to_account_info(\n            ctx.accounts.system_program.to_account_info(),\n        ];",
    "for (i, acc) in ctx.remaining_accounts.iter().enumera\n            if i < proof_1_length as usize {\n                accounts1.push(AccountMeta::new_readonly(acc.\n                account_infos1.push(acc.to_account_info());\n            } else {\n                accounts2.push(AccountMeta::new_readonly(acc.\n                account_infos2.push(acc.to_account_info());\n            }\n        }",
    "msg!(\"withdrawing cNFT#1\");",
    "solana_program::program::invoke_signed(\n            &solana_program::instruction::Instruction {\n                program_id: ctx.accounts.bubblegum_program.key\n                accounts: accounts1,\n                data: data1,\n            },\n            &account_infos1[..],\n            &[&[b\"cNFT-vault\", &[*ctx.bumps.get(\"leaf_owner\")\n        )?;",
    "msg!(\"withdrawing cNFT#2\");\n        solana_program::program::invoke_signed(\n            &solana_program::instruction::Instruction {\n                program_id: ctx.accounts.bubblegum_program.key\n                accounts: accounts2,\n                data: data2,\n            },\n            &account_infos2[..],\n            &[&[b\"cNFT-vault\", &[*ctx.bumps.get(\"leaf_owner\")\n        )?;",
    "msg!(\"successfully sent cNFTs\");\n        Ok(())\n    }\n}",
    "#[derive(Accounts)]\npub struct Withdraw<'info> {\n    #[account(\n        seeds = [merkle_tree.key().as_ref()],\n        bump,\n        seeds::program = bubblegum_program.key()\n    )]\n    /// CHECK: This account is neither written to nor read fro\n    pub tree_authority: Account<'info, TreeConfig>,",
    "bump,\n    )]\n    /// CHECK: This account doesnt even exist (it is just the \n    pub leaf_owner: UncheckedAccount<'info>, // sender (the va\n    /// CHECK: This account is neither written to nor read fro\n    pub new_leaf_owner: UncheckedAccount<'info>, // receiver\n    #[account(mut)]\n    /// CHECK: This account is modified in the downstream prog\n    pub merkle_tree: UncheckedAccount<'info>,\n    pub log_wrapper: Program<'info, Noop>,\n    pub compression_program: Program<'info, SplAccountCompres\n    pub bubblegum_program: Program<'info, MplBubblegum>,\n    pub system_program: Program<'info, System>,\n}",
    "#[derive(Accounts)]\npub struct WithdrawTwo<'info> {\n    #[account(\n        seeds = [merkle_tree1.key().as_ref()],\n        bump,\n        seeds::program = bubblegum_program.key()\n    )]\n    /// CHECK: This account is neither written to nor read fro\n    pub tree_authority1: Account<'info, TreeConfig>,\n    #[account(\n        seeds = [b\"cNFT-vault\"],\n        bump,\n    )]\n    /// CHECK: This account doesnt even exist (it is just the \n    pub leaf_owner: UncheckedAccount<'info>, // you might need\n    /// CHECK: This account is neither written to nor read fro\n    pub new_leaf_owner1: UncheckedAccount<'info>, // receiver\n    #[account(mut)]\n    /// CHECK: This account is modified in the downstream prog\n    pub merkle_tree1: UncheckedAccount<'info>,",
    "pub log_wrapper: Program<'info, Noop>,\n    pub compression_program: Program<'info, SplAccountCompres\n    pub bubblegum_program: Program<'info, MplBubblegum>,\n    pub system_program: Program<'info, System>,\n}",
    "pub mod actions;\npub use actions::*;",
    "pub mod state;\npub use state::*;",
    "use anchor_lang::prelude::*;\nuse solana_program::pubkey::Pubkey;\nuse spl_account_compression::{program::SplAccountCompression,",
    "#[derive(Clone)]\npub struct MplBubblegum;",
    "impl anchor_lang::Id for MplBubblegum {\n    fn id() -> Pubkey {",
    "mpl_bubblegum::id()\n    }\n}",
    "declare_id!(\"burZc1SfqbrAP35XG63YZZ82C9Zd22QUwhCXoEUZWNF\");",
    "#[program]\npub mod cutils {\n    use super::*;",
    "#[access_control(ctx.accounts.validate(&ctx, &params))]\n    pub fn mint<'info>(\n        ctx: Context<'_, '_, '_, 'info, Mint<'info>>,\n        params: MintParams,\n    ) -> Result<()> {\n        Mint::actuate(ctx, params)\n    }",
    "#[access_control(ctx.accounts.validate(&ctx, &params))]\n    pub fn verify<'info>(\n        ctx: Context<'_, '_, '_, 'info, Verify<'info>>,\n        params: VerifyParams,\n    ) -> Result<()> {\n        Verify::actuate(ctx, &params)\n    }\n}",
    "use anchor_lang::prelude::*;\npub mod state;\nuse state::PriceFeed;",
    "pub mod error;",
    "use error::ErrorCode;",
    "declare_id!(\"F6mNuN1xoPdRaZcUX3Xviq7x1EFtoBXygpFggCLd62eU\");",
    "#[program]\npub mod pythexample {\n    use super::*;\n    pub fn read_price(ctx: Context<Pyth>) -> Result<()> {\n        let price_feed = &ctx.accounts.price_feed;\n        let clock = &ctx.accounts.clock;\n        // Get the current timestamp\n        let timestamp: i64 = clock.unix_timestamp;\n        // Load the price from the price feed. Here, the price\n        let price: pyth_sdk::Price = price_feed\n            .get_price_no_older_than(timestamp, 30)\n            .ok_or(ErrorCode::PythError)?;",
    "let confidence_interval: u64 = price.conf;",
    "let asset_price_full: i64 = price.price;",
    "let asset_exponent: i32 = price.expo;",
    "msg!(\"Price: {}\", asset_price);\n        msg!(\"Confidence interval: {}\", confidence_interval);",
    "Ok(())\n    }\n}",
    "#[derive(Accounts)]\npub struct Pyth<'info> {\n    pub price_feed: Account<'info, PriceFeed>,\n    pub system_program: Program<'info, System>,\n    pub clock: Sysvar<'info, Clock>,\n}",
    "import { readFileSync } from 'node:fs'",
    "export function changePackageVersion(file: string, pkgName: s\n  const content = JSON.parse(readFileSync(file).toString('utf\n  if (content.dependencies && content.dependencies[pkgName] &&\n    content.dependencies[pkgName] = pkgVersion\n    return [true, content]\n  }\n  if (content.devDependencies && content.devDependencies[pkgNa\n    content.devDependencies[pkgName] = pkgVersion\n    return [true, content]\n  }\n  return [false, content]\n}",
    "import { basename } from 'node:path'\nimport * as p from 'picocolors'\nimport { getDepsCount } from './get-deps-count'\nimport { getRecursiveFileList } from './get-recursive-file-li",
    "export function commandCheck(path: string = '.') {\n  const files = getRecursiveFileList(path).filter((file) => ba\n  const depsCounter = getDepsCount(files)",
    ".map((pkg) => {\n      const versions = depsCounter[pkg]\n      const versionMap = Object.keys(versions).sort()\n      const versionsLength = versionMap.length",
    "if (versionsLength === 1) {\n        const count = versions[versionMap[0]].length\n        single.push(`${p.green(`\u2714`)} ${pkg}@${versionMap[0]} \n        return\n      }",
    "const versionCount: { version: string; count: number }[\n      for (const version of versionMap) {\n        versionCount.push({ version, count: versions[version]\n      }\n      versionCount.sort((a, b) => b.count - a.count)",
    "multiple.push(`${p.yellow(`\u26a0`)} ${pkg} has ${versionsLe",
    "for (const { count, version } of versionCount) {\n        multiple.push(`  - ${p.bold(version)} (${count})`)\n      }\n    })",
    "for (const string of [...single.sort(), ...multiple]) {\n    console.log(string)\n  }\n}",
    "export function commandHelp() {\n  console.log(`Usage: yarn sync-package-json <command> [optio\n  console.log(``)\n  console.log(`Commands:`)",
    "console.log(`  check  <path>        Check package.json file\n  console.log(`  help                 Show this help`)\n  console.log(`  list   <path>        List package.json files\n  console.log(`  set    [ver] <path>  Set specific version in \n  console.log(`  update <path> <pkgs> Update all versions in \n  console.log(``)\n  console.log(`Arguments:`)\n  console.log(`  path    Path to directory`)\n  console.log(``)\n  console.log(`Examples:`)\n  console.log(`  yarn sync-package-json check`)\n  console.log(`  yarn sync-package-json check basics`)\n  console.log(`  yarn sync-package-json list`)\n  console.log(`  yarn sync-package-json list basics`)\n  console.log(`  yarn sync-package-json help`)\n  console.log(`  yarn sync-package-json set @coral-xyz/anchor@\n  console.log(`  yarn sync-package-json set @coral-xyz/anchor@\n  console.log(`  yarn sync-package-json update`)\n  console.log(`  yarn sync-package-json update basics`)\n  console.log(`  yarn sync-package-json update . @solana/web3\n  process.exit(0)\n}",
    "import { basename } from 'node:path'\nimport { getRecursiveFileList } from './get-recursive-file-li",
    "export function commandList(path: string) {\n  const files = getRecursiveFileList(path).filter((file) => ba\n  for (const file of files) {\n    console.log(file)\n  }\n}",
    "import { writeFileSync } from 'fs'\nimport { basename } from 'node:path'\nimport { changePackageVersion } from './change-package-versio\nimport { getRecursiveFileList } from './get-recursive-file-li",
    "export function commandSet(version: string, path: string = '.\n  if (!version) {\n    console.error(`Version is required`)\n    process.exit(1)\n  }\n  if (\n    !version\n      // Strip first character if it's a `@`\n      .replace(/^@/, '')\n      .includes('@')\n  ) {\n    console.error(`Invalid package version: ${version}. Provid\n    process.exit(1)\n  }\n  // Take anything after the second `@` as the version, the re\n  const [pkg, ...rest] = version.split('@').reverse()\n  const pkgName = rest.reverse().join('@')",
    "// Make sure pkgVersions has a ^ prefix, if not add it\n  const pkgVersion = pkg.startsWith('^') ? pkg : `^${pkg}`",
    "console.log(`Setting package ${pkgName} to ${pkgVersion} in",
    "const files = getRecursiveFileList(path).filter((file) => ba\n  let count = 0\n  for (const file of files) {\n    const [changed, content] = changePackageVersion(file, pkgN\n    if (changed) {\n      writeFileSync(file, JSON.stringify(content, null, 2) +",
    "count++\n    }\n  }\n  if (count === 0) {\n    console.log(`No files updated`)\n  } else {\n    console.log(`Updated ${count} files`)\n  }\n}",
    "import { execSync } from 'child_process'\nimport { writeFileSync } from 'fs'\nimport { basename } from 'node:path'\nimport * as p from 'picocolors'\nimport { changePackageVersion } from './change-package-versio",
    "import { getDepsCount } from './get-deps-count'\nimport { getRecursiveFileList } from './get-recursive-file-li",
    "export function commandUpdate(path: string = '.', packageName\n  const files = getRecursiveFileList(path).filter((file) => ba\n  const depsCounter = getDepsCount(files)\n  const pkgNames = Object.keys(depsCounter).sort()\n  if (packageNames.length > 0) {\n    console.log(`Updating ${packageNames.join(', ')} in ${file\n  }",
    "let total = 0\n  for (const pkgName of pkgNames.filter((pkgName) => packageNa\n    // Get latest version from npm\n    const npmVersion = execSync(`npm view ${pkgName} version`",
    "let count = 0\n    for (const file of files) {",
    "const [changed, content] = changePackageVersion(file, p\n      if (changed) {\n        writeFileSync(file, JSON.stringify(content, null, 2) +\n        count++\n      }\n    }\n    total += count",
    "if (count === 0) {\n      console.log(p.dim(`Package ${pkgName} is up to date ${n\n      continue\n    }\n    console.log(p.green(` -> Updated ${count} files with ${pkg\n  }",
    "if (total === 0) {\n    console.log(`No files updated`)\n  } else {\n    console.log(`Updated ${total} files`)\n  }\n}",
    "import { readFileSync } from 'node:fs'",
    "export function getDepsCount(files: string[] = []): Record<st\n  const map: Record<string, JSON> = {}\n  const depsCounter: Record<string, Record<string, string[]>>",
    "for (const file of files) {\n    const content = JSON.parse(readFileSync(file).toString('u\n    map[file] = content",
    "const deps = content.dependencies ?? {}\n    const devDeps = content.devDependencies ?? {}",
    "const merged = { ...deps, ...devDeps }",
    "Object.keys(merged)\n      .sort()\n      .map((pkg) => {\n        const pkgVersion = merged[pkg]\n        if (!depsCounter[pkg]) {\n          depsCounter[pkg] = { [pkgVersion]: [file] }\n          return\n        }\n        if (!depsCounter[pkg][pkgVersion]) {\n          depsCounter[pkg][pkgVersion] = [file]\n          return\n        }\n        depsCounter[pkg][pkgVersion] = [...depsCounter[pkg][p\n      })\n  }\n  return depsCounter\n}",
    "// Point method at path and return a list of all the files in \nimport { readdirSync, statSync } from 'node:fs'",
    "const items = readdirSync(path)\n  items.forEach((item) => {\n    if (ignore.includes(item)) {\n      return\n    }\n    // Check out if it's a directory or a file",
    "const isDir = statSync(`${path}/${item}`).isDirectory()\n    if (isDir) {\n      // If it's a directory, recursively call the method\n      files.push(...getRecursiveFileList(`${path}/${item}`))\n    } else {\n      // If it's a file, add it to the array of files\n      files.push(`${path}/${item}`)\n    }\n  })",
    "return files.filter((file) => {\n    // Remove package.json from the root directory\n    return path === '.' ? file !== './package.json' : true\n  })\n}",
    "use {\n    anchor_lang::prelude::*,\n    anchor_spl::{\n        metadata::{create_metadata_accounts_v3, CreateMetadata\n        token::{Mint, Token},\n    },\n    mpl_token_metadata::{pda::find_metadata_account, state::Da\n};",
    "declare_id!(\"2B6MrsKB2pVq6W6tY8dJLcnSd3Uv1KE7yRaboBjdQoEX\");",
    "#[program]\npub mod create_token {\n    use super::*;",
    "ctx: Context<CreateTokenMint>,\n        token_name: String,\n        token_symbol: String,\n        token_uri: String,\n        _token_decimals: u8,\n    ) -> Result<()> {\n        msg!(\"Creating metadata account...\");\n        msg!(\n            \"Metadata account address: {}\",\n            &ctx.accounts.metadata_account.key()\n        );",
    "// Cross Program Invocation (CPI)\n        // Invoking the create_metadata_account_v3 instructio\n        create_metadata_accounts_v3(\n            CpiContext::new(\n                ctx.accounts.token_metadata_program.to_accoun\n                CreateMetadataAccountsV3 {\n                    metadata: ctx.accounts.metadata_account.to\n                    mint: ctx.accounts.mint_account.to_accoun\n                    mint_authority: ctx.accounts.payer.to_acco\n                    update_authority: ctx.accounts.payer.to_ac\n                    payer: ctx.accounts.payer.to_account_info\n                    system_program: ctx.accounts.system_progra\n                    rent: ctx.accounts.rent.to_account_info()\n                },\n            ),\n            DataV2 {\n                name: token_name,\n                symbol: token_symbol,\n                uri: token_uri,\n                seller_fee_basis_points: 0,\n                creators: None,\n                collection: None,\n                uses: None,\n            },\n            false, // Is mutable\n            true,  // Update authority is signer",
    "None,  // Collection details\n        )?;",
    "msg!(\"Token mint created successfully.\");",
    "Ok(())\n    }\n}",
    "#[derive(Accounts)]\n#[instruction(_token_decimals: u8)]\npub struct CreateTokenMint<'info> {\n    #[account(mut)]\n    pub payer: Signer<'info>,",
    "pub token_metadata_program: Program<'info, Metadata>,\n    pub token_program: Program<'info, Token>,\n    pub system_program: Program<'info, System>,\n    pub rent: Sysvar<'info, Rent>,\n}",
    "use {\n    anchor_lang::prelude::*,\n    anchor_spl::{\n        associated_token::AssociatedToken,\n        metadata::{\n            create_master_edition_v3, create_metadata_account\n            CreateMetadataAccountsV3, Metadata,\n        },\n        token::{mint_to, Mint, MintTo, Token, TokenAccount},\n    },\n    mpl_token_metadata::{\n        pda::{find_master_edition_account, find_metadata_acco\n        state::DataV2,\n    },\n};",
    "declare_id!(\"3qHNM98iLTaQtwmj2NkViXnHZQjNBS5PTHT2AuPxHXYN\");",
    "#[program]\npub mod nft_minter {\n    use super::*;",
    "pub fn mint_nft(\n        ctx: Context<CreateToken>,\n        nft_name: String,\n        nft_symbol: String,\n        nft_uri: String,\n    ) -> Result<()> {\n        msg!(\"Minting Token\");\n        // Cross Program Invocation (CPI)\n        // Invoking the mint_to instruction on the token prog\n        mint_to(\n            CpiContext::new(",
    "ctx.accounts.token_program.to_account_info(),\n                MintTo {\n                    mint: ctx.accounts.mint_account.to_accoun\n                    to: ctx.accounts.associated_token_account\n                    authority: ctx.accounts.payer.to_account_i\n                },\n            ),\n            1,\n        )?;",
    "msg!(\"Creating metadata account\");\n        // Cross Program Invocation (CPI)\n        // Invoking the create_metadata_account_v3 instructio\n        create_metadata_accounts_v3(\n            CpiContext::new(\n                ctx.accounts.token_metadata_program.to_accoun\n                CreateMetadataAccountsV3 {\n                    metadata: ctx.accounts.metadata_account.to\n                    mint: ctx.accounts.mint_account.to_accoun\n                    mint_authority: ctx.accounts.payer.to_acco\n                    update_authority: ctx.accounts.payer.to_ac\n                    payer: ctx.accounts.payer.to_account_info\n                    system_program: ctx.accounts.system_progra\n                    rent: ctx.accounts.rent.to_account_info()\n                },\n            ),\n            DataV2 {\n                name: nft_name,\n                symbol: nft_symbol,\n                uri: nft_uri,\n                seller_fee_basis_points: 0,\n                creators: None,\n                collection: None,\n                uses: None,\n            },\n            false, // Is mutable\n            true,  // Update authority is signer\n            None,  // Collection details",
    ")?;",
    "msg!(\"Creating master edition account\");\n        // Cross Program Invocation (CPI)\n        // Invoking the create_master_edition_v3 instruction o\n        create_master_edition_v3(\n            CpiContext::new(\n                ctx.accounts.token_metadata_program.to_accoun\n                CreateMasterEditionV3 {\n                    edition: ctx.accounts.edition_account.to_a\n                    mint: ctx.accounts.mint_account.to_accoun\n                    update_authority: ctx.accounts.payer.to_ac\n                    mint_authority: ctx.accounts.payer.to_acco\n                    payer: ctx.accounts.payer.to_account_info\n                    metadata: ctx.accounts.metadata_account.to\n                    token_program: ctx.accounts.token_program\n                    system_program: ctx.accounts.system_progra\n                    rent: ctx.accounts.rent.to_account_info()\n                },\n            ),\n            None, // Max Supply\n        )?;",
    "msg!(\"NFT minted successfully.\");",
    "Ok(())\n    }\n}",
    "#[derive(Accounts)]\npub struct CreateToken<'info> {\n    #[account(mut)]\n    pub payer: Signer<'info>,",
    "pub token_program: Program<'info, Token>,\n    pub token_metadata_program: Program<'info, Metadata>,\n    pub associated_token_program: Program<'info, AssociatedTo\n    pub system_program: Program<'info, System>,\n    pub rent: Sysvar<'info, Rent>,\n}",
    "use anchor_lang::prelude::*;\nuse instructions::*;\npub mod instructions;",
    "declare_id!(\"A5gNtapBvMLD6i7D2t3SSyJeFtBdfb6ibvZu1hoBLzCo\");",
    "#[program]\npub mod token_minter {\n    use super::*;",
    "pub fn create_token(\n        ctx: Context<CreateToken>,\n        token_name: String,\n        token_symbol: String,\n        token_uri: String,\n    ) -> Result<()> {\n        create::create_token(ctx, token_name, token_symbol, to\n    }",
    "pub fn mint_token(ctx: Context<MintToken>, amount: u64) ->\n        mint::mint_token(ctx, amount)\n    }\n}",
    "use anchor_lang::prelude::*;",
    "pub mod instructions;",
    "use instructions::*;",
    "declare_id!(\"77p9WmpzQW29RUEzTEef2ym7AHePBE9yNWJ9acikXfZS\");",
    "#[program]\npub mod spl_token_minter {\n    use super::*;",
    "pub fn create_token(\n        ctx: Context<CreateToken>,\n        token_name: String,\n        token_symbol: String,\n        token_uri: String,\n    ) -> Result<()> {\n        create::create_token(ctx, token_name, token_symbol, to\n    }",
    "pub fn mint_token(ctx: Context<MintToken>, amount: u64) ->\n        mint::mint_token(ctx, amount)\n    }\n}",
    "use anchor_lang::prelude::*;\nuse anchor_spl::associated_token::AssociatedToken;\nuse anchor_spl::token_interface::{\n    self, Mint, MintTo, TokenAccount, TokenInterface, Transfe\n};",
    "declare_id!(\"6qNqxkRF791FXFeQwqYQLEzAbGiqDULC5SSHVsfRoG89\");",
    "#[program]\npub mod anchor {",
    "use super::*;",
    "pub fn create_token(_ctx: Context<CreateToken>, _token_nam\n        msg!(\"Create Token\");\n        Ok(())\n    }\n    pub fn create_token_account(_ctx: Context<CreateTokenAcco\n        msg!(\"Create Token Account\");\n        Ok(())\n    }\n    pub fn create_associated_token_account(\n        _ctx: Context<CreateAssociatedTokenAccount>,\n    ) -> Result<()> {\n        msg!(\"Create Associated Token Account\");\n        Ok(())\n    }\n    pub fn transfer_token(ctx: Context<TransferToken>, amount\n        let cpi_accounts = TransferChecked {\n            from: ctx.accounts.from.to_account_info().clone()\n            mint: ctx.accounts.mint.to_account_info().clone()\n            to: ctx.accounts.to_ata.to_account_info().clone()\n            authority: ctx.accounts.signer.to_account_info(),\n        };\n        let cpi_program = ctx.accounts.token_program.to_accou\n        let cpi_context = CpiContext::new(cpi_program, cpi_acc\n        token_interface::transfer_checked(cpi_context, amount\n        msg!(\"Transfer Token\");\n        Ok(())\n    }\n    pub fn mint_token(ctx: Context<MintToken>, amount: u64) ->\n        let cpi_accounts = MintTo {\n            mint: ctx.accounts.mint.to_account_info().clone()\n            to: ctx.accounts.receiver.to_account_info().clone",
    "authority: ctx.accounts.signer.to_account_info(),\n        };\n        let cpi_program = ctx.accounts.token_program.to_accou\n        let cpi_context = CpiContext::new(cpi_program, cpi_acc\n        token_interface::mint_to(cpi_context, amount)?;\n        msg!(\"Mint Token\");\n        Ok(())\n    }\n}",
    "#[derive(Accounts)]\n#[instruction(token_name: String)]\npub struct CreateToken<'info> {\n    #[account(mut)]\n    pub signer: Signer<'info>,\n    #[account(\n        init,\n        payer = signer,\n        mint::decimals = 6,\n        mint::authority = signer.key(),\n        seeds = [b\"token-2022-token\", signer.key().as_ref(), \n        bump,\n    )]\n    pub mint: InterfaceAccount<'info, Mint>,\n    pub system_program: Program<'info, System>,\n    pub token_program: Interface<'info, TokenInterface>,\n}",
    "#[derive(Accounts)]\npub struct CreateTokenAccount<'info> {\n    #[account(mut)]\n    pub signer: Signer<'info>,\n    pub mint: InterfaceAccount<'info, Mint>,\n    #[account(\n        init,\n        token::mint = mint,\n        token::authority = signer,\n        payer = signer,",
    "seeds = [b\"token-2022-token-account\", signer.key().as_\n        bump,\n    )]\n    pub token_account: InterfaceAccount<'info, TokenAccount>,\n    pub system_program: Program<'info, System>,\n    pub token_program: Interface<'info, TokenInterface>,\n}",
    "#[derive(Accounts)]\npub struct CreateAssociatedTokenAccount<'info> {\n    #[account(mut)]\n    pub signer: Signer<'info>,\n    pub mint: InterfaceAccount<'info, Mint>,\n    #[account(\n        init,\n        associated_token::mint = mint,\n        payer = signer,\n        associated_token::authority = signer,\n    )]\n    pub token_account: InterfaceAccount<'info, TokenAccount>,\n    pub system_program: Program<'info, System>,\n    pub token_program: Interface<'info, TokenInterface>,\n    pub associated_token_program: Program<'info, AssociatedTo\n}",
    "pub struct TransferToken<'info> {\n    #[account(mut)]\n    pub signer: Signer<'info>,\n    #[account(mut)]\n    pub from: InterfaceAccount<'info, TokenAccount>,\n    pub to: SystemAccount<'info>,\n    #[account(\n        init,\n        associated_token::mint = mint,\n        payer = signer,\n        associated_token::authority = to",
    ")]\n    pub to_ata: InterfaceAccount<'info, TokenAccount>,\n    #[account(mut)]\n    pub mint: InterfaceAccount<'info, Mint>,\n    pub token_program: Interface<'info, TokenInterface>,\n    pub system_program: Program<'info, System>,\n    pub associated_token_program: Program<'info, AssociatedTo\n}",
    "#[derive(Accounts)]\npub struct MintToken<'info> {\n    #[account(mut)]\n    pub signer: Signer<'info>,\n    #[account(mut)]\n    pub mint: InterfaceAccount<'info, Mint>,\n    #[account(mut)]\n    pub receiver: InterfaceAccount<'info, TokenAccount>,\n    pub token_program: Interface<'info, TokenInterface>,\n}",
    "use {\n    borsh::{BorshDeserialize, BorshSerialize},\n    solana_program::{\n        account_info::{next_account_info, AccountInfo},\n        entrypoint,\n        entrypoint::ProgramResult,\n        msg,\n        program::invoke,\n        pubkey::Pubkey,\n        rent::Rent,\n        system_instruction,\n        sysvar::Sysvar,\n    },",
    "spl_token_2022::{\n        extension::{\n            default_account_state::instruction::{\n                initialize_default_account_state, update_defa\n            },\n            ExtensionType,\n        },\n        instruction as token_instruction,\n        state::AccountState,\n        state::Mint,\n    },\n};",
    "#[derive(BorshSerialize, BorshDeserialize, Debug)]\npub struct CreateTokenArgs {\n    pub token_decimals: u8,\n}",
    "entrypoint!(process_instruction);",
    "fn process_instruction(\n    _program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    instruction_data: &[u8],\n) -> ProgramResult {\n    let args = CreateTokenArgs::try_from_slice(instruction_da",
    "let accounts_iter = &mut accounts.iter();",
    "let mint_account = next_account_info(accounts_iter)?;\n    let mint_authority = next_account_info(accounts_iter)?;\n    let payer = next_account_info(accounts_iter)?;\n    let rent = next_account_info(accounts_iter)?;\n    let system_program = next_account_info(accounts_iter)?;\n    let token_program = next_account_info(accounts_iter)?;",
    "// Get the required rent exemption amount for the account\n    let rent_required = Rent::get()?.minimum_balance(space);",
    "msg!(\"Mint account address : {}\", mint_account.key);\n    invoke(\n        &system_instruction::create_account(\n            payer.key,\n            mint_account.key,\n            rent_required,\n            space as u64,\n            token_program.key,\n        ),\n        &[\n            mint_account.clone(),\n            payer.clone(),\n            system_program.clone(),\n            token_program.clone(),\n        ],\n    )?;",
    ")?;",
    "// Initialize the Token Mint\n    invoke(\n        &token_instruction::initialize_mint(\n            token_program.key,\n            mint_account.key,\n            mint_authority.key,\n            Some(mint_authority.key),\n            args.token_decimals,\n        )?,\n        &[\n            mint_account.clone(),\n            mint_authority.clone(),\n            token_program.clone(),\n            rent.clone(),\n        ],\n    )?;",
    "// Update the Default Account State to Initialized\n    invoke(\n        &update_default_account_state(\n            token_program.key,\n            mint_account.key,\n            payer.key,\n            &[payer.key],\n            &AccountState::Initialized,\n        )\n        .unwrap(),\n        &[\n            mint_account.clone(),\n            payer.clone(),\n            token_program.clone(),\n            system_program.clone(),\n        ],\n    )?;",
    "msg!(\"Mint created!\");",
    "Ok(())\n}",
    "use {\n    borsh::{BorshDeserialize, BorshSerialize},\n    solana_program::{\n        account_info::{next_account_info, AccountInfo},\n        entrypoint,\n        entrypoint::ProgramResult,\n        msg,\n        program::invoke,\n        pubkey::Pubkey,\n        rent::Rent,\n        system_instruction,\n        sysvar::Sysvar,\n    },\n    spl_token_2022::{extension::ExtensionType, instruction as \n};",
    "#[derive(BorshSerialize, BorshDeserialize, Debug)]\npub struct CreateTokenArgs {\n    pub token_decimals: u8,\n}",
    "entrypoint!(process_instruction);",
    "fn process_instruction(\n    _program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    instruction_data: &[u8],\n) -> ProgramResult {",
    "let accounts_iter = &mut accounts.iter();",
    "let mint_account = next_account_info(accounts_iter)?;\n    let mint_authority = next_account_info(accounts_iter)?;\n    let close_authority = next_account_info(accounts_iter)?;\n    let payer = next_account_info(accounts_iter)?;\n    let rent = next_account_info(accounts_iter)?;\n    let system_program = next_account_info(accounts_iter)?;\n    let token_program = next_account_info(accounts_iter)?;",
    "// Get the required rent exemption amount for the account\n    let rent_required = Rent::get()?.minimum_balance(space);",
    "// Create the account for the Mint and allocate space\n    msg!(\"Mint account address : {}\", mint_account.key);\n    invoke(\n        &system_instruction::create_account(\n            payer.key,\n            mint_account.key,\n            rent_required,\n            space as u64,\n            token_program.key,\n        ),\n        &[\n            mint_account.clone(),\n            payer.clone(),\n            system_program.clone(),\n            token_program.clone(),\n        ],\n    )?;",
    "// Initialize the Mint close authority Extension\n    invoke(\n        &token_instruction::initialize_mint_close_authority(\n            token_program.key,\n            mint_account.key,\n            Some(close_authority.key),\n        )\n        .unwrap(),\n        &[\n            mint_account.clone(),\n            close_authority.clone(),\n            token_program.clone(),\n            system_program.clone(),\n        ],\n    )?;",
    "// Initialize the Token Mint\n    invoke(\n        &token_instruction::initialize_mint(\n            token_program.key,\n            mint_account.key,\n            mint_authority.key,\n            Some(mint_authority.key),\n            args.token_decimals,\n        )?,\n        &[\n            mint_account.clone(),\n            mint_authority.clone(),\n            token_program.clone(),\n            rent.clone(),\n        ],\n    )?;",
    "msg!(\"Mint created!\");",
    "Ok(())\n}",
    "use {\n    borsh::{BorshDeserialize, BorshSerialize},\n    solana_program::{\n        account_info::{next_account_info, AccountInfo},\n        entrypoint,\n        entrypoint::ProgramResult,\n        msg,\n        program::invoke,\n        pubkey::Pubkey,\n        rent::Rent,\n        system_instruction,\n        sysvar::Sysvar,\n    },\n    spl_token_2022::{extension::ExtensionType, instruction as \n};",
    "#[derive(BorshSerialize, BorshDeserialize, Debug)]\npub struct CreateTokenArgs {\n    pub token_decimals: u8,\n}",
    "entrypoint!(process_instruction);",
    "fn process_instruction(\n    _program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    instruction_data: &[u8],\n) -> ProgramResult {\n    let args = CreateTokenArgs::try_from_slice(instruction_da",
    "let accounts_iter = &mut accounts.iter();",
    "let mint_account = next_account_info(accounts_iter)?;\n    let mint_authority = next_account_info(accounts_iter)?;\n    let close_authority = next_account_info(accounts_iter)?;\n    let payer = next_account_info(accounts_iter)?;\n    let rent = next_account_info(accounts_iter)?;\n    let system_program = next_account_info(accounts_iter)?;\n    let token_program = next_account_info(accounts_iter)?;",
    "// Find the size for the Mint account with the the number \n    let space = ExtensionType::get_account_len::<Mint>(&[\n        ExtensionType::MintCloseAuthority,\n        ExtensionType::NonTransferable,\n    ]);",
    "// Get the required rent exemption amount for the account\n    let rent_required = Rent::get()?.minimum_balance(space);",
    "// Create the account for the Mint and allocate space\n    msg!(\"Mint account address : {}\", mint_account.key);\n    invoke(\n        &system_instruction::create_account(\n            payer.key,\n            mint_account.key,\n            rent_required,\n            space as u64,\n            token_program.key,\n        ),\n        &[\n            mint_account.clone(),\n            payer.clone(),\n            system_program.clone(),\n            token_program.clone(),\n        ],\n    )?;",
    "// Initialize the Mint close authority Extension\n    invoke(\n        &token_instruction::initialize_mint_close_authority(\n            token_program.key,\n            mint_account.key,\n            Some(close_authority.key),\n        )\n        .unwrap(),\n        &[\n            mint_account.clone(),\n            close_authority.clone(),\n            token_program.clone(),\n            system_program.clone(),\n        ],\n    )?;",
    "// Initialize the Non Transferable Mint Extension\n    invoke(\n        &token_instruction::initialize_non_transferable_mint(\n            .unwrap(),\n        &[\n            mint_account.clone(),\n            token_program.clone(),\n            system_program.clone(),\n        ],\n    )?;",
    "mint_authority.clone(),\n            token_program.clone(),\n            rent.clone(),\n        ],\n    )?;",
    "msg!(\"Mint created!\");",
    "Ok(())\n}",
    "pub use crate::errors::GameErrorCode;\npub use anchor_lang::prelude::*;\npub use session_keys::{session_auth_or, Session, SessionError\npub mod constants;\npub mod errors;\npub mod instructions;\npub mod state;\nuse instructions::*;",
    "declare_id!(\"H31ofLpWqeAzF2Pg54HSPQGYifJad843tTJg8vCYVoh3\");",
    "#[program]\npub mod extension_nft {",
    "use super::*;",
    "pub fn init_player(ctx: Context<InitPlayer>, _level_seed: \n        init_player::init_player(ctx)\n    }",
    "// lets the player either use their session token or thei\n    // there so that the player can do multiple transactions i\n    // in the same block would result in the same signature a\n    #[session_auth_or(\n        ctx.accounts.player.authority.key() == ctx.accounts.si\n        GameErrorCode::WrongAuthority\n    )]\n    pub fn chop_tree(ctx: Context<ChopTree>, _level_seed: Stri\n        chop_tree::chop_tree(ctx, counter, 1)\n    }",
    "pub fn mint_nft(ctx: Context<MintNft>) -> Result<()> {\n        mint_nft::mint_nft(ctx)\n    }\n}",
    "use {\n    borsh::{BorshDeserialize, BorshSerialize},\n    solana_program::{\n        account_info::{next_account_info, AccountInfo},\n        entrypoint,\n        entrypoint::ProgramResult,\n        msg,\n        program::invoke,\n        pubkey::Pubkey,\n        rent::Rent,\n        system_instruction,\n        sysvar::Sysvar,\n    },\n    spl_token_2022::{extension::ExtensionType, instruction as \n};",
    "#[derive(BorshSerialize, BorshDeserialize, Debug)]\npub struct CreateTokenArgs {\n    pub token_decimals: u8,\n}",
    "entrypoint!(process_instruction);",
    "fn process_instruction(\n    _program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    instruction_data: &[u8],\n) -> ProgramResult {\n    let args = CreateTokenArgs::try_from_slice(instruction_da",
    "let accounts_iter = &mut accounts.iter();",
    "let mint_account = next_account_info(accounts_iter)?;\n    let mint_authority = next_account_info(accounts_iter)?;\n    let payer = next_account_info(accounts_iter)?;\n    let rent = next_account_info(accounts_iter)?;\n    let system_program = next_account_info(accounts_iter)?;\n    let token_program = next_account_info(accounts_iter)?;",
    "// Get the required rent exemption amount for the account\n    let rent_required = Rent::get()?.minimum_balance(space);",
    "// Create the account for the Mint and allocate space\n    msg!(\"Mint account address : {}\", mint_account.key);\n    invoke(\n        &system_instruction::create_account(\n            payer.key,\n            mint_account.key,\n            rent_required,\n            space as u64,\n            token_program.key,",
    "),\n        &[\n            mint_account.clone(),\n            payer.clone(),\n            system_program.clone(),\n            token_program.clone(),\n        ],\n    )?;",
    "// Initialize the Non Transferable Mint Extension\n    invoke(\n        &token_instruction::initialize_non_transferable_mint(\n            .unwrap(),\n        &[\n            mint_account.clone(),\n            token_program.clone(),\n            system_program.clone(),\n        ],\n    )?;",
    "// Initialize the Token Mint\n    invoke(\n        &token_instruction::initialize_mint(\n            token_program.key,\n            mint_account.key,\n            mint_authority.key,\n            Some(mint_authority.key),\n            args.token_decimals,\n        )?,\n        &[\n            mint_account.clone(),\n            mint_authority.clone(),\n            token_program.clone(),\n            rent.clone(),\n        ],\n    )?;",
    "msg!(\"Mint created!\");",
    "Ok(())\n}",
    "use {\n    borsh::{BorshDeserialize, BorshSerialize},\n    solana_program::{\n        account_info::{next_account_info, AccountInfo},\n        entrypoint,\n        entrypoint::ProgramResult,\n        msg,\n        program::invoke,\n        pubkey::Pubkey,\n        rent::Rent,\n        system_instruction,\n        sysvar::Sysvar,\n    },\n    spl_token_2022::{\n        extension::{\n            transfer_fee::instruction::{initialize_transfer_fe\n            ExtensionType,\n        },\n        instruction as token_instruction,\n        state::Mint,\n    },\n};",
    "#[derive(BorshSerialize, BorshDeserialize, Debug)]\npub struct CreateTokenArgs {",
    "pub token_decimals: u8,\n}",
    "entrypoint!(process_instruction);",
    "fn process_instruction(\n    _program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    instruction_data: &[u8],\n) -> ProgramResult {\n    let args = CreateTokenArgs::try_from_slice(instruction_da",
    "let accounts_iter = &mut accounts.iter();",
    "let mint_account = next_account_info(accounts_iter)?;\n    let mint_authority = next_account_info(accounts_iter)?;\n    let payer = next_account_info(accounts_iter)?;\n    let rent = next_account_info(accounts_iter)?;\n    let system_program = next_account_info(accounts_iter)?;\n    let token_program = next_account_info(accounts_iter)?;",
    "// Get the required rent exemption amount for the account\n    let rent_required = Rent::get()?.minimum_balance(space);",
    "// Create the account for the Mint and allocate space\n    msg!(\"Mint account address : {}\", mint_account.key);\n    invoke(\n        &system_instruction::create_account(\n            payer.key,\n            mint_account.key,\n            rent_required,\n            space as u64,\n            token_program.key,\n        ),\n        &[",
    "mint_account.clone(),\n            payer.clone(),\n            system_program.clone(),\n            token_program.clone(),\n        ],\n    )?;",
    "// The max fee will be 5 tokens, here we adjust it with t\n    let max_fee = 5 * 10u64.pow(args.token_decimals as u32);",
    "// This needs to be done before the Mint is initialized\n    // Initialize the Transfer Fee config\n    invoke(\n        &initialize_transfer_fee_config(\n            token_program.key,\n            mint_account.key,\n            Some(payer.key),\n            Some(payer.key),\n            // 1% fee on transfers\n            100,\n            max_fee,\n        )\n        .unwrap(),\n        &[\n            mint_account.clone(),\n            token_program.clone(),\n            payer.clone(),\n            system_program.clone(),\n        ],\n    )?;",
    "args.token_decimals,\n        )?,\n        &[\n            mint_account.clone(),\n            mint_authority.clone(),\n            token_program.clone(),\n            rent.clone(),\n        ],\n    )?;",
    "// Initialize the Transfer Fee config\n    invoke(\n        &set_transfer_fee(\n            token_program.key,\n            mint_account.key,\n            payer.key,\n            &[payer.key],\n            // 10% fee on transfers\n            1000,\n            max_fee,\n        )\n        .unwrap(),\n        &[\n            mint_account.clone(),\n            token_program.clone(),\n            payer.clone(),\n            system_program.clone(),\n        ],\n    )?;",
    "msg!(\"Mint created!\");",
    "Ok(())\n}",
    "use anchor_lang::{\n    prelude::*,\n    system_program::{create_account, CreateAccount},\n};\nuse anchor_spl::{\n    associated_token::AssociatedToken,\n    token_interface::{Mint, TokenAccount, TokenInterface},\n};\nuse spl_tlv_account_resolution::{\n    account::ExtraAccountMeta, seeds::Seed, state::ExtraAccou\n};\nuse spl_transfer_hook_interface::instruction::{ExecuteInstruc",
    "declare_id!(\"DrWbQtYJGtsoRwzKqAbHKHKsCJJfpysudF39GBVFSxub\");",
    "#[error_code]\npub enum MyError {\n    #[msg(\"The amount is too big\")]\n    AmountTooBig,\n}",
    "#[program]\npub mod transfer_hook {\n    use super::*;",
    "pub fn initialize_extra_account_meta_list(\n        ctx: Context<InitializeExtraAccountMetaList>,\n    ) -> Result<()> {",
    "let account_metas = vec![\n            ExtraAccountMeta::new_with_seeds(\n                &[Seed::Literal {\n                    bytes: \"counter\".as_bytes().to_vec(),",
    "}],\n                false, // is_signer\n                true,  // is_writable\n            )?,\n        ];",
    "let mint = ctx.accounts.mint.key();\n        let signer_seeds: &[&[&[u8]]] = &[&[\n            b\"extra-account-metas\",\n            &mint.as_ref(),\n            &[ctx.bumps.extra_account_meta_list],\n        ]];",
    "// create ExtraAccountMetaList account\n        create_account(\n            CpiContext::new(\n                ctx.accounts.system_program.to_account_info()\n                CreateAccount {\n                    from: ctx.accounts.payer.to_account_info(\n                    to: ctx.accounts.extra_account_meta_list.\n                },\n            )\n            .with_signer(signer_seeds),\n            lamports,\n            account_size,\n            ctx.program_id,\n        )?;",
    "// initialize ExtraAccountMetaList account with extra \n        ExtraAccountMetaList::init::<ExecuteInstruction>(\n            &mut ctx.accounts.extra_account_meta_list.try_bor\n            &account_metas,\n        )?;",
    "Ok(())\n    }",
    "if amount > 50 {\n            msg!(\"The amount is too big {0}\", amount);\n            //return err!(MyError::AmountTooBig);\n        }",
    "msg!(\"This token has been transferred {0} times\", ctx\n       \n        Ok(())\n    }",
    "// fallback instruction handler as workaround to anchor i\n    pub fn fallback<'info>(\n        program_id: &Pubkey,\n        accounts: &'info [AccountInfo<'info>],\n        data: &[u8],\n    ) -> Result<()> {\n        let instruction = TransferHookInstruction::unpack(data",
    "// match instruction discriminator to transfer hook i\n        // token2022 program CPIs this instruction on token t\n        match instruction {\n            TransferHookInstruction::Execute { amount } => {\n                let amount_bytes = amount.to_le_bytes();",
    "// invoke custom transfer hook instruction on \n                __private::__global::transfer_hook(program_id\n            }\n            _ => return Err(ProgramError::InvalidInstructionDa\n        }\n    }",
    "}",
    "#[derive(Accounts)]\npub struct InitializeExtraAccountMetaList<'info> {\n    #[account(mut)]\n    payer: Signer<'info>,",
    "/// CHECK: ExtraAccountMetaList Account, must use these se\n    #[account(\n        mut,\n        seeds = [b\"extra-account-metas\", mint.key().as_ref()]\n        bump\n    )]\n    pub extra_account_meta_list: AccountInfo<'info>,\n    pub mint: InterfaceAccount<'info, Mint>,\n    #[account(\n        init_if_needed,\n        seeds = [b\"counter\"], \n        bump,\n        payer = payer,\n        space = 16\n    )]\n    pub counter_account: Account<'info, CounterAccount>,\n    pub token_program: Interface<'info, TokenInterface>,\n    pub associated_token_program: Program<'info, AssociatedTo\n    pub system_program: Program<'info, System>,\n}",
    "// Order of accounts matters for this struct.\n// The first 4 accounts are the accounts required for token t\n// Remaining accounts are the extra accounts required from the\n// These accounts are provided via CPI to this program from t\n#[derive(Accounts)]\npub struct TransferHook<'info> {\n    #[account(\n        token::mint = mint, \n        token::authority = owner,\n    )]",
    "pub source_token: InterfaceAccount<'info, TokenAccount>,\n    pub mint: InterfaceAccount<'info, Mint>,\n    #[account(\n        token::mint = mint,\n    )]\n    pub destination_token: InterfaceAccount<'info, TokenAccou\n    /// CHECK: source token account owner, can be SystemAccou\n    pub owner: UncheckedAccount<'info>,\n    /// CHECK: ExtraAccountMetaList Account,\n    #[account(\n        seeds = [b\"extra-account-metas\", mint.key().as_ref()]\n        bump\n    )]\n    pub extra_account_meta_list: UncheckedAccount<'info>,\n    #[account(\n        seeds = [b\"counter\"],\n        bump\n    )]\n    pub counter_account: Account<'info, CounterAccount>,\n}",
    "#[account]\npub struct CounterAccount {\n    counter: u64,\n}",
    "use anchor_lang::{\n    prelude::*,",
    "system_program::{create_account, CreateAccount},\n};\nuse anchor_spl::{\n    associated_token::AssociatedToken,\n    token_interface::{Mint, TokenAccount, TokenInterface},\n};\nuse spl_tlv_account_resolution::{\n    state::ExtraAccountMetaList,\n};\nuse spl_transfer_hook_interface::instruction::{ExecuteInstruc",
    "declare_id!(\"DrWbQtYJGtsoRwzKqAbHKHKsCJJfpysudF39GBVFSxub\");",
    "#[program]\npub mod transfer_hook {\n    use super::*;",
    "pub fn initialize_extra_account_meta_list(\n        ctx: Context<InitializeExtraAccountMetaList>,\n    ) -> Result<()> {",
    "let account_metas = vec![];",
    "let mint = ctx.accounts.mint.key();\n        let signer_seeds: &[&[&[u8]]] = &[&[\n            b\"extra-account-metas\",\n            &mint.as_ref(),\n            &[ctx.bumps.extra_account_meta_list],\n        ]];",
    "ctx.accounts.system_program.to_account_info()\n                CreateAccount {\n                    from: ctx.accounts.payer.to_account_info(\n                    to: ctx.accounts.extra_account_meta_list.\n                },\n            )\n            .with_signer(signer_seeds),\n            lamports,\n            account_size,\n            ctx.program_id,\n        )?;",
    "// initialize ExtraAccountMetaList account with extra \n        ExtraAccountMetaList::init::<ExecuteInstruction>(\n            &mut ctx.accounts.extra_account_meta_list.try_bor\n            &account_metas,\n        )?;",
    "Ok(())\n    }",
    "msg!(\"Hello Transfer Hook!\");",
    "Ok(())\n    }",
    "// fallback instruction handler as workaround to anchor i\n    pub fn fallback<'info>(\n        program_id: &Pubkey,\n        accounts: &'info [AccountInfo<'info>],\n        data: &[u8],\n    ) -> Result<()> {\n        let instruction = TransferHookInstruction::unpack(data",
    "match instruction {\n            TransferHookInstruction::Execute { amount } => {\n                let amount_bytes = amount.to_le_bytes();",
    "// invoke custom transfer hook instruction on \n                __private::__global::transfer_hook(program_id\n            }\n            _ => return Err(ProgramError::InvalidInstructionDa\n        }\n    }\n}",
    "#[derive(Accounts)]\npub struct InitializeExtraAccountMetaList<'info> {\n    #[account(mut)]\n    payer: Signer<'info>,",
    "/// CHECK: ExtraAccountMetaList Account, must use these se\n    #[account(\n        mut,\n        seeds = [b\"extra-account-metas\", mint.key().as_ref()]\n        bump\n    )]\n    pub extra_account_meta_list: AccountInfo<'info>,\n    pub mint: InterfaceAccount<'info, Mint>,\n    pub token_program: Interface<'info, TokenInterface>,\n    pub associated_token_program: Program<'info, AssociatedTo\n    pub system_program: Program<'info, System>,\n}",
    "// Order of accounts matters for this struct.\n// The first 4 accounts are the accounts required for token t\n// Remaining accounts are the extra accounts required from the\n// These accounts are provided via CPI to this program from t\n#[derive(Accounts)]\npub struct TransferHook<'info> {\n    #[account(\n        token::mint = mint,",
    "token::authority = owner,\n    )]\n    pub source_token: InterfaceAccount<'info, TokenAccount>,\n    pub mint: InterfaceAccount<'info, Mint>,\n    #[account(\n        token::mint = mint,\n    )]\n    pub destination_token: InterfaceAccount<'info, TokenAccou\n    /// CHECK: source token account owner, can be SystemAccou\n    pub owner: UncheckedAccount<'info>,\n    /// CHECK: ExtraAccountMetaList Account,\n    #[account(\n        seeds = [b\"extra-account-metas\", mint.key().as_ref()]\n        bump\n    )]\n    pub extra_account_meta_list: UncheckedAccount<'info>,\n}",
    "use anchor_lang::{\n    prelude::*,\n    system_program::{create_account, CreateAccount},\n};\nuse anchor_spl::{\n    associated_token::AssociatedToken,\n    token_interface::{transfer_checked, Mint, TokenAccount, To\n};\nuse spl_tlv_account_resolution::{\n    account::ExtraAccountMeta, seeds::Seed, state::ExtraAccou\n};",
    "use spl_transfer_hook_interface::instruction::{ExecuteInstruc",
    "declare_id!(\"DrWbQtYJGtsoRwzKqAbHKHKsCJJfpysudF39GBVFSxub\");",
    "#[error_code]\npub enum MyError {\n   #[msg(\"Amount Too big\")]\n   AmountTooBig,\n}",
    "#[program]\npub mod transfer_hook {\n    use super::*;",
    "pub fn initialize_extra_account_meta_list(\n        ctx: Context<InitializeExtraAccountMetaList>,\n    ) -> Result<()> {\n        // index 0-3 are the accounts required for token tran\n        // index 4 is address of ExtraAccountMetaList account\n        let account_metas = vec![\n            // index 5, wrapped SOL mint\n            ExtraAccountMeta::new_with_pubkey(&ctx.accounts.w\n            // index 6, token program\n            ExtraAccountMeta::new_with_pubkey(&ctx.accounts.to\n            // index 7, associated token program\n            ExtraAccountMeta::new_with_pubkey(\n                &ctx.accounts.associated_token_program.key(),\n                false,\n                false,\n            )?,\n            // index 8, delegate PDA\n            ExtraAccountMeta::new_with_seeds(\n                &[Seed::Literal {\n                    bytes: \"delegate\".as_bytes().to_vec(),\n                }],",
    "false, // is_signer\n                true,  // is_writable\n            )?,\n            // index 9, delegate wrapped SOL token account\n            ExtraAccountMeta::new_external_pda_with_seeds(\n                7, // associated token program index\n                &[\n                    Seed::AccountKey { index: 8 }, // owner i\n                    Seed::AccountKey { index: 6 }, // token p\n                    Seed::AccountKey { index: 5 }, // wsol mi\n                ],\n                false, // is_signer\n                true,  // is_writable\n            )?,\n            // index 10, sender wrapped SOL token account\n            ExtraAccountMeta::new_external_pda_with_seeds(\n                7, // associated token program index\n                &[\n                    Seed::AccountKey { index: 3 }, // owner i\n                    Seed::AccountKey { index: 6 }, // token p\n                    Seed::AccountKey { index: 5 }, // wsol mi\n                ],\n                false, // is_signer\n                true,  // is_writable\n            )?,\n            ExtraAccountMeta::new_with_seeds(\n                &[Seed::Literal {\n                    bytes: \"counter\".as_bytes().to_vec(),\n                }],\n                false, // is_signer\n                true,  // is_writable\n            )?,\n        ];",
    "let mint = ctx.accounts.mint.key();\n        let signer_seeds: &[&[&[u8]]] = &[&[\n            b\"extra-account-metas\",\n            &mint.as_ref(),\n            &[ctx.bumps.extra_account_meta_list],\n        ]];",
    "// create ExtraAccountMetaList account\n        create_account(\n            CpiContext::new(\n                ctx.accounts.system_program.to_account_info()\n                CreateAccount {\n                    from: ctx.accounts.payer.to_account_info(\n                    to: ctx.accounts.extra_account_meta_list.\n                },\n            )\n            .with_signer(signer_seeds),\n            lamports,\n            account_size,\n            ctx.program_id,\n        )?;",
    "// initialize ExtraAccountMetaList account with extra \n        ExtraAccountMetaList::init::<ExecuteInstruction>(\n            &mut ctx.accounts.extra_account_meta_list.try_bor\n            &account_metas,\n        )?;",
    "Ok(())\n    }",
    "if amount > 50 {\n            //msg!(\"The amount is too big {0}\", amount);\n            //return err!(MyError::AmountTooBig);\n        }",
    "ctx.accounts.counter_account.counter += 1;",
    "msg!(\"This token has been transferred {0} times\", ctx",
    "// All accounts are non writable so you can not burn a\n        msg!(\"Is writable mint {0}\", ctx.accounts.mint.to_acco\n        msg!(\"Is destination mint {0}\", ctx.accounts.destinati\n        msg!(\"Is source mint {0}\", ctx.accounts.source_token.",
    "// Transfer WSOL from sender to delegate token accoun\n        transfer_checked(\n            CpiContext::new(\n                ctx.accounts.token_program.to_account_info(),\n                TransferChecked {\n                    from: ctx.accounts.sender_wsol_token_acco\n                    mint: ctx.accounts.wsol_mint.to_account_i\n                    to: ctx.accounts.delegate_wsol_token_acco\n                    authority: ctx.accounts.delegate.to_accou\n                },\n            )\n            .with_signer(signer_seeds),\n            amount / 2,\n            ctx.accounts.wsol_mint.decimals,\n        )?;\n        Ok(())\n    }",
    "// fallback instruction handler as workaround to anchor i\n    pub fn fallback<'info>(\n        program_id: &Pubkey,\n        accounts: &'info [AccountInfo<'info>],\n        data: &[u8],\n    ) -> Result<()> {\n        let instruction = TransferHookInstruction::unpack(data",
    "// match instruction discriminator to transfer hook i\n        // token2022 program CPIs this instruction on token t\n        match instruction {\n            TransferHookInstruction::Execute { amount } => {\n                let amount_bytes = amount.to_le_bytes();",
    "// invoke custom transfer hook instruction on \n                __private::__global::transfer_hook(program_id\n            }\n            _ => Err(ProgramError::InvalidInstructionData.into\n        }\n    }\n}",
    "#[derive(Accounts)]\npub struct InitializeExtraAccountMetaList<'info> {\n    #[account(mut)]\n    payer: Signer<'info>,",
    "pub system_program: Program<'info, System>,\n}",
    "// Order of accounts matters for this struct.\n// The first 4 accounts are the accounts required for token t\n// Remaining accounts are the extra accounts required from the\n// These accounts are provided via CPI to this program from t\n#[derive(Accounts)]\npub struct TransferHook<'info> {\n    #[account(\n        token::mint = mint, \n        token::authority = owner,\n    )]\n    pub source_token: InterfaceAccount<'info, TokenAccount>,\n    pub mint: InterfaceAccount<'info, Mint>,\n    #[account(\n        token::mint = mint,\n    )]\n    pub destination_token: InterfaceAccount<'info, TokenAccou\n    /// CHECK: source token account owner, can be SystemAccou\n    pub owner: UncheckedAccount<'info>,\n    /// CHECK: ExtraAccountMetaList Account,\n    #[account(\n        seeds = [b\"extra-account-metas\", mint.key().as_ref()]\n        bump\n    )]\n    pub extra_account_meta_list: UncheckedAccount<'info>,\n    pub wsol_mint: InterfaceAccount<'info, Mint>,\n    pub token_program: Interface<'info, TokenInterface>,\n    pub associated_token_program: Program<'info, AssociatedTo\n    #[account(\n        mut,\n        seeds = [b\"delegate\"], \n        bump\n    )]\n    pub delegate: SystemAccount<'info>,\n    #[account(\n        mut,",
    "token::mint = wsol_mint, \n        token::authority = delegate,\n    )]\n    pub delegate_wsol_token_account: InterfaceAccount<'info, T\n    #[account(\n        mut,\n        token::mint = wsol_mint, \n        token::authority = owner,\n    )]\n    pub sender_wsol_token_account: InterfaceAccount<'info, To\n    #[account(\n        seeds = [b\"counter\"],\n        bump\n    )]\n    pub counter_account: Account<'info, CounterAccount>,\n}",
    "#[account]\npub struct CounterAccount {\n    counter: u8\n}",
    "use anchor_lang::{\n    prelude::*,\n    system_program::{create_account, CreateAccount},\n};\nuse anchor_spl::{\n    associated_token::AssociatedToken, token_interface::{Mint",
    "};\nuse spl_tlv_account_resolution::state::ExtraAccountMetaList;\nuse spl_transfer_hook_interface::instruction::{ExecuteInstruc",
    "declare_id!(\"DrWbQtYJGtsoRwzKqAbHKHKsCJJfpysudF39GBVFSxub\");",
    "#[program]\npub mod transfer_hook {",
    "use spl_tlv_account_resolution::{account::ExtraAccountMeta",
    "use super::*;",
    "pub fn initialize_extra_account_meta_list(\n        ctx: Context<InitializeExtraAccountMetaList>,\n    ) -> Result<()> {",
    "let account_metas = vec![\n            ExtraAccountMeta::new_with_seeds(\n                &[Seed::Literal {\n                    bytes: \"white_list\".as_bytes().to_vec(),\n                }], // owner index (delegate PDA)\n                false, // is_signer\n                true,  // is_writable\n            )?,\n        ];",
    "let mint = ctx.accounts.mint.key();\n        let signer_seeds: &[&[&[u8]]] = &[&[\n            b\"extra-account-metas\",\n            &mint.as_ref(),",
    "&[ctx.bumps.extra_account_meta_list],\n        ]];",
    "// create ExtraAccountMetaList account\n        create_account(\n            CpiContext::new(\n                ctx.accounts.system_program.to_account_info()\n                CreateAccount {\n                    from: ctx.accounts.payer.to_account_info(\n                    to: ctx.accounts.extra_account_meta_list.\n                },\n            )\n            .with_signer(signer_seeds),\n            lamports,\n            account_size,\n            ctx.program_id,\n        )?;",
    "// initialize ExtraAccountMetaList account with extra \n        ExtraAccountMetaList::init::<ExecuteInstruction>(\n            &mut ctx.accounts.extra_account_meta_list.try_bor\n            &account_metas,\n        )?;",
    "Ok(())\n    }",
    "if !ctx.accounts.white_list.white_list.contains(&ctx.a\n            panic!(\"Account not in white list!\");\n        }",
    "msg!(\"Account in white list, all good!\");",
    "Ok(())\n    }",
    "if ctx.accounts.white_list.authority != ctx.accounts.\n            panic!(\"Only the authority can add to the white li\n        }",
    "ctx.accounts.white_list.white_list.push(ctx.accounts.\n        msg!(\"New account white listed! {0}\", ctx.accounts.new\n        msg!(\"White list length! {0}\", ctx.accounts.white_lis",
    "Ok(())\n    }",
    "// fallback instruction handler as workaround to anchor i\n    pub fn fallback<'info>(\n        program_id: &Pubkey,\n        accounts: &'info [AccountInfo<'info>],\n        data: &[u8],\n    ) -> Result<()> {\n        let instruction = TransferHookInstruction::unpack(data",
    "// match instruction discriminator to transfer hook i\n        // token2022 program CPIs this instruction on token t\n        match instruction {\n            TransferHookInstruction::Execute { amount } => {\n                let amount_bytes = amount.to_le_bytes();",
    "// invoke custom transfer hook instruction on \n                __private::__global::transfer_hook(program_id\n            }\n            _ => return Err(ProgramError::InvalidInstructionDa\n        }\n    }\n}",
    "#[derive(Accounts)]\npub struct InitializeExtraAccountMetaList<'info> {\n    #[account(mut)]",
    "/// CHECK: ExtraAccountMetaList Account, must use these se\n    #[account(\n        mut,\n        seeds = [b\"extra-account-metas\", mint.key().as_ref()]\n        bump\n    )]\n    pub extra_account_meta_list: AccountInfo<'info>,\n    pub mint: InterfaceAccount<'info, Mint>,\n    pub token_program: Interface<'info, TokenInterface>,\n    pub associated_token_program: Program<'info, AssociatedTo\n    pub system_program: Program<'info, System>,\n    #[account(\n        init_if_needed,\n        seeds = [b\"white_list\"],\n        bump,\n        payer = payer,\n        space = 400\n    )]\n    pub white_list: Account<'info, WhiteList>,\n}",
    "// Order of accounts matters for this struct.\n// The first 4 accounts are the accounts required for token t\n// Remaining accounts are the extra accounts required from the\n// These accounts are provided via CPI to this program from t\n#[derive(Accounts)]\npub struct TransferHook<'info> {\n    #[account(\n        token::mint = mint, \n        token::authority = owner,\n    )]\n    pub source_token: InterfaceAccount<'info, TokenAccount>,\n    pub mint: InterfaceAccount<'info, Mint>,\n    #[account(\n        token::mint = mint,\n    )]",
    "pub destination_token: InterfaceAccount<'info, TokenAccou\n    /// CHECK: source token account owner, can be SystemAccou\n    pub owner: UncheckedAccount<'info>,\n    /// CHECK: ExtraAccountMetaList Account,\n    #[account(\n        seeds = [b\"extra-account-metas\", mint.key().as_ref()]\n        bump\n    )]\n    pub extra_account_meta_list: UncheckedAccount<'info>,\n    #[account(\n        seeds = [b\"white_list\"],\n        bump\n    )]\n    pub white_list: Account<'info, WhiteList>,\n}",
    "#[derive(Accounts)]\npub struct AddToWhiteList<'info> {\n    /// CHECK: New account to add to white list\n    #[account()]\n    pub new_account: AccountInfo<'info>,\n    #[account(\n        mut,\n        seeds = [b\"white_list\"],\n        bump\n    )]\n    pub white_list: Account<'info, WhiteList>,\n    #[account(mut)]\n    pub signer: Signer<'info>,\n}",
    "#[account]\npub struct WhiteList {\n    pub authority: Pubkey,\n    pub white_list: Vec<Pubkey>,\n}",
    "use anchor_lang::prelude::*;",
    "mod constants;\nmod errors;\nmod instructions;\nmod state;",
    "// Set the correct key here\ndeclare_id!(\"C3ti6PFK6PoYShRFx1BNNTQU3qeY1iVwjwCA6SjJhiuW\");",
    "#[program]\npub mod swap_example {\n    pub use super::instructions::*;\n    use super::*;",
    "pub fn create_amm(ctx: Context<CreateAmm>, id: Pubkey, fee\n        instructions::create_amm(ctx, id, fee)\n    }",
    "pub fn create_pool(ctx: Context<CreatePool>) -> Result<()>\n        instructions::create_pool(ctx)\n    }",
    "pub fn deposit_liquidity(\n        ctx: Context<DepositLiquidity>,\n        amount_a: u64,\n        amount_b: u64,\n    ) -> Result<()> {",
    "instructions::deposit_liquidity(ctx, amount_a, amount_\n    }",
    "pub fn withdraw_liquidity(ctx: Context<WithdrawLiquidity>\n        instructions::withdraw_liquidity(ctx, amount)\n    }",
    "pub fn swap_exact_tokens_for_tokens(\n        ctx: Context<SwapExactTokensForTokens>,\n        swap_a: bool,\n        input_amount: u64,\n        min_output_amount: u64,\n    ) -> Result<()> {\n        instructions::swap_exact_tokens_for_tokens(ctx, swap_a\n    }\n}",
    "use anchor_lang::prelude::*;",
    "pub mod instructions;",
    "use instructions::*;",
    "declare_id!(\"2W7B8C5skxyVaAA1LfYAsRHiv26LL5j88GJ9XYyybWqc\");",
    "#[program]\npub mod transfer_tokens {\n    use super::*;",
    "token_uri: String,\n    ) -> Result<()> {\n        create::create_token(ctx, token_title, token_symbol, \n    }",
    "pub fn mint_token(ctx: Context<MintToken>, amount: u64) ->\n        mint::mint_token(ctx, amount)\n    }",
    "pub fn transfer_tokens(ctx: Context<TransferTokens>, amou\n        transfer::transfer_tokens(ctx, amount)\n    }\n}",
    "// import custom helpers for demos\nimport {\n  loadPublicKeysFromFile,\n  printConsoleSeparator,\n  savePublicKeyToFile,\n} from \"@/utils/helpers\";",
    "// imports from other libraries\nimport dotenv from \"dotenv\";\nimport { Metaplex, MetaplexError, ReadApiAssetList } from \"@me\nimport { ReadApiConnection } from \"@metaplex-foundation/js\";",
    "import { PublicKey } from \"@solana/web3.js\";",
    "// load the env variables and store the cluster RPC url\ndotenv.config();\nconst CLUSTER_URL = process.env.RPC_URL ?? \"\";",
    "(async () => {\n  // load the stored PublicKeys for ease of use\n  let keys = loadPublicKeysFromFile();",
    "const treeAddress: PublicKey = keys.treeAddress;\n  const treeAuthority: PublicKey = keys.treeAuthority;\n  const collectionMint: PublicKey = keys.collectionMint;\n  const userAddress: PublicKey = keys.userAddress;\n  const testWallet: PublicKey = keys.testWallet;",
    "console.log(\"==== Local PublicKeys loaded ====\");\n  console.log(\"Tree address:\", treeAddress.toBase58());\n  console.log(\"Tree authority:\", treeAuthority.toBase58());\n  console.log(\"Collection mint:\", collectionMint.toBase58());\n  console.log(\"User address:\", userAddress.toBase58());\n  console.log(\"Test address:\", testWallet.toBase58());",
    "// define the address we are actually going to check (in thi\n  const checkAddress = collectionMint.toBase58();",
    "printConsoleSeparator(`getAssetsByGroup: ${checkAddress}`);",
    "const connection = new ReadApiConnection(CLUSTER_URL);\n  const metaplex = Metaplex.make(connection);",
    "/**\n   * Fetch a listing of NFT assets by an owner's address (via \n   * ---\n   * NOTE: This will return both compressed NFTs AND traditio\n   */\n  const rpcAssets = await metaplex\n    .rpc()\n    .getAssetsByGroup({\n      groupKey: \"collection\",\n      groupValue: checkAddress,\n      sortBy: {\n        sortBy: \"created\",\n        sortDirection: \"asc\",\n      },\n    })\n    .then(res => {\n      if ((res as MetaplexError)?.cause) throw res;\n      else return res as ReadApiAssetList;\n    });",
    "/**\n   * Process the returned `rpcAssets` response\n   */\n  console.log(\"Total assets returned:\", rpcAssets.total);",
    "// loop over each of the asset items in the collection\n  rpcAssets.items.map(asset => {\n    // only show compressed nft assets\n    if (!asset.compression.compressed) return;",
    "// extra useful info\n    console.log(\"assetId:\", asset.id);",
    "// view the ownership info for the given asset\n    console.log(\"ownership:\", asset.ownership);",
    "// metadata json data (auto fetched thanks to the Metaplex\n    // console.log(\"metadata:\", asset.content.metadata);",
    "// view the compression specific data for the given asset\n    console.log(\"compression:\", asset.compression);",
    "if (asset.compression.compressed) {\n      console.log(\"==> This NFT is compressed! <===\");\n      console.log(\"\\tleaf_id:\", asset.compression.leaf_id);\n    } else console.log(\"==> NFT is NOT compressed! <===\");\n  });\n})();",
    "// import custom helpers for demos\nimport {\n  loadPublicKeysFromFile,\n  printConsoleSeparator,\n  savePublicKeyToFile,\n} from \"@/utils/helpers\";",
    "// imports from other libraries\nimport dotenv from \"dotenv\";",
    "import { Metaplex, MetaplexError, ReadApiAssetList } from \"@me\nimport { ReadApiConnection } from \"@metaplex-foundation/js\";\nimport { PublicKey } from \"@solana/web3.js\";",
    "// load the env variables and store the cluster RPC url\ndotenv.config();\nconst CLUSTER_URL = process.env.RPC_URL ?? \"\";",
    "(async () => {\n  // load the stored PublicKeys for ease of use\n  let keys = loadPublicKeysFromFile();",
    "const treeAddress: PublicKey = keys.treeAddress;\n  const treeAuthority: PublicKey = keys.treeAuthority;\n  const collectionMint: PublicKey = keys.collectionMint;\n  const userAddress: PublicKey = keys.userAddress;\n  const testWallet: PublicKey = keys.testWallet;",
    "console.log(\"==== Local PublicKeys loaded ====\");\n  console.log(\"Tree address:\", treeAddress.toBase58());\n  console.log(\"Tree authority:\", treeAuthority.toBase58());\n  console.log(\"Collection mint:\", collectionMint.toBase58());\n  console.log(\"User address:\", userAddress.toBase58());\n  console.log(\"Test address:\", testWallet.toBase58());",
    "// define the address we are actually going to check (in thi\n  // const checkAddress = testWallet.toBase58();\n  const checkAddress = userAddress.toBase58();",
    "printConsoleSeparator(`getAssetsByOwner: ${checkAddress}`);",
    "const connection = new ReadApiConnection(CLUSTER_URL);\n  const metaplex = Metaplex.make(connection);",
    "/**\n   * Fetch a listing of NFT assets by an owner's address (via \n   * ---\n   * NOTE: This will return both compressed NFTs AND traditio\n   */\n  const rpcAssets = await metaplex\n    .rpc()\n    .getAssetsByOwner({\n      ownerAddress: checkAddress,\n    })\n    .then(res => {\n      if ((res as MetaplexError)?.cause) throw res;\n      else return res as ReadApiAssetList;\n    });",
    "/**\n   * Process the returned `rpcAssets` response\n   */\n  console.log(\"Total assets returned:\", rpcAssets.total);",
    "// loop over each of the asset items in the collection\n  rpcAssets.items.map(asset => {\n    // only show compressed nft assets\n    if (!asset.compression.compressed) return;",
    "// extra useful info\n    console.log(\"assetId:\", asset.id);",
    "console.log(\"ownership:\", asset.ownership);",
    "// metadata json data (auto fetched thanks to the Metaplex\n    // console.log(\"metadata:\", asset.content.metadata);",
    "// view the compression specific data for the given asset\n    console.log(\"compression:\", asset.compression);",
    "if (asset.compression.compressed) {\n      console.log(\"==> This NFT is compressed! <===\");\n      console.log(\"\\tleaf_id:\", asset.compression.leaf_id);\n    } else console.log(\"==> NFT is NOT compressed! <===\");\n  });\n})();",
    "// imports from other libraries\nimport dotenv from \"dotenv\";\nimport { Metaplex, ReadApiConnection, keypairIdentity } from \nimport { PublicKey, clusterApiUrl } from \"@solana/web3.js\";",
    "// import custom helpers for demos\nimport {\n  loadPublicKeysFromFile,\n  loadKeypairFromFile,\n  loadOrGenerateKeypair,\n  explorerURL,",
    "printConsoleSeparator,\n  savePublicKeyToFile,\n} from \"@/utils/helpers\";\nimport { getLeafAssetId, metadataArgsBeet } from \"@metaplex-fo\nimport {\n  changeLogEventV1Beet,\n  deserializeApplicationDataEvent,\n  deserializeChangeLogEventV1,\n} from \"@solana/spl-account-compression\";\nimport { bs58 } from \"@project-serum/anchor/dist/cjs/utils/by\nimport { BN } from \"@project-serum/anchor\";",
    "// load the env variables and store the cluster RPC url\ndotenv.config();\nconst CLUSTER_URL = process.env.RPC_URL ?? clusterApiUrl(\"dev",
    "// create a new rpc connection\n// const connection = new Connection(CLUSTER_URL);\nconst connection = new ReadApiConnection(CLUSTER_URL);",
    "(async () => {\n  ////////////////////////////////////////////////////////////\n  ////////////////////////////////////////////////////////////",
    "// generate a new Keypair for testing, named `testWallet`\n  const testWallet = loadOrGenerateKeypair(\"testWallet\");",
    "// generate a new keypair for use in this demo (or load it l\n  const payer = process.env?.LOCAL_PAYER_JSON_ABSPATH\n    ? loadKeypairFromFile(process.env?.LOCAL_PAYER_JSON_ABSPAT\n    : loadOrGenerateKeypair(\"payer\");",
    "console.log(\"Payer address:\", payer.publicKey.toBase58());\n  console.log(\"Test wallet address:\", testWallet.publicKey.to",
    "// load the stored PublicKeys for ease of use\n  let keys = loadPublicKeysFromFile();",
    "const treeAddress: PublicKey = keys.treeAddress;\n  const collectionMint: PublicKey = keys.collectionMint;\n  const collectionAuthority: PublicKey = keys.collectionAutho",
    "console.log(\"==== Local PublicKeys loaded ====\");\n  console.log(\"Tree address:\", treeAddress.toBase58());\n  console.log(\"Collection mint:\", collectionMint.toBase58());\n  console.log(\"User address:\", payer.publicKey.toBase58());\n  console.log(\"Test address:\", testWallet.publicKey.toBase58(",
    "// mint a new compressed NFT into our existing collection\n  const { response, nft } = await metaplex.nfts().create({\n    uri: \"https://supersweetcollection.notarealurl/token.json\n    name: \"compressed with metaplex\",\n    sellerFeeBasisPoints: 500,\n    collection: collectionMint,",
    "// note: this merkle tree must have already been created\n    tree: treeAddress,\n  });",
    "console.log(\"nft minted with metaplex sdk:\", nft);",
    "printConsoleSeparator(\"View on explorer\");",
    "console.log(explorerURL({ txSignature: response.signature }\n})();",
    "// import custom helpers for demos\nimport { loadPublicKeysFromFile, printConsoleSeparator } from",
    "import dotenv from \"dotenv\";\nimport { GetAssetProofRpcResponse, Metaplex, ReadApiConnectio",
    "// imports from other libraries\nimport { PublicKey, clusterApiUrl } from \"@solana/web3.js\";\nimport {\n  ConcurrentMerkleTreeAccount,\n  MerkleTree,\n  MerkleTreeProof,",
    "} from \"@solana/spl-account-compression\";",
    "// load the env variables and store the cluster RPC url\ndotenv.config();\nconst CLUSTER_URL = process.env.RPC_URL ?? clusterApiUrl(\"dev",
    "// create a new rpc connection\n// const connection = new Connection(CLUSTER_URL);\nconst connection = new ReadApiConnection(CLUSTER_URL);",
    "(async () => {\n  ////////////////////////////////////////////////////////////\n  ////////////////////////////////////////////////////////////",
    "// load the stored PublicKeys for ease of use\n  let keys = loadPublicKeysFromFile();",
    "// ensure the primary script was already run\n  if (!keys?.assetIdTestAddress)\n    return console.warn(\n      \"No locally saved `assetIdTestAddress` was found, Please\n    );",
    "console.log(\"==== Local PublicKeys loaded ====\");\n  console.log(\"Test Asset ID:\", assetIdTestAddress.toBase58()\n  console.log(\"User Asset ID:\", assetIdUserAddress.toBase58()",
    "// set the asset to test with\n  const assetId = assetIdTestAddress;\n  // const assetId = assetIdUserAddress;",
    "const metaplex = Metaplex.make(connection);",
    "/**\n   * Fetch an asset from the ReadApi by its `assetId`\n   */\n  const nft = await metaplex.nfts().findByAssetId({ assetId }\n  console.log(nft);",
    "printConsoleSeparator(\"Get the asset proof from the RPC:\");",
    "// fetch an asset's proof from the ReadApi by its `assetId`\n  const assetProof = (await metaplex.rpc().getAssetProof(asse\n  console.log(assetProof);",
    "// construct a valid proof object to check against\n  const merkleTreeProof: MerkleTreeProof = {\n    leafIndex: nft.compression?.leaf_id || 0,\n    leaf: new PublicKey(assetProof.leaf).toBuffer(),\n    root: new PublicKey(assetProof.root).toBuffer(),\n    proof: assetProof.proof.map((node: string) => new PublicKe\n  };",
    "// get the actual merkle tree data from the Solana blockchai\n  const merkleTree = new PublicKey(assetProof.tree_id);\n  const treeAccount = await ConcurrentMerkleTreeAccount.fromAc",
    "const currentRoot = treeAccount.getCurrentRoot();\n  const rootFromRpc = new PublicKey(assetProof.root).toBuffer",
    "/**\n   * note: the current on-chain root hash (`currentRoot`) doe\n   * RPC provided root hash (`rootFromRpc`). This is because a\n   * of valid root hashes are stored on-chain via the trees o\n   * (set by your tree's `maxBufferSize` at tree creation)\n   *\n   * This check is show here purely for demonstration, and is \n   */\n  console.log(\n    \"Does the current on-chain root match RPC provided root:\"\n    new PublicKey(currentRoot).toBase58() === new PublicKey(ro\n  );\n})();",
    "// imports from other libraries\nimport dotenv from \"dotenv\";\nimport { Metaplex, ReadApiConnection, keypairIdentity } from \nimport { PublicKey, clusterApiUrl } from \"@solana/web3.js\";",
    "// import custom helpers for demos\nimport {\n  loadPublicKeysFromFile,\n  loadKeypairFromFile,\n  loadOrGenerateKeypair,\n  explorerURL,\n  printConsoleSeparator,\n} from \"@/utils/helpers\";",
    "// load the env variables and store the cluster RPC url\ndotenv.config();\nconst CLUSTER_URL = process.env.RPC_URL ?? clusterApiUrl(\"dev",
    "// create a new rpc connection\n// const connection = new Connection(CLUSTER_URL);\nconst connection = new ReadApiConnection(CLUSTER_URL);",
    "(async () => {\n  ////////////////////////////////////////////////////////////\n  ////////////////////////////////////////////////////////////",
    "// generate a new Keypair for testing, named `testWallet`\n  const testWallet = loadOrGenerateKeypair(\"testWallet\");",
    "const payer = process.env?.LOCAL_PAYER_JSON_ABSPATH\n    ? loadKeypairFromFile(process.env?.LOCAL_PAYER_JSON_ABSPAT\n    : loadOrGenerateKeypair(\"payer\");",
    "console.log(\"Payer address:\", payer.publicKey.toBase58());\n  console.log(\"Test wallet address:\", testWallet.publicKey.to",
    "// load the stored PublicKeys for ease of use\n  let keys = loadPublicKeysFromFile();",
    "// ensure the primary script was already run\n  if (!keys?.assetIdTestAddress)\n    return console.warn(\n      \"No locally saved `assetIdTestAddress` was found, Please\n    );",
    "console.log(\"==== Local PublicKeys loaded ====\");\n  console.log(\"Test Asset ID:\", assetIdTestAddress.toBase58()\n  console.log(\"User Asset ID:\", assetIdUserAddress.toBase58()",
    "// set the asset to test with\n  const assetId = assetIdTestAddress;\n  // const assetId = assetIdUserAddress;",
    "const nft = await metaplex.nfts().findByAssetId({ assetId }\n  console.log(nft);",
    "printConsoleSeparator(\"Transfer the compressed nft:\");",
    "await metaplex\n    .nfts()\n    .transfer({\n      nftOrSft: nft,\n      toOwner: payer.publicKey,\n    })\n    .then(res => {\n      console.log(\"transfer complete:\", res);",
    "console.log(explorerURL({ txSignature: res.response.sig\n    })\n    .catch(err => {\n      console.log(\"==================\");\n      console.log(\"  Transfer failed!\");\n      console.log(\"==================\");\n      console.error(err);\n    });\n})();",
    "// local import of the connection wrapper, to help with using \nimport { WrapperConnection } from \"@/ReadApi/WrapperConnectio",
    "// import custom helpers for demos\nimport {\n  explorerURL,\n  loadKeypairFromFile,\n  loadOrGenerateKeypair,\n  loadPublicKeysFromFile,\n  printConsoleSeparator,\n} from \"@/utils/helpers\";\nimport {\n  TokenProgramVersion,\n  TokenStandard,\n  computeCreatorHash,\n  computeDataHash,\n  createVerifyCreatorInstruction,\n  getLeafAssetId,\n} from \"@metaplex-foundation/mpl-bubblegum\";",
    "import {\n  SPL_ACCOUNT_COMPRESSION_PROGRAM_ID,\n  SPL_NOOP_PROGRAM_ID,\n  ConcurrentMerkleTreeAccount,\n  getAllChangeLogEventV1FromTransaction,\n} from \"@solana/spl-account-compression\";\nimport {\n  MetadataArgs,\n  Creator,\n  PROGRAM_ID as BUBBLEGUM_PROGRAM_ID,\n} from \"@metaplex-foundation/mpl-bubblegum\";\nimport {\n  AccountMeta,",
    "PublicKey,\n  TransactionMessage,\n  VersionedTransaction,\n  clusterApiUrl,\n} from \"@solana/web3.js\";",
    "import dotenv from \"dotenv\";\nimport { BN } from \"@project-serum/anchor\";\ndotenv.config();",
    "(async () => {\n  // generate a new Keypair for testing, named `wallet`\n  const testWallet = loadOrGenerateKeypair(\"testWallet\");",
    "// generate a new keypair for use in this demo (or load it l\n  const payer = process.env?.LOCAL_PAYER_JSON_ABSPATH\n    ? loadKeypairFromFile(process.env?.LOCAL_PAYER_JSON_ABSPAT\n    : loadOrGenerateKeypair(\"payer\");",
    "console.log(\"Payer address:\", payer.publicKey.toBase58());\n  console.log(\"Test wallet address:\", testWallet.publicKey.to",
    "// create a new rpc connection, using the ReadApi wrapper\n  const connection = new WrapperConnection(CLUSTER_URL);",
    "printConsoleSeparator(\"\");",
    "const tx = await connection.getTransaction(devnetSig, {\n    maxSupportedTransactionVersion: 0,\n  });",
    "if (!tx) throw Error(\"Tx not found\");",
    "printConsoleSeparator(\"Events:\");",
    "const events = getAllChangeLogEventV1FromTransaction(tx);",
    "console.log(events);\n  const leafIndex = events[0].index;",
    "console.log(\"assetId:\", assetId);\n  console.log(\"total events:\", events.length);\n})();",
    "import { Keypair, LAMPORTS_PER_SOL, clusterApiUrl } from \"@sol\nimport { ValidDepthSizePair } from \"@solana/spl-account-compre\nimport {\n  MetadataArgs,\n  TokenProgramVersion,\n  TokenStandard,\n} from \"@metaplex-foundation/mpl-bubblegum\";\nimport { CreateMetadataAccountArgsV3 } from \"@metaplex-founda",
    "// import custom helpers for demos\nimport { loadKeypairFromFile, loadOrGenerateKeypair, numberFo",
    "// import custom helpers to mint compressed NFTs\nimport { createCollection, createTree, mintCompressedNFT } fro",
    "// local import of the connection wrapper, to help with using \nimport { WrapperConnection } from \"@/ReadApi/WrapperConnectio",
    "import dotenv from \"dotenv\";\ndotenv.config();",
    "// define some reusable balance values for tracking\nlet initBalance: number, balance: number;",
    "(async () => {\n  ////////////////////////////////////////////////////////////\n  ////////////////////////////////////////////////////////////",
    "// generate a new Keypair for testing, named `wallet`\n  const testWallet = loadOrGenerateKeypair(\"testWallet\");",
    "? loadKeypairFromFile(process.env?.LOCAL_PAYER_JSON_ABSPAT\n    : loadOrGenerateKeypair(\"payer\");",
    "console.log(\"Payer address:\", payer.publicKey.toBase58());\n  console.log(\"Test wallet address:\", testWallet.publicKey.to",
    "// get the payer's starting balance (only used for demonstra\n  initBalance = await connection.getBalance(payer.publicKey);",
    "/*\n    Define our tree size parameters\n  */\n  const maxDepthSizePair: ValidDepthSizePair = {\n    // max=16,384 nodes\n    maxDepth: 14,\n    maxBufferSize: 64,\n  };\n  const canopyDepth = maxDepthSizePair.maxDepth - 5;",
    "// define the address the tree will live at\n  const treeKeypair = Keypair.generate();",
    "// define the metadata to be used for creating the NFT colle\n  const collectionMetadataV3: CreateMetadataAccountArgsV3 = {\n    data: {\n      name: \"Super Sweet NFT Collection\",\n      symbol: \"SSNC\",\n      // specific json metadata for the collection\n      uri: \"https://supersweetcollection.notarealurl/collectio\n      sellerFeeBasisPoints: 100,\n      creators: [\n        {\n          address: payer.publicKey,\n          verified: false,\n          share: 100,\n        },\n      ],\n      collection: null,\n      uses: null,\n    },\n    isMutable: false,\n    collectionDetails: null,\n  };",
    "const compressedNFTMetadata: MetadataArgs = {",
    "name: \"NFT Name\",\n    symbol: collectionMetadataV3.data.symbol,\n    // specific json metadata for each NFT\n    uri: \"https://supersweetcollection.notarealurl/token.json\n    creators: [\n      {\n        address: payer.publicKey,\n        verified: false,\n        share: 100,\n      },\n      {\n        address: testWallet.publicKey,\n        verified: false,\n        share: 0,\n      },\n    ],\n    editionNonce: 0,\n    uses: null,\n    collection: null,\n    primarySaleHappened: false,\n    sellerFeeBasisPoints: 0,\n    isMutable: false,\n    // these values are taken from the Bubblegum package\n    tokenProgramVersion: TokenProgramVersion.Original,\n    tokenStandard: TokenStandard.NonFungible,\n  };",
    "// fully mint a single compressed NFT to the payer\n  console.log(`Minting a single compressed NFT to ${payer.publ",
    "// mint to this specific wallet (in this case, the tree ow\n    payer.publicKey,\n  );",
    "// fully mint a single compressed NFT\n  console.log(`Minting a single compressed NFT to ${testWalle",
    "await mintCompressedNFT(\n    connection,\n    payer,\n    treeKeypair.publicKey,\n    collection.mint,\n    collection.metadataAccount,\n    collection.masterEditionAccount,\n    compressedNFTMetadata,\n    // mint to this specific wallet (in this case, airdrop to \n    testWallet.publicKey,\n  );",
    "// fetch the payer's final balance\n  balance = await connection.getBalance(payer.publicKey);",
    "console.log(`===============================`);\n  console.log(\n    \"Total cost:\",\n    numberFormatter((initBalance - balance) / LAMPORTS_PER_SO\n    \"SOL\\n\",\n  );\n})();"
  ]
}
